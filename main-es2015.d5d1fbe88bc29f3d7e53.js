(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(t,e,n){t.exports=n("zUnb")},1:function(t,e){},2:function(t,e){},3:function(t,e){},4:function(t,e){},5:function(t,e){},B9Yq:function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},EhIR:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e,n=this,s=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var s=.02519603282416938*(e+=t.charCodeAt(n));s-=e=s>>>0,e=(s*=e)>>>0,e+=4294967296*(s-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(t),n.s0<0&&(n.s0+=1),n.s1-=s(t),n.s1<0&&(n.s1+=1),n.s2-=s(t),n.s2<0&&(n.s2+=1),s=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),s=e&&e.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},PDX0:function(t,e){(function(e){t.exports=e}).call(this,{})},YSVl:function(t,e,n){var s=n("EhIR"),r=n("uDiL"),i=n("pJ6O"),a=n("yuCN"),o=n("euyF"),l=n("ie1u"),u=n("pJ3+");u.alea=s,u.xor128=r,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},YuTi:function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},euyF:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this;e.next=function(){var t,n,s=e.w,r=e.X,i=e.i;return e.w=s=s+1640531527|0,n=r[i+34&127],t=r[i=i+1&127],n^=n<<13,t^=t<<17,n=r[i]=(n^=n>>>15)^(t^=t>>>12),e.i=i,n+(s^s>>>16)|0},function(t,e){var n,s,r,i,a,o=[],l=128;for(e===(0|e)?(s=e,e=null):(e+="\0",s=0,l=Math.max(l,e.length)),r=0,i=-32;i<l;++i)e&&(s^=e.charCodeAt((i+32)%e.length)),0===i&&(a=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,i>=0&&(r=0==(n=o[127&i]^=s+(a=a+1640531527|0))?r+1:0);for(r>=128&&(o[127&(e&&e.length||0)]=-1),r=127,i=512;i>0;--i)s=o[r+34&127],n=o[r=r+1&127],s^=s<<13,n^=n<<17,o[r]=(s^=s>>>15)^(n^=n>>>12);t.w=a,t.X=o,t.i=r}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.X&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},g5Dd:function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),s=0;s<t.length;s++)n[t.charCodeAt(s)]=s;e.encode=function(e){var n,s=new Uint8Array(e),r=s.length,i="";for(n=0;n<r;n+=3)i+=t[s[n]>>2],i+=t[(3&s[n])<<4|s[n+1]>>4],i+=t[(15&s[n+1])<<2|s[n+2]>>6],i+=t[63&s[n+2]];return r%3==2?i=i.substring(0,i.length-1)+"=":r%3==1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,s,r,i,a,o=.75*t.length,l=t.length,u=0;"="===t[t.length-1]&&(o--,"="===t[t.length-2]&&o--);var c=new ArrayBuffer(o),h=new Uint8Array(c);for(e=0;e<l;e+=4)s=n[t.charCodeAt(e)],r=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],a=n[t.charCodeAt(e+3)],h[u++]=s<<2|r>>4,h[u++]=(15&r)<<4|i>>2,h[u++]=(3&i)<<6|63&a;return c}}()},ie1u:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,s=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-s|0,e.d=s<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var s=0;s<n.length+20;s++)e.b^=0|n.charCodeAt(s),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},"pJ3+":function(t,e,n){var s;!function(r,i){var a,o=this,l=i.pow(256,6),u=i.pow(2,52),c=2*u;function h(t,e,n){var s=[],h=m(f((e=1==e?{entropy:!0}:e||{}).entropy?[t,g(r)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(256):(t=new Uint8Array(256),(o.crypto||o.msCrypto).getRandomValues(t)),g(t)}catch(s){var e=o.navigator,n=e&&e.plugins;return[+new Date,o,n,o.screen,g(r)]}}():t,3),s),y=new d(s),b=function(){for(var t=y.g(6),e=l,n=0;t<u;)t=256*(t+n),e*=256,n=y.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|y.g(4)},b.quick=function(){return y.g(4)/4294967296},b.double=b,m(g(y.S),r),(e.pass||n||function(t,e,n,s){return s&&(s.S&&p(s,y),t.state=function(){return p(y,{})}),n?(i.random=t,e):t})(b,h,"global"in e?e.global:this==i,e.state)}function d(t){var e,n=t.length,s=this,r=0,i=s.i=s.j=0,a=s.S=[];for(n||(t=[n++]);r<256;)a[r]=r++;for(r=0;r<256;r++)a[r]=a[i=255&i+t[r%n]+(e=a[r])],a[i]=e;(s.g=function(t){for(var e,n=0,r=s.i,i=s.j,a=s.S;t--;)e=a[r=255&r+1],n=256*n+a[255&(a[r]=a[i=255&i+e])+(a[i]=e)];return s.i=r,s.j=i,n})(256)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){var n,s=[],r=typeof t;if(e&&"object"==r)for(n in t)try{s.push(f(t[n],e-1))}catch(i){}return s.length?s:"string"==r?t:t+"\0"}function m(t,e){for(var n,s=t+"",r=0;r<s.length;)e[255&r]=255&(n^=19*e[255&r])+s.charCodeAt(r++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=h,m(i.random(),r),t.exports){t.exports=h;try{a=n(3)}catch(y){}}else void 0===(s=(function(){return h}).call(e,n,e,t))||(t.exports=s)}([],Math)},pJ6O:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),s==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},uDiL:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},yuCN:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this;e.next=function(){var t,n,s=e.x,r=e.i;return t=s[r],n=(t^=t>>>7)^t<<24,n^=(t=s[r+1&7])^t>>>10,n^=(t=s[r+3&7])^t>>>3,n^=(t=s[r+4&7])^t<<7,t=s[r+7&7],s[r]=n^=(t^=t<<13)^t<<9,e.i=r+1&7,n},function(t,e){var n,s=[];if(e===(0|e))s[0]=e;else for(e=""+e,n=0;n<e.length;++n)s[7&n]=s[7&n]<<15^e.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n&&(s[7]=-1),t.x=s,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.x&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},zUnb:function(t,e,n){"use strict";n.r(e);var s={};n.r(s),n.d(s,"shuffle",function(){return D_}),n.d(s,"shuffleCombo",function(){return O_}),n.d(s,"clamp",function(){return L_}),n.d(s,"nearestLargerEven",function(){return M_}),n.d(s,"sum",function(){return P_}),n.d(s,"randUniform",function(){return z_}),n.d(s,"distSquared",function(){return B_}),n.d(s,"assert",function(){return V_}),n.d(s,"assertShapesMatch",function(){return W_}),n.d(s,"assertNonNull",function(){return U_}),n.d(s,"flatten",function(){return j_}),n.d(s,"sizeFromShape",function(){return H_}),n.d(s,"isScalarShape",function(){return G_}),n.d(s,"arraysEqual",function(){return q_}),n.d(s,"isInt",function(){return K_}),n.d(s,"tanh",function(){return X_}),n.d(s,"sizeToSquarishShape",function(){return Q_}),n.d(s,"createShuffledIndices",function(){return Y_}),n.d(s,"rightPad",function(){return Z_}),n.d(s,"repeatedTry",function(){return J_}),n.d(s,"inferFromImplicitShape",function(){return tk}),n.d(s,"parseAxisParam",function(){return ek}),n.d(s,"squeezeShape",function(){return nk}),n.d(s,"getTypedArrayFromDType",function(){return sk}),n.d(s,"getArrayFromDType",function(){return rk}),n.d(s,"checkConversionForErrors",function(){return ik}),n.d(s,"isValidDtype",function(){return ak}),n.d(s,"hasEncodingLoss",function(){return ok}),n.d(s,"isTypedArray",function(){return lk}),n.d(s,"bytesPerElement",function(){return uk}),n.d(s,"bytesFromStringArray",function(){return ck}),n.d(s,"isString",function(){return hk}),n.d(s,"isBoolean",function(){return dk}),n.d(s,"isNumber",function(){return pk}),n.d(s,"inferDtype",function(){return fk}),n.d(s,"isFunction",function(){return mk}),n.d(s,"nearestDivisor",function(){return gk}),n.d(s,"computeStrides",function(){return yk}),n.d(s,"toNestedArray",function(){return xk}),n.d(s,"makeOnesTypedArray",function(){return vk}),n.d(s,"makeZerosTypedArray",function(){return wk}),n.d(s,"makeZerosNestedTypedArray",function(){return _k}),n.d(s,"assertNonNegativeIntegerDimensions",function(){return kk}),n.d(s,"locToIndex",function(){return Sk}),n.d(s,"indexToLoc",function(){return Ck}),n.d(s,"isPromise",function(){return Ik}),n.d(s,"createScalarValue",function(){return Vk}),n.d(s,"toTypedArray",function(){return Wk}),n.d(s,"now",function(){return Uk}),n.d(s,"fetch",function(){return jk}),n.d(s,"encodeString",function(){return Hk}),n.d(s,"decodeString",function(){return Gk});var r={};n.r(r),n.d(r,"makeTypesMatch",function(){return gS}),n.d(r,"assertTypesMatch",function(){return yS}),n.d(r,"isTensorInList",function(){return bS}),n.d(r,"getTensorsInContainer",function(){return xS});var i={};n.r(i),n.d(i,"isMobile",function(){return NS}),n.d(i,"isBrowser",function(){return ES});var a={};n.r(a),n.d(a,"copyModel",function(){return wC}),n.d(a,"listModels",function(){return xC}),n.d(a,"moveModel",function(){return _C}),n.d(a,"removeModel",function(){return vC}),n.d(a,"browserFiles",function(){return RC}),n.d(a,"browserHTTPRequest",function(){return BC}),n.d(a,"concatenateArrayBuffers",function(){return HS}),n.d(a,"decodeWeights",function(){return VS}),n.d(a,"encodeWeights",function(){return BS}),n.d(a,"fromMemory",function(){return UC}),n.d(a,"getLoadHandlers",function(){return JS}),n.d(a,"getModelArtifactsInfoForJSON",function(){return qS}),n.d(a,"getSaveHandlers",function(){return ZS}),n.d(a,"http",function(){return zC}),n.d(a,"isHTTPScheme",function(){return MC}),n.d(a,"loadWeights",function(){return DC}),n.d(a,"registerLoadRouter",function(){return YS}),n.d(a,"registerSaveRouter",function(){return QS}),n.d(a,"weightsLoaderFactory",function(){return OC}),n.d(a,"withSaveHandler",function(){return jC});var o={};n.r(o),n.d(o,"fromPixelsAsync",function(){return qC}),n.d(o,"toPixels",function(){return KC}),n.d(o,"fromPixels",function(){return XC});var l={};n.r(l),n.d(l,"assertParamsValid",function(){return QC}),n.d(l,"maskToAxes",function(){return YC}),n.d(l,"computeOutShape",function(){return ZC}),n.d(l,"stridesWithElidedDims",function(){return JC}),n.d(l,"getNormalizedAxes",function(){return nI}),n.d(l,"startIndicesWithElidedDims",function(){return sI}),n.d(l,"stopIndicesWithElidedDims",function(){return rI}),n.d(l,"stridesForAxis",function(){return iI}),n.d(l,"startForAxis",function(){return aI}),n.d(l,"stopForAxis",function(){return oI}),n.d(l,"isSliceContinous",function(){return lI}),n.d(l,"computeFlatOffset",function(){return uI}),n.d(l,"parseSliceParams",function(){return cI}),n.d(l,"sliceInfo",function(){return hI});var u={};n.r(u),n.d(u,"Serializable",function(){return dI}),n.d(u,"SerializationMap",function(){return pI}),n.d(u,"registerClass",function(){return fI});var c={};n.r(c),n.d(c,"conv2d",function(){return GE}),n.d(c,"depthwiseConv2d",function(){return XE}),n.d(c,"matMul",function(){return YE});var h={};n.r(h),n.d(h,"segOpComputeOptimalWindowSize",function(){return yA}),n.d(h,"computeOutShape",function(){return bA}),n.d(h,"collectGatherOpShapeInfo",function(){return xA});var d={};n.r(d),n.d(d,"axesAreInnerMostDims",function(){return MN}),n.d(d,"combineLocations",function(){return PN}),n.d(d,"computeOutAndReduceShapes",function(){return zN}),n.d(d,"expandShapeToKeepDim",function(){return BN}),n.d(d,"assertAxesAreInnerMostDims",function(){return VN}),n.d(d,"getAxesPermutation",function(){return WN}),n.d(d,"getUndoAxesPermutation",function(){return UN}),n.d(d,"getInnerMostAxes",function(){return jN}),n.d(d,"getBroadcastDims",function(){return cN}),n.d(d,"getReductionAxes",function(){return hN}),n.d(d,"assertAndGetBroadcastShape",function(){return dN}),n.d(d,"assertParamsConsistent",function(){return PT}),n.d(d,"computeOutShape",function(){return zT}),n.d(d,"computeDilation2DInfo",function(){return TI}),n.d(d,"computePool2DInfo",function(){return AI}),n.d(d,"computePool3DInfo",function(){return RI}),n.d(d,"computeConv2DInfo",function(){return $I}),n.d(d,"computeConv3DInfo",function(){return FI}),n.d(d,"computeDefaultPad",function(){return DI}),n.d(d,"tupleValuesAreOne",function(){return zI}),n.d(d,"eitherStridesOrDilationsAreOne",function(){return BI}),n.d(d,"convertConv2DDataFormat",function(){return VI}),n.d(d,"getFusedDyActivation",function(){return WE}),n.d(d,"getFusedBiasGradient",function(){return UE}),n.d(d,"applyActivation",function(){return jE}),n.d(d,"shouldFuse",function(){return HE}),n.d(d,"PARALLELIZE_THRESHOLD",function(){return BT}),n.d(d,"computeOptimalWindowSize",function(){return VT}),n.d(d,"slice_util",function(){return l}),n.d(d,"upcastType",function(){return fS}),n.d(d,"getImageCenter",function(){return WT}),n.d(d,"getReshaped",function(){return UT}),n.d(d,"getPermuted",function(){return jT}),n.d(d,"getReshapedPermuted",function(){return HT}),n.d(d,"getSliceBeginCoords",function(){return GT}),n.d(d,"getSliceSize",function(){return qT}),n.d(d,"prepareAndValidate",function(){return KT}),n.d(d,"validateUpdateShape",function(){return XT}),n.d(d,"validateInput",function(){return QT}),n.d(d,"calculateShapes",function(){return YT}),n.d(d,"SELU_SCALEALPHA",function(){return ZT}),n.d(d,"SELU_SCALE",function(){return JT}),n.d(d,"ERF_P",function(){return tA}),n.d(d,"ERF_A1",function(){return eA}),n.d(d,"ERF_A2",function(){return nA}),n.d(d,"ERF_A3",function(){return sA}),n.d(d,"ERF_A4",function(){return rA}),n.d(d,"ERF_A5",function(){return iA}),n.d(d,"warn",function(){return aA}),n.d(d,"log",function(){return oA}),n.d(d,"mergeRealAndImagArrays",function(){return lA}),n.d(d,"splitRealAndImagArrays",function(){return uA}),n.d(d,"complexWithEvenIndex",function(){return cA}),n.d(d,"complexWithOddIndex",function(){return hA}),n.d(d,"getComplexWithIndex",function(){return dA}),n.d(d,"assignToTypedArray",function(){return pA}),n.d(d,"exponents",function(){return fA}),n.d(d,"exponent",function(){return mA}),n.d(d,"prepareSplitSize",function(){return gA}),n.d(d,"segment_util",function(){return h}),n.d(d,"fromUint8ToStringArray",function(){return vA}),n.d(d,"fromStringArrayToUint8",function(){return wA});var p={};n.r(p),n.d(p,"nonMaxSuppressionV3Impl",function(){return rT}),n.d(p,"nonMaxSuppressionV4Impl",function(){return iT}),n.d(p,"nonMaxSuppressionV5Impl",function(){return aT}),n.d(p,"whereImpl",function(){return _A});var f={};n.r(f),n.d(f,"json",function(){return vP});var m={};n.r(m),n.d(m,"json",function(){return wP});var g={};n.r(g),n.d(g,"json",function(){return _P});var y={};n.r(y),n.d(y,"json",function(){return kP});var b={};n.r(b),n.d(b,"json",function(){return SP});var x={};n.r(x),n.d(x,"json",function(){return CP});var v={};n.r(v),n.d(v,"json",function(){return IP});var w={};n.r(w),n.d(w,"json",function(){return NP});var _={};n.r(_),n.d(_,"json",function(){return EP});var k={};n.r(k),n.d(k,"json",function(){return TP});var S={};n.r(S),n.d(S,"json",function(){return AP});var C={};n.r(C),n.d(C,"json",function(){return RP});var I={};n.r(I),n.d(I,"json",function(){return $P});var N={};n.r(N),n.d(N,"json",function(){return FP});var E={};n.r(E),n.d(E,"json",function(){return DP});var T={};n.r(T),n.d(T,"json",function(){return OP});var A={};n.r(A),n.d(A,"json",function(){return LP});var R={};function $(t){return"function"==typeof t}n.r(R),n.d(R,"simpleAbsImpl",function(){return Qz}),n.d(R,"addImpl",function(){return Vz}),n.d(R,"bincountImpl",function(){return CB}),n.d(R,"bincountReduceImpl",function(){return IB}),n.d(R,"ceilImpl",function(){return TB}),n.d(R,"concatImpl",function(){return FB}),n.d(R,"expImpl",function(){return mV}),n.d(R,"expm1Impl",function(){return vV}),n.d(R,"floorImpl",function(){return zV}),n.d(R,"gatherV2Impl",function(){return HV}),n.d(R,"greaterImpl",function(){return qV}),n.d(R,"lessImpl",function(){return tW}),n.d(R,"linSpaceImpl",function(){return sW}),n.d(R,"logImpl",function(){return iW}),n.d(R,"maxImpl",function(){return pW}),n.d(R,"maximumImpl",function(){return gW}),n.d(R,"minimumImpl",function(){return NW}),n.d(R,"multiplyImpl",function(){return _V}),n.d(R,"negImpl",function(){return DW}),n.d(R,"notEqualImpl",function(){return WW}),n.d(R,"prodImpl",function(){return ZW}),n.d(R,"rangeImpl",function(){return tU}),n.d(R,"rsqrtImpl",function(){return cU}),n.d(R,"sliceImpl",function(){return wB}),n.d(R,"squaredDifferenceImpl",function(){return TU}),n.d(R,"stridedSliceImpl",function(){return $U}),n.d(R,"subImpl",function(){return EV}),n.d(R,"tileImpl",function(){return LU}),n.d(R,"topKImpl",function(){return MU}),n.d(R,"transposeImpl",function(){return eB}),n.d(R,"uniqueImpl",function(){return WU});let F=!1;const D={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else F&&console.log("RxJS: Back to a better error behavior. Thank you. <3");F=t},get useDeprecatedSynchronousErrorHandling(){return F}};function O(t){setTimeout(()=>{throw t},0)}const L={closed:!0,next(t){},error(t){if(D.useDeprecatedSynchronousErrorHandling)throw t;O(t)},complete(){}},M=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function P(t){return null!==t&&"object"==typeof t}const z=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let B=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:s,_unsubscribe:r,_subscriptions:i}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if($(r)){s&&(this._unsubscribe=void 0);try{r.call(this)}catch(a){e=a instanceof z?V(a.errors):[a]}}if(M(i)){let t=-1,n=i.length;for(;++t<n;){const n=i[t];if(P(n))try{n.unsubscribe()}catch(a){e=e||[],a instanceof z?e=e.concat(V(a.errors)):e.push(a)}}}if(e)throw new z(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:s}=n;if(null===s)n._parentOrParents=this;else if(s instanceof t){if(s===this)return n;n._parentOrParents=[s,this]}else{if(-1!==s.indexOf(this))return n;s.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function V(t){return t.reduce((t,e)=>t.concat(e instanceof z?e.errors:e),[])}const W=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class U extends B{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=L;break;case 1:if(!t){this.destination=L;break}if("object"==typeof t){t instanceof U?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new j(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new j(this,t,e,n)}}[W](){return this}static create(t,e,n){const s=new U(t,e,n);return s.syncErrorThrowable=!1,s}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class j extends U{constructor(t,e,n,s){let r;super(),this._parentSubscriber=t;let i=this;$(e)?r=e:e&&(r=e.next,n=e.error,s=e.complete,e!==L&&(i=Object.create(e),$(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=r,this._error=n,this._complete=s}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;D.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=D;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):O(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;O(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);D.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),D.useDeprecatedSynchronousErrorHandling)throw n;O(n)}}__tryOrSetError(t,e,n){if(!D.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(s){return D.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=s,t.syncErrorThrown=!0,!0):(O(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const H=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function G(t){return t}let q=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:s}=this,r=function(t,e,n){if(t){if(t instanceof U)return t;if(t[W])return t[W]()}return t||e||n?new U(t,e,n):new U(L)}(t,e,n);if(r.add(s?s.call(r,this.source):this.source||D.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),D.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(t){try{return this._subscribe(t)}catch(e){D.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:s}=t;if(e||s)return!1;t=n&&n instanceof U?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=K(e))((e,n)=>{let s;s=this.subscribe(e=>{try{t(e)}catch(r){n(r),s&&s.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[H](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?G:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=K(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function K(t){if(t||(t=D.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const X=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class Q extends B{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class Y extends U{constructor(t){super(t),this.destination=t}}let Z=(()=>{class t extends q{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[W](){return new Y(this)}lift(t){const e=new J(this,this);return e.operator=t,e}next(t){if(this.closed)throw new X;if(!this.isStopped){const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].next(t)}}error(t){if(this.closed)throw new X;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].error(t);this.observers.length=0}complete(){if(this.closed)throw new X;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let s=0;s<e;s++)n[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new X;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new X;return this.hasError?(t.error(this.thrownError),B.EMPTY):this.isStopped?(t.complete(),B.EMPTY):(this.observers.push(t),new Q(this,t))}asObservable(){const t=new q;return t.source=this,t}}return t.create=(t,e)=>new J(t,e),t})();class J extends Z{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):B.EMPTY}}function tt(t){return t&&"function"==typeof t.schedule}function et(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new nt(t,e))}}class nt{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new st(t,this.project,this.thisArg))}}class st extends U{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const rt=t=>e=>{for(let n=0,s=t.length;n<s&&!e.closed;n++)e.next(t[n]);e.complete()};function it(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const at=it(),ot=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function lt(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const ut=t=>{if(t&&"function"==typeof t[H])return s=t,t=>{const e=s[H]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(ot(t))return rt(t);if(lt(t))return n=t,t=>(n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,O),t);if(t&&"function"==typeof t[at])return e=t,t=>{const n=e[at]();for(;;){let e;try{e=n.next()}catch(s){return t.error(s),t}if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=P(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n,s};function ct(t,e){return new q(n=>{const s=new B;let r=0;return s.add(e.schedule(function(){r!==t.length?(n.next(t[r++]),n.closed||s.add(this.schedule())):n.complete()})),s})}function ht(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[H]}(t))return function(t,e){return new q(n=>{const s=new B;return s.add(e.schedule(()=>{const r=t[H]();s.add(r.subscribe({next(t){s.add(e.schedule(()=>n.next(t)))},error(t){s.add(e.schedule(()=>n.error(t)))},complete(){s.add(e.schedule(()=>n.complete()))}}))})),s})}(t,e);if(lt(t))return function(t,e){return new q(n=>{const s=new B;return s.add(e.schedule(()=>t.then(t=>{s.add(e.schedule(()=>{n.next(t),s.add(e.schedule(()=>n.complete()))}))},t=>{s.add(e.schedule(()=>n.error(t)))}))),s})}(t,e);if(ot(t))return ct(t,e);if(function(t){return t&&"function"==typeof t[at]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new q(n=>{const s=new B;let r;return s.add(()=>{r&&"function"==typeof r.return&&r.return()}),s.add(e.schedule(()=>{r=t[at](),s.add(e.schedule(function(){if(n.closed)return;let t,e;try{const n=r.next();t=n.value,e=n.done}catch(s){return void n.error(s)}e?n.complete():(n.next(t),this.schedule())}))})),s})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof q?t:new q(ut(t))}class dt extends U{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class pt extends U{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function ft(t,e){if(!e.closed)return t instanceof q?t.subscribe(e):ut(t)(e)}function mt(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?s=>s.pipe(mt((n,s)=>ht(t(n,s)).pipe(et((t,r)=>e(n,t,s,r))),n)):("number"==typeof e&&(n=e),e=>e.lift(new gt(t,n)))}class gt{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new yt(t,this.project,this.concurrent))}}class yt extends pt{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(e)}_innerSub(t){const e=new dt(this),n=this.destination;n.add(e);const s=ft(t,e);s!==e&&n.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function bt(t=Number.POSITIVE_INFINITY){return mt(G,t)}function xt(t,e){return e?ct(t,e):new q(rt(t))}function vt(...t){let e=Number.POSITIVE_INFINITY,n=null,s=t[t.length-1];return tt(s)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof s&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof q?t[0]:bt(e)(xt(t,n))}function wt(){return function(t){return t.lift(new _t(t))}}class _t{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const s=new kt(t,n),r=e.subscribe(s);return s.closed||(s.connection=n.connect()),r}}class kt extends U{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,s=t._connection;this.connection=null,!s||n&&s!==n||s.unsubscribe()}}class St extends q{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new B,t.add(this.source.subscribe(new It(this.getSubject(),this))),t.closed&&(this._connection=null,t=B.EMPTY)),t}refCount(){return wt()(this)}}const Ct=(()=>{const t=St.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class It extends Y{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function Nt(){return new Z}function Et(t){for(let e in t)if(t[e]===Et)return e;throw Error("Could not find renamed property on target object.")}function Tt(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function At(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(At).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function Rt(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const $t=Et({__forward_ref__:Et});function Ft(t){return t.__forward_ref__=Ft,t.toString=function(){return At(this())},t}function Dt(t){return Ot(t)?t():t}function Ot(t){return"function"==typeof t&&t.hasOwnProperty($t)&&t.__forward_ref__===Ft}class Lt extends Error{constructor(t,e){super(function(t,e){return`${t?`NG0${t}: `:""}${e}`}(t,e)),this.code=t}}function Mt(t){return"string"==typeof t?t:null==t?"":String(t)}function Pt(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():Mt(t)}function zt(t,e){const n=e?` in ${e}`:"";throw new Lt("201",`No provider for ${Pt(t)} found${n}`)}function Bt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Vt(t){return{providers:t.providers||[],imports:t.imports||[]}}function Wt(t){return Ut(t,Ht)||Ut(t,qt)}function Ut(t,e){return t.hasOwnProperty(e)?t[e]:null}function jt(t){return t&&(t.hasOwnProperty(Gt)||t.hasOwnProperty(Kt))?t[Gt]:null}const Ht=Et({"\u0275prov":Et}),Gt=Et({"\u0275inj":Et}),qt=Et({ngInjectableDef:Et}),Kt=Et({ngInjectorDef:Et});var Xt=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});let Qt;function Yt(t){const e=Qt;return Qt=t,e}function Zt(t,e,n){const s=Wt(t);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:n&Xt.Optional?null:void 0!==e?e:void zt(At(t),"Injector")}function Jt(t){return{toString:t}.toString()}var te=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),ee=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const ne="undefined"!=typeof globalThis&&globalThis,se="undefined"!=typeof window&&window,re="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,ie="undefined"!=typeof global&&global,ae=ne||ie||se||re,oe={},le=[],ue=[],ce=Et({"\u0275cmp":Et}),he=Et({"\u0275dir":Et}),de=Et({"\u0275pipe":Et}),pe=Et({"\u0275mod":Et}),fe=Et({"\u0275loc":Et}),me=Et({"\u0275fac":Et}),ge=Et({__NG_ELEMENT_ID__:Et});let ye=0;function be(t){return Jt(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===te.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||ue,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||ee.Emulated,id:"c",styles:t.styles||ue,_:null,setInput:null,schemas:t.schemas||null,tView:null},s=t.directives,r=t.features,i=t.pipes;return n.id+=ye++,n.inputs=ke(t.inputs,e),n.outputs=ke(t.outputs),r&&r.forEach(t=>t(n)),n.directiveDefs=s?()=>("function"==typeof s?s():s).map(xe):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(ve):null,n})}function xe(t){return Ce(t)||function(t){return t[he]||null}(t)}function ve(t){return function(t){return t[de]||null}(t)}const we={};function _e(t){const e={type:t.type,bootstrap:t.bootstrap||ue,declarations:t.declarations||ue,imports:t.imports||ue,exports:t.exports||ue,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&Jt(()=>{we[t.id]=t.type}),e}function ke(t,e){if(null==t)return oe;const n={};for(const s in t)if(t.hasOwnProperty(s)){let r=t[s],i=r;Array.isArray(r)&&(i=r[1],r=r[0]),n[r]=s,e&&(e[r]=i)}return n}const Se=be;function Ce(t){return t[ce]||null}function Ie(t,e){const n=t[pe]||null;if(!n&&!0===e)throw new Error(`Type ${At(t)} does not have '\u0275mod' property.`);return n}function Ne(t){return Array.isArray(t)&&"object"==typeof t[1]}function Ee(t){return Array.isArray(t)&&!0===t[1]}function Te(t){return 0!=(8&t.flags)}function Ae(t){return 2==(2&t.flags)}function Re(t){return 1==(1&t.flags)}function $e(t){return null!==t.template}function Fe(t,e){return t.hasOwnProperty(me)?t[me]:null}class De{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function Oe(){return Le}function Le(t){return t.type.prototype.ngOnChanges&&(t.setInput=Pe),Me}function Me(){const t=ze(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===oe)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function Pe(t,e,n,s){const r=ze(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:oe,current:null}),i=r.current||(r.current={}),a=r.previous,o=this.declaredInputs[n],l=a[o];i[o]=new De(l&&l.currentValue,e,a===oe),t[s]=e}function ze(t){return t.__ngSimpleChanges__||null}let Be;function Ve(t){return!!t.listen}Oe.ngInherit=!0;const We={createRenderer:(t,e)=>void 0!==Be?Be:"undefined"!=typeof document?document:void 0};function Ue(t){for(;Array.isArray(t);)t=t[0];return t}function je(t,e){return Ue(e[t])}function He(t,e){return Ue(e[t.index])}function Ge(t,e){return t.data[e]}function qe(t,e){const n=e[t];return Ne(n)?n:n[0]}function Ke(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function Xe(t){return 4==(4&t[2])}function Qe(t){return 128==(128&t[2])}function Ye(t,e){return null==e?null:t[e]}function Ze(t){t[18]=0}function Je(t,e){t[5]+=e;let n=t,s=t[3];for(;null!==s&&(1===e&&1===n[5]||-1===e&&0===n[5]);)s[5]+=e,n=s,s=s[3]}const tn={lFrame:Sn(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function en(){return tn.bindingsEnabled}function nn(){return tn.lFrame.lView}function sn(){return tn.lFrame.tView}function rn(t){tn.lFrame.contextLView=t}function an(){let t=on();for(;null!==t&&64===t.type;)t=t.parent;return t}function on(){return tn.lFrame.currentTNode}function ln(t,e){const n=tn.lFrame;n.currentTNode=t,n.isParent=e}function un(){return tn.lFrame.isParent}function cn(){tn.lFrame.isParent=!1}function hn(){return tn.isInCheckNoChangesMode}function dn(t){tn.isInCheckNoChangesMode=t}function pn(){return tn.lFrame.bindingIndex++}function fn(t){const e=tn.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+t,n}function mn(t,e){const n=tn.lFrame;n.bindingIndex=n.bindingRootIndex=t,gn(e)}function gn(t){tn.lFrame.currentDirectiveIndex=t}function yn(t){const e=tn.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function bn(){return tn.lFrame.currentQueryIndex}function xn(t){tn.lFrame.currentQueryIndex=t}function vn(t){const e=t[1];return 2===e.type?e.declTNode:1===e.type?t[6]:null}function wn(t,e,n){if(n&Xt.SkipSelf){let s=e,r=t;for(;s=s.parent,!(null!==s||n&Xt.Host||(s=vn(r),null===s)||(r=r[15],10&s.type)););if(null===s)return!1;e=s,t=r}const s=tn.lFrame=kn();return s.currentTNode=e,s.lView=t,!0}function _n(t){const e=kn(),n=t[1];tn.lFrame=e,e.currentTNode=n.firstChild,e.lView=t,e.tView=n,e.contextLView=t,e.bindingIndex=n.bindingStartIndex,e.inI18n=!1}function kn(){const t=tn.lFrame,e=null===t?null:t.child;return null===e?Sn(t):e}function Sn(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function Cn(){const t=tn.lFrame;return tn.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const In=Cn;function Nn(){const t=Cn();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function En(){return tn.lFrame.selectedIndex}function Tn(t){tn.lFrame.selectedIndex=t}function An(){const t=tn.lFrame;return Ge(t.tView,t.selectedIndex)}function Rn(){tn.lFrame.currentNamespace="http://www.w3.org/2000/svg"}function $n(t,e){for(let n=e.directiveStart,s=e.directiveEnd;n<s;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:r,ngAfterViewInit:i,ngAfterViewChecked:a,ngOnDestroy:o}=e;s&&(t.contentHooks||(t.contentHooks=[])).push(-n,s),r&&((t.contentHooks||(t.contentHooks=[])).push(n,r),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,r)),i&&(t.viewHooks||(t.viewHooks=[])).push(-n,i),a&&((t.viewHooks||(t.viewHooks=[])).push(n,a),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,a)),null!=o&&(t.destroyHooks||(t.destroyHooks=[])).push(n,o)}}function Fn(t,e,n){Ln(t,e,3,n)}function Dn(t,e,n,s){(3&t[2])===n&&Ln(t,e,n,s)}function On(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function Ln(t,e,n,s){const r=null!=s?s:-1,i=e.length-1;let a=0;for(let o=void 0!==s?65535&t[18]:0;o<i;o++)if("number"==typeof e[o+1]){if(a=e[o],null!=s&&a>=s)break}else e[o]<0&&(t[18]+=65536),(a<r||-1==r)&&(Mn(t,n,e,o),t[18]=(4294901760&t[18])+o+2),o++}function Mn(t,e,n,s){const r=n[s]<0,i=n[s+1],a=t[r?-n[s]:n[s]];r?t[2]>>11<t[18]>>16&&(3&t[2])===e&&(t[2]+=2048,i.call(a)):i.call(a)}class Pn{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function zn(t,e,n){const s=Ve(t);let r=0;for(;r<n.length;){const i=n[r];if("number"==typeof i){if(0!==i)break;r++;const a=n[r++],o=n[r++],l=n[r++];s?t.setAttribute(e,o,l,a):e.setAttributeNS(a,o,l)}else{const a=i,o=n[++r];Vn(a)?s&&t.setProperty(e,a,o):s?t.setAttribute(e,a,o):e.setAttribute(a,o),r++}}return r}function Bn(t){return 3===t||4===t||6===t}function Vn(t){return 64===t.charCodeAt(0)}function Wn(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let s=0;s<e.length;s++){const r=e[s];"number"==typeof r?n=r:0===n||Un(t,n,r,null,-1===n||2===n?e[++s]:null)}}return t}function Un(t,e,n,s,r){let i=0,a=t.length;if(-1===e)a=-1;else for(;i<t.length;){const n=t[i++];if("number"==typeof n){if(n===e){a=-1;break}if(n>e){a=i-1;break}}}for(;i<t.length;){const e=t[i];if("number"==typeof e)break;if(e===n){if(null===s)return void(null!==r&&(t[i+1]=r));if(s===t[i+1])return void(t[i+2]=r)}i++,null!==s&&i++,null!==r&&i++}-1!==a&&(t.splice(a,0,e),i=a+1),t.splice(i++,0,n),null!==s&&t.splice(i++,0,s),null!==r&&t.splice(i++,0,r)}function jn(t){return-1!==t}function Hn(t){return 32767&t}function Gn(t,e){let n=t>>16,s=e;for(;n>0;)s=s[15],n--;return s}let qn=!0;function Kn(t){const e=qn;return qn=t,e}let Xn=0;function Qn(t,e){const n=Zn(t,e);if(-1!==n)return n;const s=e[1];s.firstCreatePass&&(t.injectorIndex=e.length,Yn(s.data,t),Yn(e,null),Yn(s.blueprint,null));const r=Jn(t,e),i=t.injectorIndex;if(jn(r)){const t=Hn(r),n=Gn(r,e),s=n[1].data;for(let r=0;r<8;r++)e[i+r]=n[t+r]|s[t+r]}return e[i+8]=r,i}function Yn(t,e){t.push(0,0,0,0,0,0,0,0,e)}function Zn(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function Jn(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=0,s=null,r=e;for(;null!==r;){const t=r[1],e=t.type;if(s=2===e?t.declTNode:1===e?r[6]:null,null===s)return-1;if(n++,r=r[15],-1!==s.injectorIndex)return s.injectorIndex|n<<16}return-1}function ts(t,e,n){!function(t,e,n){let s;"string"==typeof n?s=n.charCodeAt(0)||0:n.hasOwnProperty(ge)&&(s=n[ge]),null==s&&(s=n[ge]=Xn++);const r=255&s;e.data[t+(r>>5)]|=1<<r}(t,e,n)}function es(t,e,n){if(n&Xt.Optional)return t;zt(e,"NodeInjector")}function ns(t,e,n,s){if(n&Xt.Optional&&void 0===s&&(s=null),0==(n&(Xt.Self|Xt.Host))){const r=t[9],i=Yt(void 0);try{return r?r.get(e,s,n&Xt.Optional):Zt(e,s,n&Xt.Optional)}finally{Yt(i)}}return es(s,e,n)}function ss(t,e,n,s=Xt.Default,r){if(null!==t){const i=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(ge)?t[ge]:void 0;return"number"==typeof e?e>=0?255&e:is:e}(n);if("function"==typeof i){if(!wn(e,t,s))return s&Xt.Host?es(r,n,s):ns(e,n,s,r);try{const t=i();if(null!=t||s&Xt.Optional)return t;zt(n)}finally{In()}}else if("number"==typeof i){let r=null,a=Zn(t,e),o=-1,l=s&Xt.Host?e[16][6]:null;for((-1===a||s&Xt.SkipSelf)&&(o=-1===a?Jn(t,e):e[a+8],-1!==o&&cs(s,!1)?(r=e[1],a=Hn(o),e=Gn(o,e)):a=-1);-1!==a;){const t=e[1];if(us(i,a,t.data)){const t=as(a,e,n,r,s,l);if(t!==rs)return t}o=e[a+8],-1!==o&&cs(s,e[1].data[a+8]===l)&&us(i,a,e)?(r=t,a=Hn(o),e=Gn(o,e)):a=-1}}}return ns(e,n,s,r)}const rs={};function is(){return new hs(an(),nn())}function as(t,e,n,s,r,i){const a=e[1],o=a.data[t+8],l=os(o,a,n,null==s?Ae(o)&&qn:s!=a&&0!=(3&o.type),r&Xt.Host&&i===o);return null!==l?ls(e,a,l,o):rs}function os(t,e,n,s,r){const i=t.providerIndexes,a=e.data,o=1048575&i,l=t.directiveStart,u=i>>20,c=r?o+u:t.directiveEnd;for(let h=s?o:o+u;h<c;h++){const t=a[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(r){const t=a[l];if(t&&$e(t)&&t.type===n)return l}return null}function ls(t,e,n,s){let r=t[n];const i=e.data;if(r instanceof Pn){const a=r;a.resolving&&function(t,e){throw new Lt("200",`Circular dependency in DI detected for ${t}`)}(Pt(i[n]));const o=Kn(a.canSeeViewProviders);a.resolving=!0;const l=a.injectImpl?Yt(a.injectImpl):null;wn(t,s,Xt.Default);try{r=t[n]=a.factory(void 0,i,t,s),e.firstCreatePass&&n>=s.directiveStart&&function(t,e,n){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:i}=e.type.prototype;if(s){const s=Le(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,r),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i))}(n,i[n],e)}finally{null!==l&&Yt(l),Kn(o),a.resolving=!1,In()}}return r}function us(t,e,n){return!!(n[e+(t>>5)]&1<<t)}function cs(t,e){return!(t&Xt.Self||t&Xt.Host&&e)}class hs{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return ss(this._tNode,this._lView,t,void 0,e)}}function ds(t){return Jt(()=>{const e=t.prototype.constructor,n=e[me]||ps(e),s=Object.prototype;let r=Object.getPrototypeOf(t.prototype).constructor;for(;r&&r!==s;){const t=r[me]||ps(r);if(t&&t!==n)return t;r=Object.getPrototypeOf(r)}return t=>new t})}function ps(t){return Ot(t)?()=>{const e=ps(Dt(t));return e&&e()}:Fe(t)}function fs(t,e,n){return Jt(()=>{const s=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function r(...t){if(this instanceof r)return s.apply(this,t),this;const e=new r(...t);return n.annotation=e,n;function n(t,n,s){const r=t.hasOwnProperty("__parameters__")?t.__parameters__:Object.defineProperty(t,"__parameters__",{value:[]}).__parameters__;for(;r.length<=s;)r.push(null);return(r[s]=r[s]||[]).push(e),t}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=t,r.annotationCls=r,r})}class ms{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Bt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const gs=new ms("AnalyzeForEntryComponents"),ys=Function;function bs(t,e){void 0===e&&(e=t);for(let n=0;n<t.length;n++){let s=t[n];Array.isArray(s)?(e===t&&(e=t.slice(0,n)),bs(s,e)):e!==t&&e.push(s)}return e}function xs(t,e){t.forEach(t=>Array.isArray(t)?xs(t,e):e(t))}function vs(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function ws(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function _s(t,e){const n=[];for(let s=0;s<t;s++)n.push(e);return n}function ks(t,e,n){let s=Cs(t,e);return s>=0?t[1|s]=n:(s=~s,function(t,e,n,s){let r=t.length;if(r==e)t.push(n,s);else if(1===r)t.push(s,t[0]),t[0]=n;else{for(r--,t.push(t[r-1],t[r]);r>e;)t[r]=t[r-2],r--;t[e]=n,t[e+1]=s}}(t,s,e,n)),s}function Ss(t,e){const n=Cs(t,e);if(n>=0)return t[1|n]}function Cs(t,e){return function(t,e,n){let s=0,r=t.length>>1;for(;r!==s;){const n=s+(r-s>>1),i=t[n<<1];if(e===i)return n<<1;i>e?r=n:s=n+1}return~(r<<1)}(t,e)}const Is={},Ns=/\n/gm,Es=Et({provide:String,useValue:Et});let Ts;function As(t){const e=Ts;return Ts=t,e}function Rs(t,e=Xt.Default){if(void 0===Ts)throw new Error("inject() must be called from an injection context");return null===Ts?Zt(t,void 0,e):Ts.get(t,e&Xt.Optional?null:void 0,e)}function $s(t,e=Xt.Default){return(Qt||Rs)(Dt(t),e)}const Fs=$s;function Ds(t){const e=[];for(let n=0;n<t.length;n++){const s=Dt(t[n]);if(Array.isArray(s)){if(0===s.length)throw new Error("Arguments array must have arguments.");let t,n=Xt.Default;for(let e=0;e<s.length;e++){const r=s[e],i=r.__NG_DI_FLAG__;"number"==typeof i?-1===i?t=r.token:n|=i:t=r}e.push($s(t,n))}else e.push($s(s))}return e}function Os(t,e){return t.__NG_DI_FLAG__=e,t.prototype.__NG_DI_FLAG__=e,t}const Ls=Os(fs("Inject",t=>({token:t})),-1),Ms=Os(fs("Optional"),8),Ps=Os(fs("SkipSelf"),4);let zs;function Bs(t){var e;return(null===(e=function(){if(void 0===zs&&(zs=null,ae.trustedTypes))try{zs=ae.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return zs}())||void 0===e?void 0:e.createHTML(t))||t}class Vs{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class Ws extends Vs{getTypeName(){return"HTML"}}class Us extends Vs{getTypeName(){return"Style"}}class js extends Vs{getTypeName(){return"Script"}}class Hs extends Vs{getTypeName(){return"URL"}}class Gs extends Vs{getTypeName(){return"ResourceURL"}}function qs(t){return t instanceof Vs?t.changingThisBreaksApplicationSecurity:t}function Ks(t,e){const n=Xs(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`)}return n===e}function Xs(t){return t instanceof Vs&&t.getTypeName()||null}class Qs{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(Bs(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class Ys{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const t=this.inertDocument.createElement("html");this.inertDocument.appendChild(t);const e=this.inertDocument.createElement("body");t.appendChild(e)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=Bs(t),e;const n=this.inertDocument.createElement("body");return n.innerHTML=Bs(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(n),n}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const n=e.item(s).name;"xmlns:ns1"!==n&&0!==n.indexOf("ns1:")||t.removeAttribute(n)}let n=t.firstChild;for(;n;)n.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(n),n=n.nextSibling}}const Zs=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,Js=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function tr(t){return(t=String(t)).match(Zs)||t.match(Js)?t:"unsafe:"+t}function er(t){const e={};for(const n of t.split(","))e[n]=!0;return e}function nr(...t){const e={};for(const n of t)for(const t in n)n.hasOwnProperty(t)&&(e[t]=!0);return e}const sr=er("area,br,col,hr,img,wbr"),rr=er("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),ir=er("rp,rt"),ar=nr(ir,rr),or=nr(sr,nr(rr,er("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),nr(ir,er("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),ar),lr=er("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),ur=er("srcset"),cr=nr(lr,ur,er("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),er("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),hr=er("script,style,template");class dr{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,n=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?n=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,n&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let t=this.checkClobberedElement(e,e.nextSibling);if(t){e=t;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!or.hasOwnProperty(e))return this.sanitizedSomething=!0,!hr.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const n=t.attributes;for(let r=0;r<n.length;r++){const t=n.item(r),e=t.name,i=e.toLowerCase();if(!cr.hasOwnProperty(i)){this.sanitizedSomething=!0;continue}let a=t.value;lr[i]&&(a=tr(a)),ur[i]&&(s=a,a=(s=String(s)).split(",").map(t=>tr(t.trim())).join(", ")),this.buf.push(" ",e,'="',mr(a),'"')}var s;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();or.hasOwnProperty(e)&&!sr.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(mr(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const pr=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,fr=/([^\#-~ |!])/g;function mr(t){return t.replace(/&/g,"&amp;").replace(pr,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(fr,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let gr;function yr(t){return"content"in t&&function(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var br=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function xr(t){return t.ngDebugContext}function vr(t){return t.ngOriginalError}function wr(t,...e){t.error(...e)}class _r{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),s=function(t){return t.ngErrorLogger||wr}(t);s(this._console,"ERROR",t),e&&s(this._console,"ORIGINAL ERROR",e),n&&s(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?xr(t)?xr(t):this._findContext(vr(t)):null}_findOriginalError(t){let e=vr(t);for(;e&&vr(e);)e=vr(e);return e}}function kr(t,e){t.__ngContext__=e}const Sr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(ae))();function Cr(t){return t instanceof Function?t():t}var Ir=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});function Nr(t,e){return(void 0)(t,e)}function Er(t){const e=t[3];return Ee(e)?e[3]:e}function Tr(t){return Rr(t[13])}function Ar(t){return Rr(t[4])}function Rr(t){for(;null!==t&&!Ee(t);)t=t[4];return t}function $r(t,e,n,s,r){if(null!=s){let i,a=!1;Ee(s)?i=s:Ne(s)&&(a=!0,s=s[0]);const o=Ue(s);0===t&&null!==n?null==r?Br(e,n,o):zr(e,n,o,r||null,!0):1===t&&null!==n?zr(e,n,o,r||null,!0):2===t?function(t,e,n){const s=Wr(t,e);s&&function(t,e,n,s){Ve(t)?t.removeChild(e,n,s):e.removeChild(n)}(t,s,e,n)}(e,o,a):3===t&&e.destroyNode(o),null!=i&&function(t,e,n,s,r){const i=n[7];i!==Ue(n)&&$r(e,t,s,i,r);for(let a=10;a<n.length;a++){const r=n[a];Qr(r[1],r,t,e,s,i)}}(e,t,i,n,r)}}function Fr(t,e,n){return Ve(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function Dr(t,e){const n=t[9],s=n.indexOf(e),r=e[3];1024&e[2]&&(e[2]&=-1025,Je(r,-1)),n.splice(s,1)}function Or(t,e){if(t.length<=10)return;const n=10+e,s=t[n];if(s){const i=s[17];null!==i&&i!==t&&Dr(i,s),e>0&&(t[n-1][4]=s[4]);const a=ws(t,10+e);Qr(s[1],r=s,r[11],2,null,null),r[0]=null,r[6]=null;const o=a[19];null!==o&&o.detachView(a[1]),s[3]=null,s[4]=null,s[2]&=-129}var r;return s}function Lr(t,e){if(!(256&e[2])){const n=e[11];Ve(n)&&n.destroyNode&&Qr(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return Mr(t[1],t);for(;e;){let n=null;if(Ne(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Ne(e)&&Mr(e[1],e),e=e[3];null===e&&(e=t),Ne(e)&&Mr(e[1],e),n=e&&e[4]}e=n}}(e)}}function Mr(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let s=0;s<n.length;s+=2){const t=e[n[s]];if(!(t instanceof Pn)){const e=n[s+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2)e[n+1].call(t[e[n]]);else e.call(t)}}}(t,e),function(t,e){const n=t.cleanup,s=e[7];let r=-1;if(null!==n)for(let i=0;i<n.length-1;i+=2)if("string"==typeof n[i]){const t=n[i+1],a="function"==typeof t?t(e):Ue(e[t]),o=s[r=n[i+2]],l=n[i+3];"boolean"==typeof l?a.removeEventListener(n[i],o,l):l>=0?s[r=l]():s[r=-l].unsubscribe(),i+=2}else{const t=s[r=n[i+1]];n[i].call(t)}if(null!==s){for(let t=r+1;t<s.length;t++)(0,s[t])();e[7]=null}}(t,e),1===e[1].type&&Ve(e[11])&&e[11].destroy();const n=e[17];if(null!==n&&Ee(e[3])){n!==e[3]&&Dr(n,e);const s=e[19];null!==s&&s.detachView(t)}}}function Pr(t,e,n){return function(t,e,n){let s=e;for(;null!==s&&40&s.type;)s=(e=s).parent;if(null===s)return n[0];if(2&s.flags){const e=t.data[s.directiveStart].encapsulation;if(e===ee.None||e===ee.Emulated)return null}return He(s,n)}(t,e.parent,n)}function zr(t,e,n,s,r){Ve(t)?t.insertBefore(e,n,s,r):e.insertBefore(n,s,r)}function Br(t,e,n){Ve(t)?t.appendChild(e,n):e.appendChild(n)}function Vr(t,e,n,s,r){null!==s?zr(t,e,n,s,r):Br(t,e,n)}function Wr(t,e){return Ve(t)?t.parentNode(e):e.parentNode}function Ur(t,e,n){return jr(t,e,n)}let jr=function(t,e,n){return 40&t.type?He(t,n):null};function Hr(t,e,n,s){const r=Pr(t,s,e),i=e[11],a=Ur(s.parent||e[6],s,e);if(null!=r)if(Array.isArray(n))for(let o=0;o<n.length;o++)Vr(i,r,n[o],a,!1);else Vr(i,r,n,a,!1)}function Gr(t,e){if(null!==e){const n=e.type;if(3&n)return He(e,t);if(4&n)return Kr(-1,t[e.index]);if(8&n){const n=e.child;if(null!==n)return Gr(t,n);{const n=t[e.index];return Ee(n)?Kr(-1,n):Ue(n)}}if(32&n)return Nr(e,t)()||Ue(t[e.index]);{const n=qr(t,e);return null!==n?Array.isArray(n)?n[0]:Gr(Er(t[16]),n):Gr(t,e.next)}}return null}function qr(t,e){return null!==e?t[16][6].projection[e.projection]:null}function Kr(t,e){const n=10+t+1;if(n<e.length){const t=e[n],s=t[1].firstChild;if(null!==s)return Gr(t,s)}return e[7]}function Xr(t,e,n,s,r,i,a){for(;null!=n;){const o=s[n.index],l=n.type;if(a&&0===e&&(o&&kr(Ue(o),s),n.flags|=4),64!=(64&n.flags))if(8&l)Xr(t,e,n.child,s,r,i,!1),$r(e,t,r,o,i);else if(32&l){const a=Nr(n,s);let l;for(;l=a();)$r(e,t,r,l,i);$r(e,t,r,o,i)}else 16&l?Yr(t,e,s,n,r,i):$r(e,t,r,o,i);n=a?n.projectionNext:n.next}}function Qr(t,e,n,s,r,i){Xr(n,s,t.firstChild,e,r,i,!1)}function Yr(t,e,n,s,r,i){const a=n[16],o=a[6].projection[s.projection];if(Array.isArray(o))for(let l=0;l<o.length;l++)$r(e,t,r,o[l],i);else Xr(t,e,o,a[3],r,i,!0)}function Zr(t,e,n){Ve(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function Jr(t,e,n){Ve(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}function ti(t,e,n){let s=t.length;for(;;){const r=t.indexOf(e,n);if(-1===r)return r;if(0===r||t.charCodeAt(r-1)<=32){const n=e.length;if(r+n===s||t.charCodeAt(r+n)<=32)return r}n=r+1}}function ei(t,e,n){let s=0;for(;s<t.length;){let r=t[s++];if(n&&"class"===r){if(r=t[s],-1!==ti(r.toLowerCase(),e,0))return!0}else if(1===r){for(;s<t.length&&"string"==typeof(r=t[s++]);)if(r.toLowerCase()===e)return!0;return!1}}return!1}function ni(t){return 4===t.type&&"ng-template"!==t.value}function si(t,e,n){return e===(4!==t.type||n?t.value:"ng-template")}function ri(t,e,n){let s=4;const r=t.attrs||[],i=function(t){for(let e=0;e<t.length;e++)if(Bn(t[e]))return e;return t.length}(r);let a=!1;for(let o=0;o<e.length;o++){const l=e[o];if("number"!=typeof l){if(!a)if(4&s){if(s=2|1&s,""!==l&&!si(t,l,n)||""===l&&1===e.length){if(ii(s))return!1;a=!0}}else{const u=8&s?l:e[++o];if(8&s&&null!==t.attrs){if(!ei(t.attrs,u,n)){if(ii(s))return!1;a=!0}continue}const c=ai(8&s?"class":l,r,ni(t),n);if(-1===c){if(ii(s))return!1;a=!0;continue}if(""!==u){let t;t=c>i?"":r[c+1].toLowerCase();const e=8&s?t:null;if(e&&-1!==ti(e,u,0)||2&s&&u!==t){if(ii(s))return!1;a=!0}}}}else{if(!a&&!ii(s)&&!ii(l))return!1;if(a&&ii(l))continue;a=!1,s=l|1&s}}return ii(s)||a}function ii(t){return 0==(1&t)}function ai(t,e,n,s){if(null===e)return-1;let r=0;if(s||!n){let n=!1;for(;r<e.length;){const s=e[r];if(s===t)return r;if(3===s||6===s)n=!0;else{if(1===s||2===s){let t=e[++r];for(;"string"==typeof t;)t=e[++r];continue}if(4===s)break;if(0===s){r+=4;continue}}r+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const s=t[n];if("number"==typeof s)return-1;if(s===e)return n;n++}return-1}(e,t)}function oi(t,e,n=!1){for(let s=0;s<e.length;s++)if(ri(t,e[s],n))return!0;return!1}function li(t,e){t:for(let n=0;n<e.length;n++){const s=e[n];if(t.length===s.length){for(let e=0;e<t.length;e++)if(t[e]!==s[e])continue t;return!0}}return!1}function ui(t,e){return t?":not("+e.trim()+")":e}function ci(t){let e=t[0],n=1,s=2,r="",i=!1;for(;n<t.length;){let a=t[n];if("string"==typeof a)if(2&s){const e=t[++n];r+="["+a+(e.length>0?'="'+e+'"':"")+"]"}else 8&s?r+="."+a:4&s&&(r+=" "+a);else""===r||ii(a)||(e+=ui(i,r),r=""),s=a,i=i||!ii(s);n++}return""!==r&&(e+=ui(i,r)),e}const hi={};function di(t){pi(sn(),nn(),En()+t,hn())}function pi(t,e,n,s){if(!s)if(3==(3&e[2])){const s=t.preOrderCheckHooks;null!==s&&Fn(e,s,n)}else{const s=t.preOrderHooks;null!==s&&Dn(e,s,0,n)}Tn(n)}function fi(t,e){return t<<17|e<<2}function mi(t){return t>>17&32767}function gi(t){return 2|t}function yi(t){return(131068&t)>>2}function bi(t,e){return-131069&t|e<<2}function xi(t){return 1|t}function vi(t,e){const n=t.contentQueries;if(null!==n)for(let s=0;s<n.length;s+=2){const r=n[s],i=n[s+1];if(-1!==i){const n=t.data[i];xn(r),n.contentQueries(2,e[i],i)}}}function wi(t,e,n,s,r,i,a,o,l,u){const c=e.blueprint.slice();return c[0]=r,c[2]=140|s,Ze(c),c[3]=c[15]=t,c[8]=n,c[10]=a||t&&t[10],c[11]=o||t&&t[11],c[12]=l||t&&t[12]||null,c[9]=u||t&&t[9]||null,c[6]=i,c[16]=2==e.type?t[16]:c,c}function _i(t,e,n,s,r){let i=t.data[e];if(null===i)i=function(t,e,n,s,r){const i=on(),a=un(),o=t.data[e]=function(t,e,n,s,r,i){return{type:n,index:s,insertBeforeIndex:null,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,a?i:i&&i.parent,n,e,s,r);return null===t.firstChild&&(t.firstChild=o),null!==i&&(a?null==i.child&&null!==o.parent&&(i.child=o):null===i.next&&(i.next=o)),o}(t,e,n,s,r),tn.lFrame.inI18n&&(i.flags|=64);else if(64&i.type){i.type=n,i.value=s,i.attrs=r;const t=function(){const t=tn.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();i.injectorIndex=null===t?-1:t.injectorIndex}return ln(i,!0),i}function ki(t,e,n,s){if(0===n)return-1;const r=e.length;for(let i=0;i<n;i++)e.push(s),t.blueprint.push(s),t.data.push(null);return r}function Si(t,e,n){_n(e);try{const s=t.viewQuery;null!==s&&Ji(1,s,n);const r=t.template;null!==r&&Ni(t,e,r,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&vi(t,e),t.staticViewQueries&&Ji(2,t.viewQuery,n);const i=t.components;null!==i&&function(t,e){for(let n=0;n<e.length;n++)Ki(t,e[n])}(e,i)}catch(s){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),s}finally{e[2]&=-5,Nn()}}function Ci(t,e,n,s){const r=e[2];if(256==(256&r))return;_n(e);const i=hn();try{Ze(e),tn.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&Ni(t,e,n,2,s);const a=3==(3&r);if(!i)if(a){const n=t.preOrderCheckHooks;null!==n&&Fn(e,n,null)}else{const n=t.preOrderHooks;null!==n&&Dn(e,n,0,null),On(e,0)}if(function(t){for(let e=Tr(t);null!==e;e=Ar(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],s=n[3];0==(1024&n[2])&&Je(s,1),n[2]|=1024}}}(e),function(t){for(let e=Tr(t);null!==e;e=Ar(e))for(let t=10;t<e.length;t++){const n=e[t],s=n[1];Qe(n)&&Ci(s,n,s.template,n[8])}}(e),null!==t.contentQueries&&vi(t,e),!i)if(a){const n=t.contentCheckHooks;null!==n&&Fn(e,n)}else{const n=t.contentHooks;null!==n&&Dn(e,n,1),On(e,1)}!function(t,e){const n=t.hostBindingOpCodes;if(null!==n)try{for(let t=0;t<n.length;t++){const s=n[t];if(s<0)Tn(~s);else{const r=s,i=n[++t],a=n[++t];mn(i,r),a(2,e[r])}}}finally{Tn(-1)}}(t,e);const o=t.components;null!==o&&function(t,e){for(let n=0;n<e.length;n++)Gi(t,e[n])}(e,o);const l=t.viewQuery;if(null!==l&&Ji(2,l,s),!i)if(a){const n=t.viewCheckHooks;null!==n&&Fn(e,n)}else{const n=t.viewHooks;null!==n&&Dn(e,n,2),On(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),i||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,Je(e[3],-1))}finally{Nn()}}function Ii(t,e,n,s){const r=e[10],i=!hn(),a=Xe(e);try{i&&!a&&r.begin&&r.begin(),a&&Si(t,e,s),Ci(t,e,n,s)}finally{i&&!a&&r.end&&r.end()}}function Ni(t,e,n,s,r){const i=En();try{Tn(-1),2&s&&e.length>20&&pi(t,e,20,hn()),n(s,r)}finally{Tn(i)}}function Ei(t,e,n){en()&&(function(t,e,n,s){const r=n.directiveStart,i=n.directiveEnd;t.firstCreatePass||Qn(n,e),kr(s,e);const a=n.initialInputs;for(let o=r;o<i;o++){const s=t.data[o],i=$e(s);i&&Wi(e,n,s);const l=ls(e,t,o,n);kr(l,e),null!==a&&Ui(0,o-r,l,s,0,a),i&&(qe(n.index,e)[8]=l)}}(t,e,n,He(n,e)),128==(128&n.flags)&&function(t,e,n){const s=n.directiveStart,r=n.directiveEnd,i=n.index,a=tn.lFrame.currentDirectiveIndex;try{Tn(i);for(let n=s;n<r;n++){const s=t.data[n],r=e[n];gn(n),null===s.hostBindings&&0===s.hostVars&&null===s.hostAttrs||Mi(s,r)}}finally{Tn(-1),gn(a)}}(t,e,n))}function Ti(t,e,n=He){const s=e.localNames;if(null!==s){let r=e.index+1;for(let i=0;i<s.length;i+=2){const a=s[i+1],o=-1===a?n(e,t):t[a];t[r++]=o}}}function Ai(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Ri(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function Ri(t,e,n,s,r,i,a,o,l,u){const c=20+s,h=c+r,d=function(t,e){const n=[];for(let s=0;s<e;s++)n.push(s<t?null:hi);return n}(c,h),p="function"==typeof u?u():u;return d[1]={type:t,blueprint:d,template:n,queries:null,viewQuery:o,declTNode:e,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof a?a():a,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function $i(t,e,n,s){const r=ea(e);null===n?r.push(s):(r.push(n),t.firstCreatePass&&na(t).push(s,r.length-1))}function Fi(t,e,n){for(let s in t)if(t.hasOwnProperty(s)){const r=t[s];(n=null===n?{}:n).hasOwnProperty(s)?n[s].push(e,r):n[s]=[e,r]}return n}function Di(t,e,n,s,r,i,a,o){const l=He(e,n);let u,c=e.inputs;var h;!o&&null!=c&&(u=c[s])?(ia(t,n,u,s,r),Ae(e)&&function(t,e){const n=qe(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3&e.type&&(s="class"===(h=s)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,r=null!=a?a(r,e.value||"",s):r,Ve(i)?i.setProperty(l,s,r):Vn(s)||(l.setProperty?l.setProperty(s,r):l[s]=r))}function Oi(t,e,n,s){let r=!1;if(en()){const i=function(t,e,n){const s=t.directiveRegistry;let r=null;if(s)for(let i=0;i<s.length;i++){const a=s[i];oi(n,a.selectors,!1)&&(r||(r=[]),ts(Qn(n,e),t,a.type),$e(a)?(Pi(t,n),r.unshift(a)):r.push(a))}return r}(t,e,n),a=null===s?null:{"":-1};if(null!==i){r=!0,Bi(n,t.data.length,i.length);for(let t=0;t<i.length;t++){const e=i[t];e.providersResolver&&e.providersResolver(e)}let s=!1,o=!1,l=ki(t,e,i.length,null);for(let r=0;r<i.length;r++){const u=i[r];n.mergedAttrs=Wn(n.mergedAttrs,u.hostAttrs),Vi(t,n,e,l,u),zi(l,u,a),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!s&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index),s=!0),o||!c.ngOnChanges&&!c.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index),o=!0),l++}!function(t,e){const n=e.directiveEnd,s=t.data,r=e.attrs,i=[];let a=null,o=null;for(let l=e.directiveStart;l<n;l++){const t=s[l],n=t.inputs,u=null===r||ni(e)?null:ji(n,r);i.push(u),a=Fi(n,l,a),o=Fi(t.outputs,l,o)}null!==a&&(a.hasOwnProperty("class")&&(e.flags|=16),a.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=i,e.inputs=a,e.outputs=o}(t,n)}a&&function(t,e,n){if(e){const s=t.localNames=[];for(let t=0;t<e.length;t+=2){const r=n[e[t+1]];if(null==r)throw new Lt("301",`Export of name '${e[t+1]}' not found!`);s.push(e[t],r)}}}(n,s,a)}return n.mergedAttrs=Wn(n.mergedAttrs,n.attrs),r}function Li(t,e,n,s,r,i){const a=i.hostBindings;if(a){let n=t.hostBindingOpCodes;null===n&&(n=t.hostBindingOpCodes=[]);const i=~e.index;(function(t){let e=t.length;for(;e>0;){const n=t[--e];if("number"==typeof n&&n<0)return n}return 0})(n)!=i&&n.push(i),n.push(s,r,a)}}function Mi(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Pi(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function zi(t,e,n){if(n){if(e.exportAs)for(let s=0;s<e.exportAs.length;s++)n[e.exportAs[s]]=t;$e(e)&&(n[""]=t)}}function Bi(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function Vi(t,e,n,s,r){t.data[s]=r;const i=r.factory||(r.factory=Fe(r.type)),a=new Pn(i,$e(r),null);t.blueprint[s]=a,n[s]=a,Li(t,e,0,s,ki(t,n,r.hostVars,hi),r)}function Wi(t,e,n){const s=He(e,t),r=Ai(n),i=t[10],a=Xi(t,wi(t,r,null,n.onPush?64:16,s,e,i,i.createRenderer(s,n),null,null));t[e.index]=a}function Ui(t,e,n,s,r,i){const a=i[e];if(null!==a){const t=s.setInput;for(let e=0;e<a.length;){const r=a[e++],i=a[e++],o=a[e++];null!==t?s.setInput(n,o,r,i):n[i]=o}}}function ji(t,e){let n=null,s=0;for(;s<e.length;){const r=e[s];if(0!==r)if(5!==r){if("number"==typeof r)break;t.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,t[r],e[s+1])),s+=2}else s+=2;else s+=4}return n}function Hi(t,e,n,s){return new Array(t,!0,!1,e,null,0,s,n,null,null)}function Gi(t,e){const n=qe(e,t);if(Qe(n)){const t=n[1];80&n[2]?Ci(t,n,t.template,n[8]):n[5]>0&&qi(n)}}function qi(t){for(let n=Tr(t);null!==n;n=Ar(n))for(let t=10;t<n.length;t++){const e=n[t];if(1024&e[2]){const t=e[1];Ci(t,e,t.template,e[8])}else e[5]>0&&qi(e)}const e=t[1].components;if(null!==e)for(let n=0;n<e.length;n++){const s=qe(e[n],t);Qe(s)&&s[5]>0&&qi(s)}}function Ki(t,e){const n=qe(e,t),s=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(s,n),Si(s,n,n[8])}function Xi(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function Qi(t){for(;t;){t[2]|=64;const e=Er(t);if(0!=(512&t[2])&&!e)return t;t=e}return null}function Yi(t,e,n){const s=e[10];s.begin&&s.begin();try{Ci(t,e,t.template,n)}catch(r){throw ra(e,r),r}finally{s.end&&s.end()}}function Zi(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],s=Ke(n),r=s[1];Ii(r,s,r.template,n)}}(t[8])}function Ji(t,e,n){xn(0),e(t,n)}const ta=(()=>Promise.resolve(null))();function ea(t){return t[7]||(t[7]=[])}function na(t){return t.cleanup||(t.cleanup=[])}function sa(t,e,n){return(null===t||$e(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function ra(t,e){const n=t[9],s=n?n.get(_r,null):null;s&&s.handleError(e)}function ia(t,e,n,s,r){for(let i=0;i<n.length;){const a=n[i++],o=n[i++],l=e[a],u=t.data[a];null!==u.setInput?u.setInput(l,r,s,o):l[o]=r}}function aa(t,e,n){const s=je(e,t);!function(t,e,n){Ve(t)?t.setValue(e,n):e.textContent=n}(t[11],s,n)}function oa(t,e,n){let s=n?t.styles:null,r=n?t.classes:null,i=0;if(null!==e)for(let a=0;a<e.length;a++){const t=e[a];"number"==typeof t?i=t:1==i?r=Rt(r,t):2==i&&(s=Rt(s,t+": "+e[++a]+";"))}n?t.styles=s:t.stylesWithoutHost=s,n?t.classes=r:t.classesWithoutHost=r}const la=new ms("INJECTOR",-1);class ua{get(t,e=Is){if(e===Is){const e=new Error(`NullInjectorError: No provider for ${At(t)}!`);throw e.name="NullInjectorError",e}return e}}const ca=new ms("Set Injector scope."),ha={},da={},pa=[];let fa;function ma(){return void 0===fa&&(fa=new ua),fa}function ga(t,e=null,n=null,s){return new ya(t,n,e||ma(),s)}class ya{constructor(t,e,n,s=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];e&&xs(e,n=>this.processProvider(n,t,e)),xs([t],t=>this.processInjectorType(t,[],r)),this.records.set(la,va(void 0,this));const i=this.records.get(ca);this.scope=null!=i?i.value:null,this.source=s||("object"==typeof t?null:At(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=Is,n=Xt.Default){this.assertNotDestroyed();const s=As(this);try{if(!(n&Xt.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(r=t)||"object"==typeof r&&r instanceof ms)&&Wt(t);e=n&&this.injectableDefInScope(n)?va(ba(t),ha):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&Xt.Self?ma():this.parent).get(t,e=n&Xt.Optional&&e===Is?null:e)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(At(t)),s)throw i;return function(t,e,n,s){const r=t.ngTempTokenPath;throw e.__source&&r.unshift(e.__source),t.message=function(t,e,n,s=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let r=At(e);if(Array.isArray(e))r=e.map(At).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let s=e[n];t.push(n+":"+("string"==typeof s?JSON.stringify(s):At(s)))}r=`{${t.join(", ")}}`}return`${n}${s?"("+s+")":""}[${r}]: ${t.replace(Ns,"\n  ")}`}("\n"+t.message,r,n,s),t.ngTokenPath=r,t.ngTempTokenPath=null,t}(i,t,"R3InjectorError",this.source)}throw i}finally{As(s)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(At(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=Dt(t)))return!1;let s=jt(t);const r=null==s&&t.ngModule||void 0,i=void 0===r?t:r,a=-1!==n.indexOf(i);if(void 0!==r&&(s=jt(r)),null==s)return!1;if(null!=s.imports&&!a){let t;n.push(i);try{xs(s.imports,s=>{this.processInjectorType(s,e,n)&&(void 0===t&&(t=[]),t.push(s))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:s}=t[e];xs(s,t=>this.processProvider(t,n,s||pa))}}this.injectorDefTypes.add(i);const o=Fe(i)||(()=>new i);this.records.set(i,va(o,ha));const l=s.providers;if(null!=l&&!a){const e=t;xs(l,t=>this.processProvider(t,e,l))}return void 0!==r&&void 0!==t.providers}processProvider(t,e,n){let s=_a(t=Dt(t))?t:Dt(t&&t.provide);const r=function(t,e,n){return wa(t)?va(void 0,t.useValue):va(xa(t),ha)}(t);if(_a(t)||!0!==t.multi)this.records.get(s);else{let e=this.records.get(s);e||(e=va(void 0,ha,!0),e.factory=()=>Ds(e.multi),this.records.set(s,e)),s=t,e.multi.push(t)}this.records.set(s,r)}hydrate(t,e){var n;return e.value===ha&&(e.value=da,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){return!!t.providedIn&&("string"==typeof t.providedIn?"any"===t.providedIn||t.providedIn===this.scope:this.injectorDefTypes.has(t.providedIn))}}function ba(t){const e=Wt(t),n=null!==e?e.factory:Fe(t);if(null!==n)return n;if(t instanceof ms)throw new Error(`Token ${At(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=_s(e,"?");throw new Error(`Can't resolve all parameters for ${At(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[Ht]||t[qt]);if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function xa(t,e,n){let s;if(_a(t)){const e=Dt(t);return Fe(e)||ba(e)}if(wa(t))s=()=>Dt(t.useValue);else if((r=t)&&r.useFactory)s=()=>t.useFactory(...Ds(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))s=()=>$s(Dt(t.useExisting));else{const e=Dt(t&&(t.useClass||t.provide));if(!function(t){return!!t.deps}(t))return Fe(e)||ba(e);s=()=>new e(...Ds(t.deps))}var r;return s}function va(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function wa(t){return null!==t&&"object"==typeof t&&Es in t}function _a(t){return"function"==typeof t}const ka=function(t,e,n){return function(t,e=null,n=null,s){const r=ga(t,e,n,s);return r._resolveInjectorDefTypes(),r}({name:n},e,t,n)};let Sa=(()=>{class t{static create(t,e){return Array.isArray(t)?ka(t,e,""):ka(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=Is,t.NULL=new ua,t.\u0275prov=Bt({token:t,providedIn:"any",factory:()=>$s(la)}),t.__NG_ELEMENT_ID__=-1,t})();function Ca(t,e){$n(Ke(t)[1],an())}function Ia(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const s=[t];for(;e;){let r;if($e(t))r=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");r=e.\u0275dir}if(r){if(n){s.push(r);const e=t;e.inputs=Na(t.inputs),e.declaredInputs=Na(t.declaredInputs),e.outputs=Na(t.outputs);const n=r.hostBindings;n&&Aa(t,n);const i=r.viewQuery,a=r.contentQueries;if(i&&Ea(t,i),a&&Ta(t,a),Tt(t.inputs,r.inputs),Tt(t.declaredInputs,r.declaredInputs),Tt(t.outputs,r.outputs),$e(r)&&r.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(r.data.animation)}}const e=r.features;if(e)for(let s=0;s<e.length;s++){const r=e[s];r&&r.ngInherit&&r(t),r===Ia&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let s=t.length-1;s>=0;s--){const r=t[s];r.hostVars=e+=r.hostVars,r.hostAttrs=Wn(r.hostAttrs,n=Wn(n,r.hostAttrs))}}(s)}function Na(t){return t===oe?{}:t===ue?[]:t}function Ea(t,e){const n=t.viewQuery;t.viewQuery=n?(t,s)=>{e(t,s),n(t,s)}:e}function Ta(t,e){const n=t.contentQueries;t.contentQueries=n?(t,s,r)=>{e(t,s,r),n(t,s,r)}:e}function Aa(t,e){const n=t.hostBindings;t.hostBindings=n?(t,s)=>{e(t,s),n(t,s)}:e}let Ra=null;function $a(){if(!Ra){const t=ae.Symbol;if(t&&t.iterator)Ra=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Ra=n)}}}return Ra}function Fa(t){return!!Da(t)&&(Array.isArray(t)||!(t instanceof Map)&&$a()in t)}function Da(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function Oa(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function La(t,e,n,s){const r=nn();return Oa(r,pn(),e)&&(sn(),function(t,e,n,s,r,i){const a=He(t,e);!function(t,e,n,s,r,i,a){if(null==i)Ve(t)?t.removeAttribute(e,r,n):e.removeAttribute(r);else{const o=null==a?Mt(i):a(i,s||"",r);Ve(t)?t.setAttribute(e,r,o,n):n?e.setAttributeNS(n,r,o):e.setAttribute(r,o)}}(e[11],a,i,t.value,n,s,r)}(An(),r,t,e,n,s)),La}function Ma(t,e,n,s,r,i,a,o){const l=nn(),u=sn(),c=t+20,h=u.firstCreatePass?function(t,e,n,s,r,i,a,o,l){const u=e.consts,c=_i(e,t,4,a||null,Ye(u,o));Oi(e,n,c,Ye(u,l)),$n(e,c);const h=c.tViews=Ri(2,c,s,r,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,u);return null!==e.queries&&(e.queries.template(e,c),h.queries=e.queries.embeddedTView(c)),c}(c,u,l,e,n,s,r,i,a):u.data[c];ln(h,!1);const d=l[11].createComment("");Hr(u,l,d,h),kr(d,l),Xi(l,l[c]=Hi(d,l,d,h)),Re(h)&&Ei(u,l,h),null!=a&&Ti(l,h,o)}function Pa(t,e=Xt.Default){const n=nn();return null===n?$s(t,e):ss(an(),n,Dt(t),e)}function za(t,e,n){const s=nn();return Oa(s,pn(),e)&&Di(sn(),An(),s,t,e,s[11],n,!1),za}function Ba(t,e,n,s,r){const i=r?"class":"style";ia(t,n,e.inputs[i],i,s)}function Va(t,e,n,s){const r=nn(),i=sn(),a=20+t,o=r[11],l=r[a]=Fr(o,e,tn.lFrame.currentNamespace),u=i.firstCreatePass?function(t,e,n,s,r,i,a){const o=e.consts,l=_i(e,t,2,r,Ye(o,i));return Oi(e,n,l,Ye(o,a)),null!==l.attrs&&oa(l,l.attrs,!1),null!==l.mergedAttrs&&oa(l,l.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,l),l}(a,i,r,0,e,n,s):i.data[a];ln(u,!0);const c=u.mergedAttrs;null!==c&&zn(o,l,c);const h=u.classes;null!==h&&Jr(o,l,h);const d=u.styles;null!==d&&Zr(o,l,d),64!=(64&u.flags)&&Hr(i,r,l,u),0===tn.lFrame.elementDepthCount&&kr(l,r),tn.lFrame.elementDepthCount++,Re(u)&&(Ei(i,r,u),function(t,e,n){if(Te(e)){const s=e.directiveEnd;for(let r=e.directiveStart;r<s;r++){const e=t.data[r];e.contentQueries&&e.contentQueries(1,n[r],r)}}}(i,u,r)),null!==s&&Ti(r,u)}function Wa(){let t=an();un()?cn():(t=t.parent,ln(t,!1));const e=t;tn.lFrame.elementDepthCount--;const n=sn();n.firstCreatePass&&($n(n,t),Te(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&Ba(n,e,nn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&Ba(n,e,nn(),e.stylesWithoutHost,!1)}function Ua(t,e,n,s){Va(t,e,n,s),Wa()}function ja(){return nn()}function Ha(t){return!!t&&"function"==typeof t.then}function Ga(t,e,n=!1,s){const r=nn(),i=sn(),a=an();return Ka(i,r,r[11],a,t,e,n,s),Ga}function qa(t,e,n=!1,s){const r=an(),i=nn(),a=sn();return Ka(a,i,sa(yn(a.data),r,i),r,t,e,n,s),qa}function Ka(t,e,n,s,r,i,a=!1,o){const l=Re(s),u=t.firstCreatePass&&na(t),c=ea(e);let h=!0;if(3&s.type){const d=He(s,e),p=o?o(d):oe,f=p.target||d,m=c.length,g=o?t=>o(Ue(t[s.index])).target:s.index;if(Ve(n)){let a=null;if(!o&&l&&(a=function(t,e,n,s){const r=t.cleanup;if(null!=r)for(let i=0;i<r.length-1;i+=2){const t=r[i];if(t===n&&r[i+1]===s){const t=e[7],n=r[i+2];return t.length>n?t[n]:null}"string"==typeof t&&(i+=2)}return null}(t,e,r,s.index)),null!==a)(a.__ngLastListenerFn__||a).__ngNextListenerFn__=i,a.__ngLastListenerFn__=i,h=!1;else{i=Qa(s,e,i,!1);const t=n.listen(p.name||f,r,i);c.push(i,t),u&&u.push(r,g,m,m+1)}}else i=Qa(s,e,i,!0),f.addEventListener(r,i,a),c.push(i),u&&u.push(r,g,m,a)}else i=Qa(s,e,i,!1);const d=s.outputs;let p;if(h&&null!==d&&(p=d[r])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(i),a=c.length;c.push(i,t),u&&u.push(r,s.index,a,-(a+1))}}}function Xa(t,e,n){try{return!1!==e(n)}catch(s){return ra(t,s),!1}}function Qa(t,e,n,s){return function r(i){if(i===Function)return n;const a=2&t.flags?qe(t.index,e):e;0==(32&e[2])&&Qi(a);let o=Xa(e,n,i),l=r.__ngNextListenerFn__;for(;l;)o=Xa(e,l,i)&&o,l=l.__ngNextListenerFn__;return s&&!1===o&&(i.preventDefault(),i.returnValue=!1),o}}function Ya(t=1){return function(t){return(tn.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,tn.lFrame.contextLView))[8]}(t)}function Za(t,e){let n=null;const s=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let r=0;r<e.length;r++){const i=e[r];if("*"!==i){if(null===s?oi(t,i,!0):li(s,i))return r}else n=r}return n}function Ja(t){const e=nn()[16][6];if(!e.projection){const n=e.projection=_s(t?t.length:1,null),s=n.slice();let r=e.child;for(;null!==r;){const e=t?Za(r,t):0;null!==e&&(s[e]?s[e].projectionNext=r:n[e]=r,s[e]=r),r=r.next}}}function to(t,e=0,n){const s=nn(),r=sn(),i=_i(r,20+t,16,null,n||null);null===i.projection&&(i.projection=e),cn(),64!=(64&i.flags)&&function(t,e,n){Yr(e[11],0,e,n,Pr(t,n,e),Ur(n.parent||e[6],n,e))}(r,s,i)}function eo(t,e,n,s,r){const i=t[n+1],a=null===e;let o=s?mi(i):yi(i),l=!1;for(;0!==o&&(!1===l||a);){const n=t[o+1];no(t[o],e)&&(l=!0,t[o+1]=s?xi(n):gi(n)),o=s?mi(n):yi(n)}l&&(t[n+1]=s?gi(i):xi(i))}function no(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Cs(t,e)>=0}const so={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function ro(t){return t.substring(so.key,so.keyEnd)}function io(t){return t.substring(so.value,so.valueEnd)}function ao(t,e){const n=so.textEnd;let s=so.key=oo(t,e,n);return n===s?-1:(s=so.keyEnd=function(t,e,n){let s;for(;e<n&&(45===(s=t.charCodeAt(e))||95===s||(-33&s)>=65&&(-33&s)<=90||s>=48&&s<=57);)e++;return e}(t,s,n),s=lo(t,s,n),s=so.value=oo(t,s,n),s=so.valueEnd=function(t,e,n){let s=-1,r=-1,i=-1,a=e,o=a;for(;a<n;){const l=t.charCodeAt(a++);if(59===l)return o;34===l||39===l?o=a=uo(t,l,a,n):e===a-4&&85===i&&82===r&&76===s&&40===l?o=a=uo(t,41,a,n):l>32&&(o=a),i=r,r=s,s=-33&l}return o}(t,s,n),lo(t,s,n))}function oo(t,e,n){for(;e<n&&t.charCodeAt(e)<=32;)e++;return e}function lo(t,e,n,s){return(e=oo(t,e,n))<n&&e++,e}function uo(t,e,n,s){let r=-1,i=n;for(;i<s;){const n=t.charCodeAt(i++);if(n==e&&92!==r)return i;r=92==n&&92===r?0:n}throw new Error}function co(t,e){return function(t,e,n,s){const r=nn(),i=sn(),a=fn(2);i.firstUpdatePass&&fo(i,t,a,true),e!==hi&&Oa(r,a,e)&&bo(i,i.data[En()],r,r[11],t,r[a+1]=function(t,e){return null==t||"object"==typeof t&&(t=At(qs(t))),t}(e),true,a)}(t,e),co}function ho(t,e){for(let n=function(t){return function(t){so.key=0,so.keyEnd=0,so.value=0,so.valueEnd=0,so.textEnd=t.length}(t),ao(t,oo(t,0,so.textEnd))}(e);n>=0;n=ao(e,n))yo(t,ro(e),io(e))}function po(t,e){return e>=t.expandoStartIndex}function fo(t,e,n,s){const r=t.data;if(null===r[n+1]){const i=r[En()],a=po(t,n);wo(i,s)&&null===e&&!a&&(e=!1),e=function(t,e,n,s){const r=yn(t);let i=s?e.residualClasses:e.residualStyles;if(null===r)0===(s?e.classBindings:e.styleBindings)&&(n=go(n=mo(null,t,e,n,s),e.attrs,s),i=null);else{const a=e.directiveStylingLast;if(-1===a||t[a]!==r)if(n=mo(r,t,e,n,s),null===i){let n=function(t,e,n){const s=n?e.classBindings:e.styleBindings;if(0!==yi(s))return t[mi(s)]}(t,e,s);void 0!==n&&Array.isArray(n)&&(n=mo(null,t,e,n[1],s),n=go(n,e.attrs,s),function(t,e,n,s){t[mi(n?e.classBindings:e.styleBindings)]=s}(t,e,s,n))}else i=function(t,e,n){let s;const r=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<r;i++)s=go(s,t[i].hostAttrs,n);return go(s,e.attrs,n)}(t,e,s)}return void 0!==i&&(s?e.residualClasses=i:e.residualStyles=i),n}(r,i,e,s),function(t,e,n,s,r,i){let a=i?e.classBindings:e.styleBindings,o=mi(a),l=yi(a);t[s]=n;let u,c=!1;if(Array.isArray(n)){const t=n;u=t[1],(null===u||Cs(t,u)>0)&&(c=!0)}else u=n;if(r)if(0!==l){const e=mi(t[o+1]);t[s+1]=fi(e,o),0!==e&&(t[e+1]=bi(t[e+1],s)),t[o+1]=131071&t[o+1]|s<<17}else t[s+1]=fi(o,0),0!==o&&(t[o+1]=bi(t[o+1],s)),o=s;else t[s+1]=fi(l,0),0===o?o=s:t[l+1]=bi(t[l+1],s),l=s;c&&(t[s+1]=gi(t[s+1])),eo(t,u,s,!0),eo(t,u,s,!1),function(t,e,n,s,r){const i=r?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&Cs(i,e)>=0&&(n[s+1]=xi(n[s+1]))}(e,u,t,s,i),a=fi(o,l),i?e.classBindings=a:e.styleBindings=a}(r,i,e,n,a,s)}}function mo(t,e,n,s,r){let i=null;const a=n.directiveEnd;let o=n.directiveStylingLast;for(-1===o?o=n.directiveStart:o++;o<a&&(i=e[o],s=go(s,i.hostAttrs,r),i!==t);)o++;return null!==t&&(n.directiveStylingLast=o),s}function go(t,e,n){const s=n?1:2;let r=-1;if(null!==e)for(let i=0;i<e.length;i++){const a=e[i];"number"==typeof a?r=a:r===s&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),ks(t,a,!!n||e[++i]))}return void 0===t?null:t}function yo(t,e,n){ks(t,e,qs(n))}function bo(t,e,n,s,r,i,a,o){if(!(3&e.type))return;const l=t.data,u=l[o+1];vo(1==(1&u)?xo(l,e,n,r,yi(u),a):void 0)||(vo(i)||2==(2&u)&&(i=xo(l,null,n,r,o,a)),function(t,e,n,s,r){const i=Ve(t);if(e)r?i?t.addClass(n,s):n.classList.add(s):i?t.removeClass(n,s):n.classList.remove(s);else{let e=-1===s.indexOf("-")?void 0:Ir.DashCase;if(null==r)i?t.removeStyle(n,s,e):n.style.removeProperty(s);else{const a="string"==typeof r&&r.endsWith("!important");a&&(r=r.slice(0,-10),e|=Ir.Important),i?t.setStyle(n,s,r,e):n.style.setProperty(s,r,a?"important":"")}}}(s,a,je(En(),n),r,i))}function xo(t,e,n,s,r,i){const a=null===e;let o;for(;r>0;){const e=t[r],i=Array.isArray(e),l=i?e[1]:e,u=null===l;let c=n[r+1];c===hi&&(c=u?le:void 0);let h=u?Ss(c,s):l===s?c:void 0;if(i&&!vo(h)&&(h=Ss(e,s)),vo(h)&&(o=h,a))return o;const d=t[r+1];r=a?mi(d):yi(d)}if(null!==e){let t=i?e.residualClasses:e.residualStyles;null!=t&&(o=Ss(t,s))}return o}function vo(t){return void 0!==t}function wo(t,e){return 0!=(t.flags&(e?16:32))}function _o(t,e=""){const n=nn(),s=sn(),r=t+20,i=s.firstCreatePass?_i(s,r,1,e,null):s.data[r],a=n[r]=function(t,e){return Ve(t)?t.createText(e):t.createTextNode(e)}(n[11],e);Hr(s,n,a,i),ln(i,!1)}function ko(t){return So("",t,""),ko}function So(t,e,n){const s=nn(),r=function(t,e,n,s){return Oa(t,pn(),n)?e+Mt(n)+s:hi}(s,t,e,n);return r!==hi&&aa(s,En(),r),So}function Co(t,e,n,s,r){const i=nn(),a=function(t,e,n,s,r,i){const a=function(t,e,n,s){const r=Oa(t,e,n);return Oa(t,e+1,s)||r}(t,tn.lFrame.bindingIndex,n,r);return fn(2),a?e+Mt(n)+s+Mt(r)+i:hi}(i,t,e,n,s,r);return a!==hi&&aa(i,En(),a),Co}function Io(t,e,n){const s=nn();return Oa(s,pn(),e)&&Di(sn(),An(),s,t,e,s[11],n,!0),Io}function No(t,e,n){const s=nn();if(Oa(s,pn(),e)){const r=sn(),i=An();Di(r,i,s,t,e,sa(yn(r.data),i,s),n,!0)}return No}const Eo=void 0;var To=["en",[["a","p"],["AM","PM"],Eo],[["AM","PM"],Eo,Eo],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Eo,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Eo,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Eo,"{1} 'at' {0}",Eo],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let Ao={};function Ro(t){return t in Ao||(Ao[t]=ae.ng&&ae.ng.common&&ae.ng.common.locales&&ae.ng.common.locales[t]),Ao[t]}var $o=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});let Fo="en-US";function Do(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,s){throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(Fo=t.toLowerCase().replace(/_/g,"-"))}function Oo(t,e,n,s,r){if(t=Dt(t),Array.isArray(t))for(let i=0;i<t.length;i++)Oo(t[i],e,n,s,r);else{const i=sn(),a=nn();let o=_a(t)?t:Dt(t.provide),l=xa(t);const u=an(),c=1048575&u.providerIndexes,h=u.directiveStart,d=u.providerIndexes>>20;if(_a(t)||!t.multi){const s=new Pn(l,r,Pa),p=Po(o,e,r?c:c+d,h);-1===p?(ts(Qn(u,a),i,o),Lo(i,t,e.length),e.push(o),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(s),a.push(s)):(n[p]=s,a[p]=s)}else{const p=Po(o,e,c+d,h),f=Po(o,e,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(r&&!g||!r&&!m){ts(Qn(u,a),i,o);const c=function(t,e,n,s,r){const i=new Pn(t,n,Pa);return i.multi=[],i.index=e,i.componentProviders=0,Mo(i,r,s&&!n),i}(r?Bo:zo,n.length,r,s,l);!r&&g&&(n[f].providerFactory=c),Lo(i,t,e.length,0),e.push(o),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(c),a.push(c)}else Lo(i,t,p>-1?p:f,Mo(n[r?f:p],l,!r&&s));!r&&s&&g&&n[f].componentProviders++}}}function Lo(t,e,n,s){const r=_a(e);if(r||e.useClass){const i=(e.useClass||e).prototype.ngOnDestroy;if(i){const a=t.destroyHooks||(t.destroyHooks=[]);if(!r&&e.multi){const t=a.indexOf(n);-1===t?a.push(n,[s,i]):a[t+1].push(s,i)}else a.push(n,i)}}}function Mo(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function Po(t,e,n,s){for(let r=n;r<s;r++)if(e[r]===t)return r;return-1}function zo(t,e,n,s){return Vo(this.multi,[])}function Bo(t,e,n,s){const r=this.multi;let i;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=ls(n,n[1],this.providerFactory.index,s);i=e.slice(0,t),Vo(r,i);for(let n=t;n<e.length;n++)i.push(e[n])}else i=[],Vo(r,i);return i}function Vo(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function Wo(t,e=[]){return n=>{n.providersResolver=(n,s)=>function(t,e,n){const s=sn();if(s.firstCreatePass){const r=$e(t);Oo(n,s.data,s.blueprint,r,!0),Oo(e,s.data,s.blueprint,r,!1)}}(n,s?s(t):t,e)}}class Uo{}class jo{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${At(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let Ho=(()=>{class t{}return t.NULL=new jo,t})();function Go(...t){}function qo(t,e){return new Xo(He(t,e))}const Ko=function(){return qo(an(),nn())};let Xo=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=Ko,t})();function Qo(t){return t instanceof Xo?t.nativeElement:t}class Yo{}let Zo=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>Jo(),t})();const Jo=function(){const t=nn(),e=qe(an().index,t);return function(t){return t[11]}(Ne(e)?e:t)};let tl=(()=>{class t{}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:()=>null}),t})();class el{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const nl=new el("11.2.6");class sl{constructor(){}supports(t){return Fa(t)}create(t){return new il(t)}}const rl=(t,e)=>e;class il{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||rl}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,s=0,r=null;for(;e||n;){const i=!n||e&&e.currentIndex<ul(n,s,r)?e:n,a=ul(i,s,r),o=i.currentIndex;if(i===n)s--,n=n._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{r||(r=[]);const t=a-s,e=o-s;if(t!=e){for(let n=0;n<t;n++){const s=n<r.length?r[n]:r[n]=0,i=s+n;e<=i&&i<t&&(r[n]=s+1)}r[i.previousIndex]=e-t}}a!==o&&t(i,a,o)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Fa(t))throw new Error(`Error trying to diff '${At(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,s,r=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],s=this._trackByFn(e,n),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,n,s,e)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,s,e),i=!0),r=r._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[$a()]();let s;for(;!(s=n.next()).done;)e(s.value)}}(t,t=>{s=this._trackByFn(e,t),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,t,s,e)),Object.is(r.item,t)||this._addIdentityChange(r,t)):(r=this._mismatch(r,t,s,e),i=!0),r=r._next,e++}),this.length=e;return this._truncate(r),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,s){let r;return null===t?r=this._itTail:(r=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,r,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,r,s)):t=this._addAfter(new al(e,n),r,s),t}_verifyReinsertion(t,e,n,s){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?t=this._reinsertAfter(r,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,r=t._nextRemoved;return null===s?this._removalsHead=r:s._nextRemoved=r,null===r?this._removalsTail=s:r._prevRemoved=s,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new ll),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new ll),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class al{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class ol{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class ll{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new ol,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function ul(t,e,n){const s=t.previousIndex;if(null===s)return s;let r=0;return n&&s<n.length&&(r=n[s]),s+e+r}class cl{constructor(){}supports(t){return t instanceof Map||Da(t)}create(){return new hl}}class hl{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Da(t)))throw new Error(`Error trying to diff '${At(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const s=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,s)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const s=n._prev,r=n._next;return s&&(s._next=r),r&&(r._prev=s),n._next=null,n._prev=null,n}const n=new dl(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class dl{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function pl(){return new fl([new sl])}let fl=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||pl()),deps:[[t,new Ps,new Ms]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:pl}),t})();function ml(){return new gl([new cl])}let gl=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||ml()),deps:[[t,new Ps,new Ms]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:ml}),t})();function yl(t,e,n,s,r=!1){for(;null!==n;){const i=e[n.index];if(null!==i&&s.push(Ue(i)),Ee(i))for(let t=10;t<i.length;t++){const e=i[t],n=e[1].firstChild;null!==n&&yl(e[1],e,n,s)}const a=n.type;if(8&a)yl(t,e,n.child,s);else if(32&a){const t=Nr(n,e);let r;for(;r=t();)s.push(r)}else if(16&a){const t=qr(e,n);if(Array.isArray(t))s.push(...t);else{const n=Er(e[16]);yl(n[1],n,t,s,!0)}}n=r?n.projectionNext:n.next}return s}class bl{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return yl(e,t,e.firstChild,[])}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Ee(t)){const e=t[8],n=e?e.indexOf(this):-1;n>-1&&(Or(t,n),ws(e,n))}this._attachedToViewContainer=!1}Lr(this._lView[1],this._lView)}onDestroy(t){$i(this._lView[1],this._lView,null,t)}markForCheck(){Qi(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Yi(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){dn(!0);try{Yi(t,e,n)}finally{dn(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var t;this._appRef=null,Qr(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class xl extends bl{constructor(t){super(t),this._view=t}detectChanges(){Zi(this._view)}checkNoChanges(){!function(t){dn(!0);try{Zi(t)}finally{dn(!1)}}(this._view)}get context(){return null}}const vl=function(t=!1){return function(t,e,n){if(!n&&Ae(t)){const n=qe(t.index,e);return new bl(n,n)}return 47&t.type?new bl(e[16],e):null}(an(),nn(),t)};let wl=(()=>{class t{}return t.__NG_ELEMENT_ID__=vl,t.__ChangeDetectorRef__=!0,t})();const _l=[new cl],kl=new fl([new sl]),Sl=new gl(_l),Cl=function(){return Tl(an(),nn())};let Il=(()=>{class t{}return t.__NG_ELEMENT_ID__=Cl,t})();const Nl=Il,El=class extends Nl{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=wi(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&&(n[19]=s.createEmbeddedView(e)),Si(e,n,t),new bl(n)}};function Tl(t,e){return 4&t.type?new El(e,t,qo(t,e)):null}class Al{}class Rl{}const $l=function(){return Pl(an(),nn())};let Fl=(()=>{class t{}return t.__NG_ELEMENT_ID__=$l,t})();const Dl=Fl,Ol=class extends Dl{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return qo(this._hostTNode,this._hostLView)}get injector(){return new hs(this._hostTNode,this._hostLView)}get parentInjector(){const t=Jn(this._hostTNode,this._hostLView);if(jn(t)){const e=Gn(t,this._hostLView),n=Hn(t);return new hs(e[1].data[n+8],e)}return new hs(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=Ll(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,n){const s=t.createEmbeddedView(e||{});return this.insert(s,n),s}createComponent(t,e,n,s,r){const i=n||this.parentInjector;if(!r&&null==t.ngModule&&i){const t=i.get(Al,null);t&&(r=t)}const a=t.create(i,s,void 0,r);return this.insert(a.hostView,e),a}insert(t,e){const n=t._lView,s=n[1];if(Ee(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],s=new Ol(e,e[6],e[3]);s.detach(s.indexOf(t))}}const r=this._adjustIndex(e),i=this._lContainer;!function(t,e,n,s){const r=10+s,i=n.length;s>0&&(n[r-1][4]=e),s<i-10?(e[4]=n[r],vs(n,10+s,e)):(n.push(e),e[4]=null),e[3]=n;const a=e[17];null!==a&&n!==a&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(a,e);const o=e[19];null!==o&&o.insertView(t),e[2]|=128}(s,n,i,r);const a=Kr(r,i),o=n[11],l=Wr(o,i[7]);return null!==l&&function(t,e,n,s,r,i){s[0]=r,s[6]=e,Qr(t,s,n,1,r,i)}(s,i[6],o,n,l,a),t.attachToViewContainerRef(),vs(Ml(i),r,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=Ll(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),n=Or(this._lContainer,e);n&&(ws(Ml(this._lContainer),e),Lr(n[1],n))}detach(t){const e=this._adjustIndex(t,-1),n=Or(this._lContainer,e);return n&&null!=ws(Ml(this._lContainer),e)?new bl(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function Ll(t){return t[8]}function Ml(t){return t[8]||(t[8]=[])}function Pl(t,e){let n;const s=e[t.index];if(Ee(s))n=s;else{let r;if(8&t.type)r=Ue(s);else{const n=e[11];r=n.createComment("");const s=He(t,e);zr(n,Wr(n,s),r,function(t,e){return Ve(t)?t.nextSibling(e):e.nextSibling}(n,s),!1)}e[t.index]=n=Hi(s,e,r,t),Xi(e,n)}return new Ol(n,t,e)}const zl={};class Bl extends Ho{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Ce(t);return new Ul(e,this.ngModule)}}function Vl(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const Wl=new ms("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Sr});class Ul extends Uo{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(ci).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Vl(this.componentDef.inputs)}get outputs(){return Vl(this.componentDef.outputs)}create(t,e,n,s){const r=(s=s||this.ngModule)?function(t,e){return{get:(n,s,r)=>{const i=t.get(n,zl,r);return i!==zl||s===zl?i:e.get(n,s,r)}}}(t,s.injector):t,i=r.get(Yo,We),a=r.get(tl,null),o=i.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(t,e,n){if(Ve(t))return t.selectRootElement(e,n===ee.ShadowDom);let s="string"==typeof e?t.querySelector(e):e;return s.textContent="",s}(o,n,this.componentDef.encapsulation):Fr(i.createRenderer(null,this.componentDef),l,function(t){const e=t.toLowerCase();return"svg"===e?"http://www.w3.org/2000/svg":"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:Sr,clean:ta,playerHandler:null,flags:0},d=Ri(0,null,null,1,0,null,null,null,null,null),p=wi(null,d,h,c,null,null,i,o,a,r);let f,m;_n(p);try{const t=function(t,e,n,s,r,i){const a=n[1];n[20]=t;const o=_i(a,20,2,"#host",null),l=o.mergedAttrs=e.hostAttrs;null!==l&&(oa(o,l,!0),null!==t&&(zn(r,t,l),null!==o.classes&&Jr(r,t,o.classes),null!==o.styles&&Zr(r,t,o.styles)));const u=s.createRenderer(t,e),c=wi(n,Ai(e),null,e.onPush?64:16,n[20],o,s,u,null,null);return a.firstCreatePass&&(ts(Qn(o,n),a,e.type),Pi(a,o),Bi(o,n.length,1)),Xi(n,c),n[20]=c}(u,this.componentDef,p,i,o);if(u)if(n)zn(o,u,["ng-version",nl.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let s=1,r=2;for(;s<t.length;){let i=t[s];if("string"==typeof i)2===r?""!==i&&e.push(i,t[++s]):8===r&&n.push(i);else{if(!ii(r))break;r=i}s++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&zn(o,u,t),e&&e.length>0&&Jr(o,u,e.join(" "))}if(m=Ge(d,20),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const s=e[n];t.push(null!=s?Array.from(s):null)}}f=function(t,e,n,s,r){const i=n[1],a=function(t,e,n){const s=an();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Vi(t,s,e,ki(t,e,1,null),n));const r=ls(e,t,s.directiveStart,s);kr(r,e);const i=He(s,e);return i&&kr(i,e),r}(i,n,e);if(s.components.push(a),t[8]=a,r&&r.forEach(t=>t(a,e)),e.contentQueries){const t=an();e.contentQueries(1,a,t.directiveStart)}const o=an();return!i.firstCreatePass||null===e.hostBindings&&null===e.hostAttrs||(Tn(o.index),Li(n[1],o,0,o.directiveStart,o.directiveEnd,e),Mi(e,a)),a}(t,this.componentDef,p,h,[Ca]),Si(d,p,null)}finally{Nn()}return new jl(this.componentType,f,qo(m,p),p,m)}}class jl extends class{}{constructor(t,e,n,s,r){super(),this.location=n,this._rootLView=s,this._tNode=r,this.instance=e,this.hostView=this.changeDetectorRef=new xl(s),this.componentType=t}get injector(){return new hs(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const Hl=new Map;class Gl extends Al{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Bl(this);const n=Ie(t),s=t[fe]||null;s&&Do(s),this._bootstrapComponents=Cr(n.bootstrap),this._r3Injector=ga(t,e,[{provide:Al,useValue:this},{provide:Ho,useValue:this.componentFactoryResolver}],At(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Sa.THROW_IF_NOT_FOUND,n=Xt.Default){return t===Sa||t===Al||t===la?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class ql extends Rl{constructor(t){super(),this.moduleType=t,null!==Ie(t)&&function(t){const e=new Set;!function t(n){const s=Ie(n,!0),r=s.id;null!==r&&(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${At(e)} vs ${At(e.name)}`)}(r,Hl.get(r),n),Hl.set(r,n));const i=Cr(s.imports);for(const a of i)e.has(a)||(e.add(a),t(a))}(t)}(t)}create(t){return new Gl(this.moduleType,t)}}const Kl=class extends Z{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){let s,r=t=>null,i=()=>null;t&&"object"==typeof t?(s=this.__isAsync?e=>{setTimeout(()=>t.next(e))}:e=>{t.next(e)},t.error&&(r=this.__isAsync?e=>{setTimeout(()=>t.error(e))}:e=>{t.error(e)}),t.complete&&(i=this.__isAsync?()=>{setTimeout(()=>t.complete())}:()=>{t.complete()})):(s=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)},e&&(r=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)}),n&&(i=this.__isAsync?()=>{setTimeout(()=>n())}:()=>{n()}));const a=super.subscribe(s,r,i);return t instanceof B&&t.add(a),a}};function Xl(){return this._results[$a()]()}class Ql{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=$a(),n=Ql.prototype;n[e]||(n[e]=Xl)}get changes(){return this._changes||(this._changes=new Kl)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){this.dirty=!1;const n=bs(t);(this._changesDetected=!function(t,e,n){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++){let r=t[s],i=e[s];if(n&&(r=n(r),i=n(i)),i!==r)return!1}return!0}(this._results,n,e))&&(this._results=n,this.length=n.length,this.last=n[this.length-1],this.first=n[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class Yl{constructor(t){this.queryList=t,this.matches=null}clone(){return new Yl(this.queryList)}setDirty(){this.queryList.setDirty()}}class Zl{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);s.push(this.queries[n.indexInDeclarationView].clone())}return new Zl(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==du(t,e).matches&&this.queries[e].setDirty()}}class Jl{constructor(t,e,n=null){this.predicate=t,this.flags=e,this.read=n}}class tu{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const s=null!==e?e.length:0,r=this.getByIndex(n).embeddedTView(t,s);r&&(r.indexInDeclarationView=n,null!==e?e.push(r):e=[r])}return null!==e?new tu(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class eu{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new eu(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&8&n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let s=0;s<n.length;s++){const r=n[s];this.matchTNodeWithReadOption(t,e,nu(e,r)),this.matchTNodeWithReadOption(t,e,os(e,t,r,!1,!1))}else n===Il?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,os(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const s=this.metadata.read;if(null!==s)if(s===Xo||s===Fl||s===Il&&4&e.type)this.addMatch(e.index,-2);else{const n=os(e,t,s,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function nu(t,e){const n=t.localNames;if(null!==n)for(let s=0;s<n.length;s+=2)if(n[s]===e)return n[s+1];return null}function su(t,e,n,s){return-1===n?function(t,e){return 11&t.type?qo(t,e):4&t.type?Tl(t,e):null}(e,t):-2===n?function(t,e,n){return n===Xo?qo(e,t):n===Il?Tl(e,t):n===Fl?Pl(e,t):void 0}(t,e,s):ls(t,t[1],n,e)}function ru(t,e,n,s){const r=e[19].queries[s];if(null===r.matches){const s=t.data,i=n.matches,a=[];for(let t=0;t<i.length;t+=2){const r=i[t];a.push(r<0?null:su(e,s[r],i[t+1],n.metadata.read))}r.matches=a}return r.matches}function iu(t,e,n,s){const r=t.queries.getByIndex(n),i=r.matches;if(null!==i){const a=ru(t,e,r,n);for(let t=0;t<i.length;t+=2){const n=i[t];if(n>0)s.push(a[t/2]);else{const r=i[t+1],a=e[-n];for(let t=10;t<a.length;t++){const e=a[t];e[17]===e[3]&&iu(e[1],e,r,s)}if(null!==a[9]){const t=a[9];for(let e=0;e<t.length;e++){const n=t[e];iu(n[1],n,r,s)}}}}}return s}function au(t){const e=nn(),n=sn(),s=bn();xn(s+1);const r=du(n,s);if(t.dirty&&Xe(e)===(2==(2&r.metadata.flags))){if(null===r.matches)t.reset([]);else{const i=r.crossesNgTemplate?iu(n,e,s,[]):ru(n,e,r,s);t.reset(i,Qo),t.notifyOnChanges()}return!0}return!1}function ou(t,e,n){const s=sn();s.firstCreatePass&&(hu(s,new Jl(t,e,n),-1),2==(2&e)&&(s.staticViewQueries=!0)),cu(s,nn(),e)}function lu(t,e,n,s){const r=sn();if(r.firstCreatePass){const i=an();hu(r,new Jl(e,n,s),i.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(n.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(r,t),2==(2&n)&&(r.staticContentQueries=!0)}cu(r,nn(),n)}function uu(){return t=nn(),e=bn(),t[19].queries[e].queryList;var t,e}function cu(t,e,n){const s=new Ql(4==(4&n));$i(t,e,s,s.destroy),null===e[19]&&(e[19]=new Zl),e[19].queries.push(new Yl(s))}function hu(t,e,n){null===t.queries&&(t.queries=new tu),t.queries.track(new eu(e,n))}function du(t,e){return t.queries.getByIndex(e)}const pu=new ms("Application Initializer");let fu=(()=>{class t{constructor(t){this.appInits=t,this.resolve=Go,this.reject=Go,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();Ha(e)&&t.push(e)}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)($s(pu,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const mu=new ms("AppId"),gu={provide:mu,useFactory:function(){return`${yu()}${yu()}${yu()}`},deps:[]};function yu(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const bu=new ms("Platform Initializer"),xu=new ms("Platform ID"),vu=new ms("appBootstrapListener");let wu=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const _u=new ms("LocaleId"),ku=new ms("DefaultCurrencyCode");class Su{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const Cu=function(t){return new ql(t)},Iu=Cu,Nu=function(t){return Promise.resolve(Cu(t))},Eu=function(t){const e=Cu(t),n=Cr(Ie(t).declarations).reduce((t,e)=>{const n=Ce(e);return n&&t.push(new Ul(n)),t},[]);return new Su(e,n)},Tu=Eu,Au=function(t){return Promise.resolve(Eu(t))};let Ru=(()=>{class t{constructor(){this.compileModuleSync=Iu,this.compileModuleAsync=Nu,this.compileModuleAndAllComponentsSync=Tu,this.compileModuleAndAllComponentsAsync=Au}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const $u=(()=>Promise.resolve(0))();function Fu(t){"undefined"==typeof Zone?$u.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Du{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Kl(!1),this.onMicrotaskEmpty=new Kl(!1),this.onStable=new Kl(!1),this.onError=new Kl(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched(),this._nesting=0,this._outer=this._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(this._inner=this._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(this._inner=this._inner.fork(Zone.longStackTraceZoneSpec)),this.shouldCoalesceEventChangeDetection=!n&&e,this.shouldCoalesceRunChangeDetection=n,this.lastRequestAnimationFrameId=-1,this.nativeRequestAnimationFrame=function(){let t=ae.requestAnimationFrame,e=ae.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const s=e[Zone.__symbol__("OriginalDelegate")];s&&(e=s)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=()=>{!function(t){-1===t.lastRequestAnimationFrameId&&(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(ae,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Mu(t),Lu(t)},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Mu(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,s,r,i,a,o)=>{try{return Pu(t),n.invokeTask(r,i,a,o)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||t.shouldCoalesceRunChangeDetection)&&e(),zu(t)}},onInvoke:(n,s,r,i,a,o,l)=>{try{return Pu(t),n.invoke(r,i,a,o,l)}finally{t.shouldCoalesceRunChangeDetection&&e(),zu(t)}},onHasTask:(e,n,s,r)=>{e.hasTask(s,r),n===s&&("microTask"==r.change?(t._hasPendingMicrotasks=r.microTask,Mu(t),Lu(t)):"macroTask"==r.change&&(t.hasPendingMacrotasks=r.macroTask))},onHandleError:(e,n,s,r)=>(e.handleError(s,r),t.runOutsideAngular(()=>t.onError.emit(r)),!1)})}(this)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Du.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Du.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,s){const r=this._inner,i=r.scheduleEventTask("NgZoneEvent: "+s,t,Ou,Go,Go);try{return r.runTask(i,e,n)}finally{r.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}const Ou={};function Lu(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Mu(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Pu(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function zu(t){t._nesting--,Lu(t)}class Bu{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Kl,this.onMicrotaskEmpty=new Kl,this.onStable=new Kl,this.onError=new Kl}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,s){return t.apply(e,n)}}let Vu=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Du.assertNotInAngularZone(),Fu(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Fu(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let s=-1;e&&e>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==s),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:s,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)($s(Du))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Wu=(()=>{class t{constructor(){this._applications=new Map,Hu.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return Hu.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Uu{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let ju,Hu=new Uu,Gu=!0,qu=!1;function Ku(){return qu=!0,Gu}const Xu=new ms("AllowMultipleToken");class Qu{constructor(t,e){this.name=t,this.token=e}}function Yu(t,e,n=[]){const s=`Platform: ${e}`,r=new ms(s);return(e=[])=>{let i=Zu();if(!i||i.injector.get(Xu,!1))if(t)t(n.concat(e).concat({provide:r,useValue:!0}));else{const t=n.concat(e).concat({provide:r,useValue:!0},{provide:ca,useValue:"platform"});!function(t){if(ju&&!ju.destroyed&&!ju.injector.get(Xu,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");ju=t.get(Ju);const e=t.get(bu,null);e&&e.forEach(t=>t())}(Sa.create({providers:t,name:s}))}return function(t){const e=Zu();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(r)}}function Zu(){return ju&&!ju.destroyed?ju:null}let Ju=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new Bu:("zone.js"===t?void 0:t)||new Du({enableLongStackTrace:Ku(),shouldCoalesceEventChangeDetection:!!(null==e?void 0:e.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==e?void 0:e.ngZoneRunCoalescing)}),n}(e?e.ngZone:void 0,{ngZoneEventCoalescing:e&&e.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:e&&e.ngZoneRunCoalescing||!1}),s=[{provide:Du,useValue:n}];return n.run(()=>{const e=Sa.create({providers:s,parent:this.injector,name:t.moduleType.name}),r=t.create(e),i=r.injector.get(_r,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const t=n.onError.subscribe({next:t=>{i.handleError(t)}});r.onDestroy(()=>{nc(this._modules,r),t.unsubscribe()})}),function(t,e,n){try{const s=n();return Ha(s)?s.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):s}catch(s){throw e.runOutsideAngular(()=>t.handleError(s)),s}}(i,n,()=>{const t=r.injector.get(fu);return t.runInitializers(),t.donePromise.then(()=>(Do(r.injector.get(_u,"en-US")||"en-US"),this._moduleDoBootstrap(r),r))})})}bootstrapModule(t,e=[]){const n=tc({},e);return function(t,e,n){const s=new ql(n);return Promise.resolve(s)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(ec);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${At(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)($s(Sa))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function tc(t,e){return Array.isArray(e)?e.reduce(tc,t):Object.assign(Object.assign({},t),e)}let ec=(()=>{class t{constructor(t,e,n,s,r){this._zone=t,this._injector=e,this._exceptionHandler=n,this._componentFactoryResolver=s,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new q(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),a=new q(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{Du.assertNotInAngularZone(),Fu(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Du.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=vt(i,a.pipe(t=>{return wt()((e=Nt,function(t){let n;n="function"==typeof e?e:function(){return e};const s=Object.create(t,Ct);return s.source=t,s.subjectFactory=n,s})(t));var e}))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof Uo?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const s=n.isBoundToModule?void 0:this._injector.get(Al),r=n.create(Sa.NULL,[],e||n.selector,s),i=r.location.nativeElement,a=r.injector.get(Vu,null),o=a&&r.injector.get(Wu);return a&&o&&o.registerApplication(i,a),r.onDestroy(()=>{this.detachView(r.hostView),nc(this.components,r),o&&o.unregisterApplication(i)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;nc(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(vu,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)($s(Du),$s(Sa),$s(_r),$s(Ho),$s(fu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function nc(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class sc{}class rc{}const ic={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let ac=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||ic}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,s]=t.split("#");return void 0===s&&(s="default"),n("zn8P")(e).then(t=>t[s]).then(t=>oc(t,e,s)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,s]=t.split("#"),r="NgFactory";return void 0===s&&(s="default",r=""),n("zn8P")(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[s+r]).then(t=>oc(t,e,s))}}return t.\u0275fac=function(e){return new(e||t)($s(Ru),$s(rc,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function oc(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const lc=Yu(null,"core",[{provide:xu,useValue:"unknown"},{provide:Ju,deps:[Sa]},{provide:Wu,deps:[]},{provide:wu,deps:[]}]),uc=[{provide:ec,useClass:ec,deps:[Du,Sa,_r,Ho,fu]},{provide:Wl,deps:[Du],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:fu,useClass:fu,deps:[[new Ms,pu]]},{provide:Ru,useClass:Ru,deps:[]},gu,{provide:fl,useFactory:function(){return kl},deps:[]},{provide:gl,useFactory:function(){return Sl},deps:[]},{provide:_u,useFactory:function(t){return Do(t=t||"undefined"!=typeof $localize&&$localize.locale||"en-US"),t},deps:[[new Ls(_u),new Ms,new Ps]]},{provide:ku,useValue:"USD"}];let cc=(()=>{class t{constructor(t){}}return t.\u0275fac=function(e){return new(e||t)($s(ec))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:uc}),t})(),hc=null;function dc(){return hc}const pc=new ms("DocumentToken");let fc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:mc,token:t,providedIn:"platform"}),t})();function mc(){return $s(yc)}const gc=new ms("Location Initialized");let yc=(()=>{class t extends fc{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=dc().getLocation(),this._history=dc().getHistory()}getBaseHrefFromDOM(){return dc().getBaseHref(this._doc)}onPopState(t){dc().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",t,!1)}onHashChange(t){dc().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",t,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){bc()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){bc()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({factory:xc,token:t,providedIn:"platform"}),t})();function bc(){return!!window.history.pushState}function xc(){return new yc($s(pc))}function vc(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function wc(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function _c(t){return t&&"?"!==t[0]?"?"+t:t}let kc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:Sc,token:t,providedIn:"root"}),t})();function Sc(t){const e=$s(pc).location;return new Ic($s(fc),e&&e.origin||"")}const Cc=new ms("appBaseHref");let Ic=(()=>{class t extends kc{constructor(t,e){if(super(),this._platformLocation=t,null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return vc(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+_c(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,s){const r=this.prepareExternalUrl(n+_c(s));this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){const r=this.prepareExternalUrl(n+_c(s));this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)($s(fc),$s(Cc,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Nc=(()=>{class t extends kc{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",null!=e&&(this._baseHref=e)}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=vc(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,s){let r=this.prepareExternalUrl(n+_c(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){let r=this.prepareExternalUrl(n+_c(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)($s(fc),$s(Cc,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Ec=(()=>{class t{constructor(t,e){this._subject=new Kl,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=wc(Ac(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+_c(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,Ac(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+_c(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+_c(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)($s(kc),$s(fc))},t.normalizeQueryParams=_c,t.joinWithSlash=vc,t.stripTrailingSlash=wc,t.\u0275prov=Bt({factory:Tc,token:t,providedIn:"root"}),t})();function Tc(){return new Ec($s(kc),$s(fc))}function Ac(t){return t.replace(/\/index.html$/,"")}var Rc=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({});class $c{}let Fc=(()=>{class t extends $c{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return function(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=Ro(e);if(n)return n;const s=e.split("-")[0];if(n=Ro(s),n)return n;if("en"===s)return To;throw new Error(`Missing locale data for the locale "${t}".`)}(t)[$o.PluralCase]}(e||this.locale)(t)){case Rc.Zero:return"zero";case Rc.One:return"one";case Rc.Two:return"two";case Rc.Few:return"few";case Rc.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)($s(_u))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Dc=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new Oc,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){Lc("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){Lc("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(Pa(Fl),Pa(Il))},t.\u0275dir=Se({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class Oc{constructor(){this.$implicit=null,this.ngIf=null}}function Lc(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${At(e)}'.`)}let Mc=(()=>{class t{constructor(t,e,n){this._ngEl=t,this._differs=e,this._renderer=n,this._ngStyle=null,this._differ=null}set ngStyle(t){this._ngStyle=t,!this._differ&&t&&(this._differ=this._differs.find(t).create())}ngDoCheck(){if(this._differ){const t=this._differ.diff(this._ngStyle);t&&this._applyChanges(t)}}_setStyle(t,e){const[n,s]=t.split(".");null!=(e=null!=e&&s?`${e}${s}`:e)?this._renderer.setStyle(this._ngEl.nativeElement,n,e):this._renderer.removeStyle(this._ngEl.nativeElement,n)}_applyChanges(t){t.forEachRemovedItem(t=>this._setStyle(t.key,null)),t.forEachAddedItem(t=>this._setStyle(t.key,t.currentValue)),t.forEachChangedItem(t=>this._setStyle(t.key,t.currentValue))}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(gl),Pa(Zo))},t.\u0275dir=Se({type:t,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"}}),t})(),Pc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[{provide:$c,useClass:Fc}]}),t})();function zc(t){return"browser"===t}function Bc(t){return"server"===t}let Vc=(()=>{class t{}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:()=>new Wc($s(pc),window)}),t})();class Wc{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){var e;if(!this.supportsScrolling())return;const n=null!==(e=this.document.getElementById(t))&&void 0!==e?e:this.document.getElementsByName(t)[0];void 0!==n&&(this.scrollToElement(n),this.attemptFocus(n))}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],s-r[1])}attemptFocus(t){return t.focus(),this.document.activeElement===t}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=Uc(this.window.history)||Uc(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function Uc(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class jc extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var t;t=new jc,hc||(hc=t)}getProperty(t,e){return t[e]}log(t){window.console&&window.console.log&&window.console.log(t)}logGroup(t){window.console&&window.console.group&&window.console.group(t)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){return t.parentNode&&t.parentNode.removeChild(t),t}getValue(t){return t.value}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(t){const e=Gc||(Gc=document.querySelector("base"),Gc)?Gc.getAttribute("href"):null;return null==e?null:(n=e,Hc||(Hc=document.createElement("a")),Hc.setAttribute("href",n),"/"===Hc.pathname.charAt(0)?Hc.pathname:"/"+Hc.pathname);var n}resetBaseElement(){Gc=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(t){return function(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[s,r]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(s.trim()===e)return decodeURIComponent(r)}return null}(document.cookie,t)}}let Hc,Gc=null;const qc=new ms("TRANSITION_ID"),Kc=[{provide:pu,useFactory:function(t,e,n){return()=>{n.get(fu).donePromise.then(()=>{const n=dc();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[qc,pc,Sa],multi:!0}];class Xc{static init(){var t;t=new Xc,Hu=t}addToWindow(t){ae.getAngularTestability=(e,n=!0)=>{const s=t.findTestabilityInTree(e,n);if(null==s)throw new Error("Could not find testability for element.");return s},ae.getAllAngularTestabilities=()=>t.getAllTestabilities(),ae.getAllAngularRootElements=()=>t.getAllRootElements(),ae.frameworkStabilizers||(ae.frameworkStabilizers=[]),ae.frameworkStabilizers.push(t=>{const e=ae.getAllAngularTestabilities();let n=e.length,s=!1;const r=function(e){s=s||e,n--,0==n&&t(s)};e.forEach(function(t){t.whenStable(r)})})}findTestabilityInTree(t,e,n){if(null==e)return null;const s=t.getTestability(e);return null!=s?s:n?dc().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}const Qc=new ms("EventManagerPlugins");let Yc=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let s=0;s<n.length;s++){const e=n[s];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error(`No event manager plugin found for event ${t}`)}}return t.\u0275fac=function(e){return new(e||t)($s(Qc),$s(Du))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Zc{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const s=dc().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,n)}}let Jc=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),th=(()=>{class t extends Jc{constructor(t){super(),this._doc=t,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(t.head)}_addStylesToHost(t,e){t.forEach(t=>{const n=this._doc.createElement("style");n.textContent=t,this._styleNodes.add(e.appendChild(n))})}addHost(t){this._addStylesToHost(this._stylesSet,t),this._hostNodes.add(t)}removeHost(t){this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach(e=>this._addStylesToHost(t,e))}ngOnDestroy(){this._styleNodes.forEach(t=>dc().remove(t))}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const eh={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},nh=/%COMP%/g;function sh(t,e,n){for(let s=0;s<e.length;s++){let r=e[s];Array.isArray(r)?sh(t,r,n):(r=r.replace(nh,t),n.push(r))}return n}function rh(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let ih=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new ah(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case ee.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new oh(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case 1:case ee.ShadowDom:return new lh(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=sh(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)($s(Yc),$s(th),$s(mu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class ah{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(eh[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,s){if(s){e=s+":"+e;const r=eh[s];r?t.setAttributeNS(r,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const s=eh[n];s?t.removeAttributeNS(s,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,s){s&(Ir.DashCase|Ir.Important)?t.style.setProperty(e,n,s&Ir.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&Ir.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,rh(n)):this.eventManager.addEventListener(t,e,rh(n))}}class oh extends ah{constructor(t,e,n,s){super(t),this.component=n;const r=sh(s+"-"+n.id,n.styles,[]);e.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(nh,s+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(nh,s+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class lh extends ah{constructor(t,e,n,s){super(t),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=sh(s.id,s.styles,[]);for(let i=0;i<r.length;i++){const t=document.createElement("style");t.textContent=r[i],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let uh=(()=>{class t extends Zc{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const ch=["alt","control","meta","shift"],hh={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},dh={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},ph={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let fh=(()=>{class t extends Zc{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,s){const r=t.parseEventName(n),i=t.eventCallback(r.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>dc().onAndCancel(e,r.domEventName,i))}static parseEventName(e){const n=e.toLowerCase().split("."),s=n.shift();if(0===n.length||"keydown"!==s&&"keyup"!==s)return null;const r=t._normalizeKey(n.pop());let i="";if(ch.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),i+=t+".")}),i+=r,0!=n.length||0===r.length)return null;const a={};return a.domEventName=s,a.fullKey=i,a}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&dh.hasOwnProperty(e)&&(e=dh[e]))}return hh[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),ch.forEach(s=>{s!=n&&(0,ph[s])(t)&&(e+=s+".")}),e+=n,e}static eventCallback(e,n,s){return r=>{t.getEventFullKey(r)===e&&s.runGuarded(()=>n(r))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),mh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return $s(gh)},token:t,providedIn:"root"}),t})(),gh=(()=>{class t extends mh{constructor(t){super(),this._doc=t}sanitize(t,e){if(null==e)return null;switch(t){case br.NONE:return e;case br.HTML:return Ks(e,"HTML")?qs(e):function(t,e){let n=null;try{gr=gr||function(t){const e=new Ys(t);return function(){try{return!!(new window.DOMParser).parseFromString(Bs(""),"text/html")}catch(t){return!1}}()?new Qs(e):e}(t);let s=e?String(e):"";n=gr.getInertBodyElement(s);let r=5,i=s;do{if(0===r)throw new Error("Failed to sanitize html because the input is unstable");r--,s=i,i=n.innerHTML,n=gr.getInertBodyElement(s)}while(s!==i);return Bs((new dr).sanitizeChildren(yr(n)||n))}finally{if(n){const t=yr(n)||n;for(;t.firstChild;)t.removeChild(t.firstChild)}}}(this._doc,String(e)).toString();case br.STYLE:return Ks(e,"Style")?qs(e):e;case br.SCRIPT:if(Ks(e,"Script"))return qs(e);throw new Error("unsafe value used in a script context");case br.URL:return Xs(e),Ks(e,"URL")?qs(e):tr(String(e));case br.RESOURCE_URL:if(Ks(e,"ResourceURL"))return qs(e);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(t){return new Ws(t)}bypassSecurityTrustStyle(t){return new Us(t)}bypassSecurityTrustScript(t){return new js(t)}bypassSecurityTrustUrl(t){return new Hs(t)}bypassSecurityTrustResourceUrl(t){return new Gs(t)}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({factory:function(){return t=$s(la),new gh(t.get(pc));var t},token:t,providedIn:"root"}),t})();const yh=Yu(lc,"browser",[{provide:xu,useValue:"browser"},{provide:bu,useValue:function(){jc.makeCurrent(),Xc.init()},multi:!0},{provide:pc,useFactory:function(){return function(t){Be=t}(document),document},deps:[]}]),bh=[[],{provide:ca,useValue:"root"},{provide:_r,useFactory:function(){return new _r},deps:[]},{provide:Qc,useClass:uh,multi:!0,deps:[pc,Du,xu]},{provide:Qc,useClass:fh,multi:!0,deps:[pc]},[],{provide:ih,useClass:ih,deps:[Yc,th,mu]},{provide:Yo,useExisting:ih},{provide:Jc,useExisting:th},{provide:th,useClass:th,deps:[pc]},{provide:Vu,useClass:Vu,deps:[Du]},{provide:Yc,useClass:Yc,deps:[Qc,Du]},[]];let xh=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:mu,useValue:e.appId},{provide:qc,useExisting:mu},Kc]}}}return t.\u0275fac=function(e){return new(e||t)($s(t,12))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:bh,imports:[Pc,cc]}),t})();"undefined"!=typeof window&&window;class vh extends Z{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new X;return this._value}next(t){super.next(this._value=t)}}class wh extends B{constructor(t,e){super()}schedule(t,e=0){return this}}class _h extends wh{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,s=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(s,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n,s=!1;try{this.work(t)}catch(r){s=!0,n=!!r&&r||new Error(r)}if(s)return this.unsubscribe(),n}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,s=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==s&&n.splice(s,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let kh=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class Sh extends kh{constructor(t,e=kh.now){super(t,()=>Sh.delegate&&Sh.delegate!==this?Sh.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return Sh.delegate&&Sh.delegate!==this?Sh.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}function Ch(...t){let e=t[t.length-1];return tt(e)?(t.pop(),ct(t,e)):xt(t)}function Ih(t,e,n,s){return $(n)&&(s=n,n=void 0),s?Ih(t,e,n).pipe(et(t=>M(t)?s(...t):s(t))):new q(s=>{Nh(t,e,function(t){s.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},s,n)})}function Nh(t,e,n,s,r){let i;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(t)){const s=t;t.addEventListener(e,n,r),i=()=>s.removeEventListener(e,n,r)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(t)){const s=t;t.on(e,n),i=()=>s.off(e,n)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(t)){const s=t;t.addListener(e,n),i=()=>s.removeListener(e,n)}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(let i=0,a=t.length;i<a;i++)Nh(t[i],e,n,s,r)}s.add(i)}function Eh(t,e){return function(n){return n.lift(new Th(t,e))}}class Th{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new Ah(t,this.predicate,this.thisArg))}}class Ah extends U{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}const Rh=new Sh(_h);function $h(t,e){return"function"==typeof e?n=>n.pipe($h((n,s)=>ht(t(n,s)).pipe(et((t,r)=>e(n,t,s,r))))):e=>e.lift(new Fh(t))}class Fh{constructor(t){this.project=t}call(t,e){return e.subscribe(new Dh(t,this.project))}}class Dh extends pt{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&&e.unsubscribe();const n=new dt(this),s=this.destination;s.add(n),this.innerSubscription=ft(t,n),this.innerSubscription!==n&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(t){this.destination.next(t)}}function Oh(t){return e=>e.lift(new Lh(t))}class Lh{constructor(t){this.notifier=t}call(t,e){const n=new Mh(t),s=ft(this.notifier,new dt(n));return s&&!n.seenValue?(n.add(s),e.subscribe(n)):n}}class Mh extends pt{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}const Ph=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})(),zh=new q(t=>t.complete());function Bh(t){return t?function(t){return new q(e=>t.schedule(()=>e.complete()))}(t):zh}function Vh(t){return e=>0===t?Bh():e.lift(new Wh(t))}class Wh{constructor(t){if(this.total=t,this.total<0)throw new Ph}call(t,e){return e.subscribe(new Uh(t,this.total))}}class Uh extends U{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function jh(){}function Hh(t,e,n){return function(s){return s.lift(new Gh(t,e,n))}}class Gh{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new qh(t,this.nextOrObserver,this.error,this.complete))}}class qh extends U{constructor(t,e,n,s){super(t),this._tapNext=jh,this._tapError=jh,this._tapComplete=jh,this._tapError=n||jh,this._tapComplete=s||jh,$(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||jh,this._tapError=e.error||jh,this._tapComplete=e.complete||jh)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}const Kh={provide:vu,useFactory:function(t,e){return()=>{if(zc(e)){const e=Array.from(t.querySelectorAll(`[class*=${Xh}]`)),n=/\bflex-layout-.+?\b/g;e.forEach(t=>{t.classList.contains(`${Xh}ssr`)&&t.parentNode?t.parentNode.removeChild(t):t.className.replace(n,"")})}}},deps:[pc,xu],multi:!0},Xh="flex-layout-";let Qh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Kh]}),t})();class Yh{constructor(t=!1,e="all",n="",s="",r=0){this.matches=t,this.mediaQuery=e,this.mqAlias=n,this.suffix=s,this.priority=r,this.property=""}clone(){return new Yh(this.matches,this.mediaQuery,this.mqAlias,this.suffix)}}let Zh=(()=>{class t{constructor(){this.stylesheet=new Map}addStyleToElement(t,e,n){const s=this.stylesheet.get(t);s?s.set(e,n):this.stylesheet.set(t,new Map([[e,n]]))}clearStyles(){this.stylesheet.clear()}getStyleForElement(t,e){const n=this.stylesheet.get(t);let s="";if(n){const t=n.get(e);"number"!=typeof t&&"string"!=typeof t||(s=t+"")}return s}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const Jh={addFlexToParent:!0,addOrientationBps:!1,disableDefaultBps:!1,disableVendorPrefixes:!1,serverLoaded:!1,useColumnBasisZero:!0,printWithBreakpoints:[],mediaTriggerAutoRestore:!0,ssrObserveBreakpoints:[]},td=new ms("Flex Layout token, config options for the library",{providedIn:"root",factory:()=>Jh}),ed=new ms("FlexLayoutServerLoaded",{providedIn:"root",factory:()=>!1}),nd=new ms("Flex Layout token, collect all breakpoints into one provider",{providedIn:"root",factory:()=>null});function sd(t,e){return t=t?t.clone():new Yh,e&&(t.mqAlias=e.alias,t.mediaQuery=e.mediaQuery,t.suffix=e.suffix,t.priority=e.priority),t}const rd=["row","column","row-reverse","column-reverse"];function id(t){if(t)switch(t.toLowerCase()){case"reverse":case"wrap-reverse":case"reverse-wrap":t="wrap-reverse";break;case"no":case"none":case"nowrap":t="nowrap";break;default:t="wrap"}return t}let ad=(()=>{class t{constructor(t,e,n,s){this.elementRef=t,this.styleBuilder=e,this.styler=n,this.marshal=s,this.DIRECTIVE_KEY="",this.inputs=[],this.mru={},this.destroySubject=new Z,this.styleCache=new Map}get parentElement(){return this.elementRef.nativeElement.parentElement}get nativeElement(){return this.elementRef.nativeElement}get activatedValue(){return this.marshal.getValue(this.nativeElement,this.DIRECTIVE_KEY)}set activatedValue(t){this.marshal.setValue(this.nativeElement,this.DIRECTIVE_KEY,t,this.marshal.activatedAlias)}ngOnChanges(t){Object.keys(t).forEach(e=>{if(-1!==this.inputs.indexOf(e)){const n=e.split(".").slice(1).join(".");this.setValue(t[e].currentValue,n)}})}ngOnDestroy(){this.destroySubject.next(),this.destroySubject.complete(),this.marshal.releaseElement(this.nativeElement)}init(t=[]){this.marshal.init(this.elementRef.nativeElement,this.DIRECTIVE_KEY,this.updateWithValue.bind(this),this.clearStyles.bind(this),t)}addStyles(t,e){const n=this.styleBuilder,s=n.shouldCache;let r=this.styleCache.get(t);r&&s||(r=n.buildStyles(t,e),s&&this.styleCache.set(t,r)),this.mru=Object.assign({},r),this.applyStyleToElement(r),n.sideEffect(t,r,e)}clearStyles(){Object.keys(this.mru).forEach(t=>{this.mru[t]=""}),this.applyStyleToElement(this.mru),this.mru={}}triggerUpdate(){this.marshal.triggerUpdate(this.nativeElement,this.DIRECTIVE_KEY)}getFlexFlowDirection(t,e=!1){if(t){const[n,s]=this.styler.getFlowDirection(t);if(!s&&e){const e=function(t){let[e,n,s]=function(t){t=t?t.toLowerCase():"";let[e,n,s]=t.split(" ");return rd.find(t=>t===e)||(e=rd[0]),"inline"===n&&(n="inline"!==s?s:"",s="inline"),[e,id(n),!!s]}(t);return function(t,e=null,n=!1){return{display:n?"inline-flex":"flex","box-sizing":"border-box","flex-direction":t,"flex-wrap":e||null}}(e,n,s)}(n);this.styler.applyStyleToElements(e,[t])}return n.trim()}return"row"}hasWrap(t){return this.styler.hasWrap(t)}applyStyleToElement(t,e,n=this.nativeElement){this.styler.applyStyleToElement(n,t,e)}setValue(t,e){this.marshal.setValue(this.nativeElement,this.DIRECTIVE_KEY,t,e)}updateWithValue(t){this.currentValue!==t&&(this.addStyles(t),this.currentValue=t)}}return t.\u0275fac=function(t){!function(){throw new Error("invalid")}()},t.\u0275dir=Se({type:t,features:[Oe]}),t})();const od=[{alias:"xs",mediaQuery:"screen and (min-width: 0px) and (max-width: 599.98px)",priority:1e3},{alias:"sm",mediaQuery:"screen and (min-width: 600px) and (max-width: 959.98px)",priority:900},{alias:"md",mediaQuery:"screen and (min-width: 960px) and (max-width: 1279.98px)",priority:800},{alias:"lg",mediaQuery:"screen and (min-width: 1280px) and (max-width: 1919.98px)",priority:700},{alias:"xl",mediaQuery:"screen and (min-width: 1920px) and (max-width: 4999.98px)",priority:600},{alias:"lt-sm",overlapping:!0,mediaQuery:"screen and (max-width: 599.98px)",priority:950},{alias:"lt-md",overlapping:!0,mediaQuery:"screen and (max-width: 959.98px)",priority:850},{alias:"lt-lg",overlapping:!0,mediaQuery:"screen and (max-width: 1279.98px)",priority:750},{alias:"lt-xl",overlapping:!0,priority:650,mediaQuery:"screen and (max-width: 1919.98px)"},{alias:"gt-xs",overlapping:!0,mediaQuery:"screen and (min-width: 600px)",priority:-950},{alias:"gt-sm",overlapping:!0,mediaQuery:"screen and (min-width: 960px)",priority:-850},{alias:"gt-md",overlapping:!0,mediaQuery:"screen and (min-width: 1280px)",priority:-750},{alias:"gt-lg",overlapping:!0,mediaQuery:"screen and (min-width: 1920px)",priority:-650}],ld="(orientation: portrait) and (max-width: 599.98px)",ud="(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)",cd="(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)",hd="(orientation: portrait) and (min-width: 840px)",dd="(orientation: landscape) and (min-width: 1280px)",pd={HANDSET:`${ld}, (orientation: landscape) and (max-width: 959.98px)`,TABLET:`${ud} , ${cd}`,WEB:`${hd}, ${dd} `,HANDSET_PORTRAIT:`${ld}`,TABLET_PORTRAIT:`${ud} `,WEB_PORTRAIT:`${hd}`,HANDSET_LANDSCAPE:"(orientation: landscape) and (max-width: 959.98px)",TABLET_LANDSCAPE:`${cd}`,WEB_LANDSCAPE:`${dd}`},fd=[{alias:"handset",priority:2e3,mediaQuery:pd.HANDSET},{alias:"handset.landscape",priority:2e3,mediaQuery:pd.HANDSET_LANDSCAPE},{alias:"handset.portrait",priority:2e3,mediaQuery:pd.HANDSET_PORTRAIT},{alias:"tablet",priority:2100,mediaQuery:pd.TABLET},{alias:"tablet.landscape",priority:2100,mediaQuery:pd.TABLET_LANDSCAPE},{alias:"tablet.portrait",priority:2100,mediaQuery:pd.TABLET_PORTRAIT},{alias:"web",priority:2200,mediaQuery:pd.WEB,overlapping:!0},{alias:"web.landscape",priority:2200,mediaQuery:pd.WEB_LANDSCAPE,overlapping:!0},{alias:"web.portrait",priority:2200,mediaQuery:pd.WEB_PORTRAIT,overlapping:!0}],md=/(\.|-|_)/g;function gd(t){let e=t.length>0?t.charAt(0):"",n=t.length>1?t.slice(1):"";return e.toUpperCase()+n}const yd=new ms("Token (@angular/flex-layout) Breakpoints",{providedIn:"root",factory:()=>{const t=Fs(nd),e=Fs(td),n=[].concat.apply([],(t||[]).map(t=>Array.isArray(t)?t:[t]));return function(t,e=[]){const n={};return t.forEach(t=>{n[t.alias]=t}),e.forEach(t=>{n[t.alias]?function(t,...e){if(null==t)throw TypeError("Cannot convert undefined or null to object");for(let n of e)if(null!=n)for(let e in n)n.hasOwnProperty(e)&&(t[e]=n[e])}(n[t.alias],t):n[t.alias]=t}),(s=Object.keys(n).map(t=>n[t])).forEach(t=>{t.suffix||(t.suffix=t.alias.replace(md,"|").split("|").map(gd).join(""),t.overlapping=!!t.overlapping)}),s;var s}((e.disableDefaultBps?[]:od).concat(e.addOrientationBps?fd:[]),n)}});function bd(t,e){return(e&&e.priority||0)-(t&&t.priority||0)}function xd(t,e){return(t.priority||0)-(e.priority||0)}let vd=(()=>{class t{constructor(t){this.findByMap=new Map,this.items=[...t].sort(xd)}findByAlias(t){return t?this.findWithPredicate(t,e=>e.alias==t):null}findByQuery(t){return this.findWithPredicate(t,e=>e.mediaQuery==t)}get overlappings(){return this.items.filter(t=>1==t.overlapping)}get aliases(){return this.items.map(t=>t.alias)}get suffixes(){return this.items.map(t=>t.suffix?t.suffix:"")}findWithPredicate(t,e){let n=this.findByMap.get(t);return n||(n=this.items.find(e)||null,this.findByMap.set(t,n)),n||null}}return t.\u0275fac=function(e){return new(e||t)($s(yd))},t.\u0275prov=Bt({factory:function(){return new t($s(yd))},token:t,providedIn:"root"}),t})(),wd=(()=>{class t{constructor(t,e,n){this._zone=t,this._platformId=e,this._document=n,this.source=new vh(new Yh(!0)),this.registry=new Map,this.pendingRemoveListenerFns=[],this._observable$=this.source.asObservable()}get activations(){const t=[];return this.registry.forEach((e,n)=>{e.matches&&t.push(n)}),t}isActive(t){const e=this.registry.get(t);return e?e.matches:this.registerQuery(t).some(t=>t.matches)}observe(t,e=!1){if(t&&t.length){const n=this._observable$.pipe(Eh(n=>!e||t.indexOf(n.mediaQuery)>-1));return vt(new q(e=>{const n=this.registerQuery(t);if(n.length){const t=n.pop();n.forEach(t=>{e.next(t)}),this.source.next(t)}e.complete()}),n)}return this._observable$}registerQuery(t){const e=Array.isArray(t)?t:[t],n=[];return function(t,e){const n=t.filter(t=>!_d[t]);if(n.length>0){const t=n.join(", ");try{const s=e.createElement("style");s.setAttribute("type","text/css"),s.styleSheet||s.appendChild(e.createTextNode(`\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${t} {.fx-query-test{ }}\n`)),e.head.appendChild(s),n.forEach(t=>_d[t]=s)}catch(s){console.error(s)}}}(e,this._document),e.forEach(t=>{const e=e=>{this._zone.run(()=>this.source.next(new Yh(e.matches,t)))};let s=this.registry.get(t);s||(s=this.buildMQL(t),s.addListener(e),this.pendingRemoveListenerFns.push(()=>s.removeListener(e)),this.registry.set(t,s)),s.matches&&n.push(new Yh(!0,t))}),n}ngOnDestroy(){let t;for(;t=this.pendingRemoveListenerFns.pop();)t()}buildMQL(t){return function(t,e){return e&&window.matchMedia("all").addListener?window.matchMedia(t):{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{},onchange:null,addEventListener(){},removeEventListener(){},dispatchEvent:()=>!1}}(t,zc(this._platformId))}}return t.\u0275fac=function(e){return new(e||t)($s(Du),$s(xu),$s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(Du),$s(xu),$s(pc))},token:t,providedIn:"root"}),t})();const _d={},kd={alias:"print",mediaQuery:"print",priority:1e3};let Sd=(()=>{class t{constructor(t,e,n){this.breakpoints=t,this.layoutConfig=e,this._document=n,this.registeredBeforeAfterPrintHooks=!1,this.isPrintingBeforeAfterEvent=!1,this.beforePrintEventListeners=[],this.afterPrintEventListeners=[],this.isPrinting=!1,this.queue=new Cd,this.deactivations=[]}withPrintQuery(t){return[...t,"print"]}isPrintEvent(t){return t.mediaQuery.startsWith("print")}get printAlias(){return this.layoutConfig.printWithBreakpoints||[]}get printBreakPoints(){return this.printAlias.map(t=>this.breakpoints.findByAlias(t)).filter(t=>null!==t)}getEventBreakpoints({mediaQuery:t}){const e=this.breakpoints.findByQuery(t);return(e?[...this.printBreakPoints,e]:this.printBreakPoints).sort(bd)}updateEvent(t){let e=this.breakpoints.findByQuery(t.mediaQuery);return this.isPrintEvent(t)&&(e=this.getEventBreakpoints(t)[0],t.mediaQuery=e?e.mediaQuery:""),sd(t,e)}registerBeforeAfterPrintHooks(t){if(!this._document.defaultView||this.registeredBeforeAfterPrintHooks)return;this.registeredBeforeAfterPrintHooks=!0;const e=()=>{this.isPrinting||(this.isPrintingBeforeAfterEvent=!0,this.startPrinting(t,this.getEventBreakpoints(new Yh(!0,"print"))),t.updateStyles())},n=()=>{this.isPrintingBeforeAfterEvent=!1,this.isPrinting&&(this.stopPrinting(t),t.updateStyles())};this._document.defaultView.addEventListener("beforeprint",e),this._document.defaultView.addEventListener("afterprint",n),this.beforePrintEventListeners.push(e),this.afterPrintEventListeners.push(n)}interceptEvents(t){return this.registerBeforeAfterPrintHooks(t),e=>{this.isPrintEvent(e)?e.matches&&!this.isPrinting?(this.startPrinting(t,this.getEventBreakpoints(e)),t.updateStyles()):e.matches||!this.isPrinting||this.isPrintingBeforeAfterEvent||(this.stopPrinting(t),t.updateStyles()):this.collectActivations(e)}}blockPropagation(){return t=>!(this.isPrinting||this.isPrintEvent(t))}startPrinting(t,e){this.isPrinting=!0,t.activatedBreakpoints=this.queue.addPrintBreakpoints(e)}stopPrinting(t){t.activatedBreakpoints=this.deactivations,this.deactivations=[],this.queue.clear(),this.isPrinting=!1}collectActivations(t){if(!this.isPrinting||this.isPrintingBeforeAfterEvent)if(t.matches)this.isPrintingBeforeAfterEvent||(this.deactivations=[]);else{const e=this.breakpoints.findByQuery(t.mediaQuery);e&&(this.deactivations.push(e),this.deactivations.sort(bd))}}ngOnDestroy(){this.beforePrintEventListeners.forEach(t=>this._document.defaultView.removeEventListener("beforeprint",t)),this.afterPrintEventListeners.forEach(t=>this._document.defaultView.removeEventListener("afterprint",t))}}return t.\u0275fac=function(e){return new(e||t)($s(vd),$s(td),$s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(vd),$s(td),$s(pc))},token:t,providedIn:"root"}),t})();class Cd{constructor(){this.printBreakpoints=[]}addPrintBreakpoints(t){return t.push(kd),t.sort(bd),t.forEach(t=>this.addBreakpoint(t)),this.printBreakpoints}addBreakpoint(t){t&&void 0===this.printBreakpoints.find(e=>e.mediaQuery===t.mediaQuery)&&(this.printBreakpoints=function(t){return!!t&&t.mediaQuery.startsWith("print")}(t)?[t,...this.printBreakpoints]:[...this.printBreakpoints,t])}clear(){this.printBreakpoints=[]}}function Id(t){for(let e in t){let n=t[e]||"";switch(e){case"display":t.display="flex"===n?["-webkit-flex","flex"]:"inline-flex"===n?["-webkit-inline-flex","inline-flex"]:n;break;case"align-items":case"align-self":case"align-content":case"flex":case"flex-basis":case"flex-flow":case"flex-grow":case"flex-shrink":case"flex-wrap":case"justify-content":t["-webkit-"+e]=n;break;case"flex-direction":n=n||"row",t["-webkit-flex-direction"]=n,t["flex-direction"]=n;break;case"order":t.order=t["-webkit-"+e]=isNaN(+n)?"0":n}}return t}let Nd=(()=>{class t{constructor(t,e,n,s){this._serverStylesheet=t,this._serverModuleLoaded=e,this._platformId=n,this.layoutConfig=s}applyStyleToElement(t,e,n=null){let s={};"string"==typeof e&&(s[e]=n,e=s),s=this.layoutConfig.disableVendorPrefixes?e:Id(e),this._applyMultiValueStyleToElement(s,t)}applyStyleToElements(t,e=[]){const n=this.layoutConfig.disableVendorPrefixes?t:Id(t);e.forEach(t=>{this._applyMultiValueStyleToElement(n,t)})}getFlowDirection(t){let e=this.lookupStyle(t,"flex-direction");return[e||"row",this.lookupInlineStyle(t,"flex-direction")||Bc(this._platformId)&&this._serverModuleLoaded?e:""]}hasWrap(t){return"wrap"===this.lookupStyle(t,"flex-wrap")}lookupAttributeValue(t,e){return t.getAttribute(e)||""}lookupInlineStyle(t,e){return zc(this._platformId)?t.style.getPropertyValue(e):this._getServerStyle(t,e)}lookupStyle(t,e,n=!1){let s="";return t&&((s=this.lookupInlineStyle(t,e))||(zc(this._platformId)?n||(s=getComputedStyle(t).getPropertyValue(e)):this._serverModuleLoaded&&(s=this._serverStylesheet.getStyleForElement(t,e)))),s?s.trim():""}_applyMultiValueStyleToElement(t,e){Object.keys(t).sort().forEach(n=>{const s=t[n],r=Array.isArray(s)?s:[s];r.sort();for(let t of r)t=t?t+"":"",zc(this._platformId)||!this._serverModuleLoaded?zc(this._platformId)?e.style.setProperty(n,t):this._setServerStyle(e,n,t):this._serverStylesheet.addStyleToElement(e,n,t)})}_setServerStyle(t,e,n){e=e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();const s=this._readStyleAttribute(t);s[e]=n||"",this._writeStyleAttribute(t,s)}_getServerStyle(t,e){return this._readStyleAttribute(t)[e]||""}_readStyleAttribute(t){const e={},n=t.getAttribute("style");if(n){const t=n.split(/;+/g);for(let n=0;n<t.length;n++){const s=t[n].trim();if(s.length>0){const t=s.indexOf(":");if(-1===t)throw new Error(`Invalid CSS style: ${s}`);e[s.substr(0,t).trim()]=s.substr(t+1).trim()}}}return e}_writeStyleAttribute(t,e){let n="";for(const s in e)e[s]&&(n+=s+":"+e[s]+";");t.setAttribute("style",n)}}return t.\u0275fac=function(e){return new(e||t)($s(Zh),$s(ed),$s(xu),$s(td))},t.\u0275prov=Bt({factory:function(){return new t($s(Zh),$s(ed),$s(xu),$s(td))},token:t,providedIn:"root"}),t})();class Ed{constructor(){this.shouldCache=!0}sideEffect(t,e,n){}}function Td(t,e="1",n="1"){let s=[e,n,t],r=t.indexOf("calc");if(r>0){s[2]=Ad(t.substring(r).trim());let e=t.substr(0,r).trim().split(" ");2==e.length&&(s[0]=e[0],s[1]=e[1])}else if(0==r)s[2]=Ad(t.trim());else{let r=t.split(" ");s=3===r.length?r:[e,n,t]}return s}function Ad(t){return t.replace(/[\s]/g,"").replace(/[\/\*\+\-]/g," $& ")}let Rd=(()=>{class t{constructor(t,e,n){this.matchMedia=t,this.breakpoints=e,this.hook=n,this.activatedBreakpoints=[],this.elementMap=new Map,this.elementKeyMap=new WeakMap,this.watcherMap=new WeakMap,this.updateMap=new WeakMap,this.clearMap=new WeakMap,this.subject=new Z,this.observeActivations()}get activatedAlias(){return this.activatedBreakpoints[0]?this.activatedBreakpoints[0].alias:""}onMediaChange(t){const e=this.findByQuery(t.mediaQuery);e&&((t=sd(t,e)).matches&&-1===this.activatedBreakpoints.indexOf(e)?(this.activatedBreakpoints.push(e),this.activatedBreakpoints.sort(bd),this.updateStyles()):t.matches||-1===this.activatedBreakpoints.indexOf(e)||(this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(e),1),this.activatedBreakpoints.sort(bd),this.updateStyles()))}init(t,e,n,s,r=[]){$d(this.updateMap,t,e,n),$d(this.clearMap,t,e,s),this.buildElementKeyMap(t,e),this.watchExtraTriggers(t,e,r)}getValue(t,e,n){const s=this.elementMap.get(t);if(s){const t=void 0!==n?s.get(n):this.getActivatedValues(s,e);if(t)return t.get(e)}}hasValue(t,e){const n=this.elementMap.get(t);if(n){const t=this.getActivatedValues(n,e);if(t)return void 0!==t.get(e)||!1}return!1}setValue(t,e,n,s){let r=this.elementMap.get(t);if(r){const i=(r.get(s)||new Map).set(e,n);r.set(s,i),this.elementMap.set(t,r)}else r=(new Map).set(s,(new Map).set(e,n)),this.elementMap.set(t,r);const i=this.getValue(t,e);void 0!==i&&this.updateElement(t,e,i)}trackValue(t,e){return this.subject.asObservable().pipe(Eh(n=>n.element===t&&n.key===e))}updateStyles(){this.elementMap.forEach((t,e)=>{const n=new Set(this.elementKeyMap.get(e));let s=this.getActivatedValues(t);s&&s.forEach((t,s)=>{this.updateElement(e,s,t),n.delete(s)}),n.forEach(n=>{if(s=this.getActivatedValues(t,n),s){const t=s.get(n);this.updateElement(e,n,t)}else this.clearElement(e,n)})})}clearElement(t,e){const n=this.clearMap.get(t);if(n){const s=n.get(e);s&&(s(),this.subject.next({element:t,key:e,value:""}))}}updateElement(t,e,n){const s=this.updateMap.get(t);if(s){const r=s.get(e);r&&(r(n),this.subject.next({element:t,key:e,value:n}))}}releaseElement(t){const e=this.watcherMap.get(t);e&&(e.forEach(t=>t.unsubscribe()),this.watcherMap.delete(t));const n=this.elementMap.get(t);n&&(n.forEach((t,e)=>n.delete(e)),this.elementMap.delete(t))}triggerUpdate(t,e){const n=this.elementMap.get(t);if(n){const s=this.getActivatedValues(n,e);s&&(e?this.updateElement(t,e,s.get(e)):s.forEach((e,n)=>this.updateElement(t,n,e)))}}buildElementKeyMap(t,e){let n=this.elementKeyMap.get(t);n||(n=new Set,this.elementKeyMap.set(t,n)),n.add(e)}watchExtraTriggers(t,e,n){if(n&&n.length){let s=this.watcherMap.get(t);if(s||(s=new Map,this.watcherMap.set(t,s)),!s.get(e)){const r=vt(...n).subscribe(()=>{const n=this.getValue(t,e);this.updateElement(t,e,n)});s.set(e,r)}}}findByQuery(t){return this.breakpoints.findByQuery(t)}getActivatedValues(t,e){for(let s=0;s<this.activatedBreakpoints.length;s++){const n=t.get(this.activatedBreakpoints[s].alias);if(n&&(void 0===e||n.has(e)&&null!=n.get(e)))return n}const n=t.get("");return void 0===e||n&&n.has(e)?n:void 0}observeActivations(){const t=this.breakpoints.items.map(t=>t.mediaQuery);this.matchMedia.observe(this.hook.withPrintQuery(t)).pipe(Hh(this.hook.interceptEvents(this)),Eh(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this))}}return t.\u0275fac=function(e){return new(e||t)($s(wd),$s(vd),$s(Sd))},t.\u0275prov=Bt({factory:function(){return new t($s(wd),$s(vd),$s(Sd))},token:t,providedIn:"root"}),t})();function $d(t,e,n,s){if(void 0!==s){let r=t.get(e);r||(r=new Map,t.set(e,r)),r.set(n,s)}}function Fd(t){return null!=t&&"false"!=`${t}`}function Dd(t){return Array.isArray(t)?t:[t]}function Od(t){return null==t?"":"string"==typeof t?t:`${t}px`}function Ld(t){return t instanceof Xo?t.nativeElement:t}new Map,new WeakMap;let Md=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Qh]]}),t})();const Pd=new ms("cdk-dir-doc",{providedIn:"root",factory:function(){return Fs(pc)}});let zd=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new Kl,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)($s(Pd,8))},t.\u0275prov=Bt({factory:function(){return new t($s(Pd,8))},token:t,providedIn:"root"}),t})(),Bd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();const Vd=["row","column","row-reverse","column-reverse"];function Wd(t){t=t?t.toLowerCase():"";let[e,n,s]=t.split(" ");return Vd.find(t=>t===e)||(e=Vd[0]),"inline"===n&&(n="inline"!==s?s:"",s="inline"),[e,jd(n),!!s]}function Ud(t){let[e]=Wd(t);return e.indexOf("row")>-1}function jd(t){if(t)switch(t.toLowerCase()){case"reverse":case"wrap-reverse":case"reverse-wrap":t="wrap-reverse";break;case"no":case"none":case"nowrap":t="nowrap";break;default:t="wrap"}return t}let Hd=(()=>{class t extends Ed{buildStyles(t){return function(t){let[e,n,s]=Wd(t);return function(t,e=null,n=!1){return{display:n?"inline-flex":"flex","box-sizing":"border-box","flex-direction":t,"flex-wrap":e||null}}(e,n,s)}(t)}}return t.\u0275fac=function(e){return Gd(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const Gd=ds(Hd),qd=["fxLayout","fxLayout.xs","fxLayout.sm","fxLayout.md","fxLayout.lg","fxLayout.xl","fxLayout.lt-sm","fxLayout.lt-md","fxLayout.lt-lg","fxLayout.lt-xl","fxLayout.gt-xs","fxLayout.gt-sm","fxLayout.gt-md","fxLayout.gt-lg"];let Kd=(()=>{class t extends ad{constructor(t,e,n,s){super(t,n,e,s),this.DIRECTIVE_KEY="layout",this.styleCache=Yd,this.init()}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Nd),Pa(Hd),Pa(Rd))},t.\u0275dir=Se({type:t,features:[Ia]}),t})(),Xd=(()=>{class t extends Kd{constructor(){super(...arguments),this.inputs=qd}}return t.\u0275fac=function(e){return Qd(e||t)},t.\u0275dir=Se({type:t,selectors:[["","fxLayout",""],["","fxLayout.xs",""],["","fxLayout.sm",""],["","fxLayout.md",""],["","fxLayout.lg",""],["","fxLayout.xl",""],["","fxLayout.lt-sm",""],["","fxLayout.lt-md",""],["","fxLayout.lt-lg",""],["","fxLayout.lt-xl",""],["","fxLayout.gt-xs",""],["","fxLayout.gt-sm",""],["","fxLayout.gt-md",""],["","fxLayout.gt-lg",""]],inputs:{fxLayout:"fxLayout","fxLayout.xs":"fxLayout.xs","fxLayout.sm":"fxLayout.sm","fxLayout.md":"fxLayout.md","fxLayout.lg":"fxLayout.lg","fxLayout.xl":"fxLayout.xl","fxLayout.lt-sm":"fxLayout.lt-sm","fxLayout.lt-md":"fxLayout.lt-md","fxLayout.lt-lg":"fxLayout.lt-lg","fxLayout.lt-xl":"fxLayout.lt-xl","fxLayout.gt-xs":"fxLayout.gt-xs","fxLayout.gt-sm":"fxLayout.gt-sm","fxLayout.gt-md":"fxLayout.gt-md","fxLayout.gt-lg":"fxLayout.gt-lg"},features:[Ia]}),t})();const Qd=ds(Xd),Yd=new Map;function Zd(t,...e){if(null==t)throw TypeError("Cannot convert undefined or null to object");for(let n of e)if(null!=n)for(let e in n)n.hasOwnProperty(e)&&(t[e]=n[e]);return t}new Map,new Map,new Map,new Map;let Jd=(()=>{class t extends Ed{constructor(t){super(),this.layoutConfig=t}buildStyles(t,e){let[n,s,...r]=t.split(" "),i=r.join(" ");const a=e.direction.indexOf("column")>-1?"column":"row",o=Ud(a)?"max-width":"max-height",l=Ud(a)?"min-width":"min-height",u=String(i).indexOf("calc")>-1,c=u||"auto"===i,h=String(i).indexOf("%")>-1&&!u,d=String(i).indexOf("px")>-1||String(i).indexOf("rem")>-1||String(i).indexOf("em")>-1||String(i).indexOf("vw")>-1||String(i).indexOf("vh")>-1;let p=u||d;n="0"==n?0:n,s="0"==s?0:s;const f=!n&&!s;let m={};const g={"max-width":null,"max-height":null,"min-width":null,"min-height":null};switch(i||""){case"":const t=!1!==this.layoutConfig.useColumnBasisZero;i="row"===a?"0%":t?"0.000000001px":"auto";break;case"initial":case"nogrow":n=0,i="auto";break;case"grow":i="100%";break;case"noshrink":s=0,i="auto";break;case"auto":break;case"none":n=0,s=0,i="auto";break;default:p||h||isNaN(i)||(i+="%"),"0%"===i&&(p=!0),"0px"===i&&(i="0%"),m=Zd(g,u?{"flex-grow":n,"flex-shrink":s,"flex-basis":p?i:"100%"}:{flex:`${n} ${s} ${p?i:"100%"}`})}return m.flex||m["flex-grow"]||(m=Zd(g,u?{"flex-grow":n,"flex-shrink":s,"flex-basis":i}:{flex:`${n} ${s} ${i}`})),"0%"!==i&&"0px"!==i&&"0.000000001px"!==i&&"auto"!==i&&(m[l]=f||p&&n?i:null,m[o]=f||!c&&s?i:null),m[l]||m[o]?e.hasWrap&&(m[u?"flex-basis":"flex"]=m[o]?u?m[o]:`${n} ${s} ${m[o]}`:u?m[l]:`${n} ${s} ${m[l]}`):m=Zd(g,u?{"flex-grow":n,"flex-shrink":s,"flex-basis":i}:{flex:`${n} ${s} ${i}`}),Zd(m,{"box-sizing":"border-box"})}}return t.\u0275fac=function(e){return new(e||t)($s(td))},t.\u0275prov=Bt({factory:function(){return new t($s(td))},token:t,providedIn:"root"}),t})();const tp=["fxFlex","fxFlex.xs","fxFlex.sm","fxFlex.md","fxFlex.lg","fxFlex.xl","fxFlex.lt-sm","fxFlex.lt-md","fxFlex.lt-lg","fxFlex.lt-xl","fxFlex.gt-xs","fxFlex.gt-sm","fxFlex.gt-md","fxFlex.gt-lg"];let ep=(()=>{class t extends ad{constructor(t,e,n,s,r){super(t,s,e,r),this.layoutConfig=n,this.marshal=r,this.DIRECTIVE_KEY="flex",this.direction=void 0,this.wrap=void 0,this.flexGrow="1",this.flexShrink="1",this.init()}get shrink(){return this.flexShrink}set shrink(t){this.flexShrink=t||"1",this.triggerReflow()}get grow(){return this.flexGrow}set grow(t){this.flexGrow=t||"1",this.triggerReflow()}ngOnInit(){this.parentElement&&(this.marshal.trackValue(this.parentElement,"layout").pipe(Oh(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)),this.marshal.trackValue(this.nativeElement,"layout-align").pipe(Oh(this.destroySubject)).subscribe(this.triggerReflow.bind(this)))}onLayoutChange(t){const e=t.value.split(" ");this.direction=e[0],this.wrap=void 0!==e[1]&&"wrap"===e[1],this.triggerUpdate()}updateWithValue(t){void 0===this.direction&&(this.direction=this.getFlexFlowDirection(this.parentElement,!1!==this.layoutConfig.addFlexToParent)),void 0===this.wrap&&(this.wrap=this.hasWrap(this.parentElement));const e=this.direction,n=e.startsWith("row"),s=this.wrap;n&&s?this.styleCache=ap:n&&!s?this.styleCache=rp:!n&&s?this.styleCache=op:n||s||(this.styleCache=ip);const r=Td(String(t).replace(";",""),this.flexGrow,this.flexShrink);this.addStyles(r.join(" "),{direction:e,hasWrap:s})}triggerReflow(){const t=this.activatedValue;if(void 0!==t){const e=Td(t+"",this.flexGrow,this.flexShrink);this.marshal.updateElement(this.nativeElement,this.DIRECTIVE_KEY,e.join(" "))}}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Nd),Pa(td),Pa(Jd),Pa(Rd))},t.\u0275dir=Se({type:t,inputs:{shrink:["fxShrink","shrink"],grow:["fxGrow","grow"]},features:[Ia]}),t})(),np=(()=>{class t extends ep{constructor(){super(...arguments),this.inputs=tp}}return t.\u0275fac=function(e){return sp(e||t)},t.\u0275dir=Se({type:t,selectors:[["","fxFlex",""],["","fxFlex.xs",""],["","fxFlex.sm",""],["","fxFlex.md",""],["","fxFlex.lg",""],["","fxFlex.xl",""],["","fxFlex.lt-sm",""],["","fxFlex.lt-md",""],["","fxFlex.lt-lg",""],["","fxFlex.lt-xl",""],["","fxFlex.gt-xs",""],["","fxFlex.gt-sm",""],["","fxFlex.gt-md",""],["","fxFlex.gt-lg",""]],inputs:{fxFlex:"fxFlex","fxFlex.xs":"fxFlex.xs","fxFlex.sm":"fxFlex.sm","fxFlex.md":"fxFlex.md","fxFlex.lg":"fxFlex.lg","fxFlex.xl":"fxFlex.xl","fxFlex.lt-sm":"fxFlex.lt-sm","fxFlex.lt-md":"fxFlex.lt-md","fxFlex.lt-lg":"fxFlex.lt-lg","fxFlex.lt-xl":"fxFlex.lt-xl","fxFlex.gt-xs":"fxFlex.gt-xs","fxFlex.gt-sm":"fxFlex.gt-sm","fxFlex.gt-md":"fxFlex.gt-md","fxFlex.gt-lg":"fxFlex.gt-lg"},features:[Ia]}),t})();const sp=ds(np),rp=new Map,ip=new Map,ap=new Map,op=new Map;new Map,new Map,new Map,new Map,new Map,new Map,new Map;let lp=(()=>{class t extends Ed{buildStyles(t,e){const n={},[s,r]=t.split(" ");switch(s){case"center":n["justify-content"]="center";break;case"space-around":n["justify-content"]="space-around";break;case"space-between":n["justify-content"]="space-between";break;case"space-evenly":n["justify-content"]="space-evenly";break;case"end":case"flex-end":n["justify-content"]="flex-end";break;case"start":case"flex-start":default:n["justify-content"]="flex-start"}switch(r){case"start":case"flex-start":n["align-items"]=n["align-content"]="flex-start";break;case"center":n["align-items"]=n["align-content"]="center";break;case"end":case"flex-end":n["align-items"]=n["align-content"]="flex-end";break;case"space-between":n["align-content"]="space-between",n["align-items"]="stretch";break;case"space-around":n["align-content"]="space-around",n["align-items"]="stretch";break;case"baseline":n["align-content"]="stretch",n["align-items"]="baseline";break;case"stretch":default:n["align-items"]=n["align-content"]="stretch"}return Zd(n,{display:e.inline?"inline-flex":"flex","flex-direction":e.layout,"box-sizing":"border-box","max-width":"stretch"===r?Ud(e.layout)?null:"100%":null,"max-height":"stretch"===r&&Ud(e.layout)?"100%":null})}}return t.\u0275fac=function(e){return up(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const up=ds(lp),cp=["fxLayoutAlign","fxLayoutAlign.xs","fxLayoutAlign.sm","fxLayoutAlign.md","fxLayoutAlign.lg","fxLayoutAlign.xl","fxLayoutAlign.lt-sm","fxLayoutAlign.lt-md","fxLayoutAlign.lt-lg","fxLayoutAlign.lt-xl","fxLayoutAlign.gt-xs","fxLayoutAlign.gt-sm","fxLayoutAlign.gt-md","fxLayoutAlign.gt-lg"];let hp=(()=>{class t extends ad{constructor(t,e,n,s){super(t,n,e,s),this.DIRECTIVE_KEY="layout-align",this.layout="row",this.inline=!1,this.init(),this.marshal.trackValue(this.nativeElement,"layout").pipe(Oh(this.destroySubject)).subscribe(this.onLayoutChange.bind(this))}updateWithValue(t){const e=this.layout||"row",n=this.inline;"row"===e&&n?this.styleCache=bp:"row"!==e||n?"row-reverse"===e&&n?this.styleCache=vp:"row-reverse"!==e||n?"column"===e&&n?this.styleCache=xp:"column"!==e||n?"column-reverse"===e&&n?this.styleCache=wp:"column-reverse"!==e||n||(this.styleCache=yp):this.styleCache=mp:this.styleCache=gp:this.styleCache=fp,this.addStyles(t,{layout:e,inline:n})}onLayoutChange(t){const e=t.value.split(" ");this.layout=e[0],this.inline=t.value.includes("inline"),Vd.find(t=>t===this.layout)||(this.layout="row"),this.triggerUpdate()}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Nd),Pa(lp),Pa(Rd))},t.\u0275dir=Se({type:t,features:[Ia]}),t})(),dp=(()=>{class t extends hp{constructor(){super(...arguments),this.inputs=cp}}return t.\u0275fac=function(e){return pp(e||t)},t.\u0275dir=Se({type:t,selectors:[["","fxLayoutAlign",""],["","fxLayoutAlign.xs",""],["","fxLayoutAlign.sm",""],["","fxLayoutAlign.md",""],["","fxLayoutAlign.lg",""],["","fxLayoutAlign.xl",""],["","fxLayoutAlign.lt-sm",""],["","fxLayoutAlign.lt-md",""],["","fxLayoutAlign.lt-lg",""],["","fxLayoutAlign.lt-xl",""],["","fxLayoutAlign.gt-xs",""],["","fxLayoutAlign.gt-sm",""],["","fxLayoutAlign.gt-md",""],["","fxLayoutAlign.gt-lg",""]],inputs:{fxLayoutAlign:"fxLayoutAlign","fxLayoutAlign.xs":"fxLayoutAlign.xs","fxLayoutAlign.sm":"fxLayoutAlign.sm","fxLayoutAlign.md":"fxLayoutAlign.md","fxLayoutAlign.lg":"fxLayoutAlign.lg","fxLayoutAlign.xl":"fxLayoutAlign.xl","fxLayoutAlign.lt-sm":"fxLayoutAlign.lt-sm","fxLayoutAlign.lt-md":"fxLayoutAlign.lt-md","fxLayoutAlign.lt-lg":"fxLayoutAlign.lt-lg","fxLayoutAlign.lt-xl":"fxLayoutAlign.lt-xl","fxLayoutAlign.gt-xs":"fxLayoutAlign.gt-xs","fxLayoutAlign.gt-sm":"fxLayoutAlign.gt-sm","fxLayoutAlign.gt-md":"fxLayoutAlign.gt-md","fxLayoutAlign.gt-lg":"fxLayoutAlign.gt-lg"},features:[Ia]}),t})();const pp=ds(dp),fp=new Map,mp=new Map,gp=new Map,yp=new Map,bp=new Map,xp=new Map,vp=new Map,wp=new Map;let _p=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Qh,Bd]]}),t})();new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map;let kp=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Qh]]}),t})();new el("11.0.0-beta.33");let Sp=(()=>{class t{constructor(t,e){Bc(e)&&!t&&console.warn("Warning: Flex Layout loaded on the server without FlexLayoutServerModule")}static withConfig(e,n=[]){return{ngModule:t,providers:e.serverLoaded?[{provide:td,useValue:Object.assign(Object.assign({},Jh),e)},{provide:nd,useValue:n,multi:!0},{provide:ed,useValue:!0}]:[{provide:td,useValue:Object.assign(Object.assign({},Jh),e)},{provide:nd,useValue:n,multi:!0}]}}}return t.\u0275fac=function(e){return new(e||t)($s(ed),$s(xu))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[_p,Md,kp],_p,Md,kp]}),t})();class Cp{}function Ip(t,e){return{type:7,name:t,definitions:e,options:{}}}function Np(t,e=null){return{type:4,styles:e,timings:t}}function Ep(t,e=null){return{type:2,steps:t,options:e}}function Tp(t){return{type:6,styles:t,offset:null}}function Ap(t,e,n){return{type:0,name:t,styles:e,options:n}}function Rp(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function $p(t){Promise.resolve(null).then(t)}class Fp{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){$p(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Dp{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,s=0;const r=this.players.length;0==r?$p(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==r&&this._onFinish()}),t.onDestroy(()=>{++n==r&&this._onDestroy()}),t.onStart(()=>{++s==r&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){const t=this.players.reduce((t,e)=>null===t||e.totalTime>t.totalTime?e:t,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function Op(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function Lp(t){switch(t.length){case 0:return new Fp;case 1:return t[0];default:return new Dp(t)}}function Mp(t,e,n,s,r={},i={}){const a=[],o=[];let l=-1,u=null;if(s.forEach(t=>{const n=t.offset,s=n==l,c=s&&u||{};Object.keys(t).forEach(n=>{let s=n,o=t[n];if("offset"!==n)switch(s=e.normalizePropertyName(s,a),o){case"!":o=r[n];break;case"*":o=i[n];break;default:o=e.normalizeStyleValue(n,s,o,a)}c[s]=o}),s||o.push(c),u=c,l=n}),a.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${a.join(t)}`)}return o}function Pp(t,e,n,s){switch(e){case"start":t.onStart(()=>s(n&&zp(n,"start",t)));break;case"done":t.onDone(()=>s(n&&zp(n,"done",t)));break;case"destroy":t.onDestroy(()=>s(n&&zp(n,"destroy",t)))}}function zp(t,e,n){const s=n.totalTime,r=Bp(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==s?t.totalTime:s,!!n.disabled),i=t._data;return null!=i&&(r._data=i),r}function Bp(t,e,n,s,r="",i=0,a){return{element:t,triggerName:e,fromState:n,toState:s,phaseName:r,totalTime:i,disabled:!!a}}function Vp(t,e,n){let s;return t instanceof Map?(s=t.get(e),s||t.set(e,s=n)):(s=t[e],s||(s=t[e]=n)),s}function Wp(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let Up=(t,e)=>!1,jp=(t,e)=>!1,Hp=(t,e,n)=>[];const Gp=Op();(Gp||"undefined"!=typeof Element)&&(Up=(t,e)=>t.contains(e),jp=(()=>{if(Gp||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):jp}})(),Hp=(t,e,n)=>{let s=[];if(n){const n=t.querySelectorAll(e);for(let t=0;t<n.length;t++)s.push(n[t])}else{const n=t.querySelector(e);n&&s.push(n)}return s});let qp=null,Kp=!1;function Xp(t){qp||(qp=("undefined"!=typeof document?document.body:null)||{},Kp=!!qp.style&&"WebkitAppearance"in qp.style);let e=!0;return qp.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in qp.style,!e&&Kp)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in qp.style),e}const Qp=jp,Yp=Up,Zp=Hp;function Jp(t){const e={};return Object.keys(t).forEach(n=>{const s=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[s]=t[n]}),e}let tf=(()=>{class t{validateStyleProperty(t){return Xp(t)}matchesElement(t,e){return Qp(t,e)}containsElement(t,e){return Yp(t,e)}query(t,e,n){return Zp(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,s,r,i=[],a){return new Fp(n,s)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),ef=(()=>{class t{}return t.NOOP=new tf,t})();function nf(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:sf(parseFloat(e[1]),e[2])}function sf(t,e){switch(e){case"s":return 1e3*t;default:return t}}function rf(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let s,r=0,i="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};s=sf(parseFloat(n[1]),n[2]);const a=n[3];null!=a&&(r=sf(parseFloat(a),n[4]));const o=n[5];o&&(i=o)}else s=t;if(!n){let n=!1,i=e.length;s<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),r<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(i,0,`The provided timing value "${t}" is invalid.`)}return{duration:s,delay:r,easing:i}}(t,e,n)}function af(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function of(t,e,n={}){if(e)for(let s in t)n[s]=t[s];else af(t,n);return n}function lf(t,e,n){return n?e+":"+n+";":""}function uf(t){let e="";for(let n=0;n<t.style.length;n++){const s=t.style.item(n);e+=lf(0,s,t.style.getPropertyValue(s))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=lf(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function cf(t,e,n){t.style&&(Object.keys(e).forEach(s=>{const r=bf(s);n&&!n.hasOwnProperty(s)&&(n[s]=t.style[r]),t.style[r]=e[s]}),Op()&&uf(t))}function hf(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=bf(e);t.style[n]=""}),Op()&&uf(t))}function df(t){return Array.isArray(t)?1==t.length?t[0]:Ep(t):t}const pf=new RegExp("{{\\s*(.+?)\\s*}}","g");function ff(t){let e=[];if("string"==typeof t){let n;for(;n=pf.exec(t);)e.push(n[1]);pf.lastIndex=0}return e}function mf(t,e,n){const s=t.toString(),r=s.replace(pf,(t,s)=>{let r=e[s];return e.hasOwnProperty(s)||(n.push(`Please provide a value for the animation param ${s}`),r=""),r.toString()});return r==s?t:r}function gf(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const yf=/-+([a-z0-9])/g;function bf(t){return t.replace(yf,(...t)=>t[1].toUpperCase())}function xf(t,e){return 0===t||0===e}function vf(t,e,n){const s=Object.keys(n);if(s.length&&e.length){let i=e[0],a=[];if(s.forEach(t=>{i.hasOwnProperty(t)||a.push(t),i[t]=n[t]}),a.length)for(var r=1;r<e.length;r++){let n=e[r];a.forEach(function(e){n[e]=_f(t,e)})}}return e}function wf(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error(`Unable to resolve animation metadata node #${e.type}`)}}function _f(t,e){return window.getComputedStyle(t)[e]}function kf(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const s=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof s)return void e.push(s);t=s}const s=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==s||s.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const r=s[1],i=s[2],a=s[3];e.push(If(r,a)),"<"!=i[0]||"*"==r&&"*"==a||e.push(If(a,r))}(t,n,e)):n.push(t),n}const Sf=new Set(["true","1"]),Cf=new Set(["false","0"]);function If(t,e){const n=Sf.has(t)||Cf.has(t),s=Sf.has(e)||Cf.has(e);return(r,i)=>{let a="*"==t||t==r,o="*"==e||e==i;return!a&&n&&"boolean"==typeof r&&(a=r?Sf.has(t):Cf.has(t)),!o&&s&&"boolean"==typeof i&&(o=i?Sf.has(e):Cf.has(e)),a&&o}}const Nf=new RegExp("s*:selfs*,?","g");function Ef(t,e,n){return new Tf(t).build(e,n)}class Tf{constructor(t){this._driver=t}build(t,e){const n=new Af(e);return this._resetContextStyleTimingState(n),wf(this,df(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,s=e.depCount=0;const r=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,s=n.name;s.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,r.push(this.visitState(n,e))}),n.name=s}else if(1==t.type){const r=this.visitTransition(t,e);n+=r.queryCount,s+=r.depCount,i.push(r)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:r,transitions:i,queryCount:n,depCount:s,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(n.containsDynamicStyles){const r=new Set,i=s||{};if(n.styles.forEach(t=>{if(Rf(t)){const e=t;Object.keys(e).forEach(t=>{ff(e[t]).forEach(t=>{i.hasOwnProperty(t)||r.add(t)})})}}),r.size){const n=gf(r.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=wf(this,df(t.animation),e);return{type:1,matchers:kf(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:$f(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>wf(this,t,e)),options:$f(t.options)}}visitGroup(t,e){const n=e.currentTime;let s=0;const r=t.steps.map(t=>{e.currentTime=n;const r=wf(this,t,e);return s=Math.max(s,e.currentTime),r});return e.currentTime=s,{type:3,steps:r,options:$f(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return Ff(rf(t,e).duration,0,"");const s=t;if(s.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=Ff(0,0,"");return t.dynamic=!0,t.strValue=s,t}return n=n||rf(s,e),Ff(n.duration,n.delay,n.easing)}(t.timings,e.errors);let s;e.currentAnimateTimings=n;let r=t.styles?t.styles:Tp({});if(5==r.type)s=this.visitKeyframes(r,e);else{let r=t.styles,i=!1;if(!r){i=!0;const t={};n.easing&&(t.easing=n.easing),r=Tp(t)}e.currentTime+=n.duration+n.delay;const a=this.visitStyle(r,e);a.isEmptyStep=i,s=a}return e.currentAnimateTimings=null,{type:4,timings:n,style:s,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?"*"==t?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let s=!1,r=null;return n.forEach(t=>{if(Rf(t)){const e=t,n=e.easing;if(n&&(r=n,delete e.easing),!s)for(let t in e)if(e[t].toString().indexOf("{{")>=0){s=!0;break}}}),{type:6,styles:n,easing:r,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let s=e.currentTime,r=e.currentTime;n&&r>0&&(r-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const i=e.collectedStyles[e.currentQuerySelector],a=i[n];let o=!0;a&&(r!=s&&r>=a.startTime&&s<=a.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${a.startTime}ms" and "${a.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${s}ms"`),o=!1),r=a.startTime),o&&(i[n]={startTime:r,endTime:s}),e.options&&function(t,e,n){const s=e.params||{},r=ff(t);r.length&&r.forEach(t=>{s.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let s=0;const r=[];let i=!1,a=!1,o=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(Rf(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(Rf(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),u=0;return null!=l&&(s++,u=n.offset=l),a=a||u<0||u>1,i=i||u<o,o=u,r.push(u),n});a&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),i&&e.errors.push("Please ensure that all keyframe offsets are in order");const u=t.steps.length;let c=0;s>0&&s<u?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==s&&(c=1/(u-1));const h=u-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,s)=>{const i=c>0?s==h?1:c*s:r[s],a=i*f;e.currentTime=d+p.delay+a,p.duration=a,this._validateStyleAst(t,e),t.offset=i,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:wf(this,df(t.animation),e),options:$f(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:$f(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:$f(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[r,i]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(Nf,"")),[t=t.replace(/@\*/g,".ng-trigger").replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,".ng-animating"),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+r:r,Vp(e.collectedStyles,e.currentQuerySelector,{});const a=wf(this,df(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:r,limit:s.limit||0,optional:!!s.optional,includeSelf:i,animation:a,originalSelector:t.selector,options:$f(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:rf(t.timings,e.errors,!0);return{type:12,animation:wf(this,df(t.animation),e),timings:n,options:null}}}class Af{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function Rf(t){return!Array.isArray(t)&&"object"==typeof t}function $f(t){var e;return t?(t=af(t)).params&&(t.params=(e=t.params)?af(e):null):t={},t}function Ff(t,e,n){return{duration:t,delay:e,easing:n}}function Df(t,e,n,s,r,i,a=null,o=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:s,duration:r,delay:i,totalTime:r+i,easing:a,subTimeline:o}}class Of{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const Lf=new RegExp(":enter","g"),Mf=new RegExp(":leave","g");function Pf(t,e,n,s,r,i={},a={},o,l,u=[]){return(new zf).buildKeyframes(t,e,n,s,r,i,a,o,l,u)}class zf{buildKeyframes(t,e,n,s,r,i,a,o,l,u=[]){l=l||new Of;const c=new Vf(t,e,l,s,r,u,[]);c.options=o,c.currentTimeline.setStyles([i],null,c.errors,o),wf(this,n,c);const h=c.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(a).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([a],null,c.errors,o)}return h.length?h.map(t=>t.buildKeyframes()):[Df(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const s=e.createSubContext(t.options),r=e.currentTimeline.currentTime,i=this._visitSubInstructions(n,s,s.options);r!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let s=e.currentTimeline.currentTime;const r=null!=n.duration?nf(n.duration):null,i=null!=n.delay?nf(n.delay):null;return 0!==r&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,r,i);s=Math.max(s,n.duration+n.delay)}),s}visitReference(t,e){e.updateOptions(t.options,!0),wf(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let s=e;const r=t.options;if(r&&(r.params||r.delay)&&(s=e.createSubContext(r),s.transformIntoNewTimeline(),null!=r.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=Bf);const t=nf(r.delay);s.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>wf(this,t,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>n&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let s=e.currentTimeline.currentTime;const r=t.options&&t.options.delay?nf(t.options.delay):0;t.steps.forEach(i=>{const a=e.createSubContext(t.options);r&&a.delayNextStep(r),wf(this,i,a),s=Math.max(s,a.currentTimeline.currentTime),n.push(a.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return rf(e.params?mf(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),s.snapshotCurrentStyles());const r=t.style;5==r.type?this.visitKeyframes(r,e):(e.incrementTime(n.duration),this.visitStyle(r,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,s=e.currentAnimateTimings;!s&&n.getCurrentStyleProperties().length&&n.forwardFrame();const r=s&&s.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(r):n.setStyles(t.styles,r,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,s=e.currentTimeline.duration,r=n.duration,i=e.createSubContext().currentTimeline;i.easing=n.easing,t.styles.forEach(t=>{i.forwardTime((t.offset||0)*r),i.setStyles(t.styles,t.easing,e.errors,e.options),i.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(i),e.transformIntoNewTimeline(s+r),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,s=t.options||{},r=s.delay?nf(s.delay):0;r&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=Bf);let i=n;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let o=null;a.forEach((n,s)=>{e.currentQueryIndex=s;const a=e.createSubContext(t.options,n);r&&a.delayNextStep(r),n===e.element&&(o=a.currentTimeline),wf(this,t.animation,a),a.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,a.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),o&&(e.currentTimeline.mergeTimelineCollectedStyles(o),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,s=e.currentTimeline,r=t.timings,i=Math.abs(r.duration),a=i*(e.currentQueryTotal-1);let o=i*e.currentQueryIndex;switch(r.duration<0?"reverse":r.easing){case"reverse":o=a-o;break;case"full":o=n.currentStaggerTime}const l=e.currentTimeline;o&&l.delayNextStep(o);const u=l.currentTime;wf(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=s.currentTime-u+(s.startTime-n.currentTimeline.startTime)}}const Bf={};class Vf{constructor(t,e,n,s,r,i,a,o){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=s,this._leaveClassName=r,this.errors=i,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=Bf,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=o||new Wf(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let s=this.options;null!=n.duration&&(s.duration=nf(n.duration)),null!=n.delay&&(s.delay=nf(n.delay));const r=n.params;if(r){let t=s.params;t||(t=this.options.params={}),Object.keys(r).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=mf(r[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const s=e||this.element,r=new Vf(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,n||0));return r.previousNode=this.previousNode,r.currentAnimateTimings=this.currentAnimateTimings,r.options=this._copyOptions(),r.updateOptions(t),r.currentQueryIndex=this.currentQueryIndex,r.currentQueryTotal=this.currentQueryTotal,r.parentContext=this,this.subContextCount++,r}transformIntoNewTimeline(t){return this.previousNode=Bf,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},r=new Uf(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(r),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,s,r,i){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(Lf,"."+this._enterClassName)).replace(Mf,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),a.push(...e)}return r||0!=a.length||i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),a}}class Wf{constructor(t,e,n,s){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Wf(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||"*",this._currentKeyframe[t]="*"}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,s){e&&(this._previousKeyframe.easing=e);const r=s&&s.params||{},i=function(t,e){const n={};let s;return t.forEach(t=>{"*"===t?(s=s||Object.keys(e),s.forEach(t=>{n[t]="*"})):of(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(i).forEach(t=>{const e=mf(i[t],r,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:"*"),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],s=t._styleSummary[e];(!n||s.time>n.time)&&this._updateStyle(e,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((r,i)=>{const a=of(r,!0);Object.keys(a).forEach(n=>{const s=a[n];"!"==s?t.add(n):"*"==s&&e.add(n)}),n||(a.offset=i/this.duration),s.push(a)});const r=t.size?gf(t.values()):[],i=e.size?gf(e.values()):[];if(n){const t=s[0],e=af(t);t.offset=0,e.offset=1,s=[t,e]}return Df(this.element,s,r,i,this.duration,this.startTime,this.easing,!1)}}class Uf extends Wf{constructor(t,e,n,s,r,i,a=!1){super(t,e,i.delay),this.element=e,this.keyframes=n,this.preStyleProps=s,this.postStyleProps=r,this._stretchStartingKeyframe=a,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const r=[],i=n+e,a=e/i,o=of(t[0],!1);o.offset=0,r.push(o);const l=of(t[0],!1);l.offset=jf(a),r.push(l);const u=t.length-1;for(let s=1;s<=u;s++){let a=of(t[s],!1);a.offset=jf((e+a.offset*n)/i),r.push(a)}n=i,e=0,s="",t=r}return Df(this.element,t,this.preStyleProps,this.postStyleProps,n,e,s,!0)}}function jf(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class Hf{}class Gf extends Hf{normalizePropertyName(t,e){return bf(t)}normalizeStyleValue(t,e,n,s){let r="";const i=n.toString().trim();if(qf[e]&&0!==n&&"0"!==n)if("number"==typeof n)r="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&s.push(`Please provide a CSS unit value for ${t}:${n}`)}return i+r}}const qf=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function Kf(t,e,n,s,r,i,a,o,l,u,c,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:r,fromState:n,fromStyles:i,toState:s,toStyles:a,timelines:o,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:h,errors:d}}const Xf={};class Qf{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,s){return function(t,e,n,s,r){return t.some(t=>t(e,n,s,r))}(this.ast.matchers,t,e,n,s)}buildStyles(t,e,n){const s=this._stateStyles["*"],r=this._stateStyles[t],i=s?s.buildStyles(e,n):{};return r?r.buildStyles(e,n):i}build(t,e,n,s,r,i,a,o,l,u){const c=[],h=this.ast.options&&this.ast.options.params||Xf,d=this.buildStyles(n,a&&a.params||Xf,c),p=o&&o.params||Xf,f=this.buildStyles(s,p,c),m=new Set,g=new Map,y=new Map,b="void"===s,x={params:Object.assign(Object.assign({},h),p)},v=u?[]:Pf(t,e,this.ast.animation,r,i,d,f,x,l,c);let w=0;if(v.forEach(t=>{w=Math.max(t.duration+t.delay,w)}),c.length)return Kf(e,this._triggerName,n,s,b,d,f,[],[],g,y,w,c);v.forEach(t=>{const n=t.element,s=Vp(g,n,{});t.preStyleProps.forEach(t=>s[t]=!0);const r=Vp(y,n,{});t.postStyleProps.forEach(t=>r[t]=!0),n!==e&&m.add(n)});const _=gf(m.values());return Kf(e,this._triggerName,n,s,b,d,f,v,_,g,y,w)}}class Yf{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},s=af(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(s[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const r=t;Object.keys(r).forEach(t=>{let i=r[t];i.length>1&&(i=mf(i,s,e)),n[t]=i})}}),n}}class Zf{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new Yf(t.style,t.options&&t.options.params||{})}),Jf(this.states,"true","1"),Jf(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new Qf(t,e,this.states))}),this.fallbackTransition=new Qf(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,s){return this.transitionFactories.find(r=>r.match(t,e,n,s))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function Jf(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const tm=new Of;class em{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],s=Ef(this._driver,e,n);if(n.length)throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);this._animations[t]=s}_buildPlayer(t,e,n){const s=t.element,r=Mp(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(s,r,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const s=[],r=this._animations[t];let i;const a=new Map;if(r?(i=Pf(this._driver,e,r,"ng-enter","ng-leave",{},{},n,tm,s),i.forEach(t=>{const e=Vp(a,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(s.push("The requested animation doesn't exist or has already been destroyed"),i=[]),s.length)throw new Error(`Unable to create the animation due to the following errors: ${s.join("\n")}`);a.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,"*")})});const o=Lp(i.map(t=>{const e=a.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=o,o.onDestroy(()=>this.destroy(t)),this.players.push(o),o}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,n,s){const r=Bp(e,"","","");return Pp(this._getPlayer(t),n,r,s),()=>{}}command(t,e,n,s){if("register"==n)return void this.register(t,s[0]);if("create"==n)return void this.create(t,e,s[0]||{});const r=this._getPlayer(t);switch(n){case"play":r.play();break;case"pause":r.pause();break;case"reset":r.reset();break;case"restart":r.restart();break;case"finish":r.finish();break;case"init":r.init();break;case"setPosition":r.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const nm=[],sm={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},rm={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class im{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(s=n?t.value:t)?s:null,n){const e=af(t);delete e.value,this.options=e}else this.options={};var s;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const am=new im("void");class om{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,fm(e,this._hostClassName)}listen(t,e,n,s){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(r=n)&&"done"!=r)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var r;const i=Vp(this._elementListeners,t,[]),a={name:e,phase:n,callback:s};i.push(a);const o=Vp(this._engine.statesByElement,t,{});return o.hasOwnProperty(e)||(fm(t,"ng-trigger"),fm(t,"ng-trigger-"+e),o[e]=am),()=>{this._engine.afterFlush(()=>{const t=i.indexOf(a);t>=0&&i.splice(t,1),this._triggers[e]||delete o[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,s=!0){const r=this._getTrigger(e),i=new um(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(fm(t,"ng-trigger"),fm(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,a={}));let o=a[e];const l=new im(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&o&&l.absorbOptions(o.options),a[e]=l,o||(o=am),"void"!==l.value&&o.value===l.value){if(!function(t,e){const n=Object.keys(t),s=Object.keys(e);if(n.length!=s.length)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(!e.hasOwnProperty(s)||t[s]!==e[s])return!1}return!0}(o.params,l.params)){const e=[],n=r.matchStyles(o.value,o.params,e),s=r.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{hf(t,n),cf(t,s)})}return}const u=Vp(this._engine.playersByElement,t,[]);u.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let c=r.matchTransition(o.value,l.value,t,l.params),h=!1;if(!c){if(!s)return;c=r.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:c,fromState:o,toState:l,player:i,isFallbackTransition:h}),h||(fm(t,"ng-animate-queued"),i.onStart(()=>{mm(t,"ng-animate-queued")})),i.onDone(()=>{let e=this.players.indexOf(i);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(i);t>=0&&n.splice(t,1)}}),this.players.push(i),u.push(i),i}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,".ng-trigger",!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,s){const r=this._engine.statesByElement.get(t);if(r){const i=[];if(Object.keys(r).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,"void",s);n&&i.push(n)}}),i.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&Lp(i).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),n=this._engine.statesByElement.get(t);if(e&&n){const s=new Set;e.forEach(e=>{const r=e.name;if(s.has(r))return;s.add(r);const i=this._triggers[r].fallbackTransition,a=n[r]||am,o=new im("void"),l=new um(this.id,r,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:r,transition:i,fromState:a,toState:o,player:l,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)s=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)n.markElementAsRemoved(this.id,t,!1,e);else{const s=t.__ng_removed;s&&s!==sm||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){fm(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const s=n.player;if(s.destroyed)return;const r=n.element,i=this._elementListeners.get(r);i&&i.forEach(e=>{if(e.name==n.triggerName){const s=Bp(r,n.triggerName,n.fromState.value,n.toState.value);s._data=t,Pp(n.player,e.phase,s,e.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,s=e.transition.ast.depCount;return 0==n||0==s?n-s:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class lm{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new om(t,e,this);return e.parentNode?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let s=!1;for(let r=n;r>=0;r--)if(this.driver.containsElement(this._namespaceList[r].hostElement,e)){this._namespaceList.splice(r+1,0,t),s=!0;break}s||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let s=this._namespaceLookup[t];s&&s.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let s=0;s<t.length;s++){const r=n[t[s]].namespaceId;if(r){const t=this._fetchNamespace(r);t&&e.add(t)}}}return e}trigger(t,e,n,s){if(cm(e)){const r=this._fetchNamespace(t);if(r)return r.trigger(e,n,s),!0}return!1}insertNode(t,e,n,s){if(!cm(e))return;const r=e.__ng_removed;if(r&&r.setForRemoval){r.setForRemoval=!1,r.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const s=this._fetchNamespace(t);s&&s.insertNode(e,n)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),fm(t,"ng-animate-disabled")):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),mm(t,"ng-animate-disabled"))}removeNode(t,e,n,s){if(cm(e)){const r=t?this._fetchNamespace(t):null;if(r?r.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,n,s){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:s,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,s,r){return cm(e)?this._fetchNamespace(t).listen(e,n,s,r):()=>{}}_buildInstruction(t,e,n,s,r){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,s,t.fromState.options,t.toState.options,e,r)}destroyInnerAnimations(t){let e=this.driver.query(t,".ng-trigger",!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,".ng-animating",!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Lp(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=sm,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,".ng-animate-disabled")&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)fm(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?Lp(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)}_flushAnimations(t,e){const n=new Of,s=[],r=new Map,i=[],a=new Map,o=new Map,l=new Map,u=new Set;this.disabledNodes.forEach(t=>{u.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)u.add(e[n])});const c=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=pm(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n="ng-enter"+f++;p.set(e,n),t.forEach(t=>fm(t,n))});const m=[],g=new Set,y=new Set;for(let A=0;A<this.collectedLeaveElements.length;A++){const t=this.collectedLeaveElements[A],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const b=new Map,x=pm(h,Array.from(g));x.forEach((t,e)=>{const n="ng-leave"+f++;b.set(e,n),t.forEach(t=>fm(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>mm(t,n))}),x.forEach((t,e)=>{const n=b.get(e);t.forEach(t=>mm(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const v=[],w=[];for(let A=this._namespaceList.length-1;A>=0;A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t=>{const e=t.player,r=t.element;if(v.push(e),this.collectedEnterElements.length){const t=r.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const u=!c||!this.driver.containsElement(c,r),h=b.get(r),d=p.get(r),f=this._buildInstruction(t,n,d,h,u);if(f.errors&&f.errors.length)w.push(f);else{if(u)return e.onStart(()=>hf(r,f.fromStyles)),e.onDestroy(()=>cf(r,f.toStyles)),void s.push(e);if(t.isFallbackTransition)return e.onStart(()=>hf(r,f.fromStyles)),e.onDestroy(()=>cf(r,f.toStyles)),void s.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(r,f.timelines),i.push({instruction:f,player:e,element:r}),f.queriedElements.forEach(t=>Vp(a,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=o.get(e);t||o.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let s=l.get(e);s||l.set(e,s=new Set),n.forEach(t=>s.add(t))})}});if(w.length){const t=[];w.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),v.forEach(t=>t.destroy()),this.reportError(t)}const _=new Map,k=new Map;i.forEach(t=>{const e=t.element;n.has(e)&&(k.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,_))}),s.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{Vp(_,e,[]).push(t),t.destroy()})});const S=m.filter(t=>bm(t,o,l)),C=new Map;dm(C,this.driver,y,l,"*").forEach(t=>{bm(t,o,l)&&S.push(t)});const I=new Map;d.forEach((t,e)=>{dm(I,this.driver,new Set(t),o,"!")}),S.forEach(t=>{const e=C.get(t),n=I.get(t);C.set(t,Object.assign(Object.assign({},e),n))});const N=[],E=[],T={};i.forEach(t=>{const{element:e,player:i,instruction:a}=t;if(n.has(e)){if(u.has(e))return i.onDestroy(()=>cf(e,a.toStyles)),i.disabled=!0,i.overrideTotalTime(a.totalTime),void s.push(i);let t=T;if(k.size>1){let n=e;const s=[];for(;n=n.parentNode;){const e=k.get(n);if(e){t=e;break}s.push(n)}s.forEach(e=>k.set(e,t))}const n=this._buildAnimation(i.namespaceId,a,_,r,I,C);if(i.setRealPlayer(n),t===T)N.push(i);else{const e=this.playersByElement.get(t);e&&e.length&&(i.parentPlayer=Lp(e)),s.push(i)}}else hf(e,a.fromStyles),i.onDestroy(()=>cf(e,a.toStyles)),E.push(i),u.has(e)&&s.push(i)}),E.forEach(t=>{const e=r.get(t.element);if(e&&e.length){const n=Lp(e);t.setRealPlayer(n)}}),s.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let A=0;A<m.length;A++){const t=m[A],e=t.__ng_removed;if(mm(t,"ng-leave"),e&&e.hasAnimation)continue;let n=[];if(a.size){let e=a.get(t);e&&e.length&&n.push(...e);let s=this.driver.query(t,".ng-animating",!0);for(let t=0;t<s.length;t++){let e=a.get(s[t]);e&&e.length&&n.push(...e)}}const s=n.filter(t=>!t.destroyed);s.length?gm(this,t,s):this.processLeaveNode(t)}return m.length=0,N.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),N}elementContainsData(t,e){let n=!1;const s=e.__ng_removed;return s&&s.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,s,r){let i=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(i=e)}else{const e=this.playersByElement.get(t);if(e){const t=!r||"void"==r;e.forEach(e=>{e.queued||(t||e.triggerName==s)&&i.push(e)})}}return(n||s)&&(i=i.filter(t=>!(n&&n!=t.namespaceId||s&&s!=t.triggerName))),i}_beforeAnimationBuild(t,e,n){const s=e.element,r=e.isRemovalTransition?void 0:t,i=e.isRemovalTransition?void 0:e.triggerName;for(const a of e.timelines){const t=a.element,o=t!==s,l=Vp(n,t,[]);this._getPreviousPlayers(t,o,r,i,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}hf(s,e.fromStyles)}_buildAnimation(t,e,n,s,r,i){const a=e.triggerName,o=e.element,l=[],u=new Set,c=new Set,h=e.timelines.map(e=>{const h=e.element;u.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new Fp(e.duration,e.delay);const p=h!==o,f=function(t){const e=[];return ym(t,e),e}((n.get(h)||nm).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=r.get(h),g=i.get(h),y=Mp(0,this._normalizer,0,e.keyframes,m,g),b=this._buildPlayer(e,y,f);if(e.subTimeline&&s&&c.add(h),p){const e=new um(t,a,h);e.setRealPlayer(b),l.push(e)}return b});l.forEach(t=>{Vp(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let s;if(t instanceof Map){if(s=t.get(e),s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&t.delete(e)}}else if(s=t[e],s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&delete t[e]}return s}(this.playersByQueriedElement,t.element,t))}),u.forEach(t=>fm(t,"ng-animating"));const d=Lp(h);return d.onDestroy(()=>{u.forEach(t=>mm(t,"ng-animating")),cf(o,e.toStyles)}),c.forEach(t=>{Vp(s,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new Fp(t.duration,t.delay)}}class um{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new Fp,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>Pp(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Vp(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function cm(t){return t&&1===t.nodeType}function hm(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function dm(t,e,n,s,r){const i=[];n.forEach(t=>i.push(hm(t)));const a=[];s.forEach((n,s)=>{const i={};n.forEach(t=>{const n=i[t]=e.computeStyle(s,t,r);n&&0!=n.length||(s.__ng_removed=rm,a.push(s))}),t.set(s,i)});let o=0;return n.forEach(t=>hm(t,i[o++])),a}function pm(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const s=new Set(e),r=new Map;function i(t){if(!t)return 1;let e=r.get(t);if(e)return e;const a=t.parentNode;return e=n.has(a)?a:s.has(a)?1:i(a),r.set(t,e),e}return e.forEach(t=>{const e=i(t);1!==e&&n.get(e).push(t)}),n}function fm(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function mm(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function gm(t,e,n){Lp(n).onDone(()=>t.processLeaveNode(e))}function ym(t,e){for(let n=0;n<t.length;n++){const s=t[n];s instanceof Dp?ym(s.players,e):e.push(s)}}function bm(t,e,n){const s=n.get(t);if(!s)return!1;let r=e.get(t);return r?s.forEach(t=>r.add(t)):e.set(t,s),n.delete(t),!0}class xm{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new lm(t,e,n),this._timelineEngine=new em(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,s,r){const i=t+"-"+s;let a=this._triggerCache[i];if(!a){const t=[],e=Ef(this._driver,r,t);if(t.length)throw new Error(`The animation trigger "${s}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);a=function(t,e){return new Zf(t,e)}(s,e),this._triggerCache[i]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,s){this._transitionEngine.insertNode(t,e,n,s)}onRemove(t,e,n,s){this._transitionEngine.removeNode(t,e,s||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,s){if("@"==n.charAt(0)){const[t,r]=Wp(n);this._timelineEngine.command(t,e,r,s)}else this._transitionEngine.trigger(t,e,n,s)}listen(t,e,n,s,r){if("@"==n.charAt(0)){const[t,s]=Wp(n);return this._timelineEngine.listen(t,e,s,r)}return this._transitionEngine.listen(t,e,n,s,r)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function vm(t,e){let n=null,s=null;return Array.isArray(e)&&e.length?(n=_m(e[0]),e.length>1&&(s=_m(e[e.length-1]))):e&&(n=_m(e)),n||s?new wm(t,n,s):null}let wm=(()=>{class t{constructor(e,n,s){this._element=e,this._startStyles=n,this._endStyles=s,this._state=0;let r=t.initialStylesByElement.get(e);r||t.initialStylesByElement.set(e,r={}),this._initialStyles=r}start(){this._state<1&&(this._startStyles&&cf(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(cf(this._element,this._initialStyles),this._endStyles&&(cf(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(hf(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(hf(this._element,this._endStyles),this._endStyles=null),cf(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function _m(t){let e=null;const n=Object.keys(t);for(let s=0;s<n.length;s++){const r=n[s];km(r)&&(e=e||{},e[r]=t[r])}return e}function km(t){return"display"===t||"position"===t}class Sm{constructor(t,e,n,s,r,i,a){this._element=t,this._name=e,this._duration=n,this._delay=s,this._easing=r,this._fillMode=i,this._onDoneFn=a,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=Am(t,"").trim();n.length&&(function(t,e){let n=0;for(let s=0;s<t.length;s++)","===t.charAt(s)&&n++}(n),e=`${n}, ${e}`),Tm(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),Em(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){Cm(this._element,this._name,"paused")}resume(){Cm(this._element,this._name,"running")}setPosition(t){const e=Im(this._element,this._name);this._position=t*this._duration,Tm(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),Em(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=Am(t,"").split(","),s=Nm(n,e);s>=0&&(n.splice(s,1),Tm(t,"",n.join(",")))}(this._element,this._name))}}function Cm(t,e,n){Tm(t,"PlayState",n,Im(t,e))}function Im(t,e){const n=Am(t,"");return n.indexOf(",")>0?Nm(n.split(","),e):Nm([n],e)}function Nm(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function Em(t,e,n){n?t.removeEventListener("animationend",e):t.addEventListener("animationend",e)}function Tm(t,e,n,s){const r="animation"+e;if(null!=s){const e=t.style[r];if(e.length){const t=e.split(",");t[s]=n,n=t.join(",")}}t.style[r]=n}function Am(t,e){return t.style["animation"+e]||""}class Rm{constructor(t,e,n,s,r,i,a,o){this.element=t,this.keyframes=e,this.animationName=n,this._duration=s,this._delay=r,this._finalStyles=a,this._specialStyles=o,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this.currentSnapshot={},this._state=0,this.easing=i||"linear",this.totalTime=s+r,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new Sm(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:_f(this.element,n))})}this.currentSnapshot=t}}class $m extends Fp{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=Jp(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class Fm{constructor(){this._count=0,this._head=document.querySelector("head")}validateStyleProperty(t){return Xp(t)}matchesElement(t,e){return Qp(t,e)}containsElement(t,e){return Yp(t,e)}query(t,e,n){return Zp(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>Jp(t));let s=`@keyframes ${e} {\n`,r="";n.forEach(t=>{r=" ";const e=parseFloat(t.offset);s+=`${r}${100*e}% {\n`,r+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(s+=`${r}animation-timing-function: ${n};\n`));default:return void(s+=`${r}${e}: ${n};\n`)}}),s+=`${r}}\n`}),s+="}\n";const i=document.createElement("style");return i.textContent=s,i}animate(t,e,n,s,r,i=[],a){const o=i.filter(t=>t instanceof Rm),l={};xf(n,s)&&o.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=vf(t,e,l));if(0==n)return new $m(t,u);const c="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,c,e);document.querySelector("head").appendChild(h);const d=vm(t,e),p=new Rm(t,e,c,n,s,r,u,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}}class Dm{constructor(t,e,n,s){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:_f(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Om{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(Lm().toString()),this._cssKeyframesDriver=new Fm}validateStyleProperty(t){return Xp(t)}matchesElement(t,e){return Qp(t,e)}containsElement(t,e){return Yp(t,e)}query(t,e,n){return Zp(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,s,r,i=[],a){if(!a&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,s,r,i);const o={duration:n,delay:s,fill:0==s?"both":"forwards"};r&&(o.easing=r);const l={},u=i.filter(t=>t instanceof Dm);xf(n,s)&&u.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=vm(t,e=vf(t,e=e.map(t=>of(t,!1)),l));return new Dm(t,e,o,c)}}function Lm(){return"undefined"!=typeof window&&void 0!==window.document&&Element.prototype.animate||{}}let Mm=(()=>{class t extends Cp{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:ee.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?Ep(t):t;return Bm(this._renderer,null,e,"register",[n]),new Pm(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)($s(Yo),$s(pc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Pm extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new zm(this._id,t,e||{},this._renderer)}}class zm{constructor(t,e,n,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return Bm(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset")}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function Bm(t,e,n,s,r){return t.setProperty(e,`@@${n}:${s}`,r)}let Vm=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new Wm("",n,this.engine),this._rendererCache.set(n,t)),t}const s=e.id,r=e.id+"-"+this._currentId;this._currentId++,this.engine.register(r,t);const i=e=>{Array.isArray(e)?e.forEach(i):this.engine.registerTrigger(s,r,t,e.name,e)};return e.data.animation.forEach(i),new Um(this,r,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)($s(Yo),$s(xm),$s(Du))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Wm{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n,s=!0){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,s){this.delegate.setAttribute(t,e,n,s)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,s){this.delegate.setStyle(t,e,n,s)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){"@"==e.charAt(0)&&"@.disabled"==e?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class Um extends Wm{constructor(t,e,n,s){super(e,n,s),this.factory=t,this.namespaceId=e}setProperty(t,e,n){"@"==e.charAt(0)?"."==e.charAt(1)&&"@.disabled"==e?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if("@"==e.charAt(0)){const s=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let r=e.substr(1),i="";return"@"!=r.charAt(0)&&([r,i]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(r)),this.engine.listen(this.namespaceId,s,r,i,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let jm=(()=>{class t extends xm{constructor(t,e,n){super(t.body,e,n)}}return t.\u0275fac=function(e){return new(e||t)($s(pc),$s(ef),$s(Hf))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const Hm=new ms("AnimationModuleType"),Gm=[{provide:ef,useFactory:function(){return"function"==typeof Lm()?new Om:new Fm}},{provide:Hm,useValue:"BrowserAnimations"},{provide:Cp,useClass:Mm},{provide:Hf,useFactory:function(){return new Gf}},{provide:xm,useClass:jm},{provide:Yo,useFactory:function(t,e,n){return new Vm(t,e,n)},deps:[ih,xm,Du]}];let qm=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:Gm,imports:[xh]}),t})();function Km(t,e,n,s){return new(n||(n=Promise))(function(r,i){function a(t){try{l(s.next(t))}catch(e){i(e)}}function o(t){try{l(s.throw(t))}catch(e){i(e)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n(function(t){t(e)})).then(a,o)}l((s=s.apply(t,e||[])).next())})}function Xm(t,e){if(1&t){const t=ja();Va(0,"ngx-dropzone-remove-badge",1),Ga("click",function(e){return rn(t),Ya()._remove(e)}),Wa()}}const Qm=[[["ngx-dropzone-label"]]],Ym=["ngx-dropzone-label"],Zm=["fileInput"];function Jm(t,e){1&t&&to(0,2,["*ngIf","!_hasPreviews"])}const tg=[[["ngx-dropzone-preview"]],"*",[["ngx-dropzone-label"]]],eg=["ngx-dropzone-preview","*","ngx-dropzone-label"];let ng=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Se({type:t,selectors:[["ngx-dropzone-label"]]}),t})();function sg(t){return null!=t&&"false"!=`${t}`}var rg=function(t){return t[t.BACKSPACE=8]="BACKSPACE",t[t.DELETE=46]="DELETE",t}({});let ig,ag=(()=>{class t{constructor(t){this.sanitizer=t,this._removable=!1,this.removed=new Kl,this.tabIndex=0}set file(t){this._file=t}get file(){return this._file}get removable(){return this._removable}set removable(t){this._removable=sg(t)}keyEvent(t){switch(t.keyCode){case rg.BACKSPACE:case rg.DELETE:this.remove()}}get hostStyle(){return this.sanitizer.bypassSecurityTrustStyle("\n\t\t\tdisplay: flex;\n\t\t\theight: 140px;\n\t\t\tmin-height: 140px;\n\t\t\tmin-width: 180px;\n\t\t\tmax-width: 180px;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t\tpadding: 0 20px;\n\t\t\tmargin: 10px;\n\t\t\tborder-radius: 5px;\n\t\t\tposition: relative;\n\t\t")}_remove(t){t.stopPropagation(),this.remove()}remove(){this._removable&&this.removed.next(this.file)}readFile(){return Km(this,void 0,void 0,function*(){return new Promise((t,e)=>{const n=new FileReader;if(n.onload=e=>{t(e.target.result)},n.onerror=t=>{console.error(`FileReader failed on file ${this.file.name}.`),e(t)},!this.file)return e("No file to read. Please provide a file using the [file] Input property.");n.readAsDataURL(this.file)})})}}return t.\u0275fac=function(e){return new(e||t)(Pa(mh))},t.\u0275cmp=be({type:t,selectors:[["ngx-dropzone-preview"]],hostVars:3,hostBindings:function(t,e){1&t&&Ga("keyup",function(t){return e.keyEvent(t)}),2&t&&(Io("tabindex",e.tabIndex),function(t,e,n,s){const r=sn(),i=fn(2);r.firstUpdatePass&&fo(r,null,i,!1);const a=nn();if(n!==hi&&Oa(a,i,n)){const s=r.data[En()];if(wo(s,!1)&&!po(r,i)){let t=s.stylesWithoutHost;null!==t&&(n=Rt(t,n||"")),Ba(r,s,a,n,!1)}else!function(t,e,n,s,r,i,a,o){r===hi&&(r=le);let l=0,u=0,c=0<r.length?r[0]:null,h=0<i.length?i[0]:null;for(;null!==c||null!==h;){const a=l<r.length?r[l+1]:void 0,d=u<i.length?i[u+1]:void 0;let p,f=null;c===h?(l+=2,u+=2,a!==d&&(f=h,p=d)):null===h||null!==c&&c<h?(l+=2,f=c):(u+=2,f=h,p=d),null!==f&&bo(t,e,n,s,f,p,!1,o),c=l<r.length?r[l]:null,h=u<i.length?i[u]:null}}(r,s,a,a[11],a[i+1],a[i+1]=function(t,e,n){if(null==n||""===n)return le;const s=[],r=qs(n);if(Array.isArray(r))for(let i=0;i<r.length;i++)t(s,r[i],!0);else if("object"==typeof r)for(const i in r)r.hasOwnProperty(i)&&t(s,i,r[i]);else"string"==typeof r&&e(s,r);return s}(t,e,n),0,i)}}(yo,ho,e.hostStyle))},inputs:{file:"file",removable:"removable"},outputs:{removed:"removed"},ngContentSelectors:Ym,decls:2,vars:1,consts:[[3,"click",4,"ngIf"],[3,"click"]],template:function(t,e){1&t&&(Ja(Qm),to(0),Ma(1,Xm,1,0,"ngx-dropzone-remove-badge",0)),2&t&&(di(1),za("ngIf",e.removable))},directives:function(){return[Dc,ug]},styles:["[_nghost-%COMP%]{background-image:linear-gradient(0deg,#ededed,#efefef,#f1f1f1,#f4f4f4,#f6f6f6)}[_nghost-%COMP%]:focus, [_nghost-%COMP%]:hover{background-image:linear-gradient(0deg,#e3e3e3,#ebeaea,#e8e7e7,#ebeaea,#f4f4f4);outline:0}[_nghost-%COMP%]:focus   ngx-dropzone-remove-badge[_ngcontent-%COMP%], [_nghost-%COMP%]:hover   ngx-dropzone-remove-badge[_ngcontent-%COMP%]{opacity:1}[_nghost-%COMP%]   ngx-dropzone-remove-badge[_ngcontent-%COMP%]{opacity:0}[_nghost-%COMP%]     ngx-dropzone-label{overflow-wrap:break-word}"]}),t})(),og=(()=>{class t{parseFileList(t,e,n,s){const r=[],i=[];for(let a=0;a<t.length;a++){const o=t.item(a);this.isAccepted(o,e)?n&&o.size>n?this.rejectFile(i,o,"size"):!s&&r.length>=1?this.rejectFile(i,o,"no_multiple"):r.push(o):this.rejectFile(i,o,"type")}return{addedFiles:r,rejectedFiles:i}}isAccepted(t,e){if("*"===e)return!0;const n=e.split(",").map(t=>t.toLowerCase().trim()),s=t.type.toLowerCase(),r=t.name.toLowerCase();return!!n.find(t=>t.endsWith("/*")?s.split("/")[0]===t.split("/")[0]:t.startsWith(".")?r.endsWith(t):t==s)}rejectFile(t,e,n){const s=e;s.reason=n,t.push(s)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),lg=(()=>{class t{constructor(t){this.service=t,this.change=new Kl,this.accept="*",this._disabled=!1,this._multiple=!0,this._maxFileSize=void 0,this._expandable=!1,this._disableClick=!1,this._isHovered=!1}get _hasPreviews(){return!!this._previewChildren.length}get disabled(){return this._disabled}set disabled(t){this._disabled=sg(t),this._isHovered&&(this._isHovered=!1)}get multiple(){return this._multiple}set multiple(t){this._multiple=sg(t)}get maxFileSize(){return this._maxFileSize}set maxFileSize(t){this._maxFileSize=function(t){return isNaN(parseFloat(t))||isNaN(Number(t))?null:Number(t)}(t)}get expandable(){return this._expandable}set expandable(t){this._expandable=sg(t)}get disableClick(){return this._disableClick}set disableClick(t){this._disableClick=sg(t)}_onClick(){this.disableClick||this.showFileSelector()}_onDragOver(t){this.disabled||(this.preventDefault(t),this._isHovered=!0)}_onDragLeave(){this._isHovered=!1}_onDrop(t){this.disabled||(this.preventDefault(t),this._isHovered=!1,this.handleFileDrop(t.dataTransfer.files))}showFileSelector(){this.disabled||this._fileInput.nativeElement.click()}_onFilesSelected(t){this.handleFileDrop(t.target.files),this._fileInput.nativeElement.value="",this.preventDefault(t)}handleFileDrop(t){const e=this.service.parseFileList(t,this.accept,this.maxFileSize,this.multiple);this.change.next({addedFiles:e.addedFiles,rejectedFiles:e.rejectedFiles,source:this})}preventDefault(t){t.preventDefault(),t.stopPropagation()}}return t.\u0275fac=function(e){return new(e||t)(Pa(og,2))},t.\u0275cmp=be({type:t,selectors:[["ngx-dropzone"],["","ngx-dropzone",""]],contentQueries:function(t,e,n){if(1&t&&lu(n,ag,1),2&t){let t;au(t=uu())&&(e._previewChildren=t)}},viewQuery:function(t,e){if(1&t&&ou(Zm,3),2&t){let t;au(t=uu())&&(e._fileInput=t.first)}},hostVars:8,hostBindings:function(t,e){1&t&&Ga("click",function(){return e._onClick()})("dragover",function(t){return e._onDragOver(t)})("dragleave",function(){return e._onDragLeave()})("drop",function(t){return e._onDrop(t)}),2&t&&co("ngx-dz-hovered",e._isHovered)("ngx-dz-disabled",e.disabled)("expandable",e.expandable)("unclickable",e.disableClick)},inputs:{accept:"accept",disabled:"disabled",multiple:"multiple",maxFileSize:"maxFileSize",expandable:"expandable",disableClick:"disableClick",id:"id",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],ariaDescribedBy:["aria-describedby","ariaDescribedBy"]},outputs:{change:"change"},features:[Wo([og])],ngContentSelectors:eg,decls:5,vars:8,consts:[["type","file",3,"id","multiple","accept","disabled","change"],["fileInput",""],[4,"ngIf"]],template:function(t,e){1&t&&(Ja(tg),Va(0,"input",0,1),Ga("change",function(t){return e._onFilesSelected(t)}),Wa(),Ma(2,Jm,1,0,"ng-content",2),to(3),to(4,1)),2&t&&(za("id",e.id)("multiple",e.multiple)("accept",e.accept)("disabled",e.disabled),La("aria-label",e.ariaLabel)("aria-labelledby",e.ariaLabelledby)("aria-describedby",e.ariaDescribedBy),di(2),za("ngIf",!e._hasPreviews))},directives:[Dc],styles:["[_nghost-%COMP%]{align-items:center;background:#fff;border:2px dashed #717386;border-radius:5px;color:#717386;cursor:pointer;display:flex;font-size:16px;height:180px;overflow-x:auto}.ngx-dz-hovered[_nghost-%COMP%]{border-style:solid}.ngx-dz-disabled[_nghost-%COMP%]{cursor:no-drop;opacity:.5;pointer-events:none}.expandable[_nghost-%COMP%]{flex-wrap:wrap;height:unset;min-height:180px;overflow:hidden}.unclickable[_nghost-%COMP%]{cursor:default}[_nghost-%COMP%]     ngx-dropzone-label{margin:10px auto;text-align:center;z-index:10}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{height:.1px;opacity:0;overflow:hidden;position:absolute;width:.1px;z-index:-1}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus +   ngx-dropzone-label{outline:1px dotted #000;outline:5px auto -webkit-focus-ring-color}"]}),t})(),ug=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["ngx-dropzone-remove-badge"]],decls:3,vars:0,consts:[["x1","0","y1","0","x2","10","y2","10"],["x1","0","y1","10","x2","10","y2","0"]],template:function(t,e){1&t&&(Rn(),Va(0,"svg"),Ua(1,"line",0),Ua(2,"line",1),Wa())},styles:["[_nghost-%COMP%]{align-items:center;background:#bbb;border-radius:50%;color:#333;cursor:pointer;display:flex;height:22px;justify-content:center;position:absolute;right:5px;top:5px;width:22px}[_nghost-%COMP%]:hover{background:#aeaeae}[_nghost-%COMP%] > svg[_ngcontent-%COMP%]{height:10px;width:10px}[_nghost-%COMP%] > svg[_ngcontent-%COMP%] > line[_ngcontent-%COMP%]{stroke:#fff;stroke-width:2px}"]}),t})(),cg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Pc]]}),t})();try{ig="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(hY){ig=!1}let hg,dg,pg,fg=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?zc(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!ig)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)($s(xu))},t.\u0275prov=Bt({factory:function(){return new t($s(xu))},token:t,providedIn:"root"}),t})(),mg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();function gg(t){return function(){if(null==hg&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>hg=!0}))}finally{hg=hg||!1}return hg}()?t:!!t.capture}function yg(){if(null==dg){if("object"!=typeof document||!document)return dg=!1,dg;if("scrollBehavior"in document.documentElement.style)dg=!0;else{const t=Element.prototype.scrollTo;dg=!!t&&!/\{\s*\[native code\]\s*\}/.test(t.toString())}}return dg}let bg=(()=>{class t{create(t){return"undefined"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),xg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[bg]}),t})(),vg=(()=>{class t{constructor(t){this._platform=t}isDisabled(t){return t.hasAttribute("disabled")}isVisible(t){return function(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(t)&&"visible"===getComputedStyle(t).visibility}isTabbable(t){if(!this._platform.isBrowser)return!1;const e=function(t){try{return t.frameElement}catch(hY){return null}}((n=t).ownerDocument&&n.ownerDocument.defaultView||window);var n;if(e){if(-1===_g(e))return!1;if(!this.isVisible(e))return!1}let s=t.nodeName.toLowerCase(),r=_g(t);return t.hasAttribute("contenteditable")?-1!==r:"iframe"!==s&&"object"!==s&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(t){let e=t.nodeName.toLowerCase(),n="input"===e&&t.type;return"text"===n||"password"===n||"select"===e||"textarea"===e}(t))&&("audio"===s?!!t.hasAttribute("controls")&&-1!==r:"video"===s?-1!==r&&(null!==r||this._platform.FIREFOX||t.hasAttribute("controls")):t.tabIndex>=0)}isFocusable(t,e){return function(t){return!function(t){return function(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function(t){return function(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||wg(t))}(t)&&!this.isDisabled(t)&&((null==e?void 0:e.ignoreVisibility)||this.isVisible(t))}}return t.\u0275fac=function(e){return new(e||t)($s(fg))},t.\u0275prov=Bt({factory:function(){return new t($s(fg))},token:t,providedIn:"root"}),t})();function wg(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return"-32768"!=e&&!(!e||isNaN(parseInt(e,10)))}function _g(t){if(!wg(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class kg{constructor(t,e,n,s,r=!1){this._element=t,this._checker=e,this._ngZone=n,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,r||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.parentNode&&t.parentNode.removeChild(t)),e&&(e.removeEventListener("focus",this.endAnchorListener),e.parentNode&&e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusInitialElement()))})}focusFirstTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusFirstTabbableElement()))})}focusLastTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusLastTabbableElement()))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let n=0;n<e.length;n++)e[n].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]):e[n].hasAttribute(`cdk-focus-region-${t}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(){const t=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(t){if(t.hasAttribute("cdk-focus-initial")&&console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",t),!this._checker.isFocusable(t)){const e=this._getFirstTabbableElement(t);return null==e||e.focus(),!!e}return t.focus(),!0}return this.focusFirstTabbableElement()}focusFirstTabbableElement(){const t=this._getRegionBoundary("start");return t&&t.focus(),!!t}focusLastTabbableElement(){const t=this._getRegionBoundary("end");return t&&t.focus(),!!t}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=0;n<e.length;n++){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[n]):null;if(t)return t}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=e.length-1;n>=0;n--){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[n]):null;if(t)return t}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Vh(1)).subscribe(t)}}let Sg=(()=>{class t{constructor(t,e,n){this._checker=t,this._ngZone=e,this._document=n}create(t,e=!1){return new kg(t,this._checker,this._ngZone,this._document,e)}}return t.\u0275fac=function(e){return new(e||t)($s(vg),$s(Du),$s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(vg),$s(Du),$s(pc))},token:t,providedIn:"root"}),t})();function Cg(t){return 0===t.buttons}function Ig(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}"undefined"!=typeof Element&&Element;const Ng=new ms("cdk-focus-monitor-default-options"),Eg=gg({passive:!0,capture:!0});let Tg=(()=>{class t{constructor(t,e,n,s){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=Cg(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{Ig(t)?this._lastTouchTarget||this._setOriginForCurrentEventQueue("keyboard"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=Ag(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=Ag(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let s=e;s;s=s.parentElement)n.call(this,t,s)},this._document=n,this._detectionMode=(null==s?void 0:s.detectionMode)||0}monitor(t,e=!1){const n=Ld(t);if(!this._platform.isBrowser||1!==n.nodeType)return Ch(null);const s=function(t){if(function(){if(null==pg){const t="undefined"!=typeof document?document.head:null;pg=!(!t||!t.createShadowRoot&&!t.attachShadow)}return pg}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}(n)||this._getDocument(),r=this._elementInfo.get(n);if(r)return e&&(r.checkChildren=!0),r.subject;const i={checkChildren:e,subject:new Z,rootNode:s};return this._elementInfo.set(n,i),this._registerGlobalListeners(i),i.subject}stopMonitoring(t){const e=Ld(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const s=Ld(t);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([t,n])=>this._originChanged(t,e,n)):(this._setOriginForCurrentEventQueue(e),"function"==typeof s.focus&&s.focus(n))}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=Ag(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);n&&(n.checkChildren||e===Ag(t))&&this._originChanged(e,this._getFocusOrigin(t),n)}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,Eg),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,Eg)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,Eg),t.addEventListener("mousedown",this._documentMousedownListener,Eg),t.addEventListener("touchstart",this._documentTouchstartListener,Eg),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Eg),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Eg),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,Eg),t.removeEventListener("mousedown",this._documentMousedownListener,Eg),t.removeEventListener("touchstart",this._documentTouchstartListener,Eg),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(t,e,n){this._setClasses(t,e),this._emitOrigin(n.subject,e),this._lastFocusOrigin=e}_getClosestElementsInfo(t){const e=[];return this._elementInfo.forEach((n,s)=>{(s===t||n.checkChildren&&s.contains(t))&&e.push([s,n])}),e}}return t.\u0275fac=function(e){return new(e||t)($s(Du),$s(fg),$s(pc,8),$s(Ng,8))},t.\u0275prov=Bt({factory:function(){return new t($s(Du),$s(fg),$s(pc,8),$s(Ng,8))},token:t,providedIn:"root"}),t})();function Ag(t){return t.composedPath?t.composedPath()[0]:t.target}let Rg=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,s=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),s){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove("cdk-high-contrast-active"),t.remove("cdk-high-contrast-black-on-white"),t.remove("cdk-high-contrast-white-on-black");const e=this.getHighContrastMode();1===e?(t.add("cdk-high-contrast-active"),t.add("cdk-high-contrast-black-on-white")):2===e&&(t.add("cdk-high-contrast-active"),t.add("cdk-high-contrast-white-on-black"))}}}return t.\u0275fac=function(e){return new(e||t)($s(fg),$s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(fg),$s(pc))},token:t,providedIn:"root"}),t})(),$g=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\u0275fac=function(e){return new(e||t)($s(Rg))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[mg,xg]]}),t})();const Fg=new el("11.2.5");function Dg(...t){return bt(1)(Ch(...t))}function Og(...t){const e=t[t.length-1];return tt(e)?(t.pop(),n=>Dg(t,n,e)):e=>Dg(t,e)}const Lg=new el("11.2.5"),Mg=new ms("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let Pg,zg=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const t=this._document.defaultView||window;return"object"==typeof t&&t?t:null}_checksAreEnabled(){return Ku()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||"function"!=typeof getComputedStyle)return;const t=this._document.createElement("div");t.classList.add("mat-theme-loaded-marker"),this._document.body.appendChild(t);const e=getComputedStyle(t);e&&"none"!==e.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),this._document.body.removeChild(t)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&Lg.full!==Fg.full&&console.warn("The Angular Material version ("+Lg.full+") does not match the Angular CDK version ("+Fg.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275fac=function(e){return new(e||t)($s(Rg),$s(Mg,8),$s(pc))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Bd],Bd]}),t})();function Bg(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Fd(t)}}}function Vg(t,e){return class extends t{constructor(...t){super(...t),this.defaultColor=e,this.color=e}get color(){return this._color}set color(t){const e=t||this.defaultColor;e!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),e&&this._elementRef.nativeElement.classList.add(`mat-${e}`),this._color=e)}}}function Wg(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Fd(t)}}}try{Pg="undefined"!=typeof Intl}catch(hY){Pg=!1}let Ug=(()=>{class t{isErrorState(t,e){return!!(t&&t.invalid&&(t.touched||e&&e.submitted))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),jg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg],zg]}),t})();class Hg{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const Gg={enterDuration:450,exitDuration:400},qg=gg({passive:!0}),Kg=["mousedown","touchstart"],Xg=["mouseup","mouseleave","touchend","touchcancel"];class Qg{constructor(t,e,n,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=Ld(n))}fadeInRipple(t,e,n={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),r=Object.assign(Object.assign({},Gg),n.animation);n.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const i=n.radius||function(t,e,n){const s=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),r=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(s*s+r*r)}(t,e,s),a=t-s.left,o=e-s.top,l=r.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-i+"px",u.style.top=o-i+"px",u.style.height=2*i+"px",u.style.width=2*i+"px",null!=n.color&&(u.style.backgroundColor=n.color),u.style.transitionDuration=`${l}ms`,this._containerElement.appendChild(u),window.getComputedStyle(u).getPropertyValue("opacity"),u.style.transform="scale(1)";const c=new Hg(this,u,n);return c.state=0,this._activeRipples.add(c),n.persistent||(this._mostRecentTransientRipple=c),this._runTimeoutOutsideZone(()=>{const t=c===this._mostRecentTransientRipple;c.state=1,n.persistent||t&&this._isPointerDown||c.fadeOut()},l),c}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,s=Object.assign(Object.assign({},Gg),t.config.animation);n.style.transitionDuration=`${s.exitDuration}ms`,n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}setupTriggerEvents(t){const e=Ld(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(Kg))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(Xg),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=Cg(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!Ig(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,qg)})})}_removeTriggerEvents(){this._triggerElement&&(Kg.forEach(t=>{this._triggerElement.removeEventListener(t,this,qg)}),this._pointerUpEventsRegistered&&Xg.forEach(t=>{this._triggerElement.removeEventListener(t,this,qg)}))}}const Yg=new ms("mat-ripple-global-options");let Zg=(()=>{class t{constructor(t,e,n,s,r){this._elementRef=t,this._animationMode=r,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new Qg(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Du),Pa(fg),Pa(Yg,8),Pa(Hm,8))},t.\u0275dir=Se({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&co("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),Jg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg,mg],zg]}),t})(),ty=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg]]}),t})(),ey=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Jg,Pc,zg,ty]]}),t})(),ny=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[$g,zg],zg]}),t})();const sy=["mat-button",""],ry=["*"],iy=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class ay{constructor(t){this._elementRef=t}}const oy=Vg(Bg(Wg(ay)));let ly=(()=>{class t extends oy{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const s of iy)this._hasHostAttributes(s)&&this._getHostElement().classList.add(s);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t,e){t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Tg),Pa(Hm,8))},t.\u0275cmp=be({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){if(1&t&&ou(Zg,1),2&t){let t;au(t=uu())&&(e.ripple=t.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(La("disabled",e.disabled||null),co("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Ia],attrs:sy,ngContentSelectors:ry,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(Ja(),Va(0,"span",0),to(1),Wa(),Ua(2,"span",1),Ua(3,"span",2)),2&t&&(di(2),co("mat-button-ripple-round",e.isRoundButton||e.isIconButton),za("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[Zg],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),t})(),uy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Jg,zg],zg]}),t})();const cy=["*",[["mat-card-footer"]]],hy=["*","mat-card-footer"];let dy=(()=>{class t{constructor(t){this._animationMode=t}}return t.\u0275fac=function(e){return new(e||t)(Pa(Hm,8))},t.\u0275cmp=be({type:t,selectors:[["mat-card"]],hostAttrs:[1,"mat-card","mat-focus-indicator"],hostVars:2,hostBindings:function(t,e){2&t&&co("_mat-animation-noopable","NoopAnimations"===e._animationMode)},exportAs:["matCard"],ngContentSelectors:hy,decls:2,vars:0,template:function(t,e){1&t&&(Ja(cy),to(0),to(1,1))},styles:[".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"],encapsulation:2,changeDetection:0}),t})(),py=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg],zg]}),t})(),fy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),my=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Jg,zg,xg,fy],zg,fy]}),t})();class gy{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new yy(t,this.durationSelector))}}class yy extends pt{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let n;try{const{durationSelector:e}=this;n=e(t)}catch(e){return this.destination.error(e)}const s=ft(n,new dt(this));!s||s.closed?this.clearThrottle():this.add(this.throttled=s)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=void 0,n.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function by(t){return!M(t)&&t-parseFloat(t)+1>=0}function xy(t){const{index:e,period:n,subscriber:s}=t;if(s.next(e),!s.closed){if(-1===n)return s.complete();t.index=e+1,this.schedule(t,n)}}function vy(t,e=Rh){return n=()=>function(t=0,e,n){let s=-1;return by(e)?s=Number(e)<1?1:Number(e):tt(e)&&(n=e),tt(n)||(n=Rh),new q(e=>{const r=by(t)?t:+t-n.now();return n.schedule(xy,r,{index:0,period:s,subscriber:e})})}(t,e),function(t){return t.lift(new gy(n))};var n}let wy=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new Z,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new q(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(vy(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Ch()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(Eh(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,s)=>{this._scrollableContainsElement(s,t)&&e.push(s)}),e}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(t,e){let n=Ld(e),s=t.getElementRef().nativeElement;do{if(n==s)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>Ih(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)($s(Du),$s(fg),$s(pc,8))},t.\u0275prov=Bt({factory:function(){return new t($s(Du),$s(fg),$s(pc,8))},token:t,providedIn:"root"}),t})(),_y=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new Z,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._document,e=this._getWindow(),n=t.documentElement,s=n.getBoundingClientRect();return{top:-s.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-s.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(vy(t)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)($s(fg),$s(Du),$s(pc,8))},t.\u0275prov=Bt({factory:function(){return new t($s(fg),$s(Du),$s(pc,8))},token:t,providedIn:"root"}),t})(),ky=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),Sy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Bd,mg,ky],Bd,ky]}),t})();class Cy{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class Iy extends Cy{constructor(t,e,n,s){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=s}}class Ny extends Cy{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class Ey extends Cy{constructor(t){super(),this.element=t instanceof Xo?t.nativeElement:t}}class Ty{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof Iy?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof Ny?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof Ey?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class Ay extends Ty{constructor(t,e,n,s,r){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=s,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=r}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let Ry=(()=>{class t extends Ty{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new Kl,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),s=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(s.hostView.rootNodes[0]),super.setDisposeFn(()=>s.destroy()),this._attachedPortal=t,this._attachedRef=s,this.attached.emit(s),s}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(Pa(Ho),Pa(Fl),Pa(pc))},t.\u0275dir=Se({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Ia]}),t})(),$y=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();const Fy=yg();class Dy{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=Od(-this._previousScrollPosition.left),t.style.top=Od(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,s=e.scrollBehavior||"",r=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),Fy&&(e.scrollBehavior=n.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),Fy&&(e.scrollBehavior=s,n.scrollBehavior=r)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}class Oy{constructor(t,e,n,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class Ly{enable(){}disable(){}attach(){}}function My(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function Py(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class zy{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();My(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let By=(()=>{class t{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new Ly,this.close=t=>new Oy(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new Dy(this._viewportRuler,this._document),this.reposition=t=>new zy(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=s}}return t.\u0275fac=function(e){return new(e||t)($s(wy),$s(_y),$s(Du),$s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(wy),$s(_y),$s(Du),$s(pc))},token:t,providedIn:"root"}),t})();class Vy{constructor(t){if(this.scrollStrategy=new Ly,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class Wy{constructor(t,e,n,s,r){this.offsetX=n,this.offsetY=s,this.panelClass=r,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class Uy{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let jy=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(pc))},token:t,providedIn:"root"}),t})(),Hy=(()=>{class t extends jy{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)($s(pc))},t.\u0275prov=Bt({factory:function(){return new t($s(pc))},token:t,providedIn:"root"}),t})(),Gy=(()=>{class t extends jy{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays.slice();for(let s=n.length-1;s>-1;s--){const r=n[s];if(!(r._outsidePointerEvents.observers.length<1)&&r.hasAttached()){if(r.overlayElement.contains(e))break;r._outsidePointerEvents.next(t)}}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("click",this._clickListener,!0),this._document.body.addEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=this._document.body.style.cursor,this._document.body.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("click",this._clickListener,!0),this._document.body.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(this._document.body.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)($s(pc),$s(fg))},t.\u0275prov=Bt({factory:function(){return new t($s(pc),$s(fg))},token:t,providedIn:"root"}),t})();const qy=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let Ky=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){if(this._platform.isBrowser||qy){const t=this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]');for(let e=0;e<t.length;e++)t[e].parentNode.removeChild(t[e])}const t=this._document.createElement("div");t.classList.add("cdk-overlay-container"),qy?t.setAttribute("platform","test"):this._platform.isBrowser||t.setAttribute("platform","server"),this._document.body.appendChild(t),this._containerElement=t}}return t.\u0275fac=function(e){return new(e||t)($s(pc),$s(fg))},t.\u0275prov=Bt({factory:function(){return new t($s(pc),$s(fg))},token:t,providedIn:"root"}),t})();class Xy{constructor(t,e,n,s,r,i,a,o,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=s,this._ngZone=r,this._keyboardDispatcher=i,this._document=a,this._location=o,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new Z,this._attachments=new Z,this._detachments=new Z,this._locationChanges=B.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new Z,this._outsidePointerEvents=new Z,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Vh(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=Od(this._config.width),t.height=Od(this._config.height),t.minWidth=Od(this._config.minWidth),t.minHeight=Od(this._config.minHeight),t.maxWidth=Od(this._config.maxWidth),t.maxHeight=Od(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add("cdk-overlay-backdrop-showing")})}):this._backdropElement.classList.add("cdk-overlay-backdrop-showing")}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const s=t.classList;Dd(e).forEach(t=>{t&&(n?s.add(t):s.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(Oh(vt(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const Qy=/([A-Za-z%]+)$/;class Yy{constructor(t,e,n,s,r){this._viewportRuler=e,this._document=n,this._platform=s,this._overlayContainer=r,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Z,this._resizeSubscription=B.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,s=[];let r;for(let i of this._preferredPositions){let a=this._getOriginPoint(t,i),o=this._getOverlayPoint(a,e,i),l=this._getOverlayFit(o,e,n,i);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(i,a);this._canFitWithFlexibleDimensions(l,o,n)?s.push({position:i,origin:a,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(a,i)}):(!r||r.overlayFit.visibleArea<l.visibleArea)&&(r={overlayFit:l,overlayPoint:o,originPoint:a,position:i,overlayRect:e})}if(s.length){let t=null,e=-1;for(const n of s){const s=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);s>e&&(e=s,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(r.position,r.originPoint);this._applyPosition(r.position,r.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Zy(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,s;if("center"==e.originX)n=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,r=this._isRtl()?t.left:t.right;n="start"==e.originX?s:r}return s="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:s}}_getOverlayPoint(t,e,n){let s,r;return s="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,r="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+s,y:t.y+r}}_getOverlayFit(t,e,n,s){const r=tb(e);let{x:i,y:a}=t,o=this._getOffset(s,"x"),l=this._getOffset(s,"y");o&&(i+=o),l&&(a+=l);let u=0-a,c=a+r.height-n.height,h=this._subtractOverflows(r.width,0-i,i+r.width-n.width),d=this._subtractOverflows(r.height,u,c),p=h*d;return{visibleArea:p,isCompletelyWithinViewport:r.width*r.height===p,fitsInViewportVertically:d===r.height,fitsInViewportHorizontally:h==r.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const s=n.bottom-e.y,r=n.right-e.x,i=Jy(this._overlayRef.getConfig().minHeight),a=Jy(this._overlayRef.getConfig().minWidth),o=t.fitsInViewportHorizontally||null!=a&&a<=r;return(t.fitsInViewportVertically||null!=i&&i<=s)&&o}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=tb(e),r=this._viewportRect,i=Math.max(t.x+s.width-r.width,0),a=Math.max(t.y+s.height-r.height,0),o=Math.max(r.top-n.top-t.y,0),l=Math.max(r.left-n.left-t.x,0);let u=0,c=0;return u=s.width<=r.width?l||-i:t.x<this._viewportMargin?r.left-n.left-t.x:0,c=s.height<=r.height?o||-a:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:u,y:c},{x:t.x+u,y:t.y+c}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new Uy(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,s=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let r=0;r<e.length;r++)e[r].style.transformOrigin=`${n} ${s}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,s=this._isRtl();let r,i,a,o,l,u;if("top"===e.overlayY)i=t.y,r=n.height-i+this._viewportMargin;else if("bottom"===e.overlayY)a=n.height-t.y+2*this._viewportMargin,r=n.height-a+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),s=this._lastBoundingBoxSize.height;r=2*e,i=t.y-e,r>s&&!this._isInitialRender&&!this._growAfterOpen&&(i=t.y-s/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)u=n.width-t.x+this._viewportMargin,o=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)l=t.x,o=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),s=this._lastBoundingBoxSize.width;o=2*e,l=t.x-e,o>s&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-s/2)}return{top:i,left:l,bottom:a,right:u,width:o,height:r}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,r=this._overlayRef.getConfig().maxWidth;s.height=Od(n.height),s.top=Od(n.top),s.bottom=Od(n.bottom),s.width=Od(n.width),s.left=Od(n.left),s.right=Od(n.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(s.maxHeight=Od(t)),r&&(s.maxWidth=Od(r))}this._lastBoundingBoxSize=n,Zy(this._boundingBox.style,s)}_resetBoundingBoxStyles(){Zy(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Zy(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},s=this._hasExactPosition(),r=this._hasFlexibleDimensions,i=this._overlayRef.getConfig();if(s){const s=this._viewportRuler.getViewportScrollPosition();Zy(n,this._getExactOverlayY(e,t,s)),Zy(n,this._getExactOverlayX(e,t,s))}else n.position="static";let a="",o=this._getOffset(e,"x"),l=this._getOffset(e,"y");o&&(a+=`translateX(${o}px) `),l&&(a+=`translateY(${l}px)`),n.transform=a.trim(),i.maxHeight&&(s?n.maxHeight=Od(i.maxHeight):r&&(n.maxHeight="")),i.maxWidth&&(s?n.maxWidth=Od(i.maxWidth):r&&(n.maxWidth="")),Zy(this._pane.style,n)}_getExactOverlayY(t,e,n){let s={top:"",bottom:""},r=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(r=this._pushOverlayOnScreen(r,this._overlayRect,n));let i=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return r.y-=i,"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(r.y+this._overlayRect.height)+"px":s.top=Od(r.y),s}_getExactOverlayX(t,e,n){let s,r={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),s=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===s?r.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":r.left=Od(i.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:Py(t,n),isOriginOutsideView:My(t,n),isOverlayClipped:Py(e,n),isOverlayOutsideView:My(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Dd(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Xo)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function Zy(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function Jy(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split(Qy);return n&&"px"!==n?null:parseFloat(e)}return t||null}function tb(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}class eb{constructor(t,e,n,s,r,i,a){this._preferredPositions=[],this._positionStrategy=new Yy(n,s,r,i,a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,s){const r=new Wy(t,e,n,s);return this._preferredPositions.push(r),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}class nb{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add("cdk-global-overlay-wrapper"),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:s,height:r,maxWidth:i,maxHeight:a}=n,o=!("100%"!==s&&"100vw"!==s||i&&"100%"!==i&&"100vw"!==i),l=!("100%"!==r&&"100vh"!==r||a&&"100%"!==a&&"100vh"!==a);t.position=this._cssPosition,t.marginLeft=o?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,o?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove("cdk-global-overlay-wrapper"),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let sb=(()=>{class t{constructor(t,e,n,s){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=s}global(){return new nb}connectedTo(t,e,n){return new eb(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new Yy(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)($s(_y),$s(pc),$s(fg),$s(Ky))},t.\u0275prov=Bt({factory:function(){return new t($s(_y),$s(pc),$s(fg),$s(Ky))},token:t,providedIn:"root"}),t})(),rb=0,ib=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l,u,c){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=s,this._keyboardDispatcher=r,this._injector=i,this._ngZone=a,this._document=o,this._directionality=l,this._location=u,this._outsideClickDispatcher=c}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),s=this._createPortalOutlet(n),r=new Vy(t);return r.direction=r.direction||this._directionality.value,new Xy(s,e,n,r,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+rb++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(ec)),new Ay(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)($s(By),$s(Ky),$s(Ho),$s(sb),$s(Hy),$s(Sa),$s(Du),$s(pc),$s(zd),$s(Ec),$s(Gy))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const ab={provide:new ms("cdk-connected-overlay-scroll-strategy"),deps:[ib],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let ob=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[ib,ab],imports:[[Bd,$y,Sy],Sy]}),t})();function lb(t){return new q(e=>{let n;try{n=t()}catch(s){return void e.error(s)}return(n?ht(n):Bh()).subscribe(e)})}function ub(t,e){}class cb{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus=!0,this.restoreFocus=!0,this.closeOnNavigation=!0}}const hb={dialogContainer:Ip("dialogContainer",[Ap("void, exit",Tp({opacity:0,transform:"scale(0.7)"})),Ap("enter",Tp({transform:"none"})),Rp("* => enter",Np("150ms cubic-bezier(0, 0, 0.2, 1)",Tp({transform:"none",opacity:1}))),Rp("* => void, * => exit",Np("75ms cubic-bezier(0.4, 0.0, 0.2, 1)",Tp({opacity:0})))])};let db=(()=>{class t extends Ty{constructor(t,e,n,s,r,i){super(),this._elementRef=t,this._focusTrapFactory=e,this._changeDetectorRef=n,this._config=r,this._focusMonitor=i,this._animationStateChanged=new Kl,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=t=>(this._portalOutlet.hasAttached(),this._portalOutlet.attachDomPortal(t)),this._ariaLabelledBy=r.ariaLabelledBy||null,this._document=s}_initializeWithAttachedContent(){this._setupFocusTrap(),this._capturePreviouslyFocusedElement(),this._focusDialogContainer()}attachComponentPortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachTemplatePortal(t)}_recaptureFocus(){this._containsFocus()||(!this._config.autoFocus||!this._focusTrap.focusInitialElement())&&this._elementRef.nativeElement.focus()}_trapFocus(){this._config.autoFocus?this._focusTrap.focusInitialElementWhenReady():this._containsFocus()||this._elementRef.nativeElement.focus()}_restoreFocus(){const t=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&t&&"function"==typeof t.focus){const e=this._getActiveElement(),n=this._elementRef.nativeElement;e&&e!==this._document.body&&e!==n&&!n.contains(e)||(this._focusMonitor?(this._focusMonitor.focusVia(t,this._closeInteractionType),this._closeInteractionType=null):t.focus())}this._focusTrap&&this._focusTrap.destroy()}_setupFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)}_capturePreviouslyFocusedElement(){this._document&&(this._elementFocusedBeforeDialogWasOpened=this._getActiveElement())}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const t=this._elementRef.nativeElement,e=this._getActiveElement();return t===e||t.contains(e)}_getActiveElement(){var t;const e=this._document.activeElement;return(null===(t=null==e?void 0:e.shadowRoot)||void 0===t?void 0:t.activeElement)||e}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Sg),Pa(wl),Pa(pc,8),Pa(cb),Pa(Tg))},t.\u0275dir=Se({type:t,viewQuery:function(t,e){if(1&t&&ou(Ry,3),2&t){let t;au(t=uu())&&(e._portalOutlet=t.first)}},features:[Ia]}),t})(),pb=(()=>{class t extends db{constructor(){super(...arguments),this._state="enter"}_onAnimationDone({toState:t,totalTime:e}){"enter"===t?(this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})):"exit"===t&&(this._restoreFocus(),this._animationStateChanged.next({state:"closed",totalTime:e}))}_onAnimationStart({toState:t,totalTime:e}){"enter"===t?this._animationStateChanged.next({state:"opening",totalTime:e}):"exit"!==t&&"void"!==t||this._animationStateChanged.next({state:"closing",totalTime:e})}_startExitAnimation(){this._state="exit",this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(e){return fb(e||t)},t.\u0275cmp=be({type:t,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1","aria-modal","true",1,"mat-dialog-container"],hostVars:6,hostBindings:function(t,e){1&t&&qa("@dialogContainer.start",function(t){return e._onAnimationStart(t)})("@dialogContainer.done",function(t){return e._onAnimationDone(t)}),2&t&&(Io("id",e._id),La("role",e._config.role)("aria-labelledby",e._config.ariaLabel?null:e._ariaLabelledBy)("aria-label",e._config.ariaLabel)("aria-describedby",e._config.ariaDescribedBy||null),No("@dialogContainer",e._state))},features:[Ia],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&Ma(0,ub,0,0,"ng-template",0)},directives:[Ry],styles:[".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"],encapsulation:2,data:{animation:[hb.dialogContainer]}}),t})();const fb=ds(pb);let mb=0;class gb{constructor(t,e,n="mat-dialog-"+mb++){this._overlayRef=t,this._containerInstance=e,this.id=n,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new Z,this._afterClosed=new Z,this._beforeClosed=new Z,this._state=0,e._id=n,e._animationStateChanged.pipe(Eh(t=>"opened"===t.state),Vh(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(Eh(t=>"closed"===t.state),Vh(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(Eh(t=>27===t.keyCode&&!this.disableClose&&!function(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}(t))).subscribe(t=>{t.preventDefault(),yb(this,"keyboard")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():yb(this,"mouse")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(Eh(t=>"closing"===t.state),Vh(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._afterClosed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t="",e=""){return this._overlayRef.updateSize({width:t,height:e}),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function yb(t,e,n){return void 0!==t._containerInstance&&(t._containerInstance._closeInteractionType=e),t.close(n)}const bb=new ms("MatDialogData"),xb=new ms("mat-dialog-default-options"),vb=new ms("mat-dialog-scroll-strategy"),wb={provide:vb,deps:[ib],useFactory:function(t){return()=>t.scrollStrategies.block()}};let _b=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l){this._overlay=t,this._injector=e,this._defaultOptions=n,this._parentDialog=s,this._overlayContainer=r,this._dialogRefConstructor=a,this._dialogContainerType=o,this._dialogDataToken=l,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Z,this._afterOpenedAtThisLevel=new Z,this._ariaHiddenElements=new Map,this.afterAllClosed=lb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Og(void 0))),this._scrollStrategy=i}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const t=this._parentDialog;return t?t._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(t,e){(e=function(t,e){return Object.assign(Object.assign({},e),t)}(e,this._defaultOptions||new cb)).id&&this.getDialogById(e.id);const n=this._createOverlay(e),s=this._attachDialogContainer(n,e),r=this._attachDialogContent(t,s,n,e);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(r),r.afterClosed().subscribe(()=>this._removeOpenDialog(r)),this.afterOpened.next(r),s._initializeWithAttachedContent(),r}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(t){return this.openDialogs.find(e=>e.id===t)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(t){const e=this._getOverlayConfig(t);return this._overlay.create(e)}_getOverlayConfig(t){const e=new Vy({positionStrategy:this._overlay.position().global(),scrollStrategy:t.scrollStrategy||this._scrollStrategy(),panelClass:t.panelClass,hasBackdrop:t.hasBackdrop,direction:t.direction,minWidth:t.minWidth,minHeight:t.minHeight,maxWidth:t.maxWidth,maxHeight:t.maxHeight,disposeOnNavigation:t.closeOnNavigation});return t.backdropClass&&(e.backdropClass=t.backdropClass),e}_attachDialogContainer(t,e){const n=Sa.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:cb,useValue:e}]}),s=new Iy(this._dialogContainerType,e.viewContainerRef,n,e.componentFactoryResolver);return t.attach(s).instance}_attachDialogContent(t,e,n,s){const r=new this._dialogRefConstructor(n,e,s.id);if(t instanceof Il)e.attachTemplatePortal(new Ny(t,null,{$implicit:s.data,dialogRef:r}));else{const n=this._createInjector(s,r,e),i=e.attachComponentPortal(new Iy(t,s.viewContainerRef,n));r.componentInstance=i.instance}return r.updateSize(s.width,s.height).updatePosition(s.position),r}_createInjector(t,e,n){const s=t&&t.viewContainerRef&&t.viewContainerRef.injector,r=[{provide:this._dialogContainerType,useValue:n},{provide:this._dialogDataToken,useValue:t.data},{provide:this._dialogRefConstructor,useValue:e}];return!t.direction||s&&s.get(zd,null)||r.push({provide:zd,useValue:{value:t.direction,change:Ch()}}),Sa.create({parent:s||this._injector,providers:r})}_removeOpenDialog(t){const e=this.openDialogs.indexOf(t);e>-1&&(this.openDialogs.splice(e,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((t,e)=>{t?e.setAttribute("aria-hidden",t):e.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const t=this._overlayContainer.getContainerElement();if(t.parentElement){const e=t.parentElement.children;for(let n=e.length-1;n>-1;n--){let s=e[n];s===t||"SCRIPT"===s.nodeName||"STYLE"===s.nodeName||s.hasAttribute("aria-live")||(this._ariaHiddenElements.set(s,s.getAttribute("aria-hidden")),s.setAttribute("aria-hidden","true"))}}}_closeDialogs(t){let e=t.length;for(;e--;)t[e].close()}}return t.\u0275fac=function(e){return new(e||t)(Pa(ib),Pa(Sa),Pa(void 0),Pa(void 0),Pa(Ky),Pa(void 0),Pa(ys),Pa(ys),Pa(ms))},t.\u0275dir=Se({type:t}),t})(),kb=(()=>{class t extends _b{constructor(t,e,n,s,r,i,a){super(t,e,s,i,a,r,gb,pb,bb)}}return t.\u0275fac=function(e){return new(e||t)($s(ib),$s(Sa),$s(Ec,8),$s(xb,8),$s(vb),$s(t,12),$s(Ky))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Sb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[kb,wb],imports:[[ob,$y,zg],zg]}),t})(),Cb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg],zg]}),t})(),Ib=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Pc,zg,xg],zg]}),t})(),Nb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[jg,zg],jg,zg]}),t})();function Eb(t){return function(e){const n=new Tb(t),s=e.lift(n);return n.caught=s}}class Tb{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Ab(t,this.selector,this.caught))}}class Ab extends pt{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const s=new dt(this);this.add(s);const r=ft(n,s);r!==s&&this.add(r)}}}class Rb{constructor(t){this.callback=t}call(t,e){return e.subscribe(new $b(t,this.callback))}}class $b extends U{constructor(t,e){super(t),this.add(new B(e))}}function Fb(t,e){return mt(t,e,1)}let Db=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg],zg]}),t})(),Ob=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[mg]]}),t})(),Lb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Ug],imports:[[Ob,Ib,zg],Ob,Ib]}),t})();const Mb={provide:new ms("mat-menu-scroll-strategy"),deps:[ib],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let Pb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Mb],imports:[zg]}),t})(),zb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Mb],imports:[[Pc,zg,Jg,ob,Pb],ky,zg,Pb]}),t})();const Bb=["primaryValueBar"];class Vb{constructor(t){this._elementRef=t}}const Wb=Vg(Vb,"primary"),Ub=new ms("mat-progress-bar-location",{providedIn:"root",factory:function(){const t=Fs(pc),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}});let jb=0,Hb=(()=>{class t extends Wb{constructor(t,e,n,s){super(t),this._elementRef=t,this._ngZone=e,this._animationMode=n,this._isNoopAnimation=!1,this._value=0,this._bufferValue=0,this.animationEnd=new Kl,this._animationEndSubscription=B.EMPTY,this.mode="determinate",this.progressbarId="mat-progress-bar-"+jb++;const r=s?s.getPathname().split("#")[0]:"";this._rectangleFillValue=`url('${r}#${this.progressbarId}')`,this._isNoopAnimation="NoopAnimations"===n}get value(){return this._value}set value(t){this._value=Gb(function(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}(t)||0)}get bufferValue(){return this._bufferValue}set bufferValue(t){this._bufferValue=Gb(t||0)}_primaryTransform(){return{transform:`scale3d(${this.value/100}, 1, 1)`}}_bufferTransform(){return"buffer"===this.mode?{transform:`scale3d(${this.bufferValue/100}, 1, 1)`}:null}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{const t=this._primaryValueBar.nativeElement;this._animationEndSubscription=Ih(t,"transitionend").pipe(Eh(e=>e.target===t)).subscribe(()=>{"determinate"!==this.mode&&"buffer"!==this.mode||this._ngZone.run(()=>this.animationEnd.next({value:this.value}))})})}ngOnDestroy(){this._animationEndSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(Du),Pa(Hm,8),Pa(Ub,8))},t.\u0275cmp=be({type:t,selectors:[["mat-progress-bar"]],viewQuery:function(t,e){if(1&t&&ou(Bb,1),2&t){let t;au(t=uu())&&(e._primaryValueBar=t.first)}},hostAttrs:["role","progressbar","aria-valuemin","0","aria-valuemax","100",1,"mat-progress-bar"],hostVars:4,hostBindings:function(t,e){2&t&&(La("aria-valuenow","indeterminate"===e.mode||"query"===e.mode?null:e.value)("mode",e.mode),co("_mat-animation-noopable",e._isNoopAnimation))},inputs:{color:"color",mode:"mode",value:"value",bufferValue:"bufferValue"},outputs:{animationEnd:"animationEnd"},exportAs:["matProgressBar"],features:[Ia],decls:9,vars:4,consts:[["width","100%","height","4","focusable","false",1,"mat-progress-bar-background","mat-progress-bar-element"],["x","4","y","0","width","8","height","4","patternUnits","userSpaceOnUse",3,"id"],["cx","2","cy","2","r","2"],["width","100%","height","100%"],[1,"mat-progress-bar-buffer","mat-progress-bar-element",3,"ngStyle"],[1,"mat-progress-bar-primary","mat-progress-bar-fill","mat-progress-bar-element",3,"ngStyle"],["primaryValueBar",""],[1,"mat-progress-bar-secondary","mat-progress-bar-fill","mat-progress-bar-element"]],template:function(t,e){1&t&&(Rn(),Va(0,"svg",0),Va(1,"defs"),Va(2,"pattern",1),Ua(3,"circle",2),Wa(),Wa(),Ua(4,"rect",3),Wa(),tn.lFrame.currentNamespace=null,Ua(5,"div",4),Ua(6,"div",5,6),Ua(8,"div",7)),2&t&&(di(2),za("id",e.progressbarId),di(2),La("fill",e._rectangleFillValue),di(1),za("ngStyle",e._bufferTransform()),di(1),za("ngStyle",e._primaryTransform()))},directives:[Mc],styles:['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'],encapsulation:2,changeDetection:0}),t})();function Gb(t,e=0,n=100){return Math.max(e,Math.min(n,t))}let qb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Pc,zg],zg]}),t})(),Kb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg,Pc],zg]}),t})();const Xb={provide:new ms("mat-select-scroll-strategy"),deps:[ib],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let Qb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Xb],imports:[[Pc,ob,ey,zg],ky,Ib,ey,zg]}),t})(),Yb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Pc,zg,mg,ky],ky,zg]}),t})(),Zb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),Jb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Zb,Jg,zg,xg],Zb,zg]}),t})();class tx extends U{notifyNext(t,e,n,s,r){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class ex extends U{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function nx(t,e,n,s,r=new ex(t,n,s)){if(!r.closed)return e instanceof q?e.subscribe(r):ut(e)(r)}const sx={};class rx{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new ix(t,this.resultSelector))}}class ix extends tx{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(sx),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++)this.add(nx(this,t[n],void 0,n))}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n){const s=this.values,r=this.toRespond?s[n]===sx?--this.toRespond:this.toRespond:0;s[n]=e,0===r&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}let ax=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[ob,$y,Pc,uy,zg],zg]}),t})(),ox=(()=>{class t{constructor(){this.changes=new Z,this.sortButtonLabel=t=>`Change sorting for ${t}`}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const lx={provide:ox,deps:[[new Ms,new Ps,ox]],useFactory:function(t){return t||new ox}};let ux=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[lx],imports:[[Pc,zg]]}),t})(),cx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Sy]]}),t})(),hx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[cx,zg],zg]}),t})(),dx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Pc,zg,$y,Jg,xg,$g],zg]}),t})();const px=["*",[["mat-toolbar-row"]]],fx=["*","mat-toolbar-row"];class mx{constructor(t){this._elementRef=t}}const gx=Vg(mx);let yx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Se({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),bx=(()=>{class t extends gx{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return t.\u0275fac=function(e){return new(e||t)(Pa(Xo),Pa(fg),Pa(pc))},t.\u0275cmp=be({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){if(1&t&&lu(n,yx,1),2&t){let t;au(t=uu())&&(e._toolbarRows=t)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&co("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[Ia],ngContentSelectors:fx,decls:2,vars:0,template:function(t,e){1&t&&(Ja(px),to(0),to(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),xx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg],zg]}),t})();const vx={provide:new ms("mat-tooltip-scroll-strategy"),deps:[ib],useFactory:function(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}};let wx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[vx],imports:[[$g,Pc,ob,zg],zg,ky]}),t})(),_x=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),kx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Pc,zg,_x,$y]]}),t})();const Sx=[uy,my,ey,Qb,zb,dx,Ib,wx,xx,Db,Kb,Sb,Nb,py,hx,ux,Lb,ax,Jb,Cb,qb,ny,Yb,kx];let Cx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[Sx,uy,my,ey,Qb,zb,dx,Ib,wx,xx,Db,Kb,Sb,Nb,py,hx,ux,Lb,ax,Jb,Cb,qb,ny,Yb,kx]}),t})();const Ix=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})();function Nx(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(s){return s.lift(new Ex(t,e,n))}}class Ex{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new Tx(t,this.accumulator,this.seed,this.hasSeed))}}class Tx extends U{constructor(t,e,n,s){super(t),this.accumulator=e,this._seed=n,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(s){this.destination.error(s)}this.seed=n,this.destination.next(n)}}function Ax(t){return function(e){return 0===t?Bh():e.lift(new Rx(t))}}class Rx{constructor(t){if(this.total=t,this.total<0)throw new Ph}call(t,e){return e.subscribe(new $x(t,this.total))}}class $x extends U{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,s=this.count++;e.length<n?e.push(t):e[s%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,s=this.ring;for(let r=0;r<n;r++){const r=e++%n;t.next(s[r])}}t.complete()}}function Fx(t=Lx){return e=>e.lift(new Dx(t))}class Dx{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new Ox(t,this.errorFactory))}}class Ox extends U{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function Lx(){return new Ix}function Mx(t=null){return e=>e.lift(new Px(t))}class Px{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new zx(t,this.defaultValue))}}class zx extends U{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Bx(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Eh((e,n)=>t(e,n,s)):G,Vh(1),n?Mx(e):Fx(()=>new Ix))}class Vx{constructor(t,e){this.id=t,this.url=e}}class Wx extends Vx{constructor(t,e,n="imperative",s=null){super(t,e),this.navigationTrigger=n,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Ux extends Vx{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class jx extends Vx{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Hx extends Vx{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Gx extends Vx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class qx extends Vx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Kx extends Vx{constructor(t,e,n,s,r){super(t,e),this.urlAfterRedirects=n,this.state=s,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Xx extends Vx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Qx extends Vx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Yx{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Zx{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Jx{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class tv{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ev{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class nv{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class sv{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class rv{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function iv(t){return new rv(t)}function av(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function ov(t,e,n){const s=n.path.split("/");if(s.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||s.length<t.length))return null;const r={};for(let i=0;i<s.length;i++){const e=s[i],n=t[i];if(e.startsWith(":"))r[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,s.length),posParams:r}}function lv(t,e){const n=t?Object.keys(t):void 0,s=e?Object.keys(e):void 0;if(!n||!s||n.length!=s.length)return!1;let r;for(let i=0;i<n.length;i++)if(r=n[i],!uv(t[r],e[r]))return!1;return!0}function uv(t,e){if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;const n=[...t].sort(),s=[...e].sort();return n.every((t,e)=>s[e]===t)}return t===e}function cv(t){return Array.prototype.concat.apply([],t)}function hv(t){return t.length>0?t[t.length-1]:null}function dv(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function pv(t){return(e=t)&&"function"==typeof e.subscribe?t:Ha(t)?ht(Promise.resolve(t)):Ch(t);var e}function fv(t,e,n){return n?function(t,e){return lv(t,e)}(t.queryParams,e.queryParams)&&mv(t.root,e.root):function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>uv(t[n],e[n]))}(t.queryParams,e.queryParams)&&gv(t.root,e.root)}function mv(t,e){if(!wv(t.segments,e.segments))return!1;if(t.numberOfChildren!==e.numberOfChildren)return!1;for(const n in e.children){if(!t.children[n])return!1;if(!mv(t.children[n],e.children[n]))return!1}return!0}function gv(t,e){return yv(t,e,e.segments)}function yv(t,e,n){if(t.segments.length>n.length)return!!wv(t.segments.slice(0,n.length),n)&&!e.hasChildren();if(t.segments.length===n.length){if(!wv(t.segments,n))return!1;for(const n in e.children){if(!t.children[n])return!1;if(!gv(t.children[n],e.children[n]))return!1}return!0}{const s=n.slice(0,t.segments.length),r=n.slice(t.segments.length);return!!wv(t.segments,s)&&!!t.children.primary&&yv(t.children.primary,e,r)}}class bv{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=iv(this.queryParams)),this._queryParamMap}toString(){return Sv.serialize(this)}}class xv{constructor(t,e){this.segments=t,this.children=e,this.parent=null,dv(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Cv(this)}}class vv{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=iv(this.parameters)),this._parameterMap}toString(){return $v(this)}}function wv(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}class _v{}class kv{parse(t){const e=new Mv(t);return new bv(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){var e;return`/${Iv(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${Ev(e)}=${Ev(t)}`).join("&"):`${Ev(e)}=${Ev(n)}`});return e.length?`?${e.join("&")}`:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}`}}const Sv=new kv;function Cv(t){return t.segments.map(t=>$v(t)).join("/")}function Iv(t,e){if(!t.hasChildren())return Cv(t);if(e){const e=t.children.primary?Iv(t.children.primary,!1):"",n=[];return dv(t.children,(t,e)=>{"primary"!==e&&n.push(`${e}:${Iv(t,!1)}`)}),n.length>0?`${e}(${n.join("//")})`:e}{const e=function(t,e){let n=[];return dv(t.children,(t,s)=>{"primary"===s&&(n=n.concat(e(t,s)))}),dv(t.children,(t,s)=>{"primary"!==s&&(n=n.concat(e(t,s)))}),n}(t,(e,n)=>"primary"===n?[Iv(t.children.primary,!1)]:[`${n}:${Iv(e,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children.primary?`${Cv(t)}/${e[0]}`:`${Cv(t)}/(${e.join("//")})`}}function Nv(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Ev(t){return Nv(t).replace(/%3B/gi,";")}function Tv(t){return Nv(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Av(t){return decodeURIComponent(t)}function Rv(t){return Av(t.replace(/\+/g,"%20"))}function $v(t){return`${Tv(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${Tv(t)}=${Tv(e[t])}`).join("")}`;var e}const Fv=/^[^\/()?;=#]+/;function Dv(t){const e=t.match(Fv);return e?e[0]:""}const Ov=/^[^=?&#]+/,Lv=/^[^?&#]+/;class Mv{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new xv([],{}):new xv([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new xv(t,e)),n}parseSegment(){const t=Dv(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new vv(Av(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Dv(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=Dv(this.remaining);t&&(n=t,this.capture(n))}t[Av(e)]=Av(n)}parseQueryParam(t){const e=function(t){const e=t.match(Ov);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(Lv);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const s=Rv(e),r=Rv(n);if(t.hasOwnProperty(s)){let e=t[s];Array.isArray(e)||(e=[e],t[s]=e),e.push(r)}else t[s]=r}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=Dv(this.remaining),s=this.remaining[n.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):t&&(r="primary");const i=this.parseChildren();e[r]=1===Object.keys(i).length?i.primary:new xv([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class Pv{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=zv(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=zv(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=Bv(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return Bv(t,this._root).map(t=>t.value)}}function zv(t,e){if(t===e.value)return e;for(const n of e.children){const e=zv(t,n);if(e)return e}return null}function Bv(t,e){if(t===e.value)return[e];for(const n of e.children){const s=Bv(t,n);if(s.length)return s.unshift(e),s}return[]}class Vv{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Wv(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class Uv extends Pv{constructor(t,e){super(t),this.snapshot=e,Xv(this,t)}toString(){return this.snapshot.toString()}}function jv(t,e){const n=function(t,e){const n=new qv([],{},{},"",{},"primary",e,null,t.root,-1,{});return new Kv("",new Vv(n,[]))}(t,e),s=new vh([new vv("",{})]),r=new vh({}),i=new vh({}),a=new vh({}),o=new vh(""),l=new Hv(s,r,a,o,i,"primary",e,n.root);return l.snapshot=n.root,new Uv(new Vv(l,[]),n)}class Hv{constructor(t,e,n,s,r,i,a,o){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=a,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(et(t=>iv(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(et(t=>iv(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Gv(t,e="emptyOnly"){const n=t.pathFromRoot;let s=0;if("always"!==e)for(s=n.length-1;s>=1;){const t=n[s],e=n[s-1];if(t.routeConfig&&""===t.routeConfig.path)s--;else{if(e.component)break;s--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(s))}class qv{constructor(t,e,n,s,r,i,a,o,l,u,c){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=a,this.routeConfig=o,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=iv(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=iv(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Kv extends Pv{constructor(t,e){super(e),this.url=t,Xv(this,e)}toString(){return Qv(this._root)}}function Xv(t,e){e.value._routerState=t,e.children.forEach(e=>Xv(t,e))}function Qv(t){const e=t.children.length>0?` { ${t.children.map(Qv).join(", ")} } `:"";return`${t.value}${e}`}function Yv(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,lv(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),lv(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!lv(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),lv(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function Zv(t,e){var n,s;return lv(t.params,e.params)&&wv(n=t.url,s=e.url)&&n.every((t,e)=>lv(t.parameters,s[e].parameters))&&!(!t.parent!=!e.parent)&&(!t.parent||Zv(t.parent,e.parent))}function Jv(t,e,n){if(n&&t.shouldReuseRoute(e.value,n.value.snapshot)){const s=n.value;s._futureSnapshot=e.value;const r=function(t,e,n){return e.children.map(e=>{for(const s of n.children)if(t.shouldReuseRoute(e.value,s.value.snapshot))return Jv(t,e,s);return Jv(t,e)})}(t,e,n);return new Vv(s,r)}{const n=t.retrieve(e.value);if(n){const t=n.route;return tw(e,t),t}{const n=new Hv(new vh((s=e.value).url),new vh(s.params),new vh(s.queryParams),new vh(s.fragment),new vh(s.data),s.outlet,s.component,s),r=e.children.map(e=>Jv(t,e));return new Vv(n,r)}}var s}function tw(t,e){if(t.value.routeConfig!==e.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(t.children.length!==e.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");e.value._futureSnapshot=t.value;for(let n=0;n<t.children.length;++n)tw(t.children[n],e.children[n])}function ew(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function nw(t){return"object"==typeof t&&null!=t&&t.outlets}function sw(t,e,n,s,r){let i={};return s&&dv(s,(t,e)=>{i[e]=Array.isArray(t)?t.map(t=>`${t}`):`${t}`}),new bv(n.root===t?e:rw(n.root,t,e),i,r)}function rw(t,e,n){const s={};return dv(t.children,(t,r)=>{s[r]=t===e?n:rw(t,e,n)}),new xv(t.segments,s)}class iw{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&ew(n[0]))throw new Error("Root segment cannot have matrix parameters");const s=n.find(nw);if(s&&s!==hv(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class aw{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function ow(t,e,n){if(t||(t=new xv([],{})),0===t.segments.length&&t.hasChildren())return lw(t,e,n);const s=function(t,e,n){let s=0,r=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;r<t.segments.length;){if(s>=n.length)return i;const e=t.segments[r],a=n[s];if(nw(a))break;const o=`${a}`,l=s<n.length-1?n[s+1]:null;if(r>0&&void 0===o)break;if(o&&l&&"object"==typeof l&&void 0===l.outlets){if(!dw(o,l,e))return i;s+=2}else{if(!dw(o,{},e))return i;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(t,e,n),r=n.slice(s.commandIndex);if(s.match&&s.pathIndex<t.segments.length){const e=new xv(t.segments.slice(0,s.pathIndex),{});return e.children.primary=new xv(t.segments.slice(s.pathIndex),t.children),lw(e,0,r)}return s.match&&0===r.length?new xv(t.segments,{}):s.match&&!t.hasChildren()?uw(t,e,n):s.match?lw(t,0,r):uw(t,e,n)}function lw(t,e,n){if(0===n.length)return new xv(t.segments,{});{const s=function(t){return nw(t[0])?t[0].outlets:{primary:t}}(n),r={};return dv(s,(n,s)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[s]=ow(t.children[s],e,n))}),dv(t.children,(t,e)=>{void 0===s[e]&&(r[e]=t)}),new xv(t.segments,r)}}function uw(t,e,n){const s=t.segments.slice(0,e);let r=0;for(;r<n.length;){const i=n[r];if(nw(i)){const t=cw(i.outlets);return new xv(s,t)}if(0===r&&ew(n[0])){s.push(new vv(t.segments[e].path,hw(n[0]))),r++;continue}const a=nw(i)?i.outlets.primary:`${i}`,o=r<n.length-1?n[r+1]:null;a&&o&&ew(o)?(s.push(new vv(a,hw(o))),r+=2):(s.push(new vv(a,{})),r++)}return new xv(s,{})}function cw(t){const e={};return dv(t,(t,n)=>{"string"==typeof t&&(t=[t]),null!==t&&(e[n]=uw(new xv([],{}),0,t))}),e}function hw(t){const e={};return dv(t,(t,n)=>e[n]=`${t}`),e}function dw(t,e,n){return t==n.path&&lv(e,n.parameters)}class pw{constructor(t,e,n,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=s}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),Yv(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const s=Wv(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,s[e],n),delete s[e]}),dv(s,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(s===r)if(s.component){const r=n.getContext(s.outlet);r&&this.deactivateChildRoutes(t,e,r.children)}else this.deactivateChildRoutes(t,e,n);else r&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),s=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:s})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet),s=n&&t.value.component?n.children:e,r=Wv(t);for(const i of Object.keys(r))this.deactivateRouteAndItsChildren(r[i],s);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated())}activateChildRoutes(t,e,n){const s=Wv(e);t.children.forEach(t=>{this.activateRoutes(t,s[t.value.outlet],n),this.forwardEvent(new nv(t.value.snapshot))}),t.children.length&&this.forwardEvent(new tv(t.value.snapshot))}activateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(Yv(s),s===r)if(s.component){const r=n.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,r.children)}else this.activateChildRoutes(t,e,n);else if(s.component){const e=n.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const t=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),fw(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(s.snapshot),r=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=s,e.resolver=r,e.outlet&&e.outlet.activateWith(s,r),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function fw(t){Yv(t.value),t.children.forEach(fw)}class mw{constructor(t,e){this.routes=t,this.module=e}}function gw(t){return"function"==typeof t}function yw(t){return t instanceof bv}const bw=Symbol("INITIAL_VALUE");function xw(){return $h(t=>function(...t){let e,n;return tt(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&M(t[0])&&(t=t[0]),xt(t,n).lift(new rx(e))}(t.map(t=>t.pipe(Vh(1),Og(bw)))).pipe(Nx((t,e)=>{let n=!1;return e.reduce((t,s,r)=>{if(t!==bw)return t;if(s===bw&&(n=!0),!n){if(!1===s)return s;if(r===e.length-1||yw(s))return s}return t},t)},bw),Eh(t=>t!==bw),et(t=>yw(t)?t:!0===t),Vh(1)))}let vw=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&Ua(0,"router-outlet")},directives:function(){return[h_]},encapsulation:2}),t})();function ww(t,e=""){for(let n=0;n<t.length;n++){const s=t[n];_w(s,kw(e,s))}}function _w(t,e){t.children&&ww(t.children,e)}function kw(t,e){return e?t||e.path?t&&!e.path?`${t}/`:!t&&e.path?e.path:`${t}/${e.path}`:"":t}function Sw(t){const e=t.children&&t.children.map(Sw),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&"primary"!==n.outlet&&(n.component=vw),n}function Cw(t){return t.outlet||"primary"}function Iw(t,e){const n=t.filter(t=>Cw(t)===e);return n.push(...t.filter(t=>Cw(t)!==e)),n}const Nw={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function Ew(t,e,n){var s;if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?Object.assign({},Nw):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(e.matcher||ov)(n,t,e);if(!r)return Object.assign({},Nw);const i={};dv(r.posParams,(t,e)=>{i[e]=t.path});const a=r.consumed.length>0?Object.assign(Object.assign({},i),r.consumed[r.consumed.length-1].parameters):i;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:a,positionalParamSegments:null!==(s=r.posParams)&&void 0!==s?s:{}}}function Tw(t,e,n,s,r="corrected"){if(n.length>0&&function(t,e,n){return n.some(n=>Aw(t,e,n)&&"primary"!==Cw(n))}(t,n,s)){const r=new xv(e,function(t,e,n,s){const r={};r.primary=s,s._sourceSegment=t,s._segmentIndexShift=e.length;for(const i of n)if(""===i.path&&"primary"!==Cw(i)){const n=new xv([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,r[Cw(i)]=n}return r}(t,e,s,new xv(n,t.children)));return r._sourceSegment=t,r._segmentIndexShift=e.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>Aw(t,e,n))}(t,n,s)){const i=new xv(t.segments,function(t,e,n,s,r,i){const a={};for(const o of s)if(Aw(t,n,o)&&!r[Cw(o)]){const n=new xv([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===i?t.segments.length:e.length,a[Cw(o)]=n}return Object.assign(Object.assign({},r),a)}(t,e,n,s,t.children,r));return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}const i=new xv(t.segments,t.children);return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}function Aw(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path}function Rw(t,e,n,s){return!!(Cw(t)===s||"primary"!==s&&Aw(e,n,t))&&("**"===t.path||Ew(e,t,n).matched)}function $w(t,e,n){return 0===e.length&&!t.children[n]}class Fw{constructor(t){this.segmentGroup=t||null}}class Dw{constructor(t){this.urlTree=t}}function Ow(t){return new q(e=>e.error(new Fw(t)))}function Lw(t){return new q(e=>e.error(new Dw(t)))}function Mw(t){return new q(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class Pw{constructor(t,e,n,s,r){this.configLoader=e,this.urlSerializer=n,this.urlTree=s,this.config=r,this.allowRedirects=!0,this.ngModule=t.get(Al)}apply(){const t=Tw(this.urlTree.root,[],[],this.config).segmentGroup,e=new xv(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,"primary").pipe(et(t=>this.createUrlTree(zw(t),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Eb(t=>{if(t instanceof Dw)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof Fw)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,"primary").pipe(et(e=>this.createUrlTree(zw(e),t.queryParams,t.fragment))).pipe(Eb(t=>{if(t instanceof Fw)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const s=t.segments.length>0?new xv([],{primary:t}):t;return new bv(s,e,n)}expandSegmentGroup(t,e,n,s){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe(et(t=>new xv([],t))):this.expandSegment(t,n,e,n.segments,s,!0)}expandChildren(t,e,n){const s=[];for(const r of Object.keys(n.children))"primary"===r?s.unshift(r):s.push(r);return ht(s).pipe(Fb(s=>{const r=n.children[s],i=Iw(e,s);return this.expandSegmentGroup(t,i,r,s).pipe(et(t=>({segment:t,outlet:s})))}),Nx((t,e)=>(t[e.outlet]=e.segment,t),{}),function(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Eh((e,n)=>t(e,n,s)):G,Ax(1),n?Mx(e):Fx(()=>new Ix))}())}expandSegment(t,e,n,s,r,i){return ht(n).pipe(Fb(a=>this.expandSegmentAgainstRoute(t,e,n,a,s,r,i).pipe(Eb(t=>{if(t instanceof Fw)return Ch(null);throw t}))),Bx(t=>!!t),Eb((t,n)=>{if(t instanceof Ix||"EmptyError"===t.name){if($w(e,s,r))return Ch(new xv([],{}));throw new Fw(e)}throw t}))}expandSegmentAgainstRoute(t,e,n,s,r,i,a){return Rw(s,e,r,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,r,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i):Ow(e):Ow(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,s){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?Lw(r):this.lineralizeSegments(n,r).pipe(mt(n=>{const r=new xv(n,{});return this.expandSegment(t,r,e,n,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){const{matched:a,consumedSegments:o,lastChild:l,positionalParamSegments:u}=Ew(e,s,r);if(!a)return Ow(e);const c=this.applyRedirectCommands(o,s.redirectTo,u);return s.redirectTo.startsWith("/")?Lw(c):this.lineralizeSegments(s,c).pipe(mt(s=>this.expandSegment(t,e,n,s.concat(r.slice(l)),i,!1)))}matchSegmentAgainstRoute(t,e,n,s,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Ch(n._loadedConfig):this.configLoader.load(t.injector,n)).pipe(et(t=>(n._loadedConfig=t,new xv(s,{})))):Ch(new xv(s,{}));const{matched:i,consumedSegments:a,lastChild:o}=Ew(e,n,s);if(!i)return Ow(e);const l=s.slice(o);return this.getChildConfig(t,n,s).pipe(mt(t=>{const s=t.module,i=t.routes,{segmentGroup:o,slicedSegments:u}=Tw(e,a,l,i),c=new xv(o.segments,o.children);if(0===u.length&&c.hasChildren())return this.expandChildren(s,i,c).pipe(et(t=>new xv(a,t)));if(0===i.length&&0===u.length)return Ch(new xv(a,{}));const h=Cw(n)===r;return this.expandSegment(s,c,i,u,h?"primary":r,!0).pipe(et(t=>new xv(a.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?Ch(new mw(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?Ch(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(mt(n=>n?this.configLoader.load(t.injector,e).pipe(et(t=>(e._loadedConfig=t,t))):function(t){return new q(e=>e.error(av(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):Ch(new mw([],t))}runCanLoadGuards(t,e,n){const s=e.canLoad;return s&&0!==s.length?Ch(s.map(s=>{const r=t.get(s);let i;if(function(t){return t&&gw(t.canLoad)}(r))i=r.canLoad(e,n);else{if(!gw(r))throw new Error("Invalid CanLoad guard");i=r(e,n)}return pv(i)})).pipe(xw(),Hh(t=>{if(!yw(t))return;const e=av(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),et(t=>!0===t)):Ch(!0)}lineralizeSegments(t,e){let n=[],s=e.root;for(;;){if(n=n.concat(s.segments),0===s.numberOfChildren)return Ch(n);if(s.numberOfChildren>1||!s.children.primary)return Mw(t.redirectTo);s=s.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,s){const r=this.createSegmentGroup(t,e.root,n,s);return new bv(r,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return dv(t,(t,s)=>{if("string"==typeof t&&t.startsWith(":")){const r=t.substring(1);n[s]=e[r]}else n[s]=t}),n}createSegmentGroup(t,e,n,s){const r=this.createSegments(t,e.segments,n,s);let i={};return dv(e.children,(e,r)=>{i[r]=this.createSegmentGroup(t,e,n,s)}),new xv(r,i)}createSegments(t,e,n,s){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,s):this.findOrReturn(e,n))}findPosParam(t,e,n){const s=n[e.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return s}findOrReturn(t,e){let n=0;for(const s of e){if(s.path===t.path)return e.splice(n),s;n++}return t}}function zw(t){const e={};for(const n of Object.keys(t.children)){const s=zw(t.children[n]);(s.segments.length>0||s.hasChildren())&&(e[n]=s)}return function(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new xv(t.segments.concat(e.segments),e.children)}return t}(new xv(t.segments,e))}class Bw{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Vw{constructor(t,e){this.component=t,this.route=e}}function Ww(t,e,n){const s=t._root;return jw(s,e?e._root:null,n,[s.value])}function Uw(t,e,n){const s=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(s?s.module.injector:n).get(t)}function jw(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=Wv(e);return t.children.forEach(t=>{!function(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=t.value,a=e?e.value:null,o=n?n.getContext(t.value.outlet):null;if(a&&i.routeConfig===a.routeConfig){const l=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!wv(t.url,e.url);case"pathParamsOrQueryParamsChange":return!wv(t.url,e.url)||!lv(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Zv(t,e)||!lv(t.queryParams,e.queryParams);case"paramsChange":default:return!Zv(t,e)}}(a,i,i.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new Bw(s)):(i.data=a.data,i._resolvedData=a._resolvedData),jw(t,e,i.component?o?o.children:null:n,s,r),l&&o&&o.outlet&&o.outlet.isActivated&&r.canDeactivateChecks.push(new Vw(o.outlet.component,a))}else a&&Hw(e,o,r),r.canActivateChecks.push(new Bw(s)),jw(t,null,i.component?o?o.children:null:n,s,r)}(t,i[t.value.outlet],n,s.concat([t.value]),r),delete i[t.value.outlet]}),dv(i,(t,e)=>Hw(t,n.getContext(e),r)),r}function Hw(t,e,n){const s=Wv(t),r=t.value;dv(s,(t,s)=>{Hw(t,r.component?e?e.children.getContext(s):null:e,n)}),n.canDeactivateChecks.push(new Vw(r.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,r))}class Gw{}function qw(t){return new q(e=>e.error(t))}class Kw{constructor(t,e,n,s,r,i){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=s,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=i}recognize(){const t=Tw(this.urlTree.root,[],[],this.config.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,"primary");if(null===e)return null;const n=new qv([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},"primary",this.rootComponentType,null,this.urlTree.root,-1,{}),s=new Vv(n,e),r=new Kv(this.url,s);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(t){const e=t.value,n=Gv(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=[];for(const r of Object.keys(e.children)){const s=e.children[r],i=Iw(t,r),a=this.processSegmentGroup(i,s,r);if(null===a)return null;n.push(...a)}const s=function(t){const e=[];for(const n of t){if(!Xw(n)){e.push(n);continue}const t=e.find(t=>n.value.routeConfig===t.value.routeConfig);void 0!==t?t.children.push(...n.children):e.push(n)}return e}(n);return s.sort((t,e)=>"primary"===t.value.outlet?-1:"primary"===e.value.outlet?1:t.value.outlet.localeCompare(e.value.outlet)),s}processSegment(t,e,n,s){for(const r of t){const t=this.processSegmentAgainstRoute(r,e,n,s);if(null!==t)return t}return $w(e,n,s)?[]:null}processSegmentAgainstRoute(t,e,n,s){if(t.redirectTo||!Rw(t,e,n,s))return null;let r,i=[],a=[];if("**"===t.path){const s=n.length>0?hv(n).parameters:{};r=new qv(n,s,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Zw(t),Cw(t),t.component,t,Qw(e),Yw(e)+n.length,Jw(t))}else{const s=Ew(e,t,n);if(!s.matched)return null;i=s.consumedSegments,a=n.slice(s.lastChild),r=new qv(i,s.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Zw(t),Cw(t),t.component,t,Qw(e),Yw(e)+i.length,Jw(t))}const o=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:u}=Tw(e,i,a,o.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const t=this.processChildren(o,l);return null===t?null:[new Vv(r,t)]}if(0===o.length&&0===u.length)return[new Vv(r,[])];const c=Cw(t)===s,h=this.processSegment(o,l,u,c?"primary":s);return null===h?null:[new Vv(r,h)]}}function Xw(t){const e=t.value.routeConfig;return e&&""===e.path&&void 0===e.redirectTo}function Qw(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function Yw(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function Zw(t){return t.data||{}}function Jw(t){return t.resolve||{}}function t_(t){return $h(e=>{const n=t(e);return n?ht(n).pipe(et(()=>e)):Ch(e)})}class e_ extends class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const n_=new ms("ROUTES");class s_{constructor(t,e,n,s){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=s}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const n=this.loadModuleFactory(e.loadChildren).pipe(et(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const s=n.create(t);return new mw(cv(s.injector.get(n_,void 0,Xt.Self|Xt.Optional)).map(Sw),s)}),Eb(t=>{throw e._loader$=void 0,t}));return e._loader$=new St(n,()=>new Z).pipe(wt()),e._loader$}loadModuleFactory(t){return"string"==typeof t?ht(this.loader.load(t)):pv(t()).pipe(mt(t=>t instanceof Rl?Ch(t):ht(this.compiler.compileModuleAsync(t))))}}class r_{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new i_,this.attachRef=null}}class i_{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new r_,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class a_{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function o_(t){throw t}function l_(t,e,n){return e.parse("/")}function u_(t,e){return Ch(null)}let c_=(()=>{class t{constructor(t,e,n,s,r,i,a,o){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=s,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new Z,this.errorHandler=o_,this.malformedUriErrorHandler=l_,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:u_,afterPreactivation:u_},this.urlHandlingStrategy=new a_,this.routeReuseStrategy=new e_,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.ngModule=r.get(Al),this.console=r.get(wu);const l=r.get(Du);this.isNgZoneEnabled=l instanceof Du&&Du.isInAngularZone(),this.resetConfig(o),this.currentUrlTree=new bv(new xv([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new s_(i,a,t=>this.triggerEvent(new Yx(t)),t=>this.triggerEvent(new Zx(t))),this.routerState=jv(this.currentUrlTree,this.rootComponentType),this.transitions=new vh({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(Eh(t=>0!==t.id),et(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),$h(t=>{let n=!1,s=!1;return Ch(t).pipe(Hh(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),$h(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return Ch(t).pipe($h(t=>{const n=this.transitions.getValue();return e.next(new Wx(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?zh:Promise.resolve(t)}),(s=this.ngModule.injector,r=this.configLoader,i=this.urlSerializer,a=this.config,$h(t=>function(t,e,n,s,r){return new Pw(t,e,n,s,r).apply()}(s,r,i,t.extractedUrl,a).pipe(et(e=>Object.assign(Object.assign({},t),{urlAfterRedirects:e}))))),Hh(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,s,r){return mt(i=>function(t,e,n,s,r="emptyOnly",i="legacy"){try{const a=new Kw(t,e,n,s,r,i).recognize();return null===a?qw(new Gw):Ch(a)}catch(a){return qw(a)}}(t,e,i.urlAfterRedirects,n(i.urlAfterRedirects),s,r).pipe(et(t=>Object.assign(Object.assign({},i),{targetSnapshot:t}))))}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),Hh(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects);const n=new Gx(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));var s,r,i,a;if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:s,source:r,restoredState:i,extras:a}=t,o=new Wx(n,this.serializeUrl(s),r,i);e.next(o);const l=jv(s,this.rootComponentType).snapshot;return Ch(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:s,extras:Object.assign(Object.assign({},a),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),zh}),t_(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:a}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!a})}),Hh(t=>{const e=new qx(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),et(t=>Object.assign(Object.assign({},t),{guards:Ww(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return mt(n=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:i,canDeactivateChecks:a}}=n;return 0===a.length&&0===i.length?Ch(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,s){return ht(t).pipe(mt(t=>function(t,e,n,s,r){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?Ch(i.map(i=>{const a=Uw(i,e,r);let o;if(function(t){return t&&gw(t.canDeactivate)}(a))o=pv(a.canDeactivate(t,e,n,s));else{if(!gw(a))throw new Error("Invalid CanDeactivate guard");o=pv(a(t,e,n,s))}return o.pipe(Bx())})).pipe(xw()):Ch(!0)}(t.component,t.route,n,e,s)),Bx(t=>!0!==t,!0))}(a,s,r,t).pipe(mt(n=>n&&"boolean"==typeof n?function(t,e,n,s){return ht(e).pipe(Fb(e=>Dg(function(t,e){return null!==t&&e&&e(new Jx(t)),Ch(!0)}(e.route.parent,s),function(t,e){return null!==t&&e&&e(new ev(t)),Ch(!0)}(e.route,s),function(t,e,n){const s=e[e.length-1],r=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>lb(()=>Ch(e.guards.map(r=>{const i=Uw(r,e.node,n);let a;if(function(t){return t&&gw(t.canActivateChild)}(i))a=pv(i.canActivateChild(s,t));else{if(!gw(i))throw new Error("Invalid CanActivateChild guard");a=pv(i(s,t))}return a.pipe(Bx())})).pipe(xw())));return Ch(r).pipe(xw())}(t,e.path,n),function(t,e,n){const s=e.routeConfig?e.routeConfig.canActivate:null;return s&&0!==s.length?Ch(s.map(s=>lb(()=>{const r=Uw(s,e,n);let i;if(function(t){return t&&gw(t.canActivate)}(r))i=pv(r.canActivate(e,t));else{if(!gw(r))throw new Error("Invalid CanActivate guard");i=pv(r(e,t))}return i.pipe(Bx())}))).pipe(xw()):Ch(!0)}(t,e.route,n))),Bx(t=>!0!==t,!0))}(s,i,t,e):Ch(n)),et(t=>Object.assign(Object.assign({},n),{guardsResult:t})))})}(this.ngModule.injector,t=>this.triggerEvent(t)),Hh(t=>{if(yw(t.guardsResult)){const e=av(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}const e=new Kx(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),Eh(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new jx(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),t_(t=>{if(t.guards.canActivateChecks.length)return Ch(t).pipe(Hh(t=>{const e=new Xx(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),$h(t=>{let n=!1;return Ch(t).pipe((s=this.paramsInheritanceStrategy,r=this.ngModule.injector,mt(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return Ch(t);let i=0;return ht(n).pipe(Fb(t=>function(t,e,n,s){return function(t,e,n,s){const r=Object.keys(t);if(0===r.length)return Ch({});const i={};return ht(r).pipe(mt(r=>function(t,e,n,s){const r=Uw(t,e,s);return pv(r.resolve?r.resolve(e,n):r(e,n))}(t[r],e,n,s).pipe(Hh(t=>{i[r]=t}))),Ax(1),mt(()=>Object.keys(i).length===r.length?Ch(i):zh))}(t._resolve,t,e,s).pipe(et(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),Gv(t,n).resolve),null)))}(t.route,e,s,r)),Hh(()=>i++),Ax(1),mt(e=>i===n.length?Ch(t):zh))})),Hh({next:()=>n=!0,complete:()=>{if(!n){const n=new jx(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var s,r}),Hh(t=>{const e=new Qx(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),t_(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:a}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!a})}),et(t=>{const e=function(t,e,n){const s=Jv(t,e._root,n?n._root:void 0);return new Uv(s,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),Hh(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(i=this.rootContexts,a=this.routeReuseStrategy,o=t=>this.triggerEvent(t),et(t=>(new pw(a,t.targetRouterState,t.currentRouterState,o).activate(i),t))),Hh({next(){n=!0},complete(){n=!0}}),(r=()=>{if(!n&&!s){this.resetUrlToCurrentUrlTree();const n=new jx(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null},t=>t.lift(new Rb(r))),Eb(n=>{if(s=!0,(r=n)&&r.ngNavigationCancelingError){const s=yw(n.url);s||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const r=new jx(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(r),s?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const s=new Hx(t.id,this.serializeUrl(t.extractedUrl),n);e.next(s);try{t.resolve(this.errorHandler(n))}catch(i){t.reject(i)}}var r;return zh}));var r,i,a,o}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{const e=this.extractLocationChangeInfoFromEvent(t);this.shouldScheduleNavigation(this.lastLocationChangeInfo,e)&&setTimeout(()=>{const{source:t,state:n,urlTree:s}=e,r={replaceUrl:!0};if(n){const t=Object.assign({},n);delete t.navigationId,0!==Object.keys(t).length&&(r.state=t)}this.scheduleNavigation(s,t,n,r)},0),this.lastLocationChangeInfo=e}))}extractLocationChangeInfoFromEvent(t){var e;return{source:"popstate"===t.type?"popstate":"hashchange",urlTree:this.parseUrl(t.url),state:(null===(e=t.state)||void 0===e?void 0:e.navigationId)?t.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(t,e){if(!t)return!0;const n=e.urlTree.toString()===t.urlTree.toString();return!(e.transitionId===t.transitionId&&n&&("hashchange"===e.source&&"popstate"===t.source||"popstate"===e.source&&"hashchange"===t.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){ww(t),this.config=t.map(Sw),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(t,e={}){const{relativeTo:n,queryParams:s,fragment:r,queryParamsHandling:i,preserveFragment:a}=e,o=n||this.routerState.root,l=a?this.currentUrlTree.fragment:r;let u=null;switch(i){case"merge":u=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=s||null}return null!==u&&(u=this.removeEmptyProps(u)),function(t,e,n,s,r){if(0===n.length)return sw(e.root,e.root,e,s,r);const i=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new iw(!0,0,t);let e=0,n=!1;const s=t.reduce((t,s,r)=>{if("object"==typeof s&&null!=s){if(s.outlets){const e={};return dv(s.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(s.segmentPath)return[...t,s.segmentPath]}return"string"!=typeof s?[...t,s]:0===r?(s.split("/").forEach((s,r)=>{0==r&&"."===s||(0==r&&""===s?n=!0:".."===s?e++:""!=s&&t.push(s))}),t):[...t,s]},[]);return new iw(n,e,s)}(n);if(i.toRoot())return sw(e.root,new xv([],{}),e,s,r);const a=function(t,e,n){if(t.isAbsolute)return new aw(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new aw(t,t===e.root,0)}const s=ew(t.commands[0])?0:1;return function(t,e,n){let s=t,r=e,i=n;for(;i>r;){if(i-=r,s=s.parent,!s)throw new Error("Invalid number of '../'");r=s.segments.length}return new aw(s,!1,r-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+s,t.numberOfDoubleDots)}(i,e,t),o=a.processChildren?lw(a.segmentGroup,a.index,i.commands):ow(a.segmentGroup,a.index,i.commands);return sw(a.segmentGroup,o,e,s,r)}(o,this.currentUrlTree,t,u,l)}navigateByUrl(t,e={skipLocationChange:!1}){const n=yw(t)?t:this.parseUrl(t),s=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(s,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){if(yw(t))return fv(this.currentUrlTree,t,e);const n=this.parseUrl(t);return fv(this.currentUrlTree,n,e)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const s=t[n];return null!=s&&(e[n]=s),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new Ux(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.currentNavigation=null,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,s,r){if(this.disposed)return Promise.resolve(!1);const i=this.getTransition(),a="imperative"!==e&&"imperative"===(null==i?void 0:i.source),o=(this.lastSuccessfulId===i.id||this.currentNavigation?i.rawUrl:i.urlAfterRedirects).toString()===t.toString();if(a&&o)return Promise.resolve(!0);let l,u,c;r?(l=r.resolve,u=r.reject,c=r.promise):c=new Promise((t,e)=>{l=t,u=e});const h=++this.navigationId;return this.setTransition({id:h,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:s,resolve:l,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,s){const r=this.urlSerializer.serialize(t);s=s||{},this.location.isCurrentPathEqualTo(r)||e?this.location.replaceState(r,"",Object.assign(Object.assign({},s),{navigationId:n})):this.location.go(r,"",Object.assign(Object.assign({},s),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)($s(ys),$s(_v),$s(i_),$s(Ec),$s(Sa),$s(sc),$s(Ru),$s(void 0))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),h_=(()=>{class t{constructor(t,e,n,s,r){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new Kl,this.deactivateEvents=new Kl,this.name=s||"primary",t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),s=this.parentContexts.getOrCreateContext(this.name).children,r=new d_(t,s,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(Pa(i_),Pa(Fl),Pa(Ho),("name",function(t,e){const n=t.attrs;if(n){const t=n.length;let e=0;for(;e<t;){const s=n[e];if(Bn(s))break;if(0===s)e+=2;else if("number"==typeof s)for(e++;e<t&&"string"==typeof n[e];)e++;else{if("name"===s)return n[e+1];e+=2}}}return null}(an())),Pa(wl))},t.\u0275dir=Se({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class d_{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===Hv?this.route:t===i_?this.childContexts:this.parent.get(t,e)}}class p_{}class f_{preload(t,e){return Ch(null)}}let m_=(()=>{class t{constructor(t,e,n,s,r){this.router=t,this.injector=s,this.preloadingStrategy=r,this.loader=new s_(e,n,e=>t.triggerEvent(new Yx(e)),e=>t.triggerEvent(new Zx(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(Eh(t=>t instanceof Ux),Fb(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(Al);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const s of e)if(s.loadChildren&&!s.canLoad&&s._loadedConfig){const t=s._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else s.loadChildren&&!s.canLoad?n.push(this.preloadConfig(t,s)):s.children&&n.push(this.processRoutes(t,s.children));return ht(n).pipe(bt(),et(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>(e._loadedConfig?Ch(e._loadedConfig):this.loader.load(t.injector,e)).pipe(mt(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)($s(c_),$s(sc),$s(Ru),$s(Sa),$s(p_))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),g_=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof Wx?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof Ux&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof sv&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new sv(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)($s(c_),$s(Vc),$s(void 0))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const y_=new ms("ROUTER_CONFIGURATION"),b_=new ms("ROUTER_FORROOT_GUARD"),x_=[Ec,{provide:_v,useClass:kv},{provide:c_,useFactory:function(t,e,n,s,r,i,a,o={},l,u){const c=new c_(null,t,e,n,s,r,i,cv(a));if(l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),function(t,e){t.errorHandler&&(e.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(e.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(e.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(e.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.relativeLinkResolution&&(e.relativeLinkResolution=t.relativeLinkResolution),t.urlUpdateStrategy&&(e.urlUpdateStrategy=t.urlUpdateStrategy)}(o,c),o.enableTracing){const t=dc();c.events.subscribe(e=>{t.logGroup(`Router Event: ${e.constructor.name}`),t.log(e.toString()),t.log(e),t.logGroupEnd()})}return c},deps:[_v,i_,Ec,Sa,sc,Ru,n_,y_,[class{},new Ms],[class{},new Ms]]},i_,{provide:Hv,useFactory:function(t){return t.routerState.root},deps:[c_]},{provide:sc,useClass:ac},m_,f_,class{preload(t,e){return e().pipe(Eb(()=>Ch(null)))}},{provide:y_,useValue:{enableTracing:!1}}];function v_(){return new Qu("Router",c_)}let w_=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[x_,C_(e),{provide:b_,useFactory:S_,deps:[[c_,new Ms,new Ps]]},{provide:y_,useValue:n||{}},{provide:kc,useFactory:k_,deps:[fc,[new Ls(Cc),new Ms],y_]},{provide:g_,useFactory:__,deps:[c_,Vc,y_]},{provide:p_,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:f_},{provide:Qu,multi:!0,useFactory:v_},[I_,{provide:pu,multi:!0,useFactory:N_,deps:[I_]},{provide:T_,useFactory:E_,deps:[I_]},{provide:vu,multi:!0,useExisting:T_}]]}}static forChild(e){return{ngModule:t,providers:[C_(e)]}}}return t.\u0275fac=function(e){return new(e||t)($s(b_,8),$s(c_,8))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();function __(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new g_(t,e,n)}function k_(t,e,n={}){return n.useHash?new Nc(t,e):new Ic(t,e)}function S_(t){return"guarded"}function C_(t){return[{provide:gs,multi:!0,useValue:t},{provide:n_,multi:!0,useValue:t}]}let I_=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new Z}appInitializer(){return this.injector.get(gc,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(c_),s=this.injector.get(y_);return"disabled"===s.initialNavigation?(n.setUpLocationChangeListener(),t(!0)):"enabled"===s.initialNavigation||"enabledBlocking"===s.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Ch(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()):t(!0),e})}bootstrapListener(t){const e=this.injector.get(y_),n=this.injector.get(m_),s=this.injector.get(g_),r=this.injector.get(c_),i=this.injector.get(ec);t===i.components[0]&&("enabledNonBlocking"!==e.initialNavigation&&void 0!==e.initialNavigation||r.initialNavigation(),n.setUpPreloading(),s.init(),r.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return t.\u0275fac=function(e){return new(e||t)($s(Sa))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function N_(t){return t.appInitializer.bind(t)}function E_(t){return t.bootstrapListener.bind(t)}const T_=new ms("Router Initializer");var A_=n("g5Dd");class R_{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class $_{refCount(t){return F_("refCount")}incRef(t){return F_("incRef")}timerAvailable(){return!0}time(t){return F_("time")}read(t){return F_("read")}readSync(t){return F_("readSync")}numDataIds(){return F_("numDataIds")}disposeData(t,e){return F_("disposeData")}write(t,e,n){return F_("write")}move(t,e,n,s,r){return F_("move")}memory(){return F_("memory")}floatPrecision(){return F_("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return F_("dispose")}}function F_(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function D_(t){let e=t.length,n=0,s=0;for(;e>0;)s=Math.random()*e|0,e--,n=t[e],t[e]=t[s],t[s]=n}function O_(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n,s,r=t.length,i=0;for(;r>0;)i=Math.random()*r|0,r--,n=t[r],s=e[r],t[r]=t[i],e[r]=e[i],t[i]=n,e[i]=s}function L_(t,e,n){return Math.max(t,Math.min(e,n))}function M_(t){return t%2==0?t:t+1}function P_(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function z_(t,e){const n=Math.random();return e*n+(1-n)*t}function B_(t,e){let n=0;for(let s=0;s<t.length;s++){const r=Number(t[s])-Number(e[s]);n+=r*r}return n}function V_(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function W_(t,e,n=""){V_(q_(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function U_(t){V_(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function j_(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||lk(t)&&!n)for(let s=0;s<t.length;++s)j_(t[s],e,n);else e.push(t);return e}function H_(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function G_(t){return 0===t.length}function q_(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function K_(t){return t%1==0}function X_(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function Q_(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Y_(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return D_(e),e}function Z_(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function J_(t,e=(t=>0),n){return new Promise((s,r)=>{let i=0;const a=()=>{if(t())return void s();i++;const o=e(i);null!=n&&i>=n?r():setTimeout(a,o)};a()})}function tk(t,e){let n=1,s=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===s){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function ek(t,e){const n=e.length;return V_((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),V_(t.every(t=>K_(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function nk(t,e){const n=[],s=[],r=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||r?null:ek(e,t).sort();let a=0;for(let o=0;o<t.length;++o){if(null!=i){if(i[a]===o&&1!==t[o])throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(null==i[a]||i[a]>o)&&1===t[o]&&(n.push(t[o]),s.push(o)),i[a]<=o&&a++}1!==t[o]&&(n.push(t[o]),s.push(o))}return{newShape:n,keptDims:s}}function sk(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function rk(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function ik(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function ak(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function ok(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function lk(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function uk(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function ck(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function hk(t){return"string"==typeof t||t instanceof String}function dk(t){return"boolean"==typeof t}function pk(t){return"number"==typeof t}function fk(t){return Array.isArray(t)?fk(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":pk(t)?"float32":hk(t)?"string":dk(t)?"bool":"float32"}function mk(t){return!!(t&&t.constructor&&t.call&&t.apply)}function gk(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function yk(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function bk(t,e,n){const s=new Array;if(1===e.length){const r=e[0];for(let e=0;e<r;e++)s[e]=n[t+e]}else{const r=e[0],i=e.slice(1),a=i.reduce((t,e)=>t*e);for(let e=0;e<r;e++)s[e]=bk(t+e*a,i,n)}return s}function xk(t,e){if(0===t.length)return e[0];const n=t.reduce((t,e)=>t*e);if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return bk(0,t,e)}function vk(t,e){const n=wk(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function wk(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function _k(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return xk(t,new Float32Array(n));if("int32"===e)return xk(t,new Int32Array(n));if("bool"===e)return xk(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function kk(t){t.forEach(e=>{V_(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Sk(t,e,n){if(0===e)return 0;if(1===e)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function Ck(t,e,n){if(0===e)return[];if(1===e)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Ik(t){return t&&t.then&&"function"==typeof t.then}class Nk{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Ik(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function Ek(){return Ak}let Tk,Ak=null;function Rk(){if(null==Tk){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Tk=t}return Tk}function $k(t,e){const n=function(){const t=Rk();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const Fk=$k("kernelRegistry",()=>new Map),Dk=$k("gradRegistry",()=>new Map);function Ok(t,e){const n=Bk(t,e);return Fk.get(n)}function Lk(t){return Dk.get(t)}function Mk(t){const e=Fk.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===t&&n.push(a)}return n}function Pk(t){const{kernelName:e,backendName:n}=t,s=Bk(e,n);Fk.has(s)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),Fk.set(s,t)}function zk(t){const{kernelName:e}=t;Dk.has(e)&&Ek().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),Dk.set(e,t)}function Bk(t,e){return`${e}_${t}`}function Vk(t,e){return"string"===e?Hk(t):Wk([t],e)}function Wk(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=j_(t)),Ek().getBool("DEBUG")&&ik(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function Uk(){return Ek().platform.now()}function jk(t,e){return Ek().platform.fetch(t,e)}function Hk(t,e="utf-8"){return e=e||"utf-8",Ek().platform.encode(t,e)}function Gk(t,e="utf-8"){return e=e||"utf-8",Ek().platform.decode(t,e)}class qk{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Xk)}profileKernel(t,e,n){let s;const r=()=>{s=n()};let i;const a=Uk();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(r);else{r();for(const t of s)t.dataSync();i=Promise.resolve({kernelMs:Uk()-a})}if(Ek().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<s.length;o++){const e=s[o];e.data().then(n=>{Kk(n,e.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(t=>t.kernelMs),extraInfo:i.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:s,inputs:r,extraInfo:i}=t;n.forEach(t=>{Promise.all([t.data(),s,i]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],r,n[2])})})}}function Kk(t,e,n){if("float32"!==e)return!1;for(let s=0;s<t.length;s++){const e=t[s];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}return!1}class Xk{logKernelProfile(t,e,n,s,r,i){const a="number"==typeof s?Z_(`${s}ms`,9):s.error,o=Z_(t,25),l=e.rank,u=e.size,c=Z_(e.shape.toString(),14);let h="";for(const d in r){const t=r[d];if(null!=t){const n=t.shape||e.shape,s=n.length;h+=`${d}: ${s}D ${s>0?n:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Qk(t,e,n,s){const r=yk(e),i=function(t,e,n,s){const r=H_(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,l="complex64"===n?tS(t):t;if(o>1)for(let u=0;u<r/i;u++){const t=u*i;for(let e=0;e<i;e++)a[e]=Math.max(a[e],Yk(l[t+e],0,n).length)}return a}(t,e,n,r),a=e.length,o=Jk(t,e,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(t=>"    "+t).join("\n")),l.join("\n")}function Yk(t,e,n){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:hk(t)?`'${t}'`:"bool"===n?Zk(t):parseFloat(t.toFixed(7)).toString(),Z_(s,e)}function Zk(t){return 0===t?"false":"true"}function Jk(t,e,n,s,r,i=!0){const a="complex64"===n?2:1,o=e[0],l=e.length;if(0===l)return"complex64"===n?[Yk(tS(t)[0],0,n)]:"bool"===n?[Zk(t[0])]:[t[0].toString()];if(1===l){if(o>20){let e=Array.from(t.slice(0,3*a)),s=Array.from(t.slice((o-3)*a,o*a));return"complex64"===n&&(e=tS(e),s=tS(s)),["["+e.map((t,e)=>Yk(t,r[e],n)).join(", ")+", ..., "+s.map((t,e)=>Yk(t,r[o-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?tS(t):Array.from(t)).map((t,e)=>Yk(t,r[e],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*a,d=[];if(o>20){for(let e=0;e<3;e++){const s=e*h;d.push(...Jk(t.slice(s,s+h),u,n,c,r,!1))}d.push("...");for(let e=o-3;e<o;e++){const s=e*h;d.push(...Jk(t.slice(s,s+h),u,n,c,r,e===o-1))}}else for(let m=0;m<o;m++){const e=m*h;d.push(...Jk(t.slice(e,e+h),u,n,c,r,m===o-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function tS(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class eS{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=H_(t),null!=n){const t=n.length;V_(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||rk(e,this.size),this.strides=yk(t)}set(t,...e){0===e.length&&(e=[0]),V_(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return nS().makeTensor(this.values,this.shape,this.dtype)}}let nS=null,sS=null,rS=null;class iS{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=H_(t),this.strides=yk(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return sS.buffer(this.shape,this.dtype,t)}bufferSync(){return sS.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return xk(this.shape,t)}arraySync(){return xk(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=nS().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>Gk(t))}catch(hY){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=nS().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>Gk(t))}catch(hY){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await nS().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(nS().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return sS.print(this,t)}clone(){return this.throwIfDisposed(),sS.clone(this)}toString(t=!1){return Qk(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),sS.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),nS().makeVariable(this,t,e,n)}}function aS(){return $k("Tensor",()=>iS)}Object.defineProperty(iS,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),aS();class oS extends iS{constructor(t,e,n,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!q_(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);nS().disposeTensor(this),this.dataId=t.dataId,nS().incRef(this,null)}dispose(){nS().disposeVariable(this),this.isDisposedInternal=!0}}var lS,uS,cS,hS,dS;Object.defineProperty(oS,Symbol.hasInstance,{value:t=>t instanceof iS&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(lS||(lS={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(uS||(uS={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(cS||(cS={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(hS||(hS={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(dS||(dS={}));const pS={float32:hS,int32:uS,bool:cS,complex64:dS};function fS(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return pS[t][e]}function mS(t){return fS(t,"int32")}function gS(t,e){if(t.dtype===e.dtype)return[t,e];const n=fS(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function yS(t,e){V_(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function bS(t,e){return e.some(e=>e.id===t.id)}function xS(t){const e=[];return vS(t,e,new Set),e}function vS(t,e,n){if(null==t)return;if(t instanceof iS)return void e.push(t);if(s=t,!Array.isArray(s)&&"object"!=typeof s)return;var s;const r=t;for(const i in r){const t=r[i];n.has(t)||(n.add(t),vS(t,e,n))}}function wS(t){return null!=t.kernelName}class _S{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class kS{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new _S}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new qk(this.backendInstance),!0}setupRegisteredKernels(){Mk(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Mk(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof $_||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,s=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),s=n.backend,r=this.readSync(e),i=s.refCount(e);s.disposeData(e,!0),n.backend=t,t.move(e,r,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,s=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(s){throw e(),s}}nextTensorId(){return kS.nextTensorId++}nextVariableId(){return kS.nextVariableId++}clone(t){const e=CS.runKernel("Identity",{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>CS.runKernel("Cast",{x:t},{dtype:"float32"})}),[],{}),e}runKernel(t,e,n){if(null==Ok(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const s=this.backend.numDataIds();let r=0;n.forEach(t=>{r+="complex64"===t.dtype?3:1});const i=s-e-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const s=this.isTapeOn(),r=this.state.numBytes,i=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const l=wS(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(wS(t)){const{kernelName:e,inputs:r,attrs:i}=t,l=Ok(e,this.backendName);V_(null!=l,()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`),a=()=>{const t=this.backend.numDataIds();o=l.kernelFunc({inputs:r,attrs:i,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,a);const u=a.map(t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:s}=t;return this.makeTensorFromDataId(e,n,s)});if(s){const t=this.getTensorsForGradient(e,r,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,r=t=>{s&&(n=t.map(t=>this.keep(this.clone(t))))};a=()=>{const t=this.backend.numDataIds();o=this.tidy(()=>e(this.backend,r));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,h=wS(t)?null:t.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=a()}),s&&this.addTapeNode(l,u,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(t=>null!=u[t]?u[t].shape:null),outputShapes:e.map(t=>t.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const s=Lk(t);if(null!=s){const t=s.inputsToSave||[],r=s.outputsToSave||[];let i;s.saveAllInputs?(V_(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(t=>e[t])):i=t.map(t=>e[t]);const a=n.filter((t,e)=>r[e]);return i.concat(a)}return[]}makeTensor(t,e,n,s){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let r=t;"string"===(n=n||"float32")&&hk(t[0])&&(r=t.map(t=>Hk(t)));const i=s.write(r,e,n),a=new iS(e,n,i,this.nextTensorId());if(this.trackTensor(a,s),"string"===n){const t=this.state.tensorInfo.get(i),e=ck(r);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,s){const r=new iS(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(r,s),r}makeVariable(t,e=!0,n,s){n=n||this.nextVariableId().toString(),null!=s&&s!==t.dtype&&(t=t.cast(s));const r=new oS(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*uk(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof oS||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*uk(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,s,r,i){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:r},o=Lk(t);null!=o&&(s=o.gradFunc),null!=s&&(a.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],s=wk(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t}),s(t.length>1?t:t[0],r,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=xS(t),n=new Set(e.map(t=>t.id));for(let r=0;r<this.state.activeScope.track.length;r++){const t=this.state.activeScope.track[r];t.kept||n.has(t.id)||t.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==s.id||this.track(t)})}gradients(t,e,n,s=!1){if(V_(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));V_(r instanceof iS,()=>"The result y returned by f() must be a tensor.");const i=function(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],i=n.inputs;for(const t in i){const a=i[t];let o=!1;for(let t=0;t<e.length;t++)if(s[a.id]){n.outputs.forEach(t=>s[t.id]=!0),o=!0,r[n.id]=!0;break}if(o)break}}const i={};i[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,a[e.id]=!0;break}}const o=[];for(let l=0;l<t.length;l++){const e=t[l];if(r[e.id]&&a[e.id]){const t={};for(const r in e.inputs){const n=e.inputs[r];s[n.id]&&(t[r]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,o.push(n)}}return o}(this.state.activeTape,e,r);if(!s&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[r.id]=null==n?function(t){const e=vk(H_(t),"float32");return CS.makeTensor(e,t,"float32")}(r.shape):n,function(t,e,n,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(e=>{const n=t[e.id];a.push(null!=n?n:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const e in i.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const r=n(()=>o[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const a=i.inputs[e];if(!q_(r.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=r;else{const e=t[a.id];t[a.id]=s(e,r),e.dispose()}}}}(t,i,t=>this.tidy(t),IS);const s=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:r,grads:s}})}customGrad(t){return V_(mk(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;V_(e.every(t=>t instanceof iS),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return e.forEach((t,e)=>{s[e]=t}),this.runKernelFunc({forwardFunc:(s,r)=>(n=t(...e,r),V_(n.value instanceof iS,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),V_(mk(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(t,s)=>{const r=n.gradFunc(t,s),i=Array.isArray(r)?r:[r];V_(i.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),V_(i.every(t=>t instanceof iS),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const a={};return i.forEach((t,e)=>{a[e]=()=>t}),a},inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=Uk(),n=await this.backend.time(t);return n.wallMs=Uk()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new _S;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function SS(){const t=Rk();if(null==t._tfengine){const e=new Nk(t);t._tfengine=new kS(e)}return Ak=t._tfengine.ENV,nS=()=>t._tfengine,t._tfengine}kS.nextTensorId=0,kS.nextVariableId=0;const CS=SS();function IS(t,e){return CS.runKernel("Add",{a:t,b:e})}function NS(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ES(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const TS=Ek();function AS(t,e){let n=t;if(lk(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||lk(n)&&"string"!==e;)s.push(n.length),n=n[0];return Array.isArray(t)&&Ek().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&RS(t,s,[]),s}function RS(t,e,n){if(n=n||[],!Array.isArray(t)&&!lk(t))return void V_(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);V_(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),V_(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)RS(t[r],s,n.concat(r))}function $S(t,e,n,s){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function FS(t,e,n,s="numeric"){if(t instanceof iS)return $S(s,t.dtype,e,n),t;let r=fk(t);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),$S(s,r,e,n),null==t||!lk(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const i=AS(t,r);lk(t)||Array.isArray(t)||(t=[t]);const a="string"!==r?Wk(t,r):j_(t,[],!0);return CS.makeTensor(a,i,r)}function DS(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>FS(t,`${e}[${r}]`,n,s))}function OS(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...t)=>{CS.startScope(n);try{const e=s(...t);return Ik(e)&&console.error("Cannot return a Promise inside of tidy."),CS.endScope(e),e}catch(e){throw CS.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}TS.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),TS.registerFlag("IS_BROWSER",()=>ES()),TS.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),TS.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),TS.registerFlag("PROD",()=>!1),TS.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>TS.getBool("DEBUG")),TS.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),TS.registerFlag("IS_TEST",()=>!1),TS.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),TS.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const LS=OS({complex_:function(t,e){const n=FS(t,"real","complex"),s=FS(e,"imag","complex");return W_(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),CS.runKernel("Complex",{real:n,imag:s})}});function MS(t,e,n,s){if(null==s&&(s=fk(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!lk(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){kk(e);const t=H_(e),s=H_(n);V_(t===s,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${s}`);for(let r=0;r<n.length;++r){const t=n[r],s=r!==n.length-1||t!==H_(e.slice(r));V_(n[r]===e[r]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return lk(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?Wk(t,s):j_(t,[],!0),CS.makeTensor(t,e,s)}function PS(t,e,n){return MS(t,e,AS(t,n),n)}const zS={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function BS(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let i=0;i<r.length;++i){const a=r[i],o=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const t=new Promise(async t=>{const e=await o.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,s=new Uint8Array(n);let r=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);s.set(n,r),r+=4,s.set(t,r),r+=t.length}t(s)});s.push(t)}else s.push(o.data());null!=e&&(l.group=e),n.push(l)}return{data:WS(await Promise.all(s)),specs:n}}function VS(t,e){const n={};let s,r=0;for(const i of e){const e=i.name,a=i.dtype,o=i.shape,l=H_(o);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const o=zS[n.dtype],c=t.slice(r,r+l*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++)u[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=KS()),u=s(h)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++)u[t]=Math.round(h[t]*n.scale+n.min)}r+=l*o}else if("string"===a){const e=H_(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(r,r+4))[0];r+=4;const n=new Uint8Array(t.slice(r,r+e));u.push(n),r+=e}}else{const s=zS[a],i=t.slice(r,r+l*s);if("float32"===a)u=new Float32Array(i);else if("int32"===a)u=new Int32Array(i);else if("bool"===a)u=new Uint8Array(i);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);{u=new Float32Array(i);const t=new Float32Array(u.length/2),s=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],s[e]=u[2*e+1];const r=PS(t,o,"float32"),a=PS(s,o,"float32");n[e]=LS(r,a),r.dispose(),a.dispose()}}r+=l*s}"complex64"!==a&&(n[e]=PS(u,o,a))}return n}function WS(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(t=>{s.set(new Uint8Array(t.buffer),r),r+=t.byteLength}),s.buffer}const US="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function jS(t){return US?Buffer.byteLength(t):new Blob([t]).size}function HS(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let s=0;return t.forEach(t=>{n.set(new Uint8Array(t),s),s+=t.byteLength}),n.buffer}function GS(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function qS(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:jS(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:jS(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function KS(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const r=s[a];i[a]=t[n[r>>10]+(1023&r)]+e[r>>10]}return new Float32Array(r)}}class XS{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==XS.instance&&(XS.instance=new XS),XS.instance}static registerSaveRouter(t){XS.getInstance().saveRouters.push(t)}static registerLoadRouter(t){XS.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return XS.getHandlers(t,"save")}static getLoadHandlers(t,e){return XS.getHandlers(t,"load",e)}static getHandlers(t,e,n){const s=[];return("load"===e?XS.getInstance().loadRouters:XS.getInstance().saveRouters).forEach(e=>{const r=e(t,n);null!==r&&s.push(r)}),s}}const QS=t=>XS.registerSaveRouter(t),YS=t=>XS.registerLoadRouter(t),ZS=t=>XS.getSaveHandlers(t),JS=(t,e)=>XS.getLoadHandlers(t,e);function tC(){if(!Ek().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function eC(t){const e=t.result;e.createObjectStore("models_store",{keyPath:"modelPath"}),e.createObjectStore("model_info_store",{keyPath:"modelPath"})}class nC{constructor(t){if(this.indexedDB=tC(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const s=this.indexedDB.open("tensorflowjs",1);s.onupgradeneeded=()=>eC(s),s.onsuccess=()=>{const r=s.result;if(null==e){const e=r.transaction("models_store","readonly"),s=e.objectStore("models_store").get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(s.result.modelArtifacts)},s.onerror=t=>(r.close(),n(s.error)),e.oncomplete=()=>r.close()}else{const s=qS(e),i=r.transaction("model_info_store","readwrite");let a=i.objectStore("model_info_store");const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:s});let l;o.onsuccess=()=>{l=r.transaction("models_store","readwrite");const o=l.objectStore("models_store").put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:s});o.onsuccess=()=>t({modelArtifactsInfo:s}),o.onerror=t=>{a=i.objectStore("model_info_store");const e=a.delete(this.modelPath);e.onsuccess=()=>(r.close(),n(o.error)),e.onerror=t=>(r.close(),n(o.error))}},o.onerror=t=>(r.close(),n(o.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},s.onerror=t=>n(s.error)})}}nC.URL_SCHEME="indexeddb://";const sC=t=>{return Ek().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(nC.URL_SCHEME)?(e=t.slice(nC.URL_SCHEME.length),new nC(e)):null;var e};XS.registerSaveRouter(sC),XS.registerLoadRouter(sC);class rC{constructor(){this.indexedDB=tC()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open("tensorflowjs",1);n.onupgradeneeded=()=>eC(n),n.onsuccess=()=>{const s=n.result,r=s.transaction("model_info_store","readonly"),i=r.objectStore("model_info_store").getAll();i.onsuccess=()=>{const e={};for(const t of i.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},i.onerror=t=>(s.close(),e(i.error)),r.oncomplete=()=>s.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(nC.URL_SCHEME)?e.slice(nC.URL_SCHEME.length):e,new Promise((e,n)=>{const s=this.indexedDB.open("tensorflowjs",1);s.onupgradeneeded=()=>eC(s),s.onsuccess=()=>{const r=s.result,i=r.transaction("model_info_store","readwrite"),a=i.objectStore("model_info_store"),o=a.get(t);let l;o.onsuccess=()=>{if(null==o.result)return r.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const s=a.delete(t),i=()=>{l=r.transaction("models_store","readwrite");const s=l.objectStore("models_store").delete(t);s.onsuccess=()=>e(o.result.modelArtifactsInfo),s.onerror=t=>n(o.error)};s.onsuccess=i,s.onerror=t=>(i(),r.close(),n(o.error))}},o.onerror=t=>(r.close(),n(o.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},s.onerror=t=>n(s.error)})}}const iC="tensorflowjs_models",aC="info",oC="model_topology",lC="weight_specs",uC="weight_data",cC="model_metadata";function hC(t){return{info:[iC,t,aC].join("/"),topology:[iC,t,oC].join("/"),weightSpecs:[iC,t,lC].join("/"),weightData:[iC,t,uC].join("/"),modelMetadata:[iC,t,cC].join("/")}}function dC(t){const e=t.split("/");if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join("/")}class pC{constructor(t){if(!Ek().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=hC(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=qS(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,function(t){if(US)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}(t.weightData));const e={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(e)),{modelArtifactsInfo:r}}catch(e){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=s;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const t=JSON.parse(r);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(US){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}(i),e}}pC.URL_SCHEME="localstorage://";const fC=t=>{return Ek().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(pC.URL_SCHEME)?(e=t.slice(pC.URL_SCHEME.length),new pC(e)):null;var e};XS.registerSaveRouter(fC),XS.registerLoadRouter(fC);class mC{constructor(){V_(Ek().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),V_("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=iC+"/",n="/"+aC;for(let s=0;s<this.LS.length;++s){const r=this.LS.key(s);r.startsWith(e)&&r.endsWith(n)&&(t[dC(r)]=JSON.parse(this.LS.getItem(r)))}return t}async removeModel(t){var e;const n=hC(t=(e=t).startsWith(pC.URL_SCHEME)?e.slice(pC.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),s}}class gC{constructor(){this.managers={}}static getInstance(){return null==gC.instance&&(gC.instance=new gC),gC.instance}static registerManager(t,e){V_(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),V_(t.length>0,()=>"scheme must not be an empty string.");const n=gC.getInstance();V_(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function yC(t){if(-1===t.indexOf("://"))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${gC.getSchemes().join(",")}`);return{scheme:t.split("://")[0],path:t.split("://")[1]}}async function bC(t,e,n=!1){V_(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=XS.getLoadHandlers(t);V_(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),V_(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],i=XS.getSaveHandlers(e);V_(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),V_(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=i[0],o=yC(t).scheme,l=yC(t).path,u=o===yC(t).scheme,c=await r.load();n&&u&&await gC.getManager(o).removeModel(l);const h=await a.save(c);return n&&!u&&await gC.getManager(o).removeModel(l),h.modelArtifactsInfo}async function xC(){const t=gC.getSchemes(),e={};for(const n of t){const t=await gC.getManager(n).listModels();for(const s in t)e[n+"://"+s]=t[s]}return e}async function vC(t){const e=yC(t);return gC.getManager(e.scheme).removeModel(e.path)}async function wC(t,e){return bC(t,e,!1)}async function _C(t,e){return bC(t,e,!0)}class kC{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Ek().get("IS_BROWSER")){Ek().setPlatform("browser",new kC);try{gC.registerManager(pC.URL_SCHEME,new mC)}catch(dY){}try{gC.registerManager(nC.URL_SCHEME,new rC)}catch(dY){}}let SC;function CC(t,e="float32",n){return e=e||"float32",kk(t),new eS(t,e,n)}Ek().get("IS_NODE")&&Ek().setPlatform("node",new class{constructor(){this.util=n(2),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Ek().global.fetch?Ek().global.fetch(t,e):(null==SC&&(SC=n(1)),SC(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const IC=OS({cast_:function(t,e){const n=FS(t,"x","cast");if(!ak(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return CS.runKernel("Cast",{x:n},{dtype:e})}}),NC=OS({clone_:function(t){const e=FS(t,"x","clone","string_or_numeric");return CS.runKernel("Identity",{x:e})}});function EC(t){return new Promise(t=>setTimeout(t)).then(t)}SS(),sS={buffer:CC,cast:IC,clone:NC,print:function(t,e=!1){console.log(t.toString(e))}};class TC{constructor(t){if(!Ek().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(TC.URL_SCHEME)&&(t=t.slice(TC.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]};null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),r=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(r.download=this.modelTopologyFileName,r.href=s,await EC(()=>r.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await EC(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:qS(t)}}}}TC.URL_SCHEME="downloads://";class AC{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise((n,s)=>{const r=new FileReader;r.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(null==a)return void s(new Error(`modelTopology field is missing from file ${t.name}`));0===e.length&&n({modelTopology:a});const o=i.weightsManifest;if(null==o)return void s(new Error(`weightManifest field is missing from file ${t.name}`));let l;try{l=this.checkManifestAndWeightFiles(o,e)}catch(dY){return void s(dY)}const u=[],c=[],h=[];o.forEach(t=>{t.paths.forEach(t=>{c.push(t),h.push(null)}),u.push(...t.weights)}),o.forEach(t=>{t.paths.forEach(t=>{const e=new FileReader;e.onload=e=>{const s=e.target.result,r=c.indexOf(t);if(h[r]=s,-1===h.indexOf(null)){const t={modelTopology:a,weightSpecs:u,weightData:HS(h),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy};null!=i.signature&&(t.signature=i.signature),null!=i.userDefinedMetadata&&(t.userDefinedMetadata=i.userDefinedMetadata),null!=i.modelInitializer&&(t.modelInitializer=i.modelInitializer),n(t)}},e.onerror=e=>s(`Failed to weights data from file of path '${t}'.`),e.readAsArrayBuffer(l[t])})})},r.onerror=e=>s(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(t)})}checkManifestAndWeightFiles(t,e){const n=[],s=e.map(t=>GS(t.name)),r={};for(const i of t)i.paths.forEach(t=>{const i=GS(t);if(-1!==n.indexOf(i))throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),-1===s.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);r[t]=e[s.indexOf(i)]});if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return r}}function RC(t){return new AC(t)}function $C(t,e,n,s){!function(t){V_(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){V_(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),V_(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),V_(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(t.map(i=>(i.then(i=>{const a=n+ ++r/t.length*(s-n);return e(a),i}),i)))}async function FC(t,e){null==e&&(e={});const n=null==e.fetchFunc?Ek().platform.fetch:e.fetchFunc,s=t.map(t=>n(t,e.requestInit,{isBinary:!0})),r=(null==e.onProgress?await Promise.all(s):await $C(s,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(r):await $C(r,e.onProgress,.5,1)}async function DC(t,e="",n,s){return OC(t=>FC(t,{requestInit:s}))(t,e,n)}function OC(t){return async(e,n="",s)=>{const r=e.map(()=>!1),i={},a=null!=s?s.map(()=>!1):[],o=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l=zS["quantization"in t?t.quantization.dtype:t.dtype]*H_(t.shape),u=()=>{r[e]=!0,null==i[e]&&(i[e]=[]),i[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=s?s.forEach((e,n)=>{e===t.name&&(u(),a[n]=!0)}):u(),o.push(t.name),n+=l})}),!a.every(t=>t)){const t=s.filter((t,e)=>!a[e]);throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((t,e,n)=>(e&&t.push(n),t),[]),u=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)})});const c=await t(u),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let s=0;for(let e=0;e<n;e++)s+=c[d+e].byteLength;const r=new ArrayBuffer(s),a=new Uint8Array(r);let o=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[d+e]);a.set(t,o),o+=t.byteLength}i[t].forEach(t=>{const e=VS(r.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const n in e)h[n]=e[n]}),d+=n}),h}}XS.registerSaveRouter(t=>Ek().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(TC.URL_SCHEME)?function(t="model"){return new TC(t)}(t.slice(TC.URL_SCHEME.length)):null);class LC{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(V_("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Ek().platform.fetch,V_(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&V_(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]};null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:qS(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(p){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=e.modelTopology,s=e.weightsManifest,r=e.generatedBy,i=e.convertedBy,a=e.format,o=e.signature,l=e.userDefinedMetadata;if(null==n&&null==s)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,c;if(null!=s){const t=await this.loadWeights(s);[u,c]=t}const h={modelTopology:n,weightSpecs:u,weightData:c,generatedBy:r,convertedBy:i,format:a};null!=o&&(h.signature=o),null!=l&&(h.userDefinedMetadata=l);const d=e.modelInitializer;return d&&(h.modelInitializer=d),h}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,s]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),r=this.weightPathPrefix||n,i=[];for(const l of t)i.push(...l.weights);const a=[],o=[];for(const l of t)for(const t of l.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):a.push(r+t+s);return this.weightUrlConverter&&a.push(...await Promise.all(o)),[i,HS(await FC(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function MC(t){return null!=t.match(LC.URL_SCHEME_REGEX)}LC.URL_SCHEME_REGEX=/^https?:\/\//;const PC=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>MC(t)):MC(t),n)return zC(t,e)}return null};function zC(t,e){return new LC(t,e)}function BC(t,e){return zC(t,e)}XS.registerSaveRouter(PC),XS.registerLoadRouter(PC);class VC{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class WC{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function UC(t,e,n,s){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new VC(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new VC({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new VC({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function jC(t){return new WC(t)}let HC;function GC(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)s=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else if(null!=t.getContext)a=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);o=!0}if(r){const e=2;if(r&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Ok("FromPixels",CS.backendName))return CS.runKernel("FromPixels",{pixels:t},{numChannels:e});const[l,u]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,h;if(a?c=t.getContext("2d").getImageData(0,0,l,u).data:s||n?c=t.data:(i||r||o)&&(null==HC&&(HC=document.createElement("canvas").getContext("2d")),HC.canvas.width=l,HC.canvas.height=u,HC.drawImage(t,0,0,l,u),c=HC.getImageData(0,0,l,u).data),4===e)h=new Int32Array(c);else{const t=l*u;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=c[4*n+t]}return function(t,e,n){if(U_(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const s=AS(t,"int32");if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return MS(t,e,s,"int32")}(h,[u,l,e])}async function qC(t,e=3){let n=null;if(Ek().getBool("WRAP_TO_IMAGEBITMAP")&&function(t){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(t instanceof ImageBitmap)&&function(t){return null!=t&&0!==t.width&&0!==t.height}(t)&&!function(t){return null!=t&&t.data instanceof Uint8Array}(t)}(t)){let e;try{e=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch(s){e=null}n=null!=e&&e.width===t.width&&e.height===t.height?e:t}else n=t;return GC(n,e)}async function KC(t,e){let n=FS(t,"img","toPixels");if(!(t instanceof iS)){const t=n;n=IC(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[s,r]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${i}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const t=[0,0,0,255];for(let s=0;s<i;s++){const e=a[u*i+s];if("float32"===n.dtype){if(e<0||e>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===n.dtype&&(e<0||e>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===i?(t[0]=e*o,t[1]=e*o,t[2]=e*o):t[s]=e*o}const e=4*u;l[e+0]=Math.round(t[0]),l[e+1]=Math.round(t[1]),l[e+2]=Math.round(t[2]),l[e+3]=Math.round(t[3])}if(null!=e){e.width=r,e.height=s;const t=e.getContext("2d"),n=new ImageData(l,r,s);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l}const XC=OS({fromPixels_:GC});function QC(t,e,n){const s=t.shape.length;V_(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),V_(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)V_(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function YC(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function ZC(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function JC(t,e,n,s){const r=[...t];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)0===i?r[e]=1:(r.splice(e,0,1),r.pop());return r}function tI(t,e,n){return n<=t?n:n-(e-1)}function eI(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function nI(t,e,n,s,r,i,a,o,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;c=sI(a,l,u,s,t),h=rI(o,l,u,r,t),d=JC(i,l,u,t)}else for(let p=0;p<u;p++)c[p]=aI(a,s,i,t,p,l),h[p]=oI(o,r,i,t,p,l),d[p]=iI(i,p,l);return{begin:c,end:h,strides:d}}function sI(t,e,n,s,r){const i=[...r],a=eI(n,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const r=tI(e,n,o);let a=s[r];t&1<<r&&(a=0),i[o]=a}return i}function rI(t,e,n,s,r){const i=[...r],a=eI(n,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const r=tI(e,n,o);let a=s[r];t&1<<r&&(a=Number.MAX_SAFE_INTEGER),i[o]=a}for(let o=0;o<i.length;o++){const t=r[o];i[o]<0&&(i[o]+=t),i[o]=L_(0,i[o],r[o])}return i}function iI(t,e,n){let s=t[e];return(n&1<<e||null==s)&&(s=1),s}function aI(t,e,n,s,r,i){let a=e[r];(t&1<<r||i&1<<r||null==a)&&(a=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=s[r];return a<0&&(a+=o),a=L_(0,a,o-1),a}function oI(t,e,n,s,r,i){let a=e[r];const o=n[r]||1;(t&1<<r||i&1<<r||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=o>0?L_(0,a,l):L_(-1,a,l-1),a}function lI(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function uI(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function cI(t,e,n){let s;const r=t.shape.length;let i;return s="number"==typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),s.forEach(t=>{V_(-1!==t,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,i=i.map((e,n)=>e>=0?e:(V_(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-s[n])),[s,i]}function hI(t,e,n,s,r,i,a,o,l){let u=e.slice(),c=n.slice(),h=s;null==s&&(h=new Array(u.length));const d=YC(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==a&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==a&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=t.length-u.length,f=YC(o),m=t.slice();f.forEach(t=>{u[t]=0,c[t]=1,m.splice(t,0,1)});const{begin:g,end:y,strides:b}=nI(m,d,p,u,c,h,r,i,a);u=g,c=y,h=b;const x=YC(l);x.forEach(t=>{c[t]=u[t]+1,h[t]=1});const v=ZC(u,c,h),w=v.filter((t,e)=>-1===x.indexOf(e));return{nonStrided:h.every(t=>1===t),$begin:u,$end:c,$strides:h,size:v,newShape:m,outShape:w}}class dI{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class pI{constructor(){this.classNameMap={}}static getMap(){return null==pI.instance&&(pI.instance=new pI),pI.instance}static register(t){pI.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function fI(t){V_(null!=t.className,()=>"Class being registered does not have the static className property defined."),V_("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),V_(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),pI.register(t)}function mI(){return CS}function gI(){return CS.memory()}function yI(t,e){return CS.tidy(t,e)}function bI(t){xS(t).forEach(t=>t.dispose())}function xI(t){return CS.keep(t)}function vI(t,e,n=1){return CS.registerBackend(t,e,n)}function wI(t){return CS.customGrad(t)}function _I(t,e){if((lk(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&lk(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return MS(t,[],[],e)}rS=function(t){Ek().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class kI extends dI{minimize(t,e=!1,n){const{value:s,grads:r}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:r[t.name]}));this.applyGradients(t)}else this.applyGradients(r);return bI(r),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){V_(mk(t),()=>"The f passed in variableGrads(f) must be a function"),V_(null==e||Array.isArray(e)&&e.every(t=>t instanceof oS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in CS.registeredVariables)e.push(CS.registeredVariables[t])}const s=n?e.filter(t=>!t.trainable):null,r=e.length;V_((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:i,grads:a}=CS.gradients(t,e,null,!0);V_(a.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),V_(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const o={};return e.forEach((t,e)=>{null!=a[e]&&(o[t.name]=a[e])}),null!=s&&s.forEach(t=>o[t.name]=null),{value:i,grads:o}}(t,e)}dispose(){null!=this.iterations_&&bI(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:_I(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(kI,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const SI=OS({abs_:function(t){const e=FS(t,"x","abs");return CS.runKernel("complex64"===e.dtype?"ComplexAbs":"Abs",{x:e})}}),CI=OS({add_:function(t,e){let n=FS(t,"a","add"),s=FS(e,"b","add");return[n,s]=gS(n,s),CS.runKernel("Add",{a:n,b:s})}}),II=OS({all_:function(t,e=null,n=!1){const s=FS(t,"x","all","bool");return CS.runKernel("All",{x:s},{axis:e,keepDims:n})}}),NI=OS({any_:function(t,e=null,n=!1){const s=FS(t,"x","any","bool");return CS.runKernel("Any",{x:s},{axis:e,keepDims:n})}}),EI=OS({argMax_:function(t,e=0){const n=FS(t,"x","argMax");return CS.runKernel("ArgMax",{x:n},{axis:e})}});function TI(t,e,n,s,r="NHWC",i){return $I(t,[...e,t[3]],n,i,s,null,null,VI(r))}function AI(t,e,n,s,r,i,a="channelsLast"){const[o,l]=OI(e);let u;if("channelsLast"===a)u=[o,l,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[o,l,t[1],t[1]]}return $I(t,u,n,s,r,i,!1,a)}function RI(t,e,n,s,r,i,a="NDHWC"){const[o,l,u]=LI(e);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,l,u,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,l,u,t[1],t[1]]}return FI(t,c,n,s,r,!1,h,i)}function $I(t,e,n,s,r,i,a=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=OI(n),[y,b]=OI(s),x=MI(d,y),v=MI(p,b),{padInfo:w,outHeight:_,outWidth:k}=function(t,e,n,s,r,i,a,o,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=function(t,e,n,s,r){null==s&&(s=DI(t,e,n));const i=t[1];return[PI((t[0]-e+2*s)/n+1,r),PI((i-e+2*s)/n+1,r)]}([e,n],i,s,t,o);c=r[0],h=r[1]}else if("same"===t){c=Math.ceil(e/s),h=Math.ceil(n/r);const t=Math.max(0,(c-1)*s+i-e),o=Math.max(0,(h-1)*r+a-n),l=Math.floor(t/2),d=t-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/s),h=Math.ceil((n-a+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=PI((e-i+d+p)/s+1,o),h=PI((n-a+f+m)/r+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(r,u,c,m,g,x,v,i,o),S=a?f*h:f;let C;return"channelsFirst"===o?C=[l,S,_,k]:"channelsLast"===o&&(C=[l,_,k,S]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:_,outWidth:k,outChannels:S,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:t,outShape:C,filterShape:e}}function FI(t,e,n,s,r,i=!1,a="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[y,b,x]=LI(n),[v,w,_]=LI(s),k=MI(p,v),S=MI(f,w),C=MI(m,_),{padInfo:I,outDepth:N,outHeight:E,outWidth:T}=function(t,e,n,s,r,i,a,o,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,s,r,i){null==r&&(r=DI(t,e,s));const a=t[1],o=t[2];return[PI((t[0]-e+2*r)/s+1,i),PI((a-e+2*r)/s+1,i),PI((o-e+2*r)/s+1,i),1]}([e,n,s,1],o,0,r,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/r),p=Math.ceil(n/i),f=Math.ceil(s/a);const t=(d-1)*r+o-e,c=(p-1)*i+l-n,m=(f-1)*a+u-s,g=Math.floor(t/2),y=t-g,b=Math.floor(c/2),x=c-b,v=Math.floor(m/2);h={top:b,bottom:x,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-o+1)/r),p=Math.ceil((n-l+1)/i),f=Math.ceil((s-u+1)/a)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,u,c,h,y,b,x,k,S,C,o),A=i?g*d:g;let R;return"channelsFirst"===a?R=[l,A,N,E,T]:"channelsLast"===a&&(R=[l,N,E,T,A]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:N,outHeight:E,outWidth:T,outChannels:A,padInfo:I,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:S,effectiveFilterWidth:C,dilationDepth:v,dilationHeight:w,dilationWidth:_,inShape:t,outShape:R,filterShape:e}}function DI(t,e,n,s=1){const r=MI(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function OI(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function LI(t){return"number"==typeof t?[t,t,t]:t}function MI(t,e){return e<=1?t:t+(t-1)*(e-1)}function PI(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function zI(t){const[e,n,s]=OI(t);return 1===e&&1===n&&1===s}function BI(t,e){return zI(t)||zI(e)}function VI(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const WI=OS({reshape_:function(t,e){const n=FS(t,"x","reshape","string_or_numeric");return CS.runKernel("Reshape",{x:n},{shape:e})}}),UI=OS({avgPool_:function(t,e,n,s,r){const i=FS(t,"x","avgPool","float32");V_(BI(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let a=i,o=!1;3===i.rank&&(o=!0,a=WI(i,[1,i.shape[0],i.shape[1],i.shape[2]])),V_(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),null!=r&&V_(K_(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let l=CS.runKernel("AvgPool",{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return l=IC(l,i.dtype),o?WI(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),jI=OS({avgPool3d_:function(t,e,n,s,r,i="NDHWC"){const a=FS(t,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=WI(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),V_(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),V_("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&V_(K_(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let u=CS.runKernel("AvgPool3D",{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return u=IC(u,o.dtype),l?WI(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),HI=OS({batchNorm_:function(t,e,n,s,r,i){null==i&&(i=.001);const a=FS(t,"x","batchNorm"),o=FS(e,"mean","batchNorm"),l=FS(n,"variance","batchNorm");let u,c;null!=r&&(u=FS(r,"scale","batchNorm")),null!=s&&(c=FS(s,"offset","batchNorm")),V_(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),V_(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),V_(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?WI(t,[1,1,1,t.size]):2===t.rank?WI(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?WI(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(a),d=CS.runKernel("FusedBatchNorm",{x:h,scale:u,offset:c,mean:o,variance:l},{varianceEpsilon:i});return WI(d,a.shape)}}),GI=OS({batchNorm2d_:function(t,e,n,s,r,i){const a=FS(t,"x","batchNorm"),o=FS(e,"mean","batchNorm"),l=FS(n,"variance","batchNorm");let u,c;return null!=r&&(u=FS(r,"scale","batchNorm")),null!=s&&(c=FS(s,"offset","batchNorm")),V_(2===a.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),V_(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),V_(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&V_(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&V_(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),HI(a,o,l,c,u,i)}}),qI=OS({batchNorm3d_:function(t,e,n,s,r,i){const a=FS(t,"x","batchNorm"),o=FS(e,"mean","batchNorm"),l=FS(n,"variance","batchNorm");let u,c;return null!=r&&(u=FS(r,"scale","batchNorm")),null!=s&&(c=FS(s,"offset","batchNorm")),V_(3===a.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),V_(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),V_(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&V_(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&V_(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),HI(a,o,l,c,u,i)}}),KI=OS({batchNorm4d_:function(t,e,n,s,r,i){const a=FS(t,"x","batchNorm"),o=FS(e,"mean","batchNorm"),l=FS(n,"variance","batchNorm");let u,c;return null!=r&&(u=FS(r,"scale","batchNorm")),null!=s&&(c=FS(s,"offset","batchNorm")),V_(4===a.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),V_(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),V_(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&V_(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&V_(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),HI(a,o,l,c,u,i)}}),XI=OS({clipByValue_:function(t,e,n){const s=FS(t,"x","clipByValue");return V_(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),CS.runKernel("ClipByValue",{x:s},{clipValueMin:e,clipValueMax:n})}}),QI=OS({concat_:function(t,e=0){V_(t.length>=1,()=>"Pass at least one tensor to concat");const n=DS(t,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}),1===n.length?NC(n[0]):CS.runKernel("Concat",n,{axis:e})}}),YI=OS({concat1d_:function(t){return QI(t,0)}}),ZI=OS({concat2d_:function(t,e){return QI(t,e)}}),JI=OS({concat3d_:function(t,e){return QI(t,e)}}),tN=OS({concat4d_:function(t,e){return QI(t,e)}}),eN=OS({conv2d_:function(t,e,n,s,r="NHWC",i=[1,1],a){const o=FS(t,"x","conv2d"),l=FS(e,"filter","conv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=WI(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V_(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),V_(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=a&&V_(K_(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h="NHWC"===r?u.shape[3]:u.shape[1];V_(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),V_(BI(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=CS.runKernel("Conv2D",{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a});return c?WI(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),nN=OS({conv1d_:function(t,e,n,s,r="NWC",i=1,a){const o=FS(t,"x","conv1d"),l=FS(e,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=WI(o,[1,o.shape[0],o.shape[1]])),V_(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),V_(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=a&&V_(K_(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),V_(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),V_(BI(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),V_("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=WI(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=WI(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=eN(d,h,[1,n],s,"NHWC",[1,i],a);return WI(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),sN=OS({conv2DBackpropInput_:function(t,e,n,s,r,i="NHWC",a){V_(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,l=e,u=!1;3===e.rank&&(u=!0,l=WI(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),V_(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),V_(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),V_(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===i?o[3]:o[1],h="NHWC"===i?l.shape[3]:l.shape[1];V_(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),V_(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=a&&V_(K_(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const d=CS.runKernel("Conv2DBackpropInput",{dy:l,filter:n},{strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o});return u?WI(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),rN=OS({conv2dTranspose_:function(t,e,n,s,r,i){const a=FS(t,"x","conv2dTranspose"),o=FS(e,"filter","conv2dTranspose");return sN(n,a,o,s,r,"NHWC",i)}}),iN=OS({conv3d_:function(t,e,n,s,r="NDHWC",i=[1,1,1]){const a=FS(t,"x","conv3d"),o=FS(e,"filter","conv3d");let l=a,u=!1;4===a.rank&&(u=!0,l=WI(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),V_(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),V_(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),V_(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),V_(BI(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),V_("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c=CS.runKernel("Conv3D",{x:l,filter:o},{strides:n,pad:s,dataFormat:r,dilations:i});return u?WI(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),aN=OS({depthwiseConv2d_:function(t,e,n,s,r="NHWC",i=[1,1],a){const o=FS(t,"x","depthwiseConv2d"),l=FS(e,"filter","depthwiseConv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=WI(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V_(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),V_(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),V_(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=a&&V_(K_(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h=CS.runKernel("DepthwiseConv2dNative",{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a});return c?WI(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),oN=OS({floorDiv_:function(t,e){let n=FS(t,"a","floorDiv"),s=FS(e,"b","floorDiv");return[n,s]=gS(n,s),CS.runKernel("FloorDiv",{a:n,b:s})}}),lN=OS({div_:function(t,e){let n=FS(t,"a","div"),s=FS(e,"b","div");return[n,s]=gS(n,s),"int32"===n.dtype&&"int32"===s.dtype?oN(n,s):CS.runKernel("RealDiv",{a:n,b:s},{})}}),uN=OS({elu_:function(t){const e=FS(t,"x","elu");return CS.runKernel("Elu",{x:e})}});function cN(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,a=t[i]||1;(e[e.length-1-r]||1)>1&&1===a&&s.unshift(i)}return s}function hN(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],i=e.length-s-1,a=e[i];(null==r||1===r&&a>1)&&n.unshift(i)}return n}function dN(t,e){const n=[],s=Math.max(t.length,e.length);for(let r=0;r<s;r++){let s=t[t.length-r-1];null==s&&(s=1);let i=e[e.length-r-1];if(null==i&&(i=1),1===s)n.unshift(i);else if(1===i)n.unshift(s);else{if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(s)}}return n}const pN=OS({equal_:function(t,e){let n=FS(t,"a","equal"),s=FS(e,"b","equal");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("Equal",{a:n,b:s})}}),fN=OS({expandDims_:function(t,e=0){const n=FS(t,"x","expandDims","string_or_numeric");return V_(e<=n.rank,()=>"Axis must be <= rank of the tensor"),CS.runKernel("ExpandDims",{input:n},{dim:e})}}),mN=OS({tile_:function(t,e){const n=FS(t,"x","tile","string_or_numeric");return V_(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),CS.runKernel("Tile",{x:n},{reps:e})}}),gN=OS({eye_:function(t,e,n,s="float32"){null==e&&(e=t);const r=CC([t,e],s),i=t<=e?t:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=WI(r.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return mN(fN(a,0),[n[0],1,1]);if(2===n.length)return mN(fN(fN(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return mN(fN(fN(fN(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function yN(t,e,n){return CS.runKernel("Fill",{},{shape:t,value:e,dtype:n})}const bN=OS({floor_:function(t){const e=FS(t,"x","floor");return CS.runKernel("Floor",{x:e})}}),xN=OS({gather_:function(t,e,n=0,s=0){const r=FS(t,"x","gather"),i=FS(e,"indices","gather","int32");return CS.runKernel("GatherV2",{x:r,indices:i},{axis:n,batchDims:s})}}),vN=OS({greater_:function(t,e){let n=FS(t,"a","greater"),s=FS(e,"b","greater");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("Greater",{a:n,b:s})}}),wN=OS({greaterEqual_:function(t,e){let n=FS(t,"a","greaterEqual"),s=FS(e,"b","greaterEqual");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("GreaterEqual",{a:n,b:s})}}),_N=OS({leakyRelu_:function(t,e=.2){const n=FS(t,"x","leakyRelu");return CS.runKernel("LeakyRelu",{x:n},{alpha:e})}}),kN=OS({log_:function(t){const e=FS(t,"x","log");return CS.runKernel("Log",{x:e})}}),SN=OS({exp_:function(t){const e=FS(t,"x","exp");return CS.runKernel("Exp",{x:e})}}),CN=OS({max_:function(t,e=null,n=!1){const s=FS(t,"x","max");return CS.runKernel("Max",{x:s},{reductionIndices:e,keepDims:n})}}),IN=OS({mul_:function(t,e){let n=FS(t,"a","mul"),s=FS(e,"b","mul");return[n,s]=gS(n,s),CS.runKernel("Multiply",{a:n,b:s})}}),NN=OS({sub_:function(t,e){let n=FS(t,"a","sub"),s=FS(e,"b","sub");return[n,s]=gS(n,s),CS.runKernel("Sub",{a:n,b:s})}}),EN=OS({sum_:function(t,e=null,n=!1){let s=FS(t,"x","sum");return"bool"===s.dtype&&(s=IC(s,"int32")),CS.runKernel("Sum",{x:s},{axis:e,keepDims:n})}}),TN=OS({logSoftmax_:function(t,e=-1){const n=FS(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return wI((t,n)=>{const s=CN(t,e,!0),r=NN(t,s),i=NN(IC(r,"float32"),kN(EN(SN(r),e,!0)));return n([i]),{value:i,gradFunc:(t,n)=>{const[s]=n,r=SN(s);return NN(t,IN(EN(t,e,!0),r))}}})(n)}}),AN=OS({logicalAnd_:function(t,e){const n=FS(t,"a","logicalAnd","bool"),s=FS(e,"b","logicalAnd","bool");return dN(n.shape,s.shape),CS.runKernel("LogicalAnd",{a:n,b:s})}}),RN=OS({maxPool_:function(t,e,n,s,r){const i=FS(t,"x","maxPool");let a=i,o=!1;3===i.rank&&(o=!0,a=WI(i,[1,i.shape[0],i.shape[1],i.shape[2]])),V_(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),V_(BI(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&V_(K_(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l=CS.runKernel("MaxPool",{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return o?WI(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),$N=OS({maxPool3d_:function(t,e=[1,1,1],n,s,r,i="NDHWC"){const a=FS(t,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=WI(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),V_(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),V_("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&V_(K_(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const u=CS.runKernel("MaxPool3D",{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return l?WI(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),FN=OS({maximum_:function(t,e){let n=FS(t,"a","maximum"),s=FS(e,"b","maximum");return[n,s]=gS(n,s),"bool"===n.dtype&&(n=IC(n,"int32"),s=IC(s,"int32")),dN(n.shape,s.shape),CS.runKernel("Maximum",{a:n,b:s})}}),DN=OS({mean_:function(t,e=null,n=!1){const s=FS(t,"x","mean");return CS.runKernel("Mean",{x:s},{axis:e,keepDims:n})}}),ON=OS({min_:function(t,e=null,n=!1){const s=FS(t,"x","min");return CS.runKernel("Min",{x:s},{axis:e,keepDims:n})}}),LN=OS({minimum_:function(t,e){let n=FS(t,"a","minimum"),s=FS(e,"b","minimum");return[n,s]=gS(n,s),"bool"===n.dtype&&(n=IC(n,"int32"),s=IC(s,"int32")),dN(n.shape,s.shape),CS.runKernel("Minimum",{a:n,b:s})}});function MN(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function PN(t,e,n){const s=t.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)-1===n.indexOf(o)?r.push(t[i++]):r.push(e[a++]);return r}function zN(t,e){const n=[],s=t.length;for(let r=0;r<s;r++)-1===e.indexOf(r)&&n.push(t[r]);return[n,e.map(e=>t[e])]}function BN(t,e){return PN(t,e.map(t=>1),e)}function VN(t,e,n){V_(MN(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function WN(t,e){if(MN(t,e))return null;const n=[];for(let s=0;s<e;++s)-1===t.indexOf(s)&&n.push(s);return t.forEach(t=>n.push(t)),n}function UN(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function jN(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}const HN=OS({square_:function(t){const e=FS(t,"x","square");return CS.runKernel("Square",{x:e},{})}}),GN=OS({moments_:function(t,e=null,n=!1){const s=ek(e,(t=FS(t,"x","moments")).shape),r=DN(t,s,n);let i=r.shape;n||(i=BN(r.shape,s));const a=HN(NN(IC(t,"float32"),WI(r,i)));return{mean:r,variance:DN(a,s,n)}}}),qN=OS({neg_:function(t){const e=FS(t,"x","neg");return CS.runKernel("Neg",{x:e})}}),KN=OS({notEqual_:function(t,e){let n=FS(t,"a","notEqual"),s=FS(e,"b","notEqual");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("NotEqual",{a:n,b:s})}}),XN=OS({oneHot_:function(t,e,n=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r=FS(t,"indices","oneHot","int32");return CS.runKernel("OneHot",{indices:r},{depth:e,onValue:n,offValue:s})}});function QN(t,e="float32"){if("complex64"===e){const e=QN(t,"float32"),n=QN(t,"float32");return LS(e,n)}const n=wk(H_(t),e);return CS.makeTensor(n,t,e)}function YN(t,e="float32"){if("complex64"===e){const e=YN(t,"float32"),n=QN(t,"float32");return LS(e,n)}const n=vk(H_(t),e);return CS.makeTensor(n,t,e)}const ZN=OS({onesLike_:function(t){const e=FS(t,"x","onesLike");return CS.runKernel("OnesLike",{x:e})}}),JN=OS({pad_:function(t,e,n=0){const s=FS(t,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return CS.runKernel("PadV2",{x:s},{paddings:e,constantValue:n})}}),tE=OS({pow_:function(t,e){let n=FS(t,"base","pow"),s=FS(e,"exp","pow");return[n,s]=gS(n,s),CS.runKernel("Pow",{a:n,b:s})}}),eE=OS({prelu_:function(t,e){const n=FS(t,"x","prelu"),s=FS(e,"alpha","prelu");return CS.runKernel("Prelu",{x:n,alpha:s})}});var nE=n("YSVl");class sE{constructor(t,e,n,s,r){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=r||Math.random();this.random=nE.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let s,r,i;do{s=2*this.random()-1,r=2*this.random()-1,i=s*s+r*r}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*r*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class rE{constructor(t=0,e=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=nE.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const iE=OS({randomNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new sE(e,n,s,!1,r),a=CC(t,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),aE=OS({randomUniform_:function(t,e=0,n=1,s="float32",r){const i=CC(t,s),a=new rE(e,n,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),oE=OS({relu_:function(t){const e=FS(t,"x","relu");return CS.runKernel("Relu",{x:e})}}),lE=OS({reverse_:function(t,e){const n=FS(t,"x","reverse");return CS.runKernel("Reverse",{x:n},{dims:e})}}),uE=OS({selu_:function(t){const e=FS(t,"x","selu");return CS.runKernel("Selu",{x:e})}}),cE=OS({separableConv2d_:function(t,e,n,s,r,i=[1,1],a="NHWC"){const o=FS(t,"x","separableConv2d"),l=FS(e,"depthwiseFilter","separableConv2d"),u=FS(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=WI(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");V_(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),V_(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),V_(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),V_(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),V_(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];V_(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=aN(c,l,s,r,a,i),m=eN(f,u,1,"valid",a);return h?WI(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),hE=OS({sigmoid_:function(t){const e=FS(t,"x","sigmoid");return CS.runKernel("Sigmoid",{x:e})}}),dE=OS({slice_:function(t,e,n){const s=FS(t,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return CS.runKernel("Slice",{x:s},{begin:e,size:n})}}),pE=OS({slice1d_:function(t,e,n){const s=FS(t,"x","slice1d");return V_(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),dE(s,[e],[n])}}),fE=OS({slice2d_:function(t,e,n){const s=FS(t,"x","slice2d");return V_(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),dE(s,e,n)}}),mE=OS({slice3d_:function(t,e,n){const s=FS(t,"x","slice3d");return V_(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),dE(s,e,n)}}),gE=OS({slice4d_:function(t,e,n){const s=FS(t,"x","slice4d");return V_(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),dE(s,e,n)}}),yE=OS({softmax_:function(t,e=-1){const n=FS(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return CS.runKernel("Softmax",{logits:n},{dim:e})}}),bE=OS({softplus_:function(t){const e=FS(t,"x","softplus");return CS.runKernel("Softplus",{x:e})}}),xE=OS({split_:function(t,e,n=0){const s=FS(t,"x","split");return CS.runKernel("SplitV",{x:s},{numOrSizeSplits:e,axis:n})}}),vE=OS({sqrt_:function(t){const e=FS(t,"x","sqrt");return CS.runKernel("Sqrt",{x:e})}}),wE=OS({squeeze_:function(t,e){const n=FS(t,"x","squeeze");return WI(n,nk(n.shape,e).newShape)}}),_E=OS({stack_:function(t,e=0){const n=DS(t,"tensors","stack","string_or_numeric");return V_(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&V_(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),CS.runKernel("Pack",n,{axis:e})}}),kE=OS({tanh_:function(t){const e=FS(t,"x","tanh");return CS.runKernel("Tanh",{x:e})}});function SE(t,e){U_(t);const n=AS(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return MS(t,null,n,e)}function CE(t,e,n){if(U_(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const s=AS(t,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return MS(t,e,s,n)}const IE=OS({truncatedNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new sE(e,n,s,!0,r),a=CC(t,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),NE=OS({unstack_:function(t,e=0){const n=FS(t,"x","unstack","string_or_numeric");return V_(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),CS.runKernel("Unpack",{value:n},{axis:e})}}),EE=OS({broadcastTo_:function(t,e){let n=FS(t,"broadcastTo","x");const s=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=WI(n,t)}const r=n.shape,i=Array.from(e);for(let a=e.length-1;a>=0;a--)if(r[a]===e[a])i[a]=1;else if(1!==n.shape[a])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);return 0===i.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?NC(n):CS.runKernel("Tile",{x:n},{reps:i})}}),TE=OS({where_:function(t,e,n){const s=FS(e,"a","where"),r=FS(n,"b","where"),i=FS(t,"condition","where","bool"),a=dN(s.shape,r.shape),o=EE(s,a),l=EE(r,a);return 1===i.rank&&V_(i.shape[0]===s.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==i.rank&&W_(i.shape,l.shape,"Error in where: "),CS.runKernel("Select",{condition:i,t:o,e:l})}}),AE=OS({zerosLike_:function(t){const e=FS(t,"x","zerosLike");return CS.runKernel("ZerosLike",{x:e})}}),RE=OS({transpose_:function(t,e){const n=FS(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),V_(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{V_(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1?n.clone():CS.runKernel("Transpose",{x:n},{perm:e})}}),$E=OS({dropout_:function(t,e,n,s){const r=FS(t,"x","dropout");if(V_("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),V_(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof iS?r.clone():r;const i=function(t,e){if(null==e)return t.shape.slice();if(q_(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)n.push(null==e[s]&&null!=t.shape[s]?t.shape[s]:e[s]);return n}return e}(r,n),a=1-e,o=lN(bN(CI(aE(i,0,1,"float32",s),a)),a);return IN(r,o)}}),FE=OS({imag_:function(t){const e=FS(t,"input","imag");return CS.runKernel("Imag",{input:e})}}),DE=OS({real_:function(t){const e=FS(t,"input","real");return CS.runKernel("Real",{input:e})}}),OE=OS({fft_:function(t){return V_("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),CS.runKernel("FFT",{input:t})}}),LE=OS({rfft_:function(t,e){V_("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(null!=e&&e<n){const s=t.shape.map(t=>0),i=t.shape.map(t=>t);i[t.shape.length-1]=e,r=dE(t,s,i),n=e}else if(null!=e&&e>n){const s=t.shape.map(t=>t);s[t.shape.length-1]=e-n,r=QI([t,QN(s)],t.shape.length-1),n=e}else r=t;const i=AE(r),a=WI(LS(r,i),[s,n]),o=OE(a),l=Math.floor(n/2)+1,u=DE(o),c=FE(o),h=xE(u,[l,n-l],u.shape.length-1),d=xE(c,[l,n-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,WI(LS(h[0],d[0]),p)}}),ME=OS({ifft_:function(t){return V_("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),CS.runKernel("IFFT",{input:t})}}),PE=OS({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=WI(t,[n,e]);s=ME(r)}else{const r=[n,2*(e-1)],i=WI(DE(t),[n,e]),a=WI(FE(t),[n,e]),o=lE(dE(i,[0,1],[n,e-2]),1),l=IN(lE(dE(a,[0,1],[n,e-2]),1),_I(-1)),u=QI([i,o],1),c=QI([a,l],1),h=WI(LS(u,c),[r[0],r[1]]);s=ME(h)}if(s=DE(s),3===t.rank&&0!==t.shape[0]){const e=s,n=t.shape[0];s=WI(s,[n,s.shape[0]/n,s.shape[1]]),e.dispose()}return s}}),zE=OS({conv2DBackpropFilter_:function(t,e,n,s,r,i="NHWC",a){let o=t;3===t.rank&&(o=WI(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=WI(e,[1,e.shape[0],e.shape[1],e.shape[2]])),V_(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),V_(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),V_(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return V_(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),V_(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=a&&V_(K_(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),CS.runKernel("Conv2DBackpropFilter",{x:o,dy:l},{strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:n})}}),BE=OS({relu6_:function(t){const e=FS(t,"x","relu6");return CS.runKernel("Relu6",{x:e})}}),VE=OS({step_:function(t,e=0){const n=FS(t,"x","step");return CS.runKernel("Step",{x:n},{alpha:e})}});function WE(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return IN(t,VE(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function UE(t,e){let n=e;const s=hN(t.shape,e.shape);return s.length>0&&(n=EN(n,s)),WI(n,t.shape)}function jE(t,e,n,s){if("linear"===e)return t;if("relu"===e)return oE(t);if("elu"===e)return uN(t);if("relu6"===e)return BE(t);if("prelu"===e)return eE(t,n);if("leakyrelu"===e)return _N(t,s);throw new Error(`Unknown fused activation ${e}.`)}const HE=(t,e)=>!(t>0)||"linear"===e,GE=OS({fusedConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===HE(CS.state.gradientDepth,l=l||"linear")){let h=eN(t,e,n,s,r,i,a);return null!=o&&(h=CI(h,o)),jE(h,l,u,c)}const h=FS(t,"x","conv2d"),d=FS(e,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=WI(h,[1,h.shape[0],h.shape[1],h.shape[2]])),V_(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),V_(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=a&&V_(K_(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),V_(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),V_(BI(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),V_("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=$I(p.shape,d.shape,n,i,s,a);let g,y;null!=o&&(g=FS(o,"bias","fused conv2d"),[g]=gS(g,h),dN(m.outShape,g.shape)),null!=u&&(y=FS(u,"prelu weights","fused conv2d"));const b=(t,e)=>{const[r,a,o,u]=e,c=WE(t,o,l);V_(zI(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const h=[sN(a.shape,c,r,n,s),zE(a,c,r.shape,n,s)];if(null!=u){const t=UE(u,c);h.push(t)}return h},x={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return null==o?wI((t,e,n)=>{let s=CS.runKernel("FusedConv2D",x,v);return n([e,t,s]),f&&(s=WI(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):wI((t,e,n,s)=>{let r=CS.runKernel("FusedConv2D",x,v);return s([e,t,r,n]),f&&(r=WI(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),qE=OS({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,s,r,i=[1,1],a){let o=t;3===t.rank&&(o=WI(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;return 3===l.rank&&(l=WI(e,[1,e.shape[0],e.shape[1],e.shape[2]])),CS.runKernel("DepthwiseConv2dNativeBackpropFilter",{x:o,dy:l},{strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:n})}}),KE=OS({depthwiseConv2dNativeBackpropInput_:function(t,e,n,s,r,i=[1,1],a){let o=e,l=!1;3===e.rank&&(l=!0,o=WI(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u=CS.runKernel("DepthwiseConv2dNativeBackpropInput",{dy:o,filter:n},{strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:t});return l?WI(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),XE=OS({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===HE(CS.state.gradientDepth,l)){let h=aN(t,e,n,s,r,i,a);return null!=o&&(h=CI(h,o)),jE(h,l,u,c)}const h=FS(t,"x","depthwiseConv2d"),d=FS(e,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=WI(h,[1,h.shape[0],h.shape[1],h.shape[2]])),V_(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),V_(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),V_(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==i&&(i=[1,1]),V_(BI(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=a&&V_(K_(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${s}.`);const m=$I(p.shape,d.shape,n,i,s,a,!0);let g,y;null!=o&&(g=FS(o,"bias","fused conv2d"),[g]=gS(g,h),dN(m.outShape,g.shape)),null!=u&&(y=FS(u,"prelu weights","fused depthwiseConv2d"));const b=(t,e)=>{V_(zI(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[r,o,u,c]=e,h=WE(t,u,l),d=KE(o.shape,h,r,n,s,i,a),p=qE(o,h,r.shape,n,s,i,a);return null!=c?[d,p,UE(g,h)]:[d,p]},x={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return null==o?wI((t,e,n)=>{let s=CS.runKernel("FusedDepthwiseConv2D",x,v);return n([e,t,s]),f&&(s=WI(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):wI((t,e,n,s)=>{let r=CS.runKernel("FusedDepthwiseConv2D",x,v);return s([e,t,r,n]),f&&(r=WI(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),QE=OS({matMul_:function(t,e,n=!1,s=!1){let r=FS(t,"a","matMul"),i=FS(e,"b","matMul");return[r,i]=gS(r,i),CS.runKernel("BatchMatMul",{a:r,b:i},{transposeA:n,transposeB:s})}}),YE=OS({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o}){if(!1===HE(CS.state.gradientDepth,i)){let l=QE(t,e,n,s);return null!=r&&(l=CI(l,r)),jE(l,i,a,o)}let l=FS(t,"a","fused matMul"),u=FS(e,"b","fused matMul");[l,u]=gS(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=H_(f),y=H_(m);V_(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),V_(q_(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),V_(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=l.shape.slice(0,-2).concat([d,p]),x=WI(l,n?[g,c,d]:[g,d,c]),v=WI(u,s?[y,p,h]:[y,h,p]);let w,_;null!=r&&(w=FS(r,"bias","fused matMul"),[w]=gS(w,l),dN(b,w.shape)),null!=a&&(_=FS(a,"prelu weights","fused matMul"));const k=(t,e)=>{const[a,o,l,u]=e,c=WE(WI(t,l.shape),l,i);let h,d;return n||s?!n&&s?(h=QE(c,o,!1,!1),d=QE(c,a,!0,!1)):n&&!s?(h=QE(o,c,!1,!0),d=QE(a,c,!1,!1)):(h=QE(o,c,!0,!0),d=QE(c,a,!0,!0)):(h=QE(c,o,!1,!0),d=QE(a,c,!0,!1)),null!=r?[h,d,UE(u,c)]:[h,d]},S={a:x,b:v,bias:w,preluActivationWeights:_},C={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:o};return null==r?wI((t,e,n)=>{const s=CS.runKernel("_FusedMatMul",S,C);return n([t,e,s]),{value:WI(s,b),gradFunc:k}})(x,v):wI((t,e,n,s)=>{const r=CS.runKernel("_FusedMatMul",S,C);return s([t,e,r,n]),{value:WI(r,b),gradFunc:k}})(x,v,w)}});function ZE(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let i=0;i<t;++i){const a=2*Math.PI*i/(t+s-1);r[i]=e-n*Math.cos(a)}return SE(r,"float32")}OS({hammingWindow_:function(t){return ZE(t,.54,.46)}});const JE=OS({hannWindow_:function(t){return ZE(t,.5,.5)}}),tT=OS({frame_:function(t,e,n,s=!1,r=0){let i=0;const a=[];for(;i+e<=t.size;)a.push(dE(t,i,e)),i+=n;if(s)for(;i<t.size;){const s=i+e-t.size,o=QI([dE(t,i,e-s),yN([s],r)]);a.push(o),i+=n}return 0===a.length?CE([],[0,e]):WI(QI(a),[a.length,e])}});function eT(t,e,n,s,r,i){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==i&&(i=0);const a=t.shape[0];return n=Math.min(n,a),V_(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),V_(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),V_(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),V_(1===e.rank,()=>"scores must be a 1D tensor"),V_(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),V_(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function nT(t,e,n){const s=function(t,e,n){return function(t,e,n){let s=0,r=t.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=n(e,t[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}(t,e,n||sT)}(t,e,n);t.splice(s<0?-(s+1):s,0,e)}function sT(t,e){return t>e?1:t<e?-1:0}function rT(t,e,n,s,r){return oT(t,e,n,s,r,0)}function iT(t,e,n,s,r,i){return oT(t,e,n,s,r,0,!1,i,!0)}function aT(t,e,n,s,r,i){return oT(t,e,n,s,r,i,!0)}function oT(t,e,n,s,r,i,a=!1,o=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(cT);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:a}=e;if(n<r)break;let o=!1;for(let l=h.length-1;l>=a;--l){const n=lT(t,i,h[l]);if(n>=s){o=!0;break}if(e.score=e.score*uT(s,c,n),e.score<=r)break}e.suppressBeginIndex=h.length,o||(e.score===n?(h.push(i),d.push(e.score)):e.score>r&&nT(u,e,cT))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function lT(t,e,n){const s=t.subarray(4*e,4*e+4),r=t.subarray(4*n,4*n+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(o-i)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(a,c),y=Math.min(o,h),b=Math.min(l,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function uT(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function cT(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}OS({stft_:function(t,e,n,s,r=JE){null==s&&(s=Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2)))));const i=tT(t,e,n),a=IN(i,r(e)),o=[];for(let l=0;l<i.shape[0];l++)o.push(LE(dE(a,[l,0],[1,e]),s));return QI(o)}}),OS({cropAndResize_:function(t,e,n,s,r="bilinear",i=0){const a=FS(t,"image","cropAndResize"),o=FS(e,"boxes","cropAndResize","float32"),l=FS(n,"boxInd","cropAndResize","int32"),u=o.shape[0];return V_(4===a.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),V_(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),V_(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),V_(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),V_(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),V_("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),CS.runKernel("CropAndResize",{image:a,boxes:o,boxInd:l},{method:r,extrapolationValue:i,cropSize:s})}}),OS({flipLeftRight_:function(t){const e=FS(t,"image","flipLeftRight","float32");return V_(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),CS.runKernel("FlipLeftRight",{image:e},{})}}),OS({rotateWithOffset_:function(t,e,n=0,s=.5){const r=FS(t,"image","rotateWithOffset","float32");return V_(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),CS.runKernel("RotateWithOffset",{image:r},{radians:e,fillValue:n,center:s})}}),OS({nonMaxSuppression_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=FS(t,"boxes","nonMaxSuppression"),a=FS(e,"scores","nonMaxSuppression"),o=eT(i,a,n,s,r);return CS.runKernel("NonMaxSuppressionV3",{boxes:i,scores:a},{maxOutputSize:n=o.maxOutputSize,iouThreshold:s=o.iouThreshold,scoreThreshold:r=o.scoreThreshold})}}),OS({nonMaxSuppressionWithScore_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=FS(t,"boxes","nonMaxSuppression"),o=FS(e,"scores","nonMaxSuppression"),l=eT(a,o,n,s,r,i),u=CS.runKernel("NonMaxSuppressionV5",{boxes:a,scores:o},{maxOutputSize:n=l.maxOutputSize,iouThreshold:s=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}}),OS({nonMaxSuppressionPadded_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=FS(t,"boxes","nonMaxSuppression"),o=FS(e,"scores","nonMaxSuppression"),l=eT(a,o,n,s,r,null),u=CS.runKernel("NonMaxSuppressionV4",{boxes:a,scores:o},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:u[0],validOutputs:u[1]}}});const hT=OS({resizeBilinear_:function(t,e,n=!1,s=!1){const r=FS(t,"images","resizeBilinear");V_(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),V_(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),V_(!1===s||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;3===r.rank&&(a=!0,i=WI(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,o=CS.runKernel("ResizeBilinear",{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return a?WI(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),dT=OS({resizeNearestNeighbor_:function(t,e,n=!1,s=!1){const r=FS(t,"images","resizeNearestNeighbor");V_(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),V_(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),V_("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),V_(!1===s||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;3===r.rank&&(a=!0,i=WI(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,o=CS.runKernel("ResizeNearestNeighbor",{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return a?WI(o,[o.shape[1],o.shape[2],o.shape[3]]):o}});OS({transform_:function(t,e,n="nearest",s="constant",r=0,i){const a=FS(t,"image","transform","float32"),o=FS(e,"transforms","transform","float32");return V_(4===a.rank,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),V_(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),V_(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),CS.runKernel("Transform",{image:a,transforms:o},{interpolation:n,fillMode:s,fillValue:r,outputShape:i})}});const pT=OS({lessEqual_:function(t,e){let n=FS(t,"a","lessEqual"),s=FS(e,"b","lessEqual");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("LessEqual",{a:n,b:s})}});function fT(t,e,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");return CS.runKernel("Range",{},{start:t,stop:e,step:n,dtype:s})}const mT=OS({bandPart_:function(t,e,n){V_(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),V_(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=FS(t,"a","bandPart");V_(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=i),n<0&&(n=a);const o=WI(fT(0,i,1,"int32"),[-1,1]),l=fT(0,a,1,"int32"),u=NN(o,l),c=AN(pT(u,_I(+e,"int32")),wN(u,_I(-n,"int32"))),h=QN([i,a],s.dtype);return WI(_E(NE(WI(s,[-1,i,a])).map(t=>TE(c,t,h))),r)}});function gT(t,e,n=null){if(0===t.rank)return SI(t);if(1!==t.rank&&null===n)return gT(WI(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return EN(SI(t),n);if(e===1/0)return CN(SI(t),n);if(e===-1/0)return ON(SI(t),n);if("euclidean"===e||2===e)return vE(EN(tE(SI(t),_I(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return CN(EN(SI(t),n[0]),n[1]-1);if(e===1/0)return CN(EN(SI(t),n[1]),n[0]);if(e===-1/0)return ON(EN(SI(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return vE(EN(HN(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const yT=OS({norm_:function(t,e="euclidean",n=null,s=!1){const r=gT(t=FS(t,"x","norm"),e,n);let i=r.shape;if(s){const e=ek(n,t.shape);i=BN(r.shape,e)}return WI(r,i)}}),bT=OS({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,V_(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)V_(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=xE(t,t.shape[0],0).map(t=>wE(t,[0]));V_(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(CS.tidy(()=>{let t=s[r];if(r>0)for(let e=0;e<r;++e){const s=IN(EN(IN(n[e],t)),n[e]);t=NN(t,s)}return lN(t,yT(t,"euclidean"))}));return e?_E(n,0):n}});function xT(t,e=!1){return CS.tidy(()=>{V_(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=gN(n),i=NC(t);const a=CE([[1]],[1,1]);let o=NC(a);const l=n>=s?s:n;for(let t=0;t<l;++t){const e=i,l=o,u=r;[o,i,r]=CS.tidy(()=>{const e=dE(i,[t,t],[n-t,1]),l=yT(e),u=dE(i,[t,t],[1,1]),c=TE(vN(u,0),CE([[-1]]),CE([[1]])),h=NN(u,IN(c,l)),d=lN(e,h);o=1===d.shape[0]?NC(a):QI([a,dE(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=qN(lN(QE(c,h),l)),f=dE(i,[t,0],[n-t,s]),m=IN(p,o),g=RE(o);if(0===t)i=NN(f,QE(m,QE(g,f)));else{const e=NN(f,QE(m,QE(g,f)));i=QI([dE(i,[0,0],[t,s]),e],0)}const y=RE(m),b=dE(r,[0,t],[n,r.shape[1]-t]);if(0===t)r=NN(b,QE(QE(b,o),y));else{const e=NN(b,QE(QE(b,o),y));r=QI([dE(r,[0,0],[n,t]),e],1)}return[o,i,r]}),bI([e,l,u])}return!e&&n>s&&(r=dE(r,[0,0],[n,s]),i=dE(i,[0,0],[s,s])),[r,i]})}const vT=OS({qr_:function(t,e=!1){if(V_(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return xT(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),s=NE(WI(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],i=[];return s.forEach(t=>{const[n,s]=xT(t,e);r.push(n),i.push(s)}),[WI(_E(r,0),t.shape),WI(_E(i,0),t.shape)]}}});var wT;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(wT||(wT={}));const _T=OS({computeWeightedLoss_:function(t,e,n=wT.SUM_BY_NONZERO_WEIGHTS){const s=FS(t,"losses","computeWeightedLoss");let r=null;null!=e&&(r=FS(e,"weights","computeWeightedLoss"));const i=null==r?s:IN(s,r);if(n===wT.NONE)return i;if(n===wT.SUM)return EN(i);if(n===wT.MEAN){if(null==r)return DN(i);{const t=s.size/r.size,e=lN(EN(i),EN(r));return t>1?lN(e,_I(t)):e}}if(n===wT.SUM_BY_NONZERO_WEIGHTS){if(null==r)return lN(EN(i),_I(s.size));{const t=IN(r,YN(s.shape)),e=IC(EN(KN(t,_I(0))),"float32");return lN(EN(i),e)}}throw Error(`Unknown reduction: ${n}`)}});OS({absoluteDifference_:function(t,e,n,s=wT.SUM_BY_NONZERO_WEIGHTS){const r=FS(t,"labels","absoluteDifference"),i=FS(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=FS(n,"weights","absoluteDifference")),W_(r.shape,i.shape,"Error in absoluteDifference: ");const o=SI(NN(r,i));return _T(o,a,s)}}),OS({cosineDistance_:function(t,e,n,s,r=wT.SUM_BY_NONZERO_WEIGHTS){const i=FS(t,"labels","cosineDistance"),a=FS(e,"predictions","cosineDistance");let o=null;null!=s&&(o=FS(s,"weights","cosineDistance")),W_(i.shape,a.shape,"Error in cosineDistance: ");const l=_I(1),u=NN(l,EN(IN(i,a),n,!0));return _T(u,o,r)}}),OS({hingeLoss_:function(t,e,n,s=wT.SUM_BY_NONZERO_WEIGHTS){let r=FS(t,"labels","hingeLoss");const i=FS(e,"predictions","hingeLoss");let a=null;null!=n&&(a=FS(n,"weights","hingeLoss")),W_(r.shape,i.shape,"Error in hingeLoss: ");const o=_I(1);r=NN(IN(_I(2),r),o);const l=oE(NN(o,IN(r,i)));return _T(l,a,s)}}),OS({huberLoss_:function(t,e,n,s=1,r=wT.SUM_BY_NONZERO_WEIGHTS){const i=FS(t,"labels","huberLoss"),a=FS(e,"predictions","huberLoss");let o=null;null!=n&&(o=FS(n,"weights","huberLoss")),W_(i.shape,a.shape,"Error in huberLoss: ");const l=_I(s),u=SI(NN(a,i)),c=LN(u,l),h=NN(u,c),d=CI(IN(_I(.5),HN(c)),IN(l,h));return _T(d,o,r)}}),OS({logLoss_:function(t,e,n,s=1e-7,r=wT.SUM_BY_NONZERO_WEIGHTS){const i=FS(t,"labels","logLoss"),a=FS(e,"predictions","logLoss");let o=null;null!=n&&(o=FS(n,"weights","logLoss")),W_(i.shape,a.shape,"Error in logLoss: ");const l=_I(1),u=_I(s),c=qN(IN(i,kN(CI(a,u)))),h=IN(NN(l,i),kN(CI(NN(l,a),u))),d=NN(c,h);return _T(d,o,r)}});const kT=OS({squaredDifference_:function(t,e){let n=FS(t,"a","squaredDifference"),s=FS(e,"b","squaredDifference");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("SquaredDifference",{a:n,b:s},{})}});OS({meanSquaredError_:function(t,e,n,s=wT.SUM_BY_NONZERO_WEIGHTS){const r=FS(t,"labels","meanSquaredError"),i=FS(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=FS(n,"weights","meanSquaredError")),W_(r.shape,i.shape,"Error in meanSquaredError: ");const o=kT(r,i);return _T(o,a,s)}});const ST=OS({log1p_:function(t){const e=FS(t,"x","log1p");return CS.runKernel("Log1p",{x:e})}});OS({sigmoidCrossEntropy_:function(t,e,n,s=0,r=wT.SUM_BY_NONZERO_WEIGHTS){let i=FS(t,"multiClassLabels","sigmoidCrossEntropy");const a=FS(e,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=FS(n,"weights","sigmoidCrossEntropy")),W_(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const t=_I(s),e=_I(1),n=_I(.5);i=CI(IN(i,NN(e,t)),IN(n,t))}const l=function(t,e){const n=FS(t,"labels","sigmoidCrossEntropyWithLogits"),s=FS(e,"logits","sigmoidCrossEntropyWithLogits");W_(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=oE(s),i=IN(s,n),a=ST(SN(qN(SI(s))));return CI(NN(r,i),a)}(i,a);return _T(l,o,r)}});const CT=OS({logSumExp_:function(t,e=null,n=!1){const s=FS(t,"x","logSumExp"),r=ek(e,s.shape),i=CN(s,r,!0),a=NN(s,i),o=SN(a),l=EN(o,r),u=kN(l),c=CI(WI(i,u.shape),u);if(n){const t=BN(c.shape,r);return WI(c,t)}return c}});OS({softmaxCrossEntropy_:function(t,e,n,s=0,r=wT.SUM_BY_NONZERO_WEIGHTS){let i=FS(t,"onehotLabels","softmaxCrossEntropy");const a=FS(e,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=FS(n,"weights","softmaxCrossEntropy")),W_(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const t=_I(s),e=_I(1),n=_I(i.shape[1]);i=CI(IN(i,NN(e,t)),lN(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return wI((t,e,s)=>{const r=CT(e,[n],!0),i=NN(IC(e,"float32"),r);s([t,i]);const a=qN(IN(i,t));return{value:EN(a,[n]),gradFunc:(t,e)=>{const[s,r]=e,i=BN(t.shape,[n]);return[IN(WI(t,i),NN(IC(s,"float32"),SN(r))),IN(WI(t,i),NN(SN(r),IC(s,"float32")))]}}})(t,e)}(i,a);return _T(l,o,r)}});const IT={bandPart:mT,gramSchmidt:bT,qr:vT};class NT extends kI{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=CS.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=CS.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:yI(()=>AE(s).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:yI(()=>AE(s).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;yI(()=>{const t=CI(IN(i,this.rho),IN(HN(r),1-this.rho)),e=IN(lN(vE(CI(a,this.epsilon)),vE(CI(i,this.epsilon))),r),n=CI(IN(a,this.rho),IN(HN(e),1-this.rho));i.assign(t),a.assign(n);const o=CI(IN(e,-this.learningRate),s);s.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(bI(this.accumulatedGrads.map(t=>t.variable)),bI(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}NT.className="Adadelta",fI(NT);class ET extends kI{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=CS.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:yI(()=>yN(s.shape,this.initialAccumulatorValue).variable(t))}}const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable;yI(()=>{const t=CI(i,HN(r));i.assign(t);const e=CI(IN(lN(r,vE(CI(t,CS.backend.epsilon()))),-this.learningRate),s);s.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&bI(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}ET.className="Adagrad",fI(ET);class TT extends kI{constructor(t,e,n,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],yI(()=>{this.accBeta1=_I(e).variable(),this.accBeta2=_I(n).variable()}),null==s&&(this.epsilon=CS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);yI(()=>{const n=NN(1,this.accBeta1),s=NN(1,this.accBeta2);e.forEach((e,r)=>{const i=CS.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:yI(()=>AE(i).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${e}/v`,variable:yI(()=>AE(i).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=CI(IN(o,this.beta1),IN(a,1-this.beta1)),c=CI(IN(l,this.beta2),IN(HN(a),1-this.beta2)),h=lN(u,n),d=lN(c,s);o.assign(u),l.assign(c);const p=CI(IN(lN(h,CI(vE(d),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(IN(this.accBeta1,this.beta1)),this.accBeta2.assign(IN(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&bI(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&bI(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),yI(()=>{this.accBeta1.assign(tE(this.beta1,this.iterations_+1)),this.accBeta2.assign(tE(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}TT.className="Adam",fI(TT);class AT extends kI{constructor(t,e,n,s=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],yI(()=>{this.iteration=_I(0).variable(),this.accBeta1=_I(e).variable()}),null==s&&(this.epsilon=CS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);yI(()=>{const n=NN(1,this.accBeta1),s=lN(-this.learningRate,CI(IN(this.iteration,this.decay),1));e.forEach((e,r)=>{const i=CS.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:AE(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${e}/v`,variable:AE(i).variable(!1)});const a=Array.isArray(t)?t[r].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=CI(IN(o,this.beta1),IN(a,1-this.beta1)),c=IN(l,this.beta2),h=SI(a),d=FN(c,h);o.assign(u),l.assign(d);const p=CI(IN(lN(s,n),lN(u,CI(d,this.epsilon))),i);i.assign(p)}),this.iteration.assign(CI(this.iteration,1)),this.accBeta1.assign(IN(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&bI(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&bI(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}AT.className="Adamax",fI(AT);class RT extends kI{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const r=CS.registeredVariables[e];yI(()=>{const t=CI(IN(this.c,s),r);r.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=xI(_I(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}RT.className="SGD",fI(RT);class $T extends RT{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=_I(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=CS.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:yI(()=>AE(s).variable(t))}}const r=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&yI(()=>{let t;const e=CI(IN(this.m,r),i);t=CI(IN(this.c,this.useNesterov?CI(i,IN(e,this.m)):e),s),r.assign(e),s.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&bI(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}$T.className="Momentum",fI($T);class FT extends kI{constructor(t,e=.9,n=0,s=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=CS.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=CS.registeredVariables[e];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:yI(()=>AE(s).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:yI(()=>AE(s).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:yI(()=>AE(s).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;yI(()=>{const t=CI(IN(i,this.decay),IN(HN(r),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,o=CI(IN(e,this.decay),IN(r,1-this.decay)),l=lN(IN(r,this.learningRate),vE(NN(t,CI(HN(o),this.epsilon)))),u=CI(IN(a,this.momentum),l);i.assign(t),e.assign(o),a.assign(u);const c=NN(s,u);s.assign(c)}else{const t=CI(IN(i,this.decay),IN(HN(r),1-this.decay)),e=CI(IN(a,this.momentum),lN(IN(r,this.learningRate),vE(CI(t,this.epsilon))));i.assign(t),a.assign(e);const n=NN(s,e);s.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&bI(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&bI(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&bI(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}FT.className="RMSProp",fI(FT);class DT{static sgd(t){return new RT(t)}static momentum(t,e,n=!1){return new $T(t,e,n)}static rmsprop(t,e=.9,n=0,s=null,r=!1){return new FT(t,e,n,s,r)}static adam(t=.001,e=.9,n=.999,s=null){return new TT(t,e,n,s)}static adadelta(t=.001,e=.95,n=null){return new NT(t,e,n)}static adamax(t=.002,e=.9,n=.999,s=null,r=0){return new AT(t,e,n,s,r)}static adagrad(t,e=.1){return new ET(t,e)}}const OT={sgd:DT.sgd,momentum:DT.momentum,adadelta:DT.adadelta,adagrad:DT.adagrad,rmsprop:DT.rmsprop,adamax:DT.adamax,adam:DT.adam},LT="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function MT(){return new Promise(t=>LT(()=>t()))}function PT(t,e){const n=t[0].length;t.forEach((t,e)=>{V_(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),V_(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((t,r)=>{for(let i=0;i<n;i++)V_(i===e||t[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${r}] (${t}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function zT(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}const BT=30;function VT(t){return t<=BT?t:gk(t,Math.floor(Math.sqrt(t)))}function WT(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function UT(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let s=0;s<n;++s)r=r.concat([t[s+1]/e[s],e[s]]);r=r.concat(t.slice(n+1))}return r}function jT(t,e,n=!0){const s=[];if(n){s.push(e);for(let n=e+1;n<t;++n)n<=2*e?(s.push(n),s.push(n-(e+1))):s.push(n)}else{const n=[],r=[];for(let s=1;s<t;++s)s>=2*e+1||s%2==1?r.push(s):n.push(s);s.push(...n),s.push(0),s.push(...r)}return s}function HT(t,e,n,s=!0){const r=[];r.push(s?t[0]/n:t[0]*n);for(let i=1;i<t.length;++i)r.push(i<=e.length?s?e[i-1]*t[i]:t[i]/e[i-1]:t[i]);return r}function GT(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function qT(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}function KT(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(0===H_(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let h=0;h<r.length-1;++h)a*=r[h];const o=t.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=o[h],l.push(o[h]);const c=[...yk(t.shape).map(t=>t/u),1].slice(0,i);return[l,a,u,c]}function XT(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(i+" update.rank != "+(r+t.length-s));for(let a=0;a<r;++a)if(n.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==t[a+s])throw new Error(i+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${t[a+r]})`)}function QT(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}XT(n,e,t)}function YT(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=n.length;let a=1;for(let l=r;l<i;++l)a*=n[l];const o=r<1?1:r;return{sliceRank:r,numUpdates:H_(e.shape)/o,sliceSize:a,strides:[...yk(n.slice(0,r)),1],outputSize:H_(n)}}const ZT=1.7580993408473768,JT=1.0507009873554805,tA=.3275911,eA=.254829592,nA=-.284496736,sA=1.421413741,rA=-1.453152027,iA=1.061405429;function aA(...t){Ek().getBool("IS_TEST")||console.warn(...t)}function oA(...t){Ek().getBool("IS_TEST")||console.log(...t)}function lA(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function uA(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function cA(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function hA(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function dA(t,e){return{real:t[2*e],imag:t[2*e+1]}}function pA(t,e,n,s){t[2*s]=e,t[2*s+1]=n}function fA(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const i=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function mA(t,e,n){const s=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(s),imag:Math.sin(s)}}function gA(t,e,n=0){let s=[];if("number"==typeof e)V_(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{V_(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(-1!==r){const s=e.reduce((t,e)=>e>0?t+e:t);e[r]=t.shape[n]-s}V_(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function yA(t,e){let n,s=!1;for(t<=BT?(n=t,s=!0):n=gk(t,Math.floor(Math.sqrt(t)));!s;)n>e||n===t?s=!0:n=gk(t,n+1);return n}function bA(t,e,n){const s=[],r=t.length;for(let i=0;i<r;i++)s.push(i!==e?t[i]:n);return s}function xA(t,e,n,s){const r=e.shape.length,i=t.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=t.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)o.push(t.shape[h]),l*=t.shape[h];for(let h=s;h<n;h++)o.push(t.shape[h]),u*=t.shape[h];for(let h=s;h<r;h++)o.push(e.shape[h]);for(let h=n+1;h<i;h++)o.push(t.shape[h]),c*=t.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function vA(t){try{return t.map(t=>Gk(t))}catch(dY){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${dY}`)}}function wA(t){return t.map(t=>Hk(t))}function _A(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const s=CC(t,"int32"),r=CC([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=s.indexToLoc(n[i]);r.values.set(e,i*t.length)}return r.toTensor()}const kA={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,VE(IC(n,"float32"),-1))}}},SA={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=HN(IC(n,"float32")),s=vE(NN(_I(1),e));return qN(lN(t,s))}}}},CA={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=vE(NN(HN(IC(n,"float32")),1));return lN(t,e)}}}},IA={kernelName:"Add",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{let e=t;const s=hN(n.shape,r);return s.length>0&&(e=EN(e,s)),WI(e,n.shape)},b:()=>{let e=t;const n=hN(s.shape,r);return n.length>0&&(e=EN(e,n)),WI(e,s.shape)}}}},NA={kernelName:"ArgMax",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>AE(n)}}},EA={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>AE(n)}}},TA={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,vE(NN(_I(1),HN(IC(n,"float32")))))}}},AA={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=vE(CI(_I(1),HN(IC(n,"float32"))));return lN(t,e)}}}},RA={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{const e=CI(HN(n),HN(s));let i=IN(t,lN(s,e));const a=hN(n.shape,r);return a.length>0&&(i=EN(i,a)),WI(i,n.shape)},b:()=>{const e=CI(HN(n),HN(s));let i=qN(IN(t,lN(n,e)));const a=hN(s.shape,r);return a.length>0&&(i=EN(i,a)),WI(i,s.shape)}}}},$A={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,CI(HN(IC(n,"float32")),1))}}},FA={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,NN(_I(1),HN(IC(n,"float32"))))}}},DA=OS({avgPool3dGrad_:function(t,e,n,s,r,i){const a=FS(t,"dy","avgPool3dGrad"),o=FS(e,"input","avgPool3dGrad");let l=a,u=o,c=!1;4===o.rank&&(c=!0,l=WI(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=WI(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),V_(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),V_(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=i&&V_(K_(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=CS.runKernel("AvgPool3DGrad",{dy:l,input:u},{filterSize:n,strides:s,pad:r,dimRoundingMode:i});return c?WI(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),OA={kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=n;return{x:()=>DA(t,s,r,i,a,o)}}},LA=OS({avgPoolGrad_:function(t,e,n,s,r){const i=FS(t,"dy","avgPoolGrad"),a=FS(e,"input","avgPoolGrad");V_(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,l=i,u=!1;3===a.rank&&(u=!0,o=WI(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=WI(i,[1,i.shape[0],i.shape[1],i.shape[2]])),V_(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),V_(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c=CS.runKernel("AvgPoolGrad",{dy:l,input:o},{filterSize:n,strides:s,pad:r});return u?WI(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),MA={kernelName:"AvgPool",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=n;return{x:()=>LA(t,s,r,i,a)}}},PA={kernelName:"BatchMatMul",inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:i,transposeB:a}=n;return i||a?!i&&a?{a:()=>QE(t,r,!1,!1),b:()=>QE(t,s,!0,!1)}:i&&!a?{a:()=>QE(r,t,!1,!0),b:()=>QE(s,t,!1,!1)}:{a:()=>QE(r,t,!0,!0),b:()=>QE(t,s,!0,!0)}:{a:()=>QE(t,r,!1,!0),b:()=>QE(s,t,!0,!1)}}},zA=OS({spaceToBatchND_:function(t,e,n){const s=FS(t,"x","spaceToBatchND");return V_(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),V_(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),V_(s.shape.reduce((t,s,r)=>r>0&&r<=e.length?t&&(s+n[r-1][0]+n[r-1][1])%e[r-1]==0:t,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),CS.runKernel("SpaceToBatchND",{x:s},{blockShape:e,paddings:n})}}),BA={kernelName:"BatchToSpaceND",gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>zA(t,s,r)}}},VA={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const s=n.inputShape,r=n.shape,i=Array.from(r);for(let o=s.length-1;o>=0;o--)if(s[o]===r[o])i[o]=1;else if(1!==s[o])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${r}].`);const a=[];for(let o=0;o<i.length;o++)i[o]>1&&a.push(o);return{x:()=>EN(t,a,!0)}}},WA={kernelName:"Ceil",gradFunc:t=>({x:()=>AE(t)})},UA={kernelName:"ClipByValue",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>TE(AN(wN(s,r),pT(s,i)),t,AE(t))}}},jA={kernelName:"ComplexAbs",inputsToSave:["x"],gradFunc:kA.gradFunc},HA={kernelName:"Concat",saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(t=>t.shape),{axis:r}=n,i=ek(r,e[0].shape)[0],a=s.map(t=>t[i]);return xE(t,a,i).map(t=>()=>t)}},GA={kernelName:"Conv2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:l}=n;return V_(zI(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>sN(s.shape,t,r,a,o,l),filter:()=>zE(s,t,r.shape,a,o,l)}}},qA={kernelName:"Conv2DBackpropInput",inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>eN(t,r,i,a,o,1,l),filter:()=>zE(t,s,r.shape,i,a,o,l)}}},KA=OS({conv3DBackpropFilter_:function(t,e,n,s,r){let i=t;4===t.rank&&(i=WI(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;return 4===a.rank&&(a=WI(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),V_(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),V_(5===a.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),V_(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),V_(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),V_(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`),CS.runKernel("Conv3DBackpropFilterV2",{x:i,dy:a},{strides:s,pad:r,filterShape:n})}}),XA=OS({conv3DBackpropInput_:function(t,e,n,s,r){V_(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,a=e,o=!1;4===e.rank&&(o=!0,a=WI(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=a.shape[4];V_(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),V_(5===a.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),V_(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),V_(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),V_(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=CS.runKernel("Conv3DBackpropInputV2",{dy:a,filter:n},{pad:r,strides:s,inputShape:i});return o?WI(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),QA={kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i}=n;V_(zI(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>XA(a.shape,t,o,r,i),filter:()=>KA(a,t,o.shape,r,i)}}},YA=OS({sin_:function(t){const e=FS(t,"x","sin");return CS.runKernel("Sin",{x:e})}}),ZA={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(qN(YA(IC(n,"float32"))),t)}}},JA=OS({sinh_:function(t){const e=FS(t,"x","sinh");return CS.runKernel("Sinh",{x:e})}}),tR={kernelName:"Cosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(JA(IC(n,"float32")),t)}}},eR=OS({cumsum_:function(t,e=0,n=!1,s=!1){const r=FS(t,"x","cumsum");return CS.runKernel("Cumsum",{x:r},{axis:e,exclusive:n,reverse:s})}}),nR={kernelName:"Cumsum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=n;return{x:()=>{const e=WN([r],s.rank);let n=eR(t,r,i,!a);return null!=e&&(n=RE(n,e)),n}}}},sR={kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=n,o=null==s?[1,1]:s;V_(zI(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=e;return V_(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),V_(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),V_(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),V_(BI(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),null!=a&&V_(K_(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),{x:()=>KE(l.shape,t,u,r,i,s,a),filter:()=>qE(l,t,u.shape,r,i,s,a)}}},rR={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,i={x:s,filter:r,dy:t},a={x:s,filter:r,dy:t};return{x:()=>CS.runKernel("Dilation2DBackpropInput",i,n),filter:()=>CS.runKernel("Dilation2DBackpropFilter",a,n)}}},iR={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>CS.runKernel("EluGrad",s)}}},aR={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=IN(SN(qN(HN(n))),2/Math.sqrt(Math.PI));return{x:()=>IN(t,s)}}},oR={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,n)}}},lR={kernelName:"ExpandDims",inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>WI(t,n.shape)}}},uR={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,SN(n))}}},cR={kernelName:"Floor",gradFunc:t=>({x:()=>AE(t)})},hR={kernelName:"FloorDiv",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{const e=lN(t,IC(s,"float32")),i=hN(n.shape,r);return i.length>0?WI(EN(e,i),n.shape):e},b:()=>{let e=IN(t,IC(n,"float32"));const i=hN(s.shape,r);i.length>0&&(e=WI(EN(e,i),s.shape));const a=HN(s);return qN(lN(e,IC(a,"float32")))}}}},dR=OS({rsqrt_:function(t){const e=FS(t,"x","rsqrt");return CS.runKernel("Rsqrt",{x:e})}}),pR={kernelName:"FusedBatchNorm",inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,i,a,o]=e,l=null==o?_I(1):o,u=hN(i.shape,r.shape),c=[];if(1===i.rank){for(let t=0;t<r.shape.length-1;++t)c.push(r.shape[t]);c.push(1)}const h=NN(r,i),d=IN(t,l),p=dR(CI(a,_I(s))),f=IN(IN(IN(p,p),p),_I(-.5));return{x:()=>WI(IN(IN(t,1===i.rank?mN(WI(p,[1,1,1,i.shape[0]]),c):p),l),r.shape),mean:()=>{let t=IN(IN(p,_I(-1)),d);return 1===i.rank&&(t=EN(t,u)),WI(t,i.shape)},variance:()=>{let t=IN(IN(f,h),d);return 1===i.rank&&(t=EN(t,u)),WI(t,i.shape)},scale:()=>{const e=IN(h,p);let n=IN(t,e);return 1===i.rank&&(n=EN(n,u)),WI(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=EN(e,u)),WI(e,i.shape)}}}},fR=OS({unsortedSegmentSum_:function(t,e,n){const s=FS(t,"x","unsortedSegmentSum"),r=FS(e,"segmentIds","unsortedSegmentSum","int32");return V_(K_(n),()=>"numSegments must be of dtype int"),CS.runKernel("UnsortedSegmentSum",{x:s,segmentIds:r},{numSegments:n})}}),mR={kernelName:"GatherV2",inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:i}=n,a=ek(i,s.shape)[0];return{x:()=>{const e=s.shape,n=r.size,o=e.slice(0,a),l=o.length,u=e.slice(i,e.length).slice(1),c=u.length,h=gR(0,l),d=gR(l+1,l+1+c),p=yR([o,[n],u]),f=WI(t,p),m=WI(r,[n]),g=yR([[l],h,d]),y=RE(f,g);let b=fR(y,m,s.shape[a]);const x=UN(g);return b=RE(b,x),b},indices:()=>r}}};function gR(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function yR(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}const bR={kernelName:"GreaterEqual",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>AE(n),b:()=>AE(s)}}},xR={kernelName:"Identity",gradFunc:t=>({x:()=>IC(t,"float32")})},vR={kernelName:"IsFinite",gradFunc:t=>({x:()=>AE(t)})},wR={kernelName:"IsInf",gradFunc:t=>({x:()=>AE(t)})},_R={kernelName:"IsNan",gradFunc:t=>({x:()=>AE(t)})},kR={kernelName:"LeakyRelu",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,i=vN(s,0);return{x:()=>TE(i,t,IN(t,r))}}},SR={kernelName:"Log1p",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,CI(n,1))}}},CR={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,IC(n,"float32"))}}},IR={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const e=SN(s);return NN(t,IN(EN(t,r,!0),e))}}}},NR=OS({localResponseNormalizationBackprop_:function(t,e,n,s=5,r=1,i=1,a=.5){return CS.runKernel("LRNGrad",{x:t,y:e,dy:n},{depthRadius:s,bias:r,alpha:i,beta:a})}}),ER={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:l}=n;return{x:()=>NR(s,r,t,i,a,o,l)}}};function TR(t,e,n,s){return e.rank<n.rank&&(e=WI(e,BN(e.shape,s))),t.rank<n.rank&&(t=WI(t,BN(t.shape,s))),{x:()=>IN(t,IC(pN(n,e),t.dtype))}}const AR={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,i=e[0],a=TR(t,e[1],i,ek(r,i.shape));return{x:()=>a.x()}}},RR=OS({less_:function(t,e){let n=FS(t,"a","less"),s=FS(e,"b","less");return[n,s]=gS(n,s),dN(n.shape,s.shape),CS.runKernel("Less",{a:n,b:s})}}),$R={kernelName:"Maximum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>IN(t,IC(wN(n,s),"float32")),b:()=>IN(t,IC(RR(n,s),"float32"))}}},FR=OS({maxPool3dGrad_:function(t,e,n,s,r,i,a){const o=FS(t,"dy","maxPool3dGrad"),l=FS(e,"input","maxPool3dGrad"),u=FS(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=WI(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=WI(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=WI(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),V_(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),V_(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),V_(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=a&&V_(K_(i),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`);const f=CS.runKernel("MaxPool3DGrad",{dy:c,input:h,output:d},{filterSize:s,strides:r,pad:i,dimRoundingMode:a});return p?WI(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),DR={kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>FR(t,s,r,i,a,o,l)}}},OR=OS({maxPoolGrad_:function(t,e,n,s,r,i,a){const o=FS(t,"dy","maxPoolGrad"),l=FS(e,"input","maxPoolGrad"),u=FS(n,"output","maxPoolGrad");return V_(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),V_(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),V_(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=a&&V_(K_(i),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),CS.runKernel("MaxPoolGrad",{dy:o,input:l,output:u},{filterSize:s,strides:r,pad:i,dimRoundingMode:a})}}),LR={kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=n;return{x:()=>OR(t,s,r,i,a,o)}}},MR={kernelName:"Mean",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,i=ek(r,s.shape),a=H_(zN(s.shape,i)[1]);return{x:()=>{const e=s.shape.slice();i.forEach(t=>{e[t]=1});const n=WI(t,e);return lN(IN(n,YN(s.shape,"float32")),a)}}}},PR={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[i,a]=e,o=TR(t,a,i,ek(r,i.shape));return{x:()=>o.x()}}},zR={kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>IN(t,IC(pT(n,s),"float32")),b:()=>IN(t,IC(vN(n,s),"float32"))}}},BR={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>dE(t,i,s.shape)}}},VR={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{const e=hN(n.shape,r);return e.length>0?WI(EN(t,e),n.shape):t},b:()=>{const e=IN(t,qN(bN(lN(n,s)))),i=hN(s.shape,r);return i.length>0?WI(EN(e,i),s.shape):e}}}},WR={kernelName:"Multiply",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{const e=IN(t,IC(s,"float32")),i=hN(n.shape,r);return i.length>0?WI(EN(e,i),n.shape):e},b:()=>{const e=IN(t,IC(n,"float32")),i=hN(s.shape,r);return i.length>0?WI(EN(e,i),s.shape):e}}}},UR={kernelName:"Neg",gradFunc:t=>({x:()=>qN(t)})},jR={kernelName:"OneHot",inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>QN(n.shape,"float32")}}},HR={kernelName:"OnesLike",gradFunc:t=>({x:()=>AE(t)})},GR={kernelName:"Pack",saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return NE(t,s).map(t=>()=>t)}},qR={kernelName:"PadV2",inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>dE(t,i,s.shape)}}},KR={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,i=n,a=s,o=dN(i.shape,a.shape);return{a:()=>{const e=IC(a,"float32");let n=IN(t,IN(e,tE(i,NN(e,_I(1)))));const s=hN(i.shape,o);return s.length>0&&(n=EN(n,s)),WI(n,i.shape)},b:()=>{const e=vN(i,0),n=TE(e,kN(i),AE(i));let s=IN(t,IN(r,n));const l=hN(a.shape,o);return l.length>0&&(s=EN(s,l)),WI(s,a.shape)}}}},XR={kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=vN(n,0);return{x:()=>TE(r,t,IN(t,s)),alpha:()=>{let e=TE(r,AE(t),IN(t,n));const i=hN(s.shape,t.shape);return i.length>0&&(e=EN(e,i)),WI(e,s.shape)}}}},QR={kernelName:"RealDiv",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{const e=lN(t,IC(s,"float32")),i=hN(n.shape,r);return i.length>0?WI(EN(e,i),n.shape):e},b:()=>{let e=IN(t,IC(n,"float32"));const i=hN(s.shape,r);i.length>0&&(e=WI(EN(e,i),s.shape));const a=HN(s);return qN(lN(e,IC(a,"float32")))}}}},YR={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,qN(HN(n)))}}},ZR={kernelName:"Relu6",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=IN(pT(n,6),VE(n));return{x:()=>IN(t,IC(s,"float32"))}}},JR={kernelName:"Relu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,IC(VE(n),"float32"))}}},t$={kernelName:"Reshape",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>WI(t,n.shape)}}},e$={kernelName:"ResizeBilinear",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>CS.runKernel("ResizeBilinearGrad",r,n)}}},n$={kernelName:"ResizeNearestNeighbor",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>CS.runKernel("ResizeNearestNeighborGrad",r,n)}}},s$={kernelName:"Reverse",gradFunc:(t,e,n)=>{const{dims:s}=n,r=ek(s,t.shape);return{x:()=>lE(t,r)}}},r$={kernelName:"Round",gradFunc:t=>({x:()=>AE(t)})},i$={kernelName:"Rsqrt",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>qN(lN(t,IN(tE(n,1.5),2)))}}},a$=OS({logicalNot_:function(t){const e=FS(t,"x","logicalNot","bool");return CS.runKernel("LogicalNot",{x:e})}}),o$={kernelName:"Select",inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>IC(AE(n),"float32"),t:()=>IN(t,IC(n,t.dtype)),e:()=>IN(t,IC(a$(n),t.dtype))}}},l$={kernelName:"Selu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=vN(n,_I(0)),s=_I(ZT),r=_I(JT),i=IN(t,r),a=IN(IN(t,s),SN(IC(n,"float32")));return TE(e,i,a)}}}},u$={kernelName:"Sigmoid",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,IN(n,NN(_I(1),n)))}}},c$={kernelName:"Sign",gradFunc:t=>({x:()=>AE(t)})},h$=OS({cos_:function(t){const e=FS(t,"x","cos");return CS.runKernel("Cos",{x:e})}}),d$={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(h$(IC(n,"float32")),t)}}},p$=OS({cosh_:function(t){const e=FS(t,"x","cosh");return CS.runKernel("Cosh",{x:e})}}),f$={kernelName:"Sinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(p$(IC(n,"float32")),t)}}},m$={kernelName:"Slice",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:i}=n,a=s.shape,[o,l]=cI(s,r,i),u=[];for(let c=0;c<t.rank;c++)u.push([o[c],a[c]-o[c]-l[c]]);return{x:()=>JN(t,u)}}},g$={kernelName:"Softmax",outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,i=IN(t,s);return{logits:()=>NN(i,IN(EN(i,[r],!0),s))}}},y$={kernelName:"Softplus",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,hE(n))}}},b$=OS({batchToSpaceND_:function(t,e,n){const s=FS(t,"x","batchToSpaceND"),r=e.reduce((t,e)=>t*e);return V_(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),V_(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),V_(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`),CS.runKernel("BatchToSpaceND",{x:s},{blockShape:e,crops:n})}}),x$={kernelName:"SpaceToBatchND",gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>b$(t,s,r)}}},v$={kernelName:"SplitV",gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>QI(t,s)}}},w$=[kA,SA,CA,IA,{kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,s)=>{n[s]=()=>t.clone()}),n}},NA,EA,TA,AA,RA,$A,FA,OA,MA,PA,BA,VA,{kernelName:"Cast",gradFunc:t=>({x:()=>t.clone()})},WA,UA,jA,HA,qA,GA,QA,ZA,tR,nR,sR,rR,QR,iR,aR,oR,lR,uR,hR,cR,pR,mR,bR,xR,vR,wR,_R,kR,SR,CR,IR,ER,AR,AR,$R,DR,LR,MR,PR,zR,BR,VR,WR,UR,jR,HR,GR,qR,qR,KR,XR,YR,ZR,JR,t$,e$,n$,s$,r$,i$,o$,l$,u$,c$,d$,f$,m$,g$,y$,x$,x$,v$,v$,{kernelName:"Sqrt",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,IN(vE(IC(n,"float32")),2))}}},{kernelName:"SquaredDifference",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=_I(2);return{a:()=>IN(t,IN(r,NN(n,s))),b:()=>IN(t,IN(r,NN(s,n)))}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(t,IN(IC(n,"float32"),2))}}},{kernelName:"Step",gradFunc:t=>({x:()=>AE(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=dN(n.shape,s.shape);return{a:()=>{let e=t;const s=hN(n.shape,r);return s.length>0&&(e=EN(e,s)),WI(e,n.shape)},b:()=>{let e=t;const n=hN(s.shape,r);return n.length>0&&(e=EN(e,n)),WI(qN(e),s.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:i}=n;ek(i,s.shape).forEach(t=>{r[t]=1});const a=WI(t,r),o=IN(a,YN(s.shape,"float32"));return{x:()=>o}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>lN(t,HN(h$(n)))}}},{kernelName:"Tanh",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>IN(NN(_I(1),HN(n)),t)}}},{kernelName:"Tile",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let e=AE(s);if(1===s.rank)for(let n=0;n<r[0];++n)e=CI(e,dE(t,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)e=CI(e,dE(t,[n*s.shape[0],i*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)e=CI(e,dE(t,[n*s.shape[0],i*s.shape[1],a*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)for(let o=0;o<r[3];++o)e=CI(e,dE(t,[n*s.shape[0],i*s.shape[1],a*s.shape[2],o*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return e}}}},{kernelName:"Transpose",gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,i=UN(r);return{x:()=>RE(t,i)}}},{kernelName:"Unpack",gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>_E(t,r)}}},{kernelName:"UnsortedSegmentSum",inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=FN(e,AE(e)),s=xN(t,n);let r=wN(e,_I(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=fN(r,o+1);r=AN(r,YN(s.shape,"bool"));const a=AE(s);return TE(r,s,a)}(t,n)}}},{kernelName:"ZerosLike",gradFunc:t=>({x:()=>AE(t)})}];for(const pY of w$)zk(pY);aS().prototype.abs=function(){return this.throwIfDisposed(),SI(this)};const _$=OS({acos_:function(t){const e=FS(t,"x","acos");return CS.runKernel("Acos",{x:e})}});aS().prototype.acos=function(){return this.throwIfDisposed(),_$(this)};const k$=OS({acosh_:function(t){const e=FS(t,"x","acosh");return CS.runKernel("Acosh",{x:e})}});aS().prototype.acosh=function(){return this.throwIfDisposed(),k$(this)},aS().prototype.add=function(t){return this.throwIfDisposed(),CI(this,t)},aS().prototype.all=function(t,e){return this.throwIfDisposed(),II(this,t,e)},aS().prototype.any=function(t,e){return this.throwIfDisposed(),NI(this,t,e)},aS().prototype.argMax=function(t){return this.throwIfDisposed(),EI(this,t)};const S$=OS({argMin_:function(t,e=0){const n=FS(t,"x","argMin");return CS.runKernel("ArgMin",{x:n},{axis:e})}});aS().prototype.argMin=function(t){return this.throwIfDisposed(),S$(this,t)},aS().prototype.asScalar=function(){return this.throwIfDisposed(),V_(1===this.size,()=>"The array must have only 1 element."),WI(this,[])},aS().prototype.asType=function(t){return this.throwIfDisposed(),IC(this,t)},aS().prototype.as1D=function(){return this.throwIfDisposed(),WI(this,[this.size])},aS().prototype.as2D=function(t,e){return this.throwIfDisposed(),WI(this,[t,e])},aS().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),WI(this,[t,e,n])},aS().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),WI(this,[t,e,n,s])},aS().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),WI(this,[t,e,n,s,r])};const C$=OS({asin_:function(t){const e=FS(t,"x","asin");return CS.runKernel("Asin",{x:e})}});aS().prototype.asin=function(){return this.throwIfDisposed(),C$(this)};const I$=OS({asinh_:function(t){const e=FS(t,"x","asinh");return CS.runKernel("Asinh",{x:e})}});aS().prototype.asinh=function(){return this.throwIfDisposed(),I$(this)};const N$=OS({atan_:function(t){const e=FS(t,"x","atan");return CS.runKernel("Atan",{x:e})}});aS().prototype.atan=function(){return this.throwIfDisposed(),N$(this)};const E$=OS({atan2_:function(t,e){let n=FS(t,"a","atan2"),s=FS(e,"b","atan2");return[n,s]=gS(n,s),CS.runKernel("Atan2",{a:n,b:s})}});aS().prototype.atan2=function(t){return this.throwIfDisposed(),E$(this,t)};const T$=OS({atanh_:function(t){const e=FS(t,"x","atanh");return CS.runKernel("Atanh",{x:e})}});aS().prototype.atanh=function(){return this.throwIfDisposed(),T$(this)},aS().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),UI(this,t,e,n,s)},aS().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),b$(this,t,e)},aS().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),HI(this,t,e,n,s,r)},aS().prototype.broadcastTo=function(t){return this.throwIfDisposed(),EE(this,t)},aS().prototype.cast=function(t){return this.throwIfDisposed(),IC(this,t)};const A$=OS({ceil_:function(t){const e=FS(t,"x","ceil");return CS.runKernel("Ceil",{x:e})}});aS().prototype.ceil=function(){return this.throwIfDisposed(),A$(this)},aS().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),XI(this,t,e)},aS().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof iS&&(t=[t]),QI([this,...t],e)},aS().prototype.conv1d=function(t,e,n,s,r,i){return this.throwIfDisposed(),nN(this,t,e,n,s,r,i)},aS().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),rN(this,t,e,n,s,r)},aS().prototype.conv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),eN(this,t,e,n,s,r,i)},aS().prototype.cos=function(){return this.throwIfDisposed(),h$(this)},aS().prototype.cosh=function(){return this.throwIfDisposed(),p$(this)},aS().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),eR(this,t,e,n)};const R$=OS({depthToSpace_:function(t,e,n="NHWC"){const s=FS(t,"x","depthToSpace"),r="NHWC"===n?s.shape[1]:s.shape[2],i="NHWC"===n?s.shape[2]:s.shape[3],a="NHWC"===n?s.shape[3]:s.shape[1];return V_(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${e}  for depthToSpace with input shape\n    ${s.shape}`),V_(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${s.shape}`),V_(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`),CS.runKernel("DepthToSpace",{x:s},{blockSize:e,dataFormat:n})}});aS().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),R$(this,t,e)},aS().prototype.depthwiseConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),aN(this,t,e,n,s,r,i)};const $$=OS({dilation2d_:function(t,e,n,s,r=[1,1],i="NHWC"){const a=FS(t,"x","dilation2d"),o=FS(e,"filter","dilation2d");V_(3===a.rank||4===a.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),V_(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),V_("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=a,u=!1;3===a.rank&&(l=WI(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c=CS.runKernel("Dilation2D",{x:l,filter:o},{strides:n,pad:s,dilations:r});return u?WI(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});aS().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),$$(this,t,e,n,s,r)};const F$=OS({divNoNan_:function(t,e){let n=FS(t,"a","div"),s=FS(e,"b","div");[n,s]=gS(n,s);const r=lN(n,s),i=AE(r),a=pN(s,i);return TE(a,i,r)}});aS().prototype.divNoNan=function(t){return this.throwIfDisposed(),F$(this,t)},aS().prototype.div=function(t){return this.throwIfDisposed(),lN(this,t)};const D$=OS({dot_:function(t,e){const n=FS(t,"t1","dot"),s=FS(e,"t2","dot");V_(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],i=1===s.rank?s.size:s.shape[0];if(V_(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),1===n.rank&&1===s.rank){const t=WI(n,[1,-1]),e=WI(s,[-1,1]),r=QE(t,e);return WI(r,[])}if(1===n.rank&&2===s.rank){const t=WI(n,[1,-1]),e=WI(s,[s.shape[0],s.shape[1]]),r=QE(t,e);return WI(r,[r.size])}if(2===n.rank&&1===s.rank){const t=WI(s,[-1,1]),e=QE(n,t);return WI(e,[e.size])}{const t=WI(s,[s.shape[0],s.shape[1]]);return QE(n,t)}}});aS().prototype.dot=function(t){return this.throwIfDisposed(),D$(this,t)},aS().prototype.elu=function(){return this.throwIfDisposed(),uN(this)},aS().prototype.equal=function(t){return this.throwIfDisposed(),pN(this,t)};const O$=OS({erf_:function(t){let e=FS(t,"x","erf");return V_("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=IC(e,"float32")),CS.runKernel("Erf",{x:e})}});aS().prototype.erf=function(){return this.throwIfDisposed(),O$(this)},aS().prototype.exp=function(){return this.throwIfDisposed(),SN(this)},aS().prototype.expandDims=function(t){return this.throwIfDisposed(),fN(this,t)};const L$=OS({expm1_:function(t){const e=FS(t,"x","expm1");return CS.runKernel("Expm1",{x:e})}});aS().prototype.expm1=function(){return this.throwIfDisposed(),L$(this)},aS().prototype.fft=function(){return this.throwIfDisposed(),OE(this)},aS().prototype.flatten=function(){return this.throwIfDisposed(),WI(this,[this.size])},aS().prototype.floor=function(){return this.throwIfDisposed(),bN(this)},aS().prototype.floorDiv=function(t){return this.throwIfDisposed(),oN(this,t)},aS().prototype.gather=function(t,e){return this.throwIfDisposed(),xN(this,t,e)},aS().prototype.greaterEqual=function(t){return this.throwIfDisposed(),wN(this,t)},aS().prototype.greater=function(t){return this.throwIfDisposed(),vN(this,t)},aS().prototype.ifft=function(){return this.throwIfDisposed(),ME(this)},aS().prototype.irfft=function(){return this.throwIfDisposed(),PE(this)};const M$=OS({isFinite_:function(t){const e=FS(t,"x","isFinite");return CS.runKernel("IsFinite",{x:e})}});aS().prototype.isFinite=function(){return this.throwIfDisposed(),M$(this)};const P$=OS({isInf_:function(t){const e=FS(t,"x","isInf");return CS.runKernel("IsInf",{x:e})}});aS().prototype.isInf=function(){return this.throwIfDisposed(),P$(this)};const z$=OS({isNaN_:function(t){const e=FS(t,"x","isNaN");return CS.runKernel("IsNan",{x:e})}});aS().prototype.isNaN=function(){return this.throwIfDisposed(),z$(this)},aS().prototype.leakyRelu=function(t){return this.throwIfDisposed(),_N(this,t)},aS().prototype.lessEqual=function(t){return this.throwIfDisposed(),pT(this,t)},aS().prototype.less=function(t){return this.throwIfDisposed(),RR(this,t)};const B$=OS({localResponseNormalization_:function(t,e=5,n=1,s=1,r=.5){const i=FS(t,"x","localResponseNormalization");V_(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),V_(K_(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;3===i.rank&&(o=!0,a=WI(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l=CS.runKernel("LRN",{x:a},{depthRadius:e,bias:n,alpha:s,beta:r});return o?WI(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});aS().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),B$(this,t,e,n,s)};const V$=OS({logSigmoid_:function(t){const e=FS(t,"x","logSigmoid");return wI(t=>({value:qN(bE(qN(t))),gradFunc:e=>IN(e,hE(qN(t)))}))(e)}});aS().prototype.logSigmoid=function(){return this.throwIfDisposed(),V$(this)},aS().prototype.logSoftmax=function(t){return this.throwIfDisposed(),TN(this,t)},aS().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),CT(this,t,e)},aS().prototype.log=function(){return this.throwIfDisposed(),kN(this)},aS().prototype.log1p=function(){return this.throwIfDisposed(),ST(this)},aS().prototype.logicalAnd=function(t){return this.throwIfDisposed(),AN(this,t)},aS().prototype.logicalNot=function(){return this.throwIfDisposed(),a$(this)};const W$=OS({logicalOr_:function(t,e){const n=FS(t,"a","logicalOr","bool"),s=FS(e,"b","logicalOr","bool");return dN(n.shape,s.shape),CS.runKernel("LogicalOr",{a:n,b:s})}});aS().prototype.logicalOr=function(t){return this.throwIfDisposed(),W$(this,t)};const U$=OS({logicalXor_:function(t,e){const n=FS(t,"a","logicalXor","bool"),s=FS(e,"b","logicalXor","bool");return dN(n.shape,s.shape),AN(W$(t,e),a$(AN(t,e)))}});aS().prototype.logicalXor=function(t){return this.throwIfDisposed(),U$(this,t)},aS().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),QE(this,t,e,n)},aS().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),RN(this,t,e,n,s)},aS().prototype.max=function(t,e){return this.throwIfDisposed(),CN(this,t,e)},aS().prototype.maximum=function(t){return this.throwIfDisposed(),FN(this,t)},aS().prototype.mean=function(t,e){return this.throwIfDisposed(),DN(this,t,e)},aS().prototype.min=function(t,e){return this.throwIfDisposed(),ON(this,t,e)},aS().prototype.minimum=function(t){return this.throwIfDisposed(),LN(this,t)};const j$=OS({mirrorPad_:function(t,e,n){V_("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=FS(t,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");V_(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r="reflect"===n?1:0;for(let i=0;i<s.rank;i++)V_(2===e[i].length,()=>"Invalid number of paddings. Must be length of 2 each."),V_(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);return CS.runKernel("MirrorPad",{x:s},{paddings:e,mode:n})}});aS().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),j$(this,t,e)};const H$=OS({mod_:function(t,e){let n=FS(t,"a","mod"),s=FS(e,"b","mod");return[n,s]=gS(n,s),CS.runKernel("Mod",{a:n,b:s})}});aS().prototype.mod=function(t){return this.throwIfDisposed(),H$(this,t)},aS().prototype.mul=function(t){return this.throwIfDisposed(),IN(this,t)},aS().prototype.neg=function(){return this.throwIfDisposed(),qN(this)},aS().prototype.norm=function(t,e,n){return this.throwIfDisposed(),yT(this,t,e,n)},aS().prototype.notEqual=function(t){return this.throwIfDisposed(),KN(this,t)},aS().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),XN(this,t,e,n)},aS().prototype.onesLike=function(){return this.throwIfDisposed(),ZN(this)},aS().prototype.pad=function(t,e){return this.throwIfDisposed(),JN(this,t,e)};const G$=OS({pool_:function(t,e,n,s,r,i){null==r&&(r=[1,1]),null==i&&(i=1),0===s&&(s="valid");const a=FS(t,"x","maxPool");let o=a,l=!1;3===a.rank&&(l=!0,o=WI(a,[1,a.shape[0],a.shape[1],a.shape[2]])),V_(BI(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const u=AI(o.shape,e,i,r,s),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===s?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),s=n.map(t=>Math.floor(t/2)),r=n.map((t,e)=>t-s[e]);return n.map((t,e)=>[s[e],r[e]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(t,e,n){const s=n.map(t=>t[0]),r=n.map(t=>t[1]),i=t.concat(s,r),a=e.map((t,e)=>(t-i[e]%t)%t),o=r.map((t,e)=>t+a[e]);return[e.map((t,e)=>[s[e],o[e]]),e.map((t,e)=>[0,a[e]])]}([u.inHeight,u.inWidth],c,h),m=d?s:"valid",g=d?o:zA(o,c,p),y=("avg"===n?()=>UI(g,e,i,m):()=>RN(g,e,i,m))(),b=d?y:b$(y,c,f);return l?WI(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});aS().prototype.pool=function(t,e,n,s,r){return this.throwIfDisposed(),G$(this,t,e,n,s,r)},aS().prototype.pow=function(t){return this.throwIfDisposed(),tE(this,t)},aS().prototype.prelu=function(t){return this.throwIfDisposed(),eE(this,t)};const q$=OS({prod_:function(t,e=null,n=!1){let s=FS(t,"x","prod");return"bool"===s.dtype&&(s=IC(s,"int32")),CS.runKernel("Prod",{x:s},{axis:e,keepDims:n})}});aS().prototype.prod=function(t,e){return this.throwIfDisposed(),q$(this,t,e)};const K$=OS({reciprocal_:function(t){const e=FS(t,"x","reciprocal");return CS.runKernel("Reciprocal",{x:e})}});aS().prototype.reciprocal=function(){return this.throwIfDisposed(),K$(this)},aS().prototype.relu=function(){return this.throwIfDisposed(),oE(this)},aS().prototype.relu6=function(){return this.throwIfDisposed(),BE(this)},aS().prototype.reshapeAs=function(t){return this.throwIfDisposed(),WI(this,t.shape)},aS().prototype.reshape=function(t){return this.throwIfDisposed(),WI(this,t)},aS().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),hT(this,t,e,n)},aS().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),dT(this,t,e,n)},aS().prototype.reverse=function(t){return this.throwIfDisposed(),lE(this,t)},aS().prototype.rfft=function(){return this.throwIfDisposed(),LE(this)};const X$=OS({round_:function(t){const e=FS(t,"x","round");return CS.runKernel("Round",{x:e})}});aS().prototype.round=function(){return this.throwIfDisposed(),X$(this)},aS().prototype.rsqrt=function(){return this.throwIfDisposed(),dR(this)},aS().prototype.selu=function(){return this.throwIfDisposed(),uE(this)},aS().prototype.separableConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),cE(this,t,e,n,s,r,i)},aS().prototype.sigmoid=function(){return this.throwIfDisposed(),hE(this)};const Q$=OS({sign_:function(t){const e=FS(t,"x","sign");return CS.runKernel("Sign",{x:e})}});aS().prototype.sign=function(){return this.throwIfDisposed(),Q$(this)},aS().prototype.sin=function(){return this.throwIfDisposed(),YA(this)},aS().prototype.sinh=function(){return this.throwIfDisposed(),JA(this)},aS().prototype.slice=function(t,e){return this.throwIfDisposed(),dE(this,t,e)},aS().prototype.softmax=function(t){return this.throwIfDisposed(),yE(this,t)},aS().prototype.softplus=function(){return this.throwIfDisposed(),bE(this)},aS().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),zA(this,t,e)},aS().prototype.split=function(t,e){return this.throwIfDisposed(),xE(this,t,e)},aS().prototype.sqrt=function(){return this.throwIfDisposed(),vE(this)},aS().prototype.square=function(){return this.throwIfDisposed(),HN(this)},aS().prototype.squaredDifference=function(t){return this.throwIfDisposed(),kT(this,t)},aS().prototype.squeeze=function(t){return this.throwIfDisposed(),wE(this,t)},aS().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof iS?[this,t]:[this,...t];return _E(n,e)},aS().prototype.step=function(t){return this.throwIfDisposed(),VE(this,t)};const Y$=OS({stridedSlice_:function(t,e,n,s,r=0,i=0,a=0,o=0,l=0){const u=FS(t,"x","stridedSlice");return CS.runKernel("StridedSlice",{x:u},{begin:e,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l})}});aS().prototype.stridedSlice=function(t,e,n,s,r,i,a,o){return this.throwIfDisposed(),Y$(this,t,e,n,s,r,i,a,o)},aS().prototype.sub=function(t){return this.throwIfDisposed(),NN(this,t)},aS().prototype.sum=function(t,e){return this.throwIfDisposed(),EN(this,t,e)};const Z$=OS({tan_:function(t){const e=FS(t,"x","tan");return CS.runKernel("Tan",{x:e})}});aS().prototype.tan=function(){return this.throwIfDisposed(),Z$(this)},aS().prototype.tanh=function(){return this.throwIfDisposed(),kE(this)},aS().prototype.tile=function(t){return this.throwIfDisposed(),mN(this,t)},aS().prototype.toBool=function(){return this.throwIfDisposed(),IC(this,"bool")},aS().prototype.toFloat=function(){return this.throwIfDisposed(),IC(this,"float32")},aS().prototype.toInt=function(){return this.throwIfDisposed(),IC(this,"int32")};const J$=OS({topk_:function(t,e=1,n=!0){const s=FS(t,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:n},[o,l]=CS.runKernel("TopK",i,a);return{values:o,indices:l}}});aS().prototype.topk=function(t,e){return this.throwIfDisposed(),J$(this,t,e)},aS().prototype.transpose=function(t){return this.throwIfDisposed(),RE(this,t)};const tF=OS({unique_:function(t,e=0){const n=FS(t,"x","unique","string_or_numeric");V_(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[i,a]=CS.runKernel("Unique",s,r);return{values:i,indices:a}}});let eF;function nF(){return null==eF&&(eF=CS.backend.epsilon()),eF}aS().prototype.unique=function(t){return this.throwIfDisposed(),tF(this,t)},aS().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),fR(this,t,e)},aS().prototype.unstack=function(t){return this.throwIfDisposed(),NE(this,t)},aS().prototype.where=function(t,e){return this.throwIfDisposed(),TE(t,this,e)},aS().prototype.zerosLike=function(){return this.throwIfDisposed(),AE(this)};class sF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,sF.prototype)}}class rF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,rF.prototype)}}class iF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,iF.prototype)}}class aF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,aF.prototype)}}class oF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oF.prototype)}}function lF(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function uF(t,e){if(!t)throw new oF(e)}function cF(t,e){let n=0;for(const s of t)s===e&&n++;return n}function hF(t){return 1===t.length?t[0]:t}function dF(t){return Array.isArray(t)?t:[t]}function pF(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function fF(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let mF={};function gF(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function yF(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>yF(t));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?yF(e):t[n]=e.value)}}}function bF(t,e={},n={},s="object",r=!1){if("string"==typeof t){const r=t;let i;if(r in n)i=n[r];else if(r in mF)i=mF[r];else if(i=e[r],null==i)throw new iF(`Unknown ${s}: ${t}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new iF(`${s}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const a=i.className;let o,l;if(a in n?[o,l]=n[a]:a in mF?[o,l]=mF.className:a in e&&([o,l]=e[a]),null==o)throw new iF(`Unknown ${s}: ${a}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(mF))t[n]=mF[n];for(const r of Object.keys(n))t[r]=n[r];i.config.customObjects=t;const e=Object.assign({},mF);for(const r of Object.keys(n))mF[r]=n[r];yF(i.config);const s=l(o,i.config,n,r);return mF=Object.assign({},e),s}{const t=Object.assign({},mF);for(const s of Object.keys(n))mF[s]=n[s];const e=new o(i.config);return mF=Object.assign({},t),e}}}function xF(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function vF(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function wF(t){if(null==t)throw new iF(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function _F(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new iF(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function kF(t,e,n=0,s=1/0){return uF(n>=0),uF(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(t=>typeof t===e)}function SF(t,e){Array.isArray(t)?(s.assert(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((t,n)=>SF(t,`element ${n+1} of ${e}`))):s.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${CF(t)}.`)}function CF(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>CF(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function IF(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function NF(t,e){return yI(()=>vE(EN(IN(t,t),e,!0)))}class EF extends u.Serializable{getConfig(){return{}}}class TF extends EF{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return yI(()=>{const e=NF(t,this.axis),n=XI(e,0,this.maxValue);return IN(t,lN(n,CI(nF(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}TF.className="MaxNorm",u.registerClass(TF);class AF extends EF{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return yI(()=>lN(t,CI(nF(),NF(t,this.axis))))}getConfig(){return{axis:this.axis}}}AF.className="UnitNorm",u.registerClass(AF);class RF extends EF{apply(t){return oE(t)}}RF.className="NonNeg",u.registerClass(RF);class $F extends EF{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return yI(()=>{const e=NF(t,this.axis),n=CI(IN(this.rate,XI(e,this.minValue,this.maxValue)),IN(1-this.rate,e));return IN(t,lN(n,CI(nF(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}$F.className="MinMaxNorm",u.registerClass($F);const FF={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function DF(t){return gF(t)}function OF(t,e={}){return bF(t,u.SerializationMap.getMap().classNameMap,e,"constraint")}function LF(t){return null==t?null:"string"==typeof t?OF({className:t in FF?FF[t]:t,config:{}}):t instanceof EF?t:OF(t)}const MF=["channelsFirst","channelsLast"],PF=["nearest","bilinear"],zF=["valid","same","causal"],BF=["max","avg"],VF=["sum","mul","concat","ave"],WF=new Map;function UF(t){_F(MF,"DataFormat",t)}function jF(t){_F(zF,"PaddingMode",t)}function HF(t){_F(BF,"PoolMode",t)}const GF=[];function qF(t,e){GF.push(t);try{const t=e();return GF.pop(),t}catch(n){throw GF.pop(),n}}function KF(t){if(!YF(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===GF.length?"":GF.join("/")+"/")+t}function XF(t){if(!YF(t))throw new Error("Not a valid tensor name: '"+t+"'");WF.has(t)||WF.set(t,0);const e=WF.get(t);if(WF.set(t,WF.get(t)+1),e>0){const n=`${t}_${e}`;return WF.set(n,1),n}return t}const QF=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function YF(t){return!!t.match(QF)}function ZF(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function JF(t){return SE(t=Array.isArray(t)?new Float32Array(t):t)}function tD(t){return ON(JF(t)).dataSync()[0]}function eD(t){return CN(JF(t)).dataSync()[0]}function nD(t,e){if(e<t)throw new iF(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}function sD(t,e){return t.asType(e)}function rD(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function iD(t,e,n){return yI(()=>{switch(t.rank){case 1:return pE(t,e,n);case 2:return fE(t,[e,0],[n,t.shape[1]]);case 3:return mE(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return gE(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return dE(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return dE(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new iF(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function aD(t,e,n){return yI(()=>{switch(t.rank){case 1:return pE(t,e,n);case 2:return fE(t,[0,e],[t.shape[0],n]);case 3:return mE(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return gE(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new iF(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function oD(t,e,n,s){return yI(()=>{switch(t.rank){case 1:return pE(t,e,n);case 2:switch(s){case 1:return iD(t,e,n);case 2:return aD(t,e,n);default:throw new iF(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return iD(t,e,n);case 2:return mE(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return aD(t,e,n);default:throw new iF(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return iD(t,e,n);case 2:return gE(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return gE(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return aD(t,e,n);default:throw new iF(`The axis is not within the rank of the tensor ${s}`)}default:throw new iF(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function lD(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),QI(t,e)}function uD(t,e){switch(t.rank){case 1:return YI([t,e]);case 2:return ZI([t,e],0);case 3:return JI([t,e],0);case 4:return tN([t,e],0);default:throw new iF(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function cD(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new iF(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return mN(t,e)}function hD(t,e=0,n=1,s,r){return iE(t,e,n,s,r)}function dD(t,e,n,s){if(t.rank<2||e.rank<2)throw new aF(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new aF(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return c.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?mD(t.rank,s,"channelsLast"):null,activation:n});{const r=t.shape.slice(),i=r.pop();t=t.reshape([-1,i]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],h=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(h).reshape([l,-1]);const d=[...r,...u];return c.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?mD(t.rank,s,"channelsLast"):null,activation:n}).reshape(d)}}function pD(t,e,n){return yI(()=>(e=Array.isArray(e)?SE(e,"int32"):e.toInt(),xN(t,e,n)))}function fD(t){return IN(t,t)}function mD(t,e,n){const s=e.shape;if(1!==e.rank&&e.rank!==t)throw new iF(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,s[0]]:[1].concat(s))}else if(t<3)return e;throw new iF(`Unsupported input rank by biasAdd: ${e.rank}`)}function gD(t,e,n){return yI(()=>(null==n&&(n="channelsLast"),UF(n),t.add(mD(t.rank,e,n))))}function yD(t,e,n,s){return yI(()=>$E(t,e,n,s))}function bD(t,e,n=!1){return n?t():e()}const xD=["fanIn","fanOut","fanAvg"],vD=["normal","uniform","truncatedNormal"];class wD extends u.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class _D extends wD{apply(t,e){return QN(t,e)}}_D.className="Zeros",u.registerClass(_D);class kD extends wD{apply(t,e){return YN(t,e)}}kD.className="Ones",u.registerClass(kD);class SD extends wD{constructor(t){if(super(),"object"!=typeof t)throw new iF(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new iF(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return yI(()=>IN(_I(this.value),YN(t,e)))}getConfig(){return{value:this.value}}}SD.className="Constant",u.registerClass(SD);class CD extends wD{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return aE(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}CD.className="RandomUniform",u.registerClass(CD);class ID extends wD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new aF(`randomNormal does not support dType ${e}.`);return hD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ID.className="RandomNormal",u.registerClass(ID);class ND extends wD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new aF(`truncatedNormal does not support dType ${e}.`);return IE(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ND.className="TruncatedNormal",u.registerClass(ND);class ED extends wD{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return yI(()=>{if(2!==t.length||t[0]!==t[1])throw new iF("Identity matrix initializer can only be used for 2D square matrices.");return IN(this.gain,gN(t[0]))})}getConfig(){return{gain:this.gain}}}ED.className="Identity",u.registerClass(ED);class TD extends wD{constructor(t){if(super(),t.scale<0)throw new iF(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,_F(xD,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,_F(vD,"Distribution",this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,s;if(UF(e),2===t.length)n=t[0],s=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=ZF(t,2);n=t[1]*e,s=t[0]*e}else if("channelsLast"===e){const e=ZF(t,0,t.length-2);n=t[t.length-2]*e,s=t[t.length-1]*e}}else{const e=ZF(t);n=Math.sqrt(e),s=Math.sqrt(e)}return[n,s]}(t),s=n[0],r=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new aF(`${this.getClassName()} does not support dType ${e}.`);return IE(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return aE(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}TD.className="VarianceScaling",u.registerClass(TD);class AD extends TD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return TD.className}}AD.className="GlorotUniform",u.registerClass(AD);class RD extends TD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return TD.className}}RD.className="GlorotNormal",u.registerClass(RD);class $D extends TD{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return TD.className}}$D.className="HeNormal",u.registerClass($D);class FD extends TD{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return TD.className}}FD.className="HeUniform",u.registerClass(FD);class DD extends TD{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return TD.className}}DD.className="LeCunNormal",u.registerClass(DD);class OD extends TD{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return TD.className}}OD.className="LeCunNormal",u.registerClass(OD);class LD extends wD{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new aF("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return yI(()=>{if(t.length<2)throw new aF("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=hD(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=IT.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),IN(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}LD.className="Orthogonal",u.registerClass(LD);const MD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function PD(t,e={}){return bF(t,u.SerializationMap.getMap().classNameMap,e,"initializer")}function zD(t){return gF(t)}function BD(t){if("string"==typeof t){const e=t in MD?MD[t]:t;if("GlorotNormal"===e)return new RD;if("GlorotUniform"===e)return new AD;if("HeNormal"===e)return new $D;if("HeUniform"===e)return new FD;if("LeCunNormal"===e)return new DD;if("LeCunUniform"===e)return new OD;{const t={};return t.className=e,t.config={},PD(t)}}return t instanceof wD?t:PD(t)}let VD=0;function WD(){return VD++}const UD={};function jD(t=""){return t in UD||(UD[t]=0),UD[t]+=1,t+UD[t].toString()}function HD(t){return Array.isArray(t)&&Array.isArray(t[0])}function GD(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function qD(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new iF(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function KD(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new iF(`Expected exactly 1 Shape; got ${t.length}`)}return t}function XD(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class QD{constructor(t,e="float32",n="Variable",s=!0,r=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=WD(),this.originalName=KF(n=null==n?"Variable":n),this.name=XF(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(t,e=!0,n,s){return CS.makeVariable(t,e,n,s)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function YD(t){return t.map(t=>t.read())}function ZD(t){t.forEach(t=>{t[0].write(t[1])})}class JD{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class tO{constructor(t,e,n,s,r,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=a,this.id=WD(),null!=i&&(this.originalName=KF(i),this.name=XF(this.originalName)),this.rank=e.length}}let eO=0;class nO{constructor(t,e){this.callArgs=e,this.id=eO++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let sO=0;class rO extends u.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=sO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=pF(t)+"_"+jD(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new rF(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new iF(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return hF(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return hF(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new sF(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new sF(`Layer ${this.name} is not connected, no input to return.`);return hF(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new sF(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new sF(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return hF(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=dF(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=dF(this.inputSpec);if(t.length!==e.length)throw new iF(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const s=t[n],r=e[n];if(null==r)continue;const i=s.rank;if(null!=r.ndim&&i!==r.ndim)throw new iF(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${i}`);if(null!=r.maxNDim&&i>r.maxNDim)throw new iF(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${i}`);if(null!=r.minNDim&&i<r.minNDim)throw new iF(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${i}.`);if(null!=r.dtype&&s.dtype!==r.dtype)throw new iF(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);if(r.axes){const t=s.shape;for(const e in r.axes){const s=Number(e),i=r.axes[e],a=s>=0?t[s]:t[t.length+s];if(null!=i&&-1===[i,null].indexOf(a))throw new iF(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const e=r.shape[t],i=s.shape[t];if(null!=e&&null!=i&&e!==i)throw new iF(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=dF(t);let s=!0;for(const i of n)if(!(i instanceof tO)){s=!1;break}let r=!0;for(const i of n)if(i instanceof tO){r=!1;break}if(s===r)throw new iF("Arguments to apply() must be all SymbolicTensors or all Tensors");return qF(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of dF(t))e.push(n.shape);this.build(hF(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let s=this.call(t,e);const r=dF(s),i=[];for(let t of r)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(s=hF(i),null!=this.activityRegularizer)throw new aF("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(t){t=dF(t);const e=[];for(const n of t)e.push(n.shape);return hF(e)}(t),s=this.computeOutputShape(n);let r;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,s)=>new tO(i,n,this,dF(t),e,this.name,s)):new tO(i,s,this,dF(t),e,this.name),this.addInboundNode(t,r,null,null,n,s,e),this._refCount++,null!=this.activityRegularizer)throw new aF("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,s)=>{null!=n&&null!=t[s]&&t[s]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new sF(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new sF(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new rF(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return XD(this.weights)}build(t){this.built=!0}getWeights(t=!1){return YD(t?this.trainableWeights:this.weights)}setWeights(t){yI(()=>{const e=this.weights;if(e.length!==t.length)throw new iF(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],r=YD(e);for(let i=0;i<r.length;++i){const a=r[i],o=e[i],l=t[i];if(!s.arraysEqual(a.shape,l.shape))throw new iF(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);n.push([o,l])}ZD(n)})}addWeight(t,e,n,s,r,i,a){if(-1!==this._addedWeightNames.indexOf(t))throw new iF(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=BD("zeros"));const o=s.apply(e,n),l=new QD(o,n,t,i,a);return o.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=dF(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,s,r,i,a=null){const o=dF(t);e=dF(e),n=dF(n),s=dF(s),r=GD(r),i=GD(i);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new nO({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function iO(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const s=iO(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of s)-1===e.indexOf(t)&&e.push(t)}return e}}}class aO extends rO{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:jD("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new iF("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new iF("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new iF("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const s=new tO(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new nO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new iF(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function oO(t){if(null==t)return;const e=[],n=[],s=[];for(const r in t){const i=t[r];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(r),s.push(t)}}if(e.length>0){const r=await Promise.all(e);for(let e=0;e<r.length;++e)t[n[e]]=r[e][0];bI(s)}}function lO(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var uO;aO.className="InputLayer",u.registerClass(aO),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(uO||(uO={}));class cO{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class hO{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class dO extends cO{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const s in e){const t=e[s];if("number"==typeof t)this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+t*n;else{let e;s in this.totals?e=this.totals[s]:this.totals[s]=0;const r=yI(()=>CI(this.totals[s],IN(t,n)));this.totals[s]=r,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?e[n]=this.totals[n]/this.seen:yI(()=>{const t=IN(lN(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),xI(e[n])}))}}class pO extends cO{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const r in this.history){const s=this.history[r];for(let i=0;i<s.length;++i)"number"!=typeof s[i]&&(t.push(s[i].data()),e.push(r),n.push(i))}const s=await Promise.all(t);for(let r=0;r<s.length;++r)this.history[e[r]][n[r]].dispose(),this.history[e[r]][n[r]]=s[r][0]}}class fO extends cO{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");s.isNumber(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,r=s.now();return(...i)=>{const a=s.now();return a-r<e||(r=a,n=t(...i)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const s=[];null!=this.yield&&(await oO(n),s.push(this.yield(t,e,n))),s.push(MT()),await Promise.all(s)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await oO(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await oO(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(MT()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await oO(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await oO(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(MT()):s.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await oO(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await oO(t),await this.trainEnd(t))}}function mO(t,e){return null==t&&(t={}),t instanceof cO?[t]:Array.isArray(t)&&t[0]instanceof cO?t:dF(t).map(t=>new fO(t,e))}class gO{constructor(){}static registerCallbackConstructor(t,e){s.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),gO.checkForDuplicate(e),null==gO.constructors[t]&&(gO.constructors[t]=[]),gO.constructors[t].push(e)}static checkForDuplicate(t){for(const e in gO.constructors)gO.constructors[+e].forEach(e=>{if(e===t)throw new iF("Duplicate callback constructor.")})}static clear(){gO.constructors={}}static createCallbacks(t){const e=[];for(const n in gO.constructors){const s=+n;t>=s&&e.push(...gO.constructors[s])}return e.map(t=>new t)}}function yO(t,e,n,s,r,i,a,o,l){const u=new pO,c=[new dO,...gO.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new hO(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:u}}function bO(t,e={},n=!1){return bF(t,u.SerializationMap.getMap().classNameMap,e,"layer",n)}function xO(t,e){return yI(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=EN(fD(t),e,!0),s=yN(n.shape,nF()),r=vE(FN(n,s));return lN(t,r)})}function vO(t,e){return yI(()=>DN(fD(NN(e,t)),-1))}function wO(t,e){return yI(()=>DN(SI(NN(e,t)),-1))}function _O(t,e){return yI(()=>{const n=NN(t,e),s=XI(SI(t),nF(),Number.MAX_VALUE),r=SI(lN(n,s));return IN(100,DN(r,-1))})}function kO(t,e,n=!1){return yI(()=>{if(n)e=yE(e);else{const t=EN(e,e.shape.length-1,!0);e=lN(e,t)}return e=XI(e,nF(),1-nF()),qN(EN(IN(t.toFloat(),kN(e)),e.shape.length-1))})}function SO(t,e,n=!1){return yI(()=>{const s=bN(function(t){const e=[ZF(t.shape)];return t.reshape(e)}(t)).toInt(),r=(e=XI(e,nF(),1-nF())).shape;return kO(XN(s,r[r.length-1]).reshape(r),e,n)})}function CO(t,e){return yI(()=>{let n;return n=XI(e,nF(),1-nF()),n=kN(lN(n,NN(1,n))),DN(function(t,e){if(!s.arraysEqual(t.shape,e.shape))throw new iF(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return yI(()=>{const n=e.relu(),s=e.abs().neg();return n.sub(e.mul(t)).add(s.exp().log1p())})}(t,n),-1)})}function IO(t,e){return yI(()=>{const n=xO(t,-1),s=xO(e,-1),r=IN(n,s);return qN(EN(r,-1))})}gO.constructors={};const NO={meanSquaredError:vO,meanAbsoluteError:wO,meanAbsolutePercentageError:_O,meanSquaredLogarithmicError:function(t,e){return yI(()=>{const n=XI(e,nF(),Number.MAX_VALUE),s=kN(CI(1,n)),r=XI(t,nF(),Number.MAX_VALUE),i=kN(CI(1,r));return DN(fD(NN(s,i)),-1)})},squaredHinge:function(t,e){return yI(()=>{const n=FN(0,NN(1,IN(t,e)));return DN(fD(n),-1)})},hinge:function(t,e){return yI(()=>{const n=FN(0,NN(1,IN(t,e)));return DN(n,-1)})},categoricalHinge:function(t,e){return yI(()=>{const n=EN(IN(t,e),-1),s=CN(IN(NN(1,t),e),-1);return FN(0,CI(1,NN(s,n)))})},logcosh:function(t,e){return yI(()=>{const n=Math.log(2),s=NN(e,t),r=NN(CI(s,bE(IN(-2,s))),n);return DN(r,-1)})},categoricalCrossentropy:kO,sparseCategoricalCrossentropy:SO,binaryCrossentropy:CO,kullbackLeiblerDivergence:function(t,e){return yI(()=>{const n=XI(t,nF(),1),s=XI(e,nF(),1);return EN(IN(t,kN(lN(n,s))),-1)})},poisson:function(t,e){return yI(()=>{const n=kN(CI(nF(),e));return DN(NN(e,IN(t,n)),-1)})},cosineProximity:IO};function EO(t){if("string"==typeof t){if(t in NO)return NO[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new iF(e)}return t}function TO(t,e){return yI(()=>{const n=IN(.5,ZN(e)),s=sD(vN(e,n),t.dtype);return DN(pN(t,s),-1)})}function AO(t,e){return yI(()=>sD(pN(EI(t,-1),EI(e,-1)),"float32"))}function RO(t,e){return CO(t,e)}function $O(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),pN(t,e).asType("float32")}const FO=kO,DO=SO,OO={binaryAccuracy:TO,categoricalAccuracy:AO,precision:function(t,e){return yI(()=>{const n=function(t,e){return yI(()=>AN(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),s=function(t,e){return yI(()=>AN(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),r=n.add(s);return TE(vN(r,0),n.div(r),0).cast("float32")})},categoricalCrossentropy:FO,sparseCategoricalCrossentropy:DO,mse:vO,MSE:vO,mae:wO,MAE:wO,mape:_O,MAPE:_O,cosine:IO};function LO(t){if("string"==typeof t&&t in OO)return OO[t];if("string"!=typeof t&&null!=t)return t;throw new iF(`Unknown metric ${t}`)}function MO(t){if(uF(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(NO))if(NO[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(OO))if(OO[n]===t){e=n;break}return void 0!==e?e:t.name}}function PO(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!zO(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function zO(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!zO(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!zO(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function BO(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function VO(t,e,n){let s;try{s=JSON.stringify(t.outputShape)}catch(dY){s="multiple"}BO([`${t.name} (${t.getClassName()})`,s,t.countParams().toString()],e,n)}function WO(t,e,n,s){let r;try{r=JSON.stringify(t.outputShape)}catch(dY){r="multiple"}const i=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t)i.push(`${u.inboundLayers[t].name}[${u.nodeIndices[t]}][${u.tensorIndices[t]}]`);const a=t.name,o=t.getClassName(),l=0===i.length?"":i[0];BO([`${a} (${o})`,r,t.countParams().toString(),l],e,s);for(let u=1;u<i.length;++u)BO(["","","",i[u]],e,s)}function UO(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function jO(t,e){if(null===t)return null;if("string"==typeof t)return fF(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];UO(e,r,s)?n.push(s):n.push(jO(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];if("name"===n&&"string"==typeof s)e[n]=s;else{const t=fF(n);e[t]=jO(s,t)}}return e}}function HO(t,e){if(null==t)return null;if("string"==typeof t)return pF(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];UO(e,r,s)?n.push(s):n.push(HO(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];e[pF(n)]="name"!==n&&"className"!==n||"string"!=typeof s?HO(s,n):s}return e}}class GO{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof GO)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new iF(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return IC(e,t.dtype)}catch(dY){throw new iF(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof tO){if(null==this.id2Value[t.id])throw new iF(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new iF(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof tO){if(null==this.id2Value[t.id])throw new iF(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new iF(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&bI(this.id2Mask)}}const qO={},KO={};function XO(t,e,n,r){const i=null!=n&&n.training,a=Array.isArray(t),o=a?t:[t],l=o.map(t=>t.name),u=[],c=e.names();for(const s of l)-1!==c.indexOf(s)?u.push(e.getValue(s)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().join(",");let d,p;if(null==qO[h]){const t=function(t,e){s.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===t.length){const s=YO(t[0],e);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of t){const{sorted:t,recipientMap:a}=YO(i,e);for(const e of t)s.has(e.name)||(n.push(e),s.add(e.name));for(const e in a)null==r[e]&&(r[e]=new Set),a[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:QO(r)}}(o,e);d=t.sorted,p=t.recipientCounts,qO[h]=d,KO[h]=p}d=qO[h],p={},i||Object.assign(p,KO[h]);const f=new GO(e);for(let s=0;s<d.length;++s){if(null!=r){const t=gI().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[s],a=t.sourceLayer;if(a instanceof aO)continue;const o=[],c=[],h=[];let m=!1;for(const n of t.inputs){const t=f.getValue(n),s=f.getMask(n);o.push(t),c.push(s),null!=s&&(m=!0),i||(p[n.name]--,0!==p[n.name]||e.hasKey(n)||-1!==l.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||h.push(t))}m&&((n=n||{}).mask=c[0]);const g=dF(a.apply(o,n));let y=null;a.supportsMasking&&(y=a.computeMask(o,c));const b=ZO(t),x=Array.isArray(b)?b:[b];for(let e=0;e<x.length;++e){f.hasKey(x[e])||f.add(x[e],g[e],Array.isArray(y)?y[0]:y);const t=l.indexOf(x[e].name);-1!==t&&(u[t]=g[e])}i||bI(h)}return f.disposeMasks(),a?u:u[0]}function QO(t){const e={};for(const n in t)e[n]=t[n].size;return e}function YO(t,e){const n=new Set,s=[],r={};for(const o of e.names())n.add(o);const i=[],a=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=a[a.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),s.push(t),n.add(t.name),e&&a.pop();else{a.push(i.length-1);for(const e of t.inputs)null==r[e.name]&&(r[e.name]=new Set),r[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:s,recipientMap:r}}function ZO(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const s of t.sourceLayer.inboundNodes[e].outputTensors)if(s.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class JO extends rO{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=jD(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],vF(this.inputs).length!==this.inputs.length)throw new iF(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(t=>t.name)}`);vF(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;uF(0===e,"input layer has >1 nodes"),uF(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof aO))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},s={},r={},i={},a=[],o=(t,e,n,s,r,l)=>{null!=s&&null!=r&&null!=l||(s=t.sourceLayer,r=t.nodeIndex,l=t.tensorIndex);const u=s.inboundNodes[r];if(-1!==n.indexOf(u))throw new rF(`The tensor ${t.name} at layer "${s.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(JO.nodeKey(s,r)),s.id in i||(i[s.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++)o(u.inputTensors[i],e,n,u.inboundLayers[i],u.nodeIndices[i],u.tensorIndices[i]);for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);a.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=a.slice().reverse();for(const y of c){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==s[y.outboundLayer.id]?0:s[y.outboundLayer.id]),s[y.outboundLayer.id]=t,r[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let s=0;s<y.inboundLayers.length;s++){const r=y.inboundLayers[s].inboundNodes[y.nodeIndices[s]];e[r.id]=Math.max(t+1,null==e[r.id]?0:e[r.id]),n[r.id]=r}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in s){const t=s[y];t in d||(d[t]=[]),d[t].push(r[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(xF);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=i[t.id],s=i[e.id];return n<s?-1:n>s?1:0});for(const e of t)e instanceof JO&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(xF);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new rF(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new rF(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new nO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new iF("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let s=0;for(const i of this.layers)for(const t of i.weights){if(null!=n[t.originalName])throw new iF(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,s++}const r=[];for(const i in t){let s=i;if(null==n[i]){const t=i.split("/");s=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[s])r.push([n[s],t[i]]);else if(e)throw new iF(`Provided weight data has no target variable: ${i}`);delete n[s]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new iF(`${t.length} of ${s} weights are not set: ${t}`)}ZD(r)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.3.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=HO(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return yI(()=>{t=dF(t);const n=new GO;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return XO(this.outputs,n,e)})}computeMask(t,e){return yI(()=>{let n;return t=dF(t),n=null==e?lF(null,t.length):dF(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=GD(t);if(e.length!==this.inputLayers.length)throw new iF(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let a=0;a<e.length;a++)n[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(xF);if(s.length>1)for(const a of s){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const s=[];for(let a=0;a<e.inboundLayers.length;a++)s.push(n[`${e.inboundLayers[a].name}_${e.nodeIndices[a]}_${e.tensorIndices[a]}`]);const r=GD(t.computeOutputShape(hF(s))),i=t.inboundNodes.indexOf(e);for(let e=0;e<r.length;e++)n[`${t.name}_${i}_${e}`]=r[e]}}const r=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const t=i[a];uF(t in n),r.push(n[t])}return hF(r)}runInternalGraph(t,e){null==e&&(e=lF(null,t.length));const n={};for(let o=0;o<this.inputs.length;++o)n[this.inputs[o].id]=[t[o],e[o]];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(xF);for(const o of s){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer,s=e.inputTensors,r=e.outputTensors,i=new Array;for(const e of s)e.id in n&&i.push(n[e.id]);if(i.length===s.length){let s,a,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===i.length){const[e,n]=i[0];null==u.mask&&(u.mask=n),o=dF(t.call(e,u)),l=dF(t.computeMask(e,n)),s=[e],a=[n]}else s=i.map(t=>t[0]),a=i.map(t=>t[1]),null==u.mask&&(u.mask=a),o=dF(t.call(s,u)),l=dF(t.computeMask(s,a));if(t.activityRegularizer)throw new aF("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t)n[r[t].id]=[o[t],l[t]]}}}const r=[],i=[],a=[];for(const o of this.outputs){uF(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[t,e]=n[o.id];a.push(t.shape),r.push(t),i.push(e)}return[r,i,a]}buildNodeConversionMap(t){const e={};let n;for(const s of this.layers){n=s instanceof JO?1:0;for(let t=0;t<s.inboundNodes.length;t++){const r=JO.nodeKey(s,t);this.containerNodes.has(r)&&(e[r]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new iF(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new iF("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new iF(`No such layer: ${t}`)}calculateLosses(){return yI(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const s=JO.nodeKey(e,n);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const t=i.getClassName(),s=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){const t=i.inboundNodes[n],s=JO.nodeKey(i,n);let a={};if(this.containerNodes.has(s)){if(t.callArgs)try{JSON.stringify(t.callArgs),a=t.callArgs}catch(dY){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(t.inboundLayers.length>0){const n=[];for(let s=0;s<t.inboundLayers.length;s++){const r=t.inboundLayers[s],i=t.tensorIndices[s];let o=e[JO.nodeKey(r,t.nodeIndices[s])];null==o&&(o=0),n.push([r.name,o,i,a])}r.push(n)}}}const a={};a.name=i.name,a.className=t,a.config=s,a.inboundNodes=r,n.push(a)}t.layers=n;const s=[];for(let i=0;i<this.inputLayers.length;i++){const t=this.inputLayers[i],n=JO.nodeKey(t,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),s.push([t.name,r,this.inputLayersTensorIndices[i]])}t.inputLayers=s;const r=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],n=JO.nodeKey(t,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=e[n];null==s&&(s=0),r.push([t.name,s,this.outputLayersTensorIndices[i]])}return t.outputLayers=r,t}static fromConfig(t,e,n={},s=!1){const r={},i={};function a(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function o(t,e){const n=[];let s;for(const i of e){const o=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(o in r))return void a(t,e);const c=r[o];if(c.inboundNodes.length<=l)return void a(t,e);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&t.apply(hF(n),s)}function l(t){const n=t.name,i=bO(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(s),r[n]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new iF(`Corrupted configuration, expected array for nodeData: ${t}`);a(i,t)})}const u=e.name,c=e.layers;for(const m of c)l(m);for(;!wF(i);)for(const t of c){const e=r[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)o(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];uF(t in r),h.push(r[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];uF(t in r),d.push(r[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new iF("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){yI(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function tL(t,e){return function(t,e,n){const s=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===s)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${s}) outputs, so classWeight must be either an array with ${s} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}async function eL(t,e,n,s){if(null!=e||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=yI(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await e.data());bI(e);const r=[];return s.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);r.push(n[t])}),SE(r,"float32")}return null}function nL(t,e){return IN(t,e)}function sL(t,e){let n,r;n=e.xs,r=e.ys,s.assert(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=rL("input",t.inputNames,n),a=rL("output",t.outputNames,r),o=i[0].shape[0];s.assert(i.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),s.assert(a.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<i.length;l++)s.assert(i[l].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let l=0;l<a.length;l++)s.assert(a[l].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:i,ys:a}}function rL(t,e,n){if(n instanceof iS)return[n];if(Array.isArray(n))return s.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(null==n[r])throw new iF(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function iL(t){return"function"==typeof t.iterator}function aL(t){s.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function oL(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>iD(t,e,n-e)):iD(t,e,n-e)}function lL(t,e){return yI(()=>null==t?null:Array.isArray(t)?t.map(t=>lL(t,e)):pD(t,"int32"===e.dtype?e:e.toInt()))}function uL(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function cL(t){const e=[];t instanceof iS&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(1===s.rank)e.push(rD(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function hL(t,e){if(null==t)return;const n=[];if(e instanceof iS)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const r in e)n.push(e[r].id);const s=[];if(t instanceof iS)-1===n.indexOf(t.id)&&s.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&s.push(t)});else if(null!=t)for(const r in t){const e=t[r];-1===n.indexOf(e.id)&&s.push(e)}s.forEach(t=>{t.isDisposed||t.dispose()})}function dL(t){return Array.isArray(t)}function pL(t){return!function(t){return t instanceof iS}(t)&&!dL(t)}function fL(t,e,n,s=!0,r=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(dL(t)&&t.length>0)e=!0;else if(pL(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new iF(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(null==t)return e.map(t=>null);let i;if(pL(t)){t=t,i=[];for(const n of e){if(null==t[n])throw new iF(`No data provided for "${n}". Need data for each key in: ${e}`);i.push(t[n])}}else if(dL(t)){if((t=t).length!==e.length)throw new iF(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(t=t,e.length>1)throw new iF(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=cL(i),null!=n)for(let a=0;a<e.length;++a){if(null==n[a])continue;const t=i[a];if(t.shape.length!==n[a].length)throw new iF(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s). but got array with shape ${t.shape}`);for(let i=0;i<n[a].length;++i){if(0===i&&!s)continue;const o=t.shape[i],l=n[a][i];if(null!=l&&l>=0&&o!==l)throw new iF(`Error when checking ${r}: expected ${e[a]} to have shape [${n[a]}], but got array with shape [${t.shape}].`)}}return i}function mL(t,e,n,s=!0,r=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new iF(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new iF(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(null!=n)for(let a=0;a<e.length;++a){if(null==n[a])continue;const t=i[a];if(t.shape.length!==n[a].length)throw new iF(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(t.shape)}`);for(let i=0;i<n[a].length;++i){if(0===i&&!s)continue;const o=t.shape[i],l=n[a][i];if(null!=l&&l!==o)throw new iF(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class gL extends JO{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new iF("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,s=console.log){const r=function(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let t=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Output shape","Param #"];let a;if(r?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!r){i.push("Receives inputs"),a=[];for(const e in t.nodesByDepth)a.push(...t.nodesByDepth[e])}s("_".repeat(e)),BO(i,n,s),s("=".repeat(e));const o=t.layers;for(let c=0;c<o.length;++c)r?VO(o[c],n,s):WO(o[c],n,a,s),s((c===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=XD(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),u=XD(t.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>OT.adagrad(.01),Adadelta:()=>OT.adadelta(1,.95,nF()),Adam:()=>OT.adam(.001,.9,.999,nF()),Adamax:()=>OT.adamax(.002,.9,.999,nF(),0),RMSProp:()=>OT.rmsprop(.001,.9,0,nF()),SGD:()=>OT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new iF(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof kI))throw new iF("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new iF(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>EO(t))}else{const n=EO(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new iF(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(EO(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const t=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],qF("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const s=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const s of e){let e=n.hasOwnProperty(s)?n[s]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),r=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};qF("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,s,i;for(const a of e){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const e=this.internalOutputShapes[t];let r;1===e[e.length-1]||this.lossFunctions[t]===CO?-1!==["accuracy","acc"].indexOf(a)?s=TO:-1!==["crossentropy","ce"].indexOf(a)&&(s=RO):this.lossFunctions[t]===SO?-1!==["accuracy","acc"].indexOf(a)?s=$O:-1!==["crossentropy","ce"].indexOf(a)&&(s=DO):-1!==["accuracy","acc"].indexOf(a)?s=AO:-1!==["crossentropy","ce"].indexOf(a)&&(s=FO),-1!==["accuracy","acc"].indexOf(a)?r="acc":-1!==["crossentropy","ce"].indexOf(a)&&(r="ce"),i=s,n=""+r}else{const t=LO(a);i=t,n=""+MO(a)}let e;qF(n,()=>{e=i}),r(t,n,e)}})(s[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const s=null==n.batchSize?32:n.batchSize;aL(s);const r=this.standardizeUserDataXY(t,e,!0,s);try{const i=r[0].concat(r[1]);return this.makeTestFunction(),hF(this.testLoop(this.testFunction,i,s,n.verbose,n.steps))}finally{hL(r[0],t),hL(r[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,i=t.testFunction;let a=[];if(n.verbose>0)throw new aF("Verbose mode is not implemented yet.");s.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o="function"==typeof e.next?e:await e.iterator();let l=0,u=0;for(;!r||u<n.batches;){const e=await o.next();if(a=yI(()=>{if(e.value){const{xs:n,ys:s}=sL(t,e.value),r=n.concat(s),o=yI(()=>i(r));if(bI(r),0===u)for(let t=0;t<o.length;++t)a.push(_I(0));const c=r[0].shape[0];for(let t=0;t<o.length;++t){const e=o[t],n=a[t];a[t]=yI(()=>CI(a[t],IN(c,e))),u>0&&bI(n)}bI(o),l+=c,++u}return a}),e.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let s=0;s<a.length;++s){const t=a[s];a[s]=lN(a[s],l),bI(t)}return hF(a)}(this,t,e)}checkNumSamples(t,e,n,s="steps"){let r;if(null!=n){if(r=null,null!=e)throw new iF(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new iF(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new iF("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),s=this.retrieveSymbolicTensors(n?e:[e]),r=new GO;if(t instanceof iS&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new iF(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)r.add(this.inputs[e],t[e])}else for(const a of this.inputs){const e=t[a.name];if(null==e)throw new iF(`No value is provided for the model's input ${a.name}`);r.add(a,e)}const i=XO(s,r);return n?i:i[0]}retrieveSymbolicTensors(t){const e=lF(null,t.length);let n=t.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],i=r.map(t=>t.name);for(let s=0;s<t.length;++s){const a=i.indexOf(t[s]);if(-1!==a&&(e[s]=r[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,s)=>{null==e&&n.push(t[s])}),new iF(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return yI(()=>{const s=this.checkNumSamples(t);if(n)throw new aF("Verbose predictLoop() is not implemented yet.");const r=uL(s,e),i=this.outputs.map(t=>[]);for(let e=0;e<r.length;++e)yI(()=>{const n=oL(t,r[e][0],r[e][1]),s=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)s.push({key:this.inputs[t],value:n[t]});else s.push({key:this.inputs[0],value:n});const i=new GO(s);return XO(this.outputs,i)}).forEach((t,e)=>i[e].push(t));return hF(i.map(t=>QI(t,0)))})}predict(t,e={}){const n=cL(t);mL(n,this.inputNames,this.feedInputShapes,!1);try{const s=null==e.batchSize?32:e.batchSize;return aL(s),this.predictLoop(n,s)}finally{hL(n,t)}}predictOnBatch(t){mL(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(null==this.optimizer_)throw new rF("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let s=0;s<this.feedOutputShapes.length;++s){const t=this.feedOutputShapes[s];i.push(this.feedLossFns[s]===SO?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const r=vF(t.map(t=>t.shape[0]));r.sort();const i=vF(e.map(t=>t.shape[0]));if(i.sort(),r.length>1)throw new iF(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(t=>t.shape))}`);if(i.length>1)throw new iF(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(t=>t.shape))}`);if(r.length>0&&i.length>0&&!s.arraysEqual(r,i))throw new iF(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(t=fL(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=fL(e,this.feedOutputNames,i,!1,"target")),function(t,e,n){const s=[vO,CO,kO];for(let r=0;r<t.length;++r){const i=t[r],a=e[r],o=n[r];if(null!=a){if(a===kO&&1===i.shape[i.shape.length-1])throw new iF(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(a)){const t=i.shape.slice(1),e=o.slice(1);for(let n=0;n<t.length;++n){const s=t[n],r=e[n];if(null!=r&&s!==r)throw new iF(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&t[0].shape[0]%r!=0)throw new iF(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,s,r=!0,i){const[a,o]=this.standardizeUserDataXY(t,e,r,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=s){const t=tL(s,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await eL(o[e],null,t[e]))}return[a,o,l]}testLoop(t,e,n,s=0,r){return yI(()=>{const i=this.checkNumSamples(e,n,r,"steps"),a=[];if(s>0)throw new aF("Verbose mode is not implemented yet.");if(null!=r)throw new aF("steps mode in testLoop() is not implemented yet");{const s=uL(i,n),r=SE(nD(0,i));for(let n=0;n<s.length;++n){const i=s[n][0],o=s[n][1],l=iD(r,i,o-i),u=lL(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)a.push(_I(0));for(let t=0;t<c.length;++t)a[t]=CI(a[t],IN(o-i,c[t]))}for(let t=0;t<a.length;++t)a[t]=lN(a[t],i)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const s=t[n];let r=s;cF(t,s)>1&&(r+=`_${cF(t.slice(0,n),s)}`),e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],a=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const a=new GO(t),o=XO(this.outputs,a,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(s[n],o[n]);null!=r[n]&&(t=nL(t,r[n]));const i=DN(t);e.push(i),l=0===n?t:CI(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=DN((0,this.metricsTensors[n][0])(s[e],o[e]))}xI(t),i.push(t)}return l=DN(l),this.calculateLosses().forEach(t=>{l=CI(l,t)}),l},!0,a)].concat(i)}}makeTestFunction(){this.testFunction=t=>yI(()=>{const e=[];let n;const s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:s[t]});const a=new GO(i),o=XO(this.outputs,a);for(let t=0;t<this.lossFunctions.length;++t){const s=DN((0,this.lossFunctions[t])(r[t],o[t]));n=0===t?s:CI(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],s=DN((0,this.metricsTensors[t][0])(r[n],o[n]));e.push(s)}return e})}async fit(t,e,n={}){return async function(t,e,n,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,o,l,u,c,h;t.isTraining=!0;try{const d=null==r.batchSize?32:r.batchSize;aL(d);const p=!1,f=await t.standardizeUserData(e,n,r.sampleWeight,r.classWeight,p,d);i=f[0],a=f[1],h=f[2];let m,g=!1;if(null!=r.validationData&&r.validationData.length>0){if(g=!0,2!==r.validationData.length)throw 3===r.validationData.length?new aF("validationData including sample weights is not supported yet."):new iF(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);o=r.validationData[0],l=r.validationData[1];const e=!0,n=await t.standardizeUserData(o,l,null,null,e,d);u=n[0],c=n[1],m=u.concat(c)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){g=!0;const t=Math.floor(i[0].shape[0]*(1-r.validationSplit)),e=i[0].shape[0];u=oL(i,t,e),i=oL(i,0,t),c=oL(a,t,e),a=oL(a,0,t),m=u.concat(c)}else null!=r.validationSteps&&(g=!0);const y=i.concat(a).concat(h);t.checkTrainableWeightsConsistency();const b=t.makeTrainFunction(),x=t.getDedupedMetricsNames();let v,w;g?(t.makeTestFunction(),v=t.testFunction,w=x.slice().concat(x.map(t=>"val_"+t))):(v=null,m=[],w=x.slice());const _=mO(r.callbacks,r.yieldEvery);return await async function(t,e,n,r,i,a,o,l,u,c,h,d,p,f,m){null==i&&(i=32),null==a&&(a=1),null==h&&(h=!0),null==p&&(p=0);let g=!1;null!=u&&null!=c&&(g=!0);const y=t.checkNumSamples(n,i,null,"steps_per_epoch");let b;null!=y&&(b=nD(0,y)),null==o&&(o=1);const{callbackList:x,history:v}=yO(l,o,a,p,y,null,i,g,d);x.setModel(t),t.history=v,await x.onTrainBegin(),t.stopTraining_=!1;for(let w=p;w<a;++w){await x.onEpochBegin(w);const a={};{if("batch"===h)throw new aF("batch shuffling is not implemneted yet");h&&s.shuffle(b);const o=SE(b),l=uL(y,i);for(let s=0;s<l.length;++s){const h={};if(await x.onBatchBegin(s,h),yI(()=>{const d=l[s][0],p=l[s][1],f=iD(o,d,p-d);h.batch=s,h.size=p-d;const m=lL(n,f),y=e(m);for(let t=0;t<r.length;++t){const e=y[t];h[r[t]]=e,xI(e)}if(s===l.length-1&&g){const e=t.testLoop(u,c,i);for(let t=0;t<r.length;++t){const n=r[t],s=e[t];xI(s),a["val_"+n]=s}}}),await x.onBatchEnd(s,h),lO(h),t.stopTraining_)break}o.dispose()}if(await x.onEpochEnd(w,a),t.stopTraining_)break}return await x.onTrainEnd(),await t.history.syncData(),t.history}(t,b,y,x,d,r.epochs,r.verbose,_,v,m,r.shuffle,w,r.initialEpoch)}finally{t.isTraining=!1,hL(i,e),hL(a,n),hL(u,o),hL(c,l),null!=h&&bI(h)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const r=null!=n.batchesPerEpoch;if(s.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),s.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),s.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),s.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),s.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=n.validationData;let a,o;if(i)if(iL(n.validationData))s.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const t=function(t){if(3===t.length)throw new aF("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);a=t.xs,o=t.ys}const l=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let c;c=i?u.slice().concat(u.map(t=>"val_"+t)):u.slice();const h=mO(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=yO(h,d,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,i,c);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const s={};await p.onEpochBegin(m);let c=0,h=0;for(r||(g=await e.iterator());!r||c<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:s,ys:r}=sL(t,e.value),i={};i.batch=h,i.size=s[0].shape[0],await p.onBatchBegin(h,i);const a=[];if(null!=n.classWeight){const e=tL(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)a.push(await eL(r[t],null,e[t]))}const o=s.concat(r).concat(a),d=l(o);bI(o);for(let t=0;t<u.length;++t){const e=d[t];i[u[t]]=e,xI(e)}await p.onBatchEnd(h,i),lO(i),h++,c++}if(r?c>=n.batchesPerEpoch:e.done){if(i){let e;e=iL(n.validationData)?dF(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):dF(t.evaluate(a,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)s[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,s),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),s=n[0],r=n[1],i=this.makeTrainFunction()(s.concat(r)),a=[];for(const o of i){const t=await o.data();a.push(t[0])}return bI(i),hF(a)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let i=0;i<s.length;++i)n&&!s[i].trainable||e.push({name:s[i].originalName,tensor:r[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=gI().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-gI().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=pF(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>pF(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const s of e){if("string"!=typeof n[s])throw new Error("Serialization of non-string loss is not supported.");t[s]=pF(n[s])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[pF(MO(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>pF(MO(t)));{const t={};for(const e in this.metrics)t[e]=pF(MO(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=bO(jO(t.optimizer_config));let n,s;if("string"==typeof t.loss)n=fF(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>fF(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=fF(t.loss[e])}if(Array.isArray(t.metrics))s=t.metrics.map(t=>fF(t));else if(null!=t.metrics){s={};for(const e in t.metrics)s[e]=fF(t.metrics[e])}this.compile({loss:n,metrics:s,optimizer:e})}async save(t,e){if("string"==typeof t){const e=a.getSaveHandlers(t);if(0===e.length)throw new iF(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new iF(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new iF("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await a.encodeWeights(this.getNamedWeights(e)),s={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.3.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:r}=await a.encodeWeights(await this.optimizer.getWeights(),t);n.specs.push(...r),n.data=a.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(PO(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,t.save(s)}setUserDefinedMetadata(t){PO(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}gL.className="Model",u.registerClass(gL);class yL extends gL{}yL.className="Functional",u.registerClass(yL);class bL extends gL{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:jD("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new iF(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof bL||t instanceof gL;let n;if(e){if(n=t,1!==n.outputs.length)throw new iF("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new iF("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new iF("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new iF("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new aO({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new iF(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new iF("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=iO(this.outputs[0])}this.inboundNodes=[],new nO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:lF(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(KD(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new gL({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new rF("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new rF("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new rF("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new rF("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},r=!1){let i,a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new iF("Legacy serialization format not supported yet.");i=e}else s.assert(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,a=e;const o=new t(a);if(!(o instanceof bL))throw new aF(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const s of i){const t=bO(s,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(t){if(null==this.model)throw new iF("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new iF("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}bL.className="Sequential",u.registerClass(bL);class xL extends u.Serializable{getConfig(){return{}}}class vL extends xL{apply(t,e=1){return function(t,e=1){if(1!==e)throw new aF(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return uN(t)}(t,e)}}vL.className="elu",u.registerClass(vL);class wL extends xL{apply(t){return uE(t)}}wL.className="selu",u.registerClass(wL);class _L extends xL{apply(t){return oE(t)}}_L.className="relu",u.registerClass(_L);class kL extends xL{apply(t){return yI(()=>LN(6,oE(t)))}}kL.className="relu6",u.registerClass(kL);class SL extends xL{apply(t){return t}}SL.className="linear",u.registerClass(SL);class CL extends xL{apply(t){return hE(t)}}CL.className="sigmoid",u.registerClass(CL);class IL extends xL{apply(t){return function(t){return yI(()=>{const e=CI(.5,IN(.2,t));return XI(e,0,1)})}(t)}}IL.className="hardSigmoid",u.registerClass(IL);class NL extends xL{apply(t){return bE(t)}}NL.className="softplus",u.registerClass(NL);class EL extends xL{apply(t){return function(t){return yI(()=>lN(t,SI(t).add(1)))}(t)}}EL.className="softsign",u.registerClass(EL);class TL extends xL{apply(t){return kE(t)}}TL.className="tanh",u.registerClass(TL);class AL extends xL{apply(t,e=-1){return yE(t,e)}}AL.className="softmax",u.registerClass(AL);class RL extends xL{apply(t,e=-1){return TN(t,e)}}RL.className="logSoftmax",u.registerClass(RL);class $L extends xL{apply(t,e=1){return yI(()=>hE(t.mul(e)).mul(t))}}function FL(t){return t.getClassName()}function DL(t,e={}){return bF(t,u.SerializationMap.getMap().classNameMap,e,"activation")}function OL(t){if(null==t)return DL({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},DL(e)}return t instanceof xL?t:DL(t)}$L.className="swish",u.registerClass($L);class LL extends u.Serializable{}class ML extends LL{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return yI(()=>{let e=QN([1]);return this.hasL1&&(e=CI(e,EN(IN(this.l1,SI(t))))),this.hasL2&&(e=CI(e,EN(IN(this.l2,fD(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}ML.className="L1L2",u.registerClass(ML);const PL={l1l2:"L1L2"};function zL(t){return gF(t)}function BL(t,e={}){return bF(t,u.SerializationMap.getMap().classNameMap,e,"regularizer")}function VL(t){return null==t?null:"string"==typeof t?BL({className:t in PL?PL[t]:t,config:{}}):t instanceof LL?t:BL(t)}class WL extends rO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=qD(t);let n=oE(t);return null!=this.maxValue&&(n=XI(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}WL.className="ReLU",u.registerClass(WL);class UL extends rO{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=qD(t);return _N(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}UL.className="LeakyReLU",u.registerClass(UL);class jL extends rO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=BD(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=VL(t.alphaRegularizer),this.alphaConstraint=LF(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new iF(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=KD(t)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<t.length;++s)n[s]=t[s];this.inputSpec=[new JD({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=qD(t),eE(t,this.alpha.read())}getConfig(){const t={alphaInitializer:zD(this.alphaInitializer),alphaRegularizer:zL(this.alphaRegularizer),alphaConstraint:DF(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}jL.className="PReLU",u.registerClass(jL);class HL extends rO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new aF(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=qD(t);return uN(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}HL.className="ELU",u.registerClass(HL);class GL extends rO{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=qD(t);return n.mul(sD(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}GL.className="ThresholdedReLU",u.registerClass(GL);class qL extends rO{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new AL).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=qD(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function KL(t,e,n){if("number"==typeof t)return lF(t,e);if(t.length!==e)throw new iF(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const i=t[r];if((s=i)!==parseInt(s.toString(),10))throw new iF(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t;var s}function XL(t,e,n,s,r=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(r-1))+1,Math.floor((i+s-1)/s)}function QL(t,e,n,s){if(null==t)return null;if("valid"===s)t=t*e+eD([n-e,0]);else{if("same"!==s)throw new iF(`Unsupport padding mode: ${s}.`);t*=e}return t}function YL(t,e){return yI(()=>(UF(e),"channelsFirst"===e?RE(t,[0,2,3,1]):t))}function ZL(t,e){return yI(()=>(UF(e),"channelsFirst"===e?RE(t,[0,2,3,4,1]):t))}function JL(t,e,n,s=[1,1],r="valid",i,a,o=null){return yI(()=>{if(null==i&&(i="channelsLast"),UF(i),3!==t.rank&&4!==t.rank)throw new iF(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new iF(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=YL(t,i);if("causal"===r)throw new aF("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=c.conv2d({x:l,filter:e,strides:s,pad:"same"===r?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=RE(l,[0,3,1,2])),l})}qL.className="Softmax",u.registerClass(qL);class tM extends rO{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",tM.verifyArgs(e),this.rank=t,SF(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new aF(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=KL(e.kernelSize,t,"kernelSize"),this.strides=KL(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,jF(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,UF(this.dataFormat),this.activation=OL(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=BD(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=LF(e.biasConstraint),this.biasRegularizer=VL(e.biasRegularizer),this.activityRegularizer=VL(e.activityRegularizer),this.dilationRate=KL(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new iF(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new iF(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new iF(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(uF("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!kF(t.kernelSize,"number",1,3))throw new iF(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:FL(this.activation),useBias:this.useBias,biasInitializer:zD(this.biasInitializer),biasRegularizer:zL(this.biasRegularizer),activityRegularizer:zL(this.activityRegularizer),biasConstraint:DF(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class eM extends tM{constructor(t,e){super(t,e),this.kernel=null,eM.verifyArgs(e),this.filters=e.filters,SF(this.filters,"filters"),this.kernelInitializer=BD(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=LF(e.kernelConstraint),this.kernelRegularizer=VL(e.kernelRegularizer)}build(t){t=KD(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new iF(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return yI(()=>{let e;t=qD(t);const n=null==this.bias?null:this.bias.read(),s=IF(this.activation.getClassName());if(null!=s&&2===this.rank)e=JL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)e=function(t,e,n,s=1,r="valid",i,a=1){return yI(()=>{if(null==i&&(i="channelsLast"),UF(i),3!==t.shape.length)throw new iF(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new iF(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new iF(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===i&&(t=RE(t,[0,2,1])),"causal"===r)throw new aF("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=nN(t,e,s,"same"===r?"same":"valid","NWC",a);return null!=n&&(o=gD(o,n)),o})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=JL(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new aF("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,s=[1,1,1],r="valid",i,a){return yI(()=>{if(null==i&&(i="channelsLast"),UF(i),4!==t.rank&&5!==t.rank)throw new iF(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new iF(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=ZL(t,i);if("causal"===r)throw new aF("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=iN(o,e,s,"same"===r?"same":"valid","NDHWC",a),null!=n&&(o=gD(o,n)),"channelsFirst"===i&&(o=RE(o,[0,4,1,2,3])),o})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=KD(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<n.length;++r){const t=XL(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(t)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:zD(this.kernelInitializer),kernelRegularizer:zL(this.kernelRegularizer),kernelConstraint:DF(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new iF(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class nM extends eM{constructor(t){super(2,t),nM.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!kF(t.kernelSize,"number",1,2))throw new iF(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}nM.className="Conv2D",u.registerClass(nM);class sM extends eM{constructor(t){super(3,t),sM.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new iF(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}sM.className="Conv3D",u.registerClass(sM);class rM extends nM{constructor(t){if(super(t),this.inputSpec=[new JD({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new iF(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=KD(t)).length)throw new iF("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new iF("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new JD({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return yI(()=>{let e=qD(t);if(4!==e.shape.length)throw new iF(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const i=n[r],a=this.kernelSize[1],o=this.strides[1],l=[n[0],QL(n[s],this.strides[0],this.kernelSize[0],this.padding),QL(i,o,a,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=RE(e,[0,2,3,1]));let u=rN(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=RE(u,[0,3,1,2])),null!=this.bias&&(u=gD(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(t){const e=(t=KD(t)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const i=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[s]=QL(e[s],o,i,this.padding),e[r]=QL(e[r],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}rM.className="Conv2DTranspose",u.registerClass(rM);class iM extends eM{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new iF("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new iF("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new iF(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=BD(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=VL(e.depthwiseRegularizer),this.depthwiseConstraint=LF(e.depthwiseConstraint),this.pointwiseInitializer=BD(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=VL(e.pointwiseRegularizer),this.pointwiseConstraint=LF(e.pointwiseConstraint)}build(t){if((t=KD(t)).length<this.rank+2)throw new iF(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new iF(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.inputSpec=[new JD({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return yI(()=>{let e;if(t=qD(t),1===this.rank)throw new aF("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=RE(t,[0,2,3,1])),e=cE(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=gD(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=RE(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=zD(this.depthwiseInitializer),t.pointwiseInitializer=zD(this.pointwiseInitializer),t.depthwiseRegularizer=zL(this.depthwiseRegularizer),t.pointwiseRegularizer=zL(this.pointwiseRegularizer),t.depthwiseConstraint=DF(this.depthwiseConstraint),t.pointwiseConstraint=DF(this.pointwiseConstraint),t}}iM.className="SeparableConv";class aM extends iM{constructor(t){super(2,t)}}aM.className="SeparableConv2D",u.registerClass(aM);class oM extends eM{constructor(t){super(1,t),oM.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!kF(t.kernelSize,"number",1,1))throw new iF(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}oM.className="Conv1D",u.registerClass(oM);class lM extends rO{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return yI(()=>{if(t=qD(t),"channelsLast"===this.dataFormat){const e=oD(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return oD(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=oD(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return oD(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}lM.className="Cropping2D",u.registerClass(lM);class uM extends rO{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,UF(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,_F(PF,"InterpolationFormat",this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return yI(()=>{let e=qD(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=RE(e,[0,2,3,1]);const t=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s]);return RE(r,[0,3,1,2])}{const t=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}uM.className="UpSampling2D",u.registerClass(uM);class cM extends tM{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=BD(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=LF(t.depthwiseConstraint),this.depthwiseRegularizer=VL(t.depthwiseRegularizer)}build(t){if((t=KD(t)).length<4)throw new iF(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new iF(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return yI(()=>{let e=function(t,e,n=[1,1],s="valid",r,i){return yI(()=>{null==r&&(r="channelsLast"),UF(r);let a=YL(t,r);if(4!==t.rank)throw new iF(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new iF(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=aN(a,e,n,"same"===s?"same":"valid","NHWC",i),"channelsFirst"===r&&(a=RE(a,[0,3,1,2])),a})}(t=qD(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=gD(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=KD(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=XL("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),r=XL(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,s,r]:[t[0],s,r,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=zD(this.depthwiseInitializer),t.depthwiseRegularizer=zL(this.depthwiseRegularizer),t.depthwiseConstraint=DF(this.depthwiseRegularizer),t}}function hM(t,e,n,s){if(Array.isArray(t)){if(null!=e||null!=n)throw new iF("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:n=r(n)}}function dM(t,e,n,s=!1,r,i,a=!1,o=!1){return yI(()=>{const l=e.shape.length;if(l<3)throw new iF(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(nD(2,l));if(e=RE(e,u),null!=i)throw new aF("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=r.asType("bool").asType("float32")).rank===l-1&&(r=fN(r,-1)),r=RE(r,u)),s&&(e=lE(e,0),null!=r&&(r=lE(r,0)));const c=[];let h,d=n;const p=e.shape[0],f=NE(e);let m,g;null!=r&&(m=NE(r));for(let e=0;e<p;++e){const n=f[e],s=yI(()=>t(n,d));if(null==r)h=s[0],d=s[1];else{const t=yI(()=>{const t=m[e],n=ZN(t).sub(t);return{output:s[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,r)=>s[1][r].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}o&&c.push(h)}return o&&(g=_E(c,1)),[h,g,d]})}cM.className="DepthwiseConv2D",u.registerClass(cM);class pM extends rO{constructor(t){let e;if(super(t),null==t.cell)throw new iF("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new wM({cells:t.cell}):t.cell,null==e.stateSize)throw new iF("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new JD({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?nD(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){HD(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let s;if(s=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const s of e)n.push([t[0],s]);return[s].concat(n)}return s}computeMask(t,e){return yI(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new aF("Constants support is not implemented in RNN yet.");HD(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new JD({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let i;if(this.cell.build(r),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!s.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),i))throw new iF(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(t=>new JD({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){yI(()=>{if(!this.stateful)throw new sF("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new iF("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>QN([n,t])):[QN([n,this.cell.stateSize])];else if(null==t)bI(this.states_),null!=this.keptStates&&(bI(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>QN([n,t])):this.states_[0]=QN([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new iF(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):bI(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,a=[n,i];if(!s.arraysEqual(r.shape,a))throw new iF(`State ${e} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map(t=>xI(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=hM(t,n,s,this.numConstants);t=r.inputs,n=r.initialState,s=r.constants;let i=[],a=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new JD({shape:t.shape}));a=a.concat(this.stateSpec)}if(null!=s&&(e.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof tO){const n=[t].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,e);return this.inputSpec=r,o}return super.apply(t,e)}call(t,e){return yI(()=>{const n=null==e?null:e.mask,s=null==e?null:e.training;let r=null==e?null:e.initialState;t=qD(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==i)throw new iF(`RNN Layer has ${i} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},o=dM((t,e)=>{const n=this.cell.call([t].concat(e),a);return[n[0],n.slice(1)]},t,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,s);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(t){return yI(()=>{let e=QN(t.shape);return e=EN(e,[1,2]),e=rD(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?cD(e,[1,t]):e):this.cell.stateSize>1?[cD(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===pM.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const s=bO(e.cell,n);return new t(Object.assign(e,{cell:s}))}}pM.className="RNN",u.registerClass(pM);class fM extends rO{}class mM extends fM{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,SF(this.units,"units"),this.activation=OL(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=BD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=BD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=BD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=VL(t.kernelRegularizer),this.recurrentRegularizer=VL(t.recurrentRegularizer),this.biasRegularizer=VL(t.biasRegularizer),this.kernelConstraint=LF(t.kernelConstraint),this.recurrentConstraint=LF(t.recurrentConstraint),this.biasConstraint=LF(t.biasConstraint),this.dropout=tD([1,eD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=tD([1,eD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=KD(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return yI(()=>{if(2!==(t=t).length)throw new iF(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const s=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_M({ones:()=>ZN(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_M({ones:()=>ZN(n),rate:this.recurrentDropout,training:s}));const i=this.dropoutMask,a=this.recurrentDropoutMask;r=dD(null!=i?IN(t,i):t,this.kernel.read()),null!=this.bias&&(r=gD(r,this.bias.read())),null!=a&&(n=IN(n,a));let o=CI(r,dD(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:FL(this.activation),useBias:this.useBias,kernelInitializer:zD(this.kernelInitializer),recurrentInitializer:zD(this.recurrentInitializer),biasInitializer:zD(this.biasInitializer),kernelRegularizer:zL(this.kernelRegularizer),recurrentRegularizer:zL(this.recurrentRegularizer),biasRegularizer:zL(this.biasRegularizer),activityRegularizer:zL(this.activityRegularizer),kernelConstraint:DF(this.kernelConstraint),recurrentConstraint:DF(this.recurrentConstraint),biasConstraint:DF(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}mM.className="SimpleRNNCell",u.registerClass(mM);class gM extends pM{constructor(t){t.cell=new mM(t),super(t)}call(t,e){return yI(()=>(null!=this.cell.dropoutMask&&(bI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return new t(e)}}gM.className="SimpleRNN",u.registerClass(gM);class yM extends fM{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new iF("GRUCell does not support reset_after parameter set to true.");this.units=t.units,SF(this.units,"units"),this.activation=OL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=OL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=BD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=BD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=BD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=VL(t.kernelRegularizer),this.recurrentRegularizer=VL(t.recurrentRegularizer),this.biasRegularizer=VL(t.biasRegularizer),this.kernelConstraint=LF(t.kernelConstraint),this.recurrentConstraint=LF(t.recurrentConstraint),this.biasConstraint=LF(t.biasConstraint),this.dropout=tD([1,eD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=tD([1,eD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=KD(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return yI(()=>{if(2!==(t=t).length)throw new iF(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_M({ones:()=>ZN(t),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_M({ones:()=>ZN(s),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let i,a,o;0<this.dropout&&this.dropout<1&&(t=IN(t,this.dropoutMask[0]));let l=dD(t,this.kernel.read());this.useBias&&(l=gD(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=IN(s,r[0]));const u=this.recurrentKernel.read(),[c,h]=xE(u,[2*this.units,this.units],u.rank-1),d=dD(s,c),[p,f,m]=xE(l,3,l.rank-1),[g,y]=xE(d,2,d.rank-1);i=this.recurrentActivation.apply(CI(p,g)),a=this.recurrentActivation.apply(CI(f,y));const b=dD(IN(a,s),h);o=this.activation.apply(CI(m,b));const x=CI(IN(i,s),IN(CI(1,qN(i)),o));return[x,x]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:FL(this.activation),recurrentActivation:FL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:zD(this.kernelInitializer),recurrentInitializer:zD(this.recurrentInitializer),biasInitializer:zD(this.biasInitializer),kernelRegularizer:zL(this.kernelRegularizer),recurrentRegularizer:zL(this.recurrentRegularizer),biasRegularizer:zL(this.biasRegularizer),activityRegularizer:zL(this.activityRegularizer),kernelConstraint:DF(this.kernelConstraint),recurrentConstraint:DF(this.recurrentConstraint),biasConstraint:DF(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}yM.className="GRUCell",u.registerClass(yM);class bM extends pM{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new yM(t),super(t)}call(t,e){return yI(()=>(null!=this.cell.dropoutMask&&(bI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}bM.className="GRU",u.registerClass(bM);class xM extends fM{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,SF(this.units,"units"),this.activation=OL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=OL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=BD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=BD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=BD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=VL(t.kernelRegularizer),this.recurrentRegularizer=VL(t.recurrentRegularizer),this.biasRegularizer=VL(t.biasRegularizer),this.kernelConstraint=LF(t.kernelConstraint),this.recurrentConstraint=LF(t.recurrentConstraint),this.biasConstraint=LF(t.biasConstraint),this.dropout=tD([1,eD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=tD([1,eD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=KD(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,s=this.units;n=new((e=class extends wD{apply(e,n){const r=t.apply([s]),i=(new kD).apply([s]),a=t.apply([2*s]);return uD(uD(r,i),a)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return yI(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new iF(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_M({ones:()=>ZN(t),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_M({ones:()=>ZN(s),rate:this.recurrentDropout,training:n,count:4}));const i=this.recurrentDropoutMask;let a,o,l,u;0<this.dropout&&this.dropout<1&&(t=IN(t,this.dropoutMask[0]));let c=dD(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=IN(s,i[0])),c=CI(c,dD(s,this.recurrentKernel.read())),this.useBias&&(c=gD(c,this.bias.read()));const[h,d,p,f]=xE(c,4,c.rank-1);a=this.recurrentActivation.apply(h),o=this.recurrentActivation.apply(d),l=CI(IN(o,r),IN(a,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=IN(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:FL(this.activation),recurrentActivation:FL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:zD(this.kernelInitializer),recurrentInitializer:zD(this.recurrentInitializer),biasInitializer:zD(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:zL(this.kernelRegularizer),recurrentRegularizer:zL(this.recurrentRegularizer),biasRegularizer:zL(this.biasRegularizer),activityRegularizer:zL(this.activityRegularizer),kernelConstraint:DF(this.kernelConstraint),recurrentConstraint:DF(this.recurrentConstraint),biasConstraint:DF(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}xM.className="LSTMCell",u.registerClass(xM);class vM extends pM{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new xM(t),super(t)}call(t,e){return yI(()=>(null!=this.cell.dropoutMask&&(bI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}vM.className="LSTM",u.registerClass(vM);class wM extends fM{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return yI(()=>{let n=(t=t).slice(1);const s=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?s.push(n.splice(0,t.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let i;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=s[a],i=0===a?[t[0]].concat(n):[i[0]].concat(n),i=o.call(i,e),r.push(i.slice(1))}n=[];for(const t of r.slice().reverse())n.push(...t);return[i[0]].concat(n)})}build(t){let e;HD(t)&&(t=t[0]),t=t,this.cells.forEach((n,s)=>{qF(`RNNCell_${s}`,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}));return Object.assign({},t,{cells:e})}static fromConfig(t,e,n={}){const s=[];for(const r of e.cells)s.push(bO(r,n));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return YD(t)}setWeights(t){const e=[];for(const n of this.cells){const s=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],s[t]])}ZD(e)}}function _M(t){const{ones:e,rate:n,training:s=!1,count:r=1}=t,i=()=>yD(e(),n),a=()=>bD(i,e,s);return!r||r<=1?xI(a().clone()):Array(r).fill(void 0).map(a).map(t=>xI(t.clone()))}var kM,SM;wM.className="StackedRNNCells",u.registerClass(wM);class CM extends pM{constructor(t){if(t.unroll)throw new aF("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new aF("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new JD({ndim:5})]}call(t,e){return yI(()=>{if(null!=this.cell.dropoutMask&&(bI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(bI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new iF("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return yI(()=>{const{stateSize:e}=this.cell,n=this.computeSingleOutputShape(t.shape),s=QN([n[0],...n.slice(2)]);return Array.isArray(e)?Array(e.length).fill(s):[s]})}resetStates(t,e=!1){yI(()=>{if(!this.stateful)throw new sF("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(null==n[0])throw new iF("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>QN(i)):[QN(i)];else if(null==t)bI(this.states_),null!=this.keptStates&&(bI(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>QN(i)):this.states_[0]=QN(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new iF(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):bI(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=i;if(!s.arraysEqual(n.shape,r))throw new iF(`State ${e} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map(t=>xI(t.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:s,padding:r,strides:i,dilationRate:a}=this.cell,o="channelsFirst"===e,l=t[o?4:3],u=XL(t[o?3:2],s[0],r,i[0],a[0]),c=XL(l,s[1],r,i[1],a[1]);return[...t.slice(0,2),...o?[n,u,c]:[u,c,n]]}}CM.className="ConvRNN2D";class IM extends xM{constructor(t){const{filters:e,kernelSize:n,strides:s,padding:r,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,SF(this.filters,"filters"),this.kernelSize=KL(n,2,"kernelSize"),this.kernelSize.forEach(t=>SF(t,"kernelSize")),this.strides=KL(s||1,2,"strides"),this.strides.forEach(t=>SF(t,"strides")),this.padding=r||"valid",jF(this.padding),this.dataFormat=i||"channelsLast",UF(this.dataFormat),this.dilationRate=KL(a||1,2,"dilationRate"),this.dilationRate.forEach(t=>SF(t,"dilationRate"))}build(t){var e;t=KD(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new iF(`The channel dimension of the input should be defined. Found ${t[n]}`);const s=this.kernelSize.concat([t[n],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;t=new((e=class extends wD{apply(t,e){return lD([n.apply([s]),YN([s]),n.apply([2*s])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return yI(()=>{if(3!==t.length)throw new iF(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,s=t[0],r=t[1],i=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_M({ones:()=>ZN(s),rate:this.dropout,training:n,count:4}));const a=this.dropoutMask,o=(t,e,n)=>e&&e[n]?IN(e[n],t):t;let l=o(s,a,0),u=o(s,a,1),c=o(s,a,2),h=o(s,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_M({ones:()=>ZN(r),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=o(r,d,0),f=o(r,d,1),m=o(r,d,2),g=o(r,d,3);const[y,b,x,v]=xE(this.kernel.read(),4,3),[w,_,k,S]=this.useBias?xE(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,_,this.padding),c=this.inputConv(c,x,k,this.padding),h=this.inputConv(h,v,S,this.padding);const[C,I,N,E]=xE(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,I),m=this.recurrentConv(m,N),g=this.recurrentConv(g,E);const T=this.recurrentActivation.apply(CI(l,p)),A=this.recurrentActivation.apply(CI(u,f)),R=CI(IN(A,i),IN(T,this.activation.apply(CI(c,m)))),$=IN(this.recurrentActivation.apply(CI(h,g)),this.activation.apply(R));return[$,$,R]})}getConfig(){const t=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},t,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(t,e,n,s){const r=eN(t,e,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?gD(r,n,this.dataFormat):r}recurrentConv(t,e){return eN(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}IM.className="ConvLSTM2DCell",u.registerClass(IM);class NM extends CM{constructor(t){const e=new IM(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}NM.className="ConvLSTM2D",u.registerClass(NM);class EM extends rO{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?e[s]:this.noiseShape[s]);return n}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,s=this.getNoiseShape(n);return bD(()=>yD(n,this.rate,s,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}EM.className="Dropout",u.registerClass(EM);class TM extends EM{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}TM.className="SpatialDropout1D",u.registerClass(TM);class AM extends rO{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,SF(this.units,"units"),this.activation=OL(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=BD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=BD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=LF(t.kernelConstraint),this.biasConstraint=LF(t.biasConstraint),this.kernelRegularizer=VL(t.kernelRegularizer),this.biasRegularizer=VL(t.biasRegularizer),this.activityRegularizer=VL(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=KD(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=KD(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t),s=IF(this.activation.getClassName());let r;return null!=s?r=dD(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=dD(n,this.kernel.read()),null!=this.bias&&(r=gD(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:FL(this.activation),useBias:this.useBias,kernelInitializer:zD(this.kernelInitializer),biasInitializer:zD(this.biasInitializer),kernelRegularizer:zL(this.kernelRegularizer),biasRegularizer:zL(this.biasRegularizer),activityRegularizer:zL(this.activityRegularizer),kernelConstraint:DF(this.kernelConstraint),biasConstraint:DF(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}AM.className="Dense",u.registerClass(AM);class RM extends rO{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=KD(t);for(const e of t.slice(1))if(null==e)throw new iF(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ZF(t,1)]}call(t,e){return yI(()=>{this.invokeCallHook(t,e);let n=qD(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new iF(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],ZF(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}RM.className="Flatten",u.registerClass(RM);class $M extends rO{constructor(t){super(t),this.supportsMasking=!0,this.activation=OL(t.activation)}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t);return this.activation.apply(n)})}getConfig(){const t={activation:FL(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}$M.className="Activation",u.registerClass($M);class FM extends rO{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return yI(()=>{return t=qD(t),e=t,n=this.n,yI(()=>{if(2!==e.shape.length)throw new iF(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return cD(rD(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}FM.className="RepeatVector",u.registerClass(FM);class DM extends rO{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",s=e.slice();let r=1,i=null;for(let o=0;o<s.length;++o){const t=s[o];if(this.isUnknown(t)){if(null!==i)throw new iF("Can only specifiy one unknown dimension.");i=o}else r*=t}const a=ZF(t);if(null!==i){if(0===r||a%r!=0)throw new iF(n);s[i]=a/r}else if(a!==r)throw new iF(n);return s}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}DM.className="Reshape",u.registerClass(DM);class OM extends rO{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=nD(1,t.dims.length+1);if(!s.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new JD({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=KD(t)).slice();return this.dims.forEach((n,s)=>{e[s+1]=t[n]}),e}call(t,e){return RE(qD(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}OM.className="Permute",u.registerClass(OM);class LM extends rO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=qD(t);return NI(KN(n,this.maskValue),-1)}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t),s=NI(KN(n,this.maskValue),-1,!0);return n.mul(s.asType(n.dtype))})}}LM.className="Masking",u.registerClass(LM);class MM extends rO{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(dF(t.inputLength))}this.inputDim=t.inputDim,SF(this.inputDim,"inputDim"),this.outputDim=t.outputDim,SF(this.outputDim,"outputDim"),this.embeddingsInitializer=BD(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=VL(t.embeddingsRegularizer),this.activityRegularizer=VL(t.activityRegularizer),this.embeddingsConstraint=LF(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return yI(()=>this.maskZero?(t=qD(t),KN(t,AE(t))):null)}computeOutputShape(t){if(t=KD(t),null==this.inputLength)return[...t,this.outputDim];const e=dF(this.inputLength);if(e.length!==t.length-1)throw new iF(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let s=0;s<e.length;++s){const r=e[s],i=t[s+1];if(null!=r&&null!=i&&r!==i)throw new iF(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==r&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return yI(()=>{this.invokeCallHook(t,e);let n=qD(t);return"int32"!==n.dtype&&(n=sD(n,"int32")),pD(this.embeddings.read(),n.as1D()).reshape(KD(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:zD(this.embeddingsInitializer),embeddingsRegularizer:zL(this.embeddingsRegularizer),activityRegularizer:zL(this.activityRegularizer),embeddingsConstraint:DF(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}MM.className="Embedding",u.registerClass(MM);class PM extends rO{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new aF}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const r=t[t.length-e.length+s],i=e[s];if(null==r||null==i||r<0||i<0)n.push(null);else if(1===r)n.push(i);else if(1===i)n.push(r);else{if(r!==i)throw new iF("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(r)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[KD(t)]),(t=t).length<2)throw new iF(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)null!=r&&null!==r[0]&&e.push(r[0]);if(e=vF(e),e.length>1)throw new iF(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const e=null==t[r]?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const s=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==vF(s).length}call(t,e){return yI(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const s=eD(n);for(let n of t){const t=n.rank;for(let e=0;e<s-t;++e)n=rD(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,s=t[0],r=t.slice(1).concat([s]);let a=i.reshape([s].concat(ZF(t.slice(1))));a=RE(a,[1,0]),a=a.reshape(r),e.push(a),n=!0}else if(t>1){const s=nD(1,t).concat([0]);e.push(RE(i,s)),n=!0}else e.push(i)}let s=this.mergeFunction(e);const r=s.rank;if(n)if(null==r){const t=s.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));s=RE(s.reshape([-1,e]),[1,0]).reshape(n)}else if(r>1){const t=[r-1].concat(nD(0,r-1));s=RE(s,t)}return s}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const n=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const s of t)null!=s&&null!==s[0]&&n.push(s[0]);return n=vF(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return yI(()=>{if(null==e)return null;if(!Array.isArray(e))throw new iF("`mask` should be an Array");if(!Array.isArray(t))throw new iF("`inputs` should be an Array");if(e.length!==t.length)throw new iF(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:fN(t,0)))[0];for(let t=1;t<e.length-1;++t)n=AN(n,e[t]);return n})}}class zM extends PM{constructor(t){super(t)}mergeFunction(t){return yI(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=CI(e,t[n]);return e})}}zM.className="Add",u.registerClass(zM);class BM extends PM{constructor(t){super(t)}mergeFunction(t){return yI(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=IN(e,t[n]);return e})}}BM.className="Multiply",u.registerClass(BM);class VM extends PM{constructor(t){super(t)}mergeFunction(t){return yI(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=CI(e,t[n]);return IN(1/t.length,e)})}}VM.className="Average",u.registerClass(VM);class WM extends PM{constructor(t){super(t)}mergeFunction(t){return yI(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=FN(e,t[n]);return e})}}WM.className="Maximum",u.registerClass(WM);class UM extends PM{constructor(t){super(t)}mergeFunction(t){return yI(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=LN(e,t[n]);return e})}}UM.className="Minimum",u.registerClass(UM);class jM extends PM{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new iF("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const s of t)if(null!=s){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let i=!1;for(const t of n)if(s.arraysEqual(t,e)){i=!0;break}i||n.push(e)}if(n.length>1)throw new iF("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return yI(()=>lD(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new iF("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of e.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new iF("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new iF("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new iF(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return yI(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const s=[];for(let i=0;i<t.length;++i)s.push(null==e[i]?ZN(t[i]).asType("bool"):e[i].rank<t[i].rank?fN(e[i],-1):e[i]);const r=QI(s,this.axis);return II(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function HM(t,e){for(;t<0;)t+=e;return t}jM.className="Concatenate",u.registerClass(jM);class GM extends PM{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){s.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new aF("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new iF(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(2!==t.length)throw new iF(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>HM(e,t[n].shape.length)):[HM(this.axes,n.shape.length),HM(this.axes,r.shape.length)],this.normalize&&(n=xO(n,e[0]),r=xO(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new aF("batchDot is not implemented for tensors of 4D or higher rank yet");if(s.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),s.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new aF("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,i=e.shape.length;null==n&&(n=[r-1,i-2]);const a=n;return yI(()=>{let n,s;if(r>i){n=r-i;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(i>r){n=i-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(s=2===t.shape.length&&2===e.shape.length?a[0]===a[1]?t.mul(e).sum(a[0]):t.transpose([1,0]).mul(e).sum(a[1]):t.matMul(e,a[0]!==t.shape.length-1,a[1]===e.shape.length-1),n>0){let t;t=r>i?r+i-3:r-1;const e=[];for(let s=t;s<t+n;++s)e.push(s);s=s.squeeze(e)}return 1===s.shape.length&&(s=s.expandDims(1)),s})}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[HM(this.axes,t.length),HM(this.axes,e.length)],n}computeOutputShape(t){s.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new aF("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const i=e.concat(n);return 1===i.length&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}GM.className="Dot",u.registerClass(GM);class qM extends rO{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t);return bD(()=>hD(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}qM.className="GaussianNoise",u.registerClass(qM);class KM extends rO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return yI(()=>{this.invokeCallHook(t,e);const n=qD(t);return this.rate>0&&this.rate<1?bD(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(hD(n.shape,1,t))},()=>n,e.training||!1):n})}}KM.className="GaussianDropout",u.registerClass(KM);class XM extends rO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||qD(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return yI(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return bD(()=>{const e=qD(t),s=-1.7580993408473766;let r=wN(aE(n),this.rate);r=sD(r,"float32");const i=((1-this.rate)*(1+this.rate*s**2))**-.5,a=-i*s*this.rate;return e.mul(r).add(r.add(-1).mul(s)).mul(i).add(a)},()=>qD(t),e.training||!1)}return t})}}function QM(t,e,n,s,r,i=.001){let a;if(2===t.rank)a=GI(t,e,n,s,r,i);else if(3===t.rank)a=qI(t,e,n,s,r,i);else{if(4!==t.rank)throw new aF(`batchNormalization is not implemented for array of rank ${t.rank} yet`);a=KI(t,e,n,s,r,i)}return a}XM.className="AlphaDropout",u.registerClass(XM);class YM extends rO{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=BD(t.betaInitializer||"zeros"),this.gammaInitializer=BD(t.gammaInitializer||"ones"),this.movingMeanInitializer=BD(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=BD(t.movingVarianceInitializer||"ones"),this.betaConstraint=LF(t.betaConstraint),this.gammaConstraint=LF(t.gammaConstraint),this.betaRegularizer=VL(t.betaRegularizer),this.gammaRegularizer=VL(t.gammaRegularizer)}build(t){t=KD(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new iF(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new JD({ndim:t.length,axes:{[e]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return yI(()=>{const n=null!=e.training&&e.training,r=qD(t),i=r.shape,a=i.length,o=nD(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const u=lF(1,a);u[l]=i[l];const c=o.slice();c.sort();const h=!s.arraysEqual(c,nD(0,a).slice(0,a-1));if(!n)return(()=>{if(h){const t=this.movingMean.read().reshape(u),e=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,s=this.scale?this.gamma.read().reshape(u):null;return QM(r,t,e,n,s,this.epsilon)}return QM(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(t,e,n,r,i=.001){return s.arraysEqual(r.slice().sort(),nD(0,t.rank-1))?function(t,e,n,s,r=.001){return yI(()=>{const i=GN(t,s),a=i.mean,o=i.variance;return[QM(t,a,o,n,e,r),a,o]})}(t,e,n,r,i):function(t,e,n,s,r=.001){return yI(()=>{const i=GN(t,s),a=i.mean,o=i.variance,l=[];for(const e of nD(0,t.rank))-1!==s.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=a.reshape(l),c=o.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[QM(t,u,c,d,h,r),a,o]})}(t,e,n,r,i)}(r,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(t,e,n)=>{yI(()=>{const s=1-n,r=t.read(),i=r.sub(e).mul(s);t.write(r.sub(i))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:zD(this.betaInitializer),gammaInitializer:zD(this.gammaInitializer),movingMeanInitializer:zD(this.movingMeanInitializer),movingVarianceInitializer:zD(this.movingVarianceInitializer),betaRegularizer:zL(this.betaRegularizer),gammaRegularizer:zL(this.gammaRegularizer),betaConstraint:DF(this.betaConstraint),gammaConstraint:DF(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}YM.className="BatchNormalization",u.registerClass(YM);class ZM extends rO{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=BD(t.betaInitializer||"zeros"),this.gammaInitializer=BD(t.gammaInitializer||"ones"),this.betaRegularizer=VL(t.betaRegularizer),this.gammaRegularizer=VL(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=KD(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(const s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==vF(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=qD(t),s=n.shape,r=s.length;return yI(()=>{let{mean:t,variance:e}=GN(n,this.axis,!0);const i=lF(1,r);for(const n of this.axis)i[n]=s[n];const a=t=>null!=t&&t.shape.length!==r&&this.axis!==[r-1]?t.reshape(i):t;let o=a(this.gamma.read()),l=a(this.beta.read());const u=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(u.push(s[n]),c.push(1)):(u.push(1),c.push(s[n]));return t=t.tile(u),e=e.tile(u),o=o.tile(c),l=l.tile(c),QM(n,t,e,l,o,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:zD(this.betaInitializer),gammaInitializer:zD(this.gammaInitializer),betaRegularizer:zL(this.betaRegularizer),gammaRegularizer:zL(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}ZM.className="LayerNormalization",u.registerClass(ZM);class JM extends rO{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new iF(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new iF(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new iF(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new JD({ndim:4})]}computeOutputShape(t){let e,n;return t=KD(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return yI(()=>{return e=qD(t),n=this.padding,s=this.dataFormat,yI(()=>{if(4!==e.rank)throw new iF(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new iF("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new iF(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],JN(e,t)});var e,n,s})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function tP(t,e,n,s,r,i){return yI(()=>{let a;UF(r),HF(i),jF(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=YL(t,r);const o="same"===s?"same":"valid";return a="max"===i?RN(t,e,n,o):UI(t,e,n,o),"channelsFirst"===r&&(a=RE(a,[0,3,1,2])),a})}function eP(t,e,n,s,r,i){return yI(()=>{let a;UF(r),HF(i),jF(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=ZL(t,r);const o="same"===s?"same":"valid";return a="max"===i?$N(t,e,n,o):jI(t,e,n,o),"channelsFirst"===r&&(a=RE(a,[0,4,1,2,3])),a})}JM.className="ZeroPadding2D",u.registerClass(JM);class nP extends rO{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new iF(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(SF(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new iF(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}SF(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,jF(this.padding),this.inputSpec=[new JD({ndim:3})]}computeOutputShape(t){const e=XL((t=KD(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return yI(()=>{this.invokeCallHook(t,e),t=rD(qD(t),2);const n=this.poolingFunction(qD(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return wE(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class sP extends nP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return UF(r),jF(s),tP(t,e,n,s,r,"max")}}sP.className="MaxPooling1D",u.registerClass(sP);class rP extends nP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return UF(r),jF(s),tP(t,e,n,s,r,"avg")}}rP.className="AveragePooling1D",u.registerClass(rP);class iP extends rO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new iF(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];SF(this.poolSize,"poolSize"),SF(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,UF(this.dataFormat),jF(this.padding),this.inputSpec=[new JD({ndim:4})]}computeOutputShape(t){t=KD(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=XL(e,this.poolSize[0],this.padding,this.strides[0]),n=XL(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return yI(()=>(this.invokeCallHook(t,e),this.poolingFunction(qD(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class aP extends iP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return UF(r),jF(s),tP(t,e,n,s,r,"max")}}aP.className="MaxPooling2D",u.registerClass(aP);class oP extends iP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return UF(r),jF(s),tP(t,e,n,s,r,"avg")}}oP.className="AveragePooling2D",u.registerClass(oP);class lP extends rO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new iF(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];SF(this.poolSize,"poolSize"),SF(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,UF(this.dataFormat),jF(this.padding),this.inputSpec=[new JD({ndim:5})]}computeOutputShape(t){t=KD(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=XL(e,this.poolSize[0],this.padding,this.strides[0]),n=XL(n,this.poolSize[1],this.padding,this.strides[1]),s=XL(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,s]:[t[0],e,n,s,t[4]]}call(t,e){return yI(()=>(this.invokeCallHook(t,e),this.poolingFunction(qD(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class uP extends lP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return UF(r),jF(s),eP(t,e,n,s,r,"max")}}uP.className="MaxPooling3D",u.registerClass(uP);class cP extends lP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return UF(r),jF(s),eP(t,e,n,s,r,"avg")}}cP.className="AveragePooling3D",u.registerClass(cP);class hP extends rO{constructor(t){super(t),this.inputSpec=[new JD({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new aF}}class dP extends hP{constructor(t){super(t||{})}call(t,e){return yI(()=>{const e=qD(t);return DN(e,1)})}}dP.className="GlobalAveragePooling1D",u.registerClass(dP);class pP extends hP{constructor(t){super(t||{})}call(t,e){return yI(()=>{const e=qD(t);return CN(e,1)})}}pP.className="GlobalMaxPooling1D",u.registerClass(pP);class fP extends rO{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,UF(this.dataFormat),this.inputSpec=[new JD({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new aF}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class mP extends fP{call(t,e){return yI(()=>{const e=qD(t);return DN(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}mP.className="GlobalAveragePooling2D",u.registerClass(mP);class gP extends fP{call(t,e){return yI(()=>{const e=qD(t);return CN(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}gP.className="GlobalMaxPooling2D",u.registerClass(gP);class yP extends rO{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const s=bO(e.layer,n);delete e.layer;const r={layer:s};return Object.assign(r,e),new t(r)}}class bP extends yP{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=KD(t)).length<3)throw new iF(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=KD(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return yI(()=>dM((t,n)=>[qD(this.layer.call(t,e)),[]],t=qD(t),[],!1,null,null,!1,!0)[1])}}bP.className="TimeDistributed",u.registerClass(bP);class xP extends yP{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=bO(n),e.goBackwards=!0!==e.goBackwards;const s={};if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=bO(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,_F(VF,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new aF("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,s,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(s=r.slice(1),e=r[0]):e=r[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[e].concat(s).concat(s.slice()):hF(n)}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=hM(t,n,s,this.numConstants);if(t=r.inputs,n=r.initialState,s=r.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==s)return super.apply(t,e);const i=[],a=[];if(null!=n){const t=n.length;if(t%2>0)throw new iF("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const s=n.map(t=>new JD({shape:t.shape}));this.forwardLayer.stateSpec=s.slice(0,t/2),this.backwardLayer.stateSpec=s.slice(t/2),a.push(...s)}if(null!=s)throw new aF("Support for constants in Bidirectional layers is not implemented yet.");const o=i[0]instanceof tO;for(const l of i)if(l instanceof tO!==o)throw new iF("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[t].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,e);return this.inputSpec=r,o}return super.apply(t,e)}call(t,e){return yI(()=>{const n=e.initialState;let s,r,i,a;if(null==n)s=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),a=n.slice(n.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:a}))}return this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=lE(r,1)),"concat"===this.mergeMode?a=lD([s,r]):"sum"===this.mergeMode?a=CI(s,r):"ave"===this.mergeMode?a=IN(.5,CI(s,r)):"mul"===this.mergeMode?a=IN(s,r):null==this.mergeMode&&(a=[s,r]),this.returnState?null==this.mergeMode?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){qF(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),qF(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=bO(e.layer);if(delete e.layer,null!=e.numConstants)throw new aF("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=e;return s.layer=n,new t(s)}}xP.className="Bidirectional",u.registerClass(xP),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(kM||(kM={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(SM||(SM={}));const vP=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wP=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_P=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],kP=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],SP=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],CP=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],IP=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],NP=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],EP=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],TP=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],AP=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RP=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$P=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],FP=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],DP=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],OP=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],LP=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];function MP(t,e,n=new Map,s=new Set){if(null==t)return null;if(s.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(VP(t)){const r=Array.isArray(t)?[]:{};s.add(t);for(const i in t){const a=MP(t[i],e,n,s);r[i]=a}return s.delete(t),r}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,r.value),r.value}function PP(t,e=BP){return zP(t,e)}function zP(t,e,n=new Set){const s=t[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(VP(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const i in s){const s=zP(t.map(t=>t[i]),e,n);r[i]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function BP(t){return null===t?null:VP(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function VP(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof iS))}function WP(t){return MP(t,UP)}function UP(t){return t instanceof iS?{value:t.clone(),recurse:!1}:VP(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}OS({addN_:function(t){V_(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),V_(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((t,e)=>FS(t,`tensors${e}`,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!q_(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),CS.runKernel("AddN",e)}}),OS({maxPoolWithArgmax_:function(t,e,n,s,r=!1){const i=FS(t,"x","maxPoolWithArgmax"),a=CS.runKernel("MaxPoolWithArgmax",{x:i},{filterSize:e,strides:n,pad:s,includeBatchInIndex:r});return{result:a[0],indexes:a[1]}}}),OS({multinomial_:function(t,e,n,s=!1){const r=FS(t,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const o=1===a?WI(r,[1,-1]):r,l=CS.runKernel("Multinomial",{logits:o},{numSamples:e,seed:n,normalized:s});return 1===a?WI(l,[l.size]):l}}),OS({sparseToDense_:function(t,e,n,s=0){const r=FS(t,"sparseIndices","sparseToDense","int32"),i=FS(e,"sparseValues","sparseToDense"),a=FS(s,"defaultValue","sparseToDense",i.dtype);return function(t,e,n,s){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,i=t.rank>1?t.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);if(0!==e.rank&&(1!==e.rank||e.size!==r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,i,n,a),CS.runKernel("SparseToDense",{sparseIndices:r,sparseValues:i,defaultValue:a},{outputShape:n})}}),OS({bincount_:function(t,e,n){const s=FS(t,"x","bincount"),r=FS(e,"weights","bincount");return V_("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),V_(n>=0,()=>`size must be non-negative, but got ${n}.`),V_(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),CS.runKernel("Bincount",{x:s,weights:r},{size:n})}}),OS({denseBincount_:function(t,e,n,s=!1){const r=FS(t,"x","denseBincount"),i=FS(e,"weights","denseBincount");return V_("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),V_(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),V_(n>=0,()=>`size must be non-negative, but got ${n}.`),V_(i.size===r.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`),CS.runKernel("DenseBincount",{x:r,weights:i},{size:n,binaryOutput:s})}}),OS({scatterND_:function(t,e,n){const s=FS(t,"indices","scatterND","int32"),r=FS(e,"updates","scatterND");return QT(r,s,n),CS.runKernel("ScatterNd",{indices:s,updates:r},{shape:n})}}),OS({gatherND_:function(t,e){const n=FS(e,"indices","gatherND","int32"),s=FS(t,"x","gatherND");return CS.runKernel("GatherNd",{params:s,indices:n})}});class jP{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class HP extends jP{constructor(){super(HP.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let s=0;s<n;s++)e[s]=this.get(this.wrap(this.begin+s));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}HP.INITIAL_CAPACITY=32;class GP{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new ez(this,t)}filter(t){return new JP(this,t)}map(t){return new tz(this,t)}mapAsync(t){return new nz(this,t)}serialMapAsync(t){return new nz(this,t).serial()}flatmap(t){return new rz(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new ZP(this,t,e)}columnMajorBatch(t,e=!0,n=BP){return this.rowMajorBatch(t,e).map(t=>PP(t,n))}concatenate(t,e){return new iz(new qP([this,t]),e)}take(t){return t<0||null==t?this:new YP(this,t)}skip(t){return t<0||null==t?this:new QP(this,t)}prefetch(t){return new oz(this,t)}shuffle(t,e){return new lz(this,t,e)}serial(){return new XP(this)}}class qP extends GP{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:WP(t),done:!1}}}class KP extends GP{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class XP extends GP{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class QP extends GP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;bI(t.value)}return this.upstream.next()}}class YP extends GP{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class ZP extends GP{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class JP extends GP{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;bI(t.value)}}}class tz extends GP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=r.getTensorsInContainer(t.value),n=this.transform(t.value),s=r.getTensorsInContainer(n);for(const i of e)r.isTensorInList(i,s)||i.dispose();return{value:n,done:!1}}}class ez extends GP{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class nz extends GP{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=r.getTensorsInContainer(t.value),n=await this.transform(t.value),s=r.getTensorsInContainer(n);for(const i of e)r.isTensorInList(i,s)||i.dispose();return{value:n,done:!1}}}class sz extends GP{constructor(){super(),this.outputQueue=new HP,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class rz extends sz{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=r.getTensorsInContainer(t.value),n=this.transform(t.value),s=r.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const i of e)r.isTensorInList(i,s)||i.dispose();return!0}}class iz extends GP{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var az;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(az||(az={}));class oz extends GP{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new jP(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class lz extends oz{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=nE.alea(n||s.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class uz{constructor(){this.size=null}batch(t,e=!0){const n=this;let r;return s.assert(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),cz(async()=>(await n.iterator()).columnMajorBatch(t,e,hz),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,cz(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,cz(async()=>(await e.iterator()).filter(e=>yI(()=>t(e))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return cz(async()=>(await e.iterator()).map(e=>yI(()=>t(e))),this.size)}mapAsync(t){const e=this;return cz(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return cz(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,cz(async()=>{return n=(s=async()=>({value:await e.iterator(),done:!1}),new KP(s)).take(t),new iz(n,undefined);var n,s},n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,cz(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=nE.alea(e||s.now().toString());return cz(async()=>{let e=i.int32();return n&&(e+=i.int32()),(await r.iterator()).shuffle(t,e.toString())},this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,cz(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function cz(t,e=null){return new class extends uz{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function hz(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof iS||s.isTypedArray(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof iS?_E(t):PS(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function dz(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&s.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the CPU backend.`)})}uz.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const pz=p.whereImpl;class fz extends $_{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new R_(this,mI())}nextDataId(){return fz.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,Ek().get("IS_NODE")&&d.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:n,refCount:1}),s}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&s.isString(n[0])){const i=n.map(t=>s.encodeString(t));r=this.write(i,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,s,r){this.data.set(t,{values:e,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){const t=this.readSync(n.real.dataId),e=this.readSync(n.imag.dataId);return d.mergeRealAndImagArrays(t,e)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>s.decodeString(t))}catch(hY){throw new Error("Failed to decode encoded string bytes into utf-8")}return CC(t.shape,t.dtype,n)}makeOutput(t,e,n){const s=this.write(t,e,n);return mI().makeTensorFromDataId(s,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=s.now();return t(),{kernelMs:s.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){dz([t],"where");const e=this.readSync(t.dataId);return pz(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function mz(t,e,n){return({inputs:r,attrs:i,backend:a})=>{const{x:o}=r;if(dz(o,t),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const l=a,u=l.data.get(o.dataId).values,c=s.sizeFromShape(o.shape),h=n||o.dtype,d=s.getArrayFromDType(h,c);for(let t=0;t<c;++t)d[t]=e(u[t],i);return l.makeTensorInfo(o.shape,h,d)}}function gz(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;if(dz(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,l=o.data.get(a.dataId).values,u=n||a.dtype,c=e(l,u,r);return o.makeTensorInfo(a.shape,u,c)}}fz.nextDataId=0,vI("cpu",()=>new fz,1);const yz=mz("Elu",t=>t>=0?t:Math.exp(t)-1),bz={kernelName:"Elu",backendName:"cpu",kernelFunc:yz};function xz(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const vz={kernelName:"Identity",backendName:"cpu",kernelFunc:xz};function wz(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:a}=r;dz([i],"leakyRelu");const o=s.sizeFromShape(i.shape),l=n.data.get(i.dataId).values,u=s.getTypedArrayFromDType("float32",o);for(let s=0;s<l.length;s++)u[s]=l[s]<0?a*l[s]:l[s];return n.makeTensorInfo(i.shape,"float32",u)}const _z={kernelName:"LeakyRelu",backendName:"cpu",kernelFunc:wz};function kz(t){return(e,n,r,i,a)=>{const o=d.assertAndGetBroadcastShape(e,n),l=o.length,u=s.computeStrides(o),c=s.sizeFromShape(o),h=s.getTypedArrayFromDType(a,c),p=e.length,f=n.length,m=s.computeStrides(e),g=s.computeStrides(n),y=d.getBroadcastDims(e,o),b=d.getBroadcastDims(n,o);if(y.length+b.length===0)for(let s=0;s<h.length;++s)h[s]=t(r[s%r.length],i[s%i.length]);else for(let d=0;d<h.length;++d){const e=s.indexToLoc(d,l,u),n=e.slice(-p);y.forEach(t=>n[t]=0);const a=s.locToIndex(n,p,m),o=e.slice(-f);b.forEach(t=>o[t]=0);const c=s.locToIndex(o,f,g);h[d]=t(r[a],i[c])}return[h,o]}}const Sz=kz((t,e)=>t<0?e*t:t);function Cz(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;dz([s,r],"prelu");const i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,[o,l]=Sz(s.shape,r.shape,i,a,s.dtype);return n.makeTensorInfo(l,s.dtype,o)}const Iz={kernelName:"Prelu",backendName:"cpu",kernelFunc:Cz},Nz=mz("Relu",t=>Math.max(0,t)),Ez={kernelName:"Relu",backendName:"cpu",kernelFunc:Nz},Tz=mz("Relu6",t=>Math.min(Math.max(0,t),6)),Az={kernelName:"Relu6",backendName:"cpu",kernelFunc:Tz};function Rz(t,e,n,s,r){if("linear"===n)return xz({inputs:{x:e},backend:t});if("relu"===n)return Nz({inputs:{x:e},backend:t});if("elu"===n)return yz({inputs:{x:e},backend:t});if("relu6"===n)return Tz({inputs:{x:e},backend:t});if("prelu"===n)return Cz({inputs:{x:e,alpha:s},backend:t});if("leakyrelu"===n)return wz({inputs:{x:e},backend:t,attrs:{alpha:r}});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function $z(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",a)},o}const Fz={kernelName:"Complex",backendName:"cpu",kernelFunc:$z};function Dz(t,e,n="float32"){if("complex64"===n)return $z({inputs:{real:Dz(t,e,"float32"),imag:Dz(t,e,"float32")},backend:t});const r=s.makeZerosTypedArray(s.sizeFromShape(e),n);return t.makeTensorInfo(e,n,r)}function Oz(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const Lz={kernelName:"Real",backendName:"cpu",kernelFunc:Oz};function Mz(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dtype:a}=r;if("complex64"===a){if("complex64"===i.dtype)return xz({inputs:{x:i},backend:n});const t=Dz(n,i.shape,i.dtype),e=Mz({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),s=$z({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),s}if("complex64"===i.dtype){const t=Oz({inputs:{input:i},backend:n}),e=Mz({inputs:{x:t},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(t),e}if(!s.hasEncodingLoss(i.dtype,a)){const t=xz({inputs:{x:i},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:a}}if("int32"===a){const t=n.data.get(i.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(i.shape,"int32",e)}if("bool"===a){const t=n.data.get(i.dataId).values,e=s.toTypedArray([0],i.dtype),[r,a]=kz((t,e)=>t!==e?1:0)(i.shape,[],t,e,"bool");return n.makeTensorInfo(a,"bool",r)}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}const Pz={kernelName:"Cast",backendName:"cpu",kernelFunc:Mz};function zz(t,e,n,s){return null==n?({inputs:n,backend:r})=>{const{a:i,b:a}=n,o=r;dz([i,a],t);const l=o.data.get(i.dataId).values,u=o.data.get(a.dataId).values,c=s||i.dtype,[h,d]=e(i.shape,a.shape,l,u,c);return o.makeTensorInfo(d,c,h)}:({inputs:t,backend:r})=>{const{a:i,b:a}=t,o=r;if("complex64"===i.dtype||"complex64"===a.dtype){const t=Mz({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),e=o.data.get(t.dataId),s=e.complexTensorInfos.imag,r=o.data.get(e.complexTensorInfos.real.dataId).values,l=o.data.get(s.dataId).values,u=Mz({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(u.dataId),h=c.complexTensorInfos.imag,d=o.data.get(c.complexTensorInfos.real.dataId).values,p=o.data.get(h.dataId).values,[f,m,g]=n(i.shape,a.shape,r,l,d,p),y=o.makeTensorInfo(g,"float32",f),b=o.makeTensorInfo(g,"float32",m),x=$z({inputs:{real:y,imag:b},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(u),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(b),x}{const t=o.data.get(i.dataId).values,n=o.data.get(a.dataId).values,r=s||i.dtype,[l,u]=e(i.shape,a.shape,t,n,r);return o.makeTensorInfo(u,r,l)}}}function Bz(t){return(e,n,r,i,a,o)=>{const l=d.assertAndGetBroadcastShape(e,n),u=s.sizeFromShape(l),c=l.length,h=s.computeStrides(l),p=s.getTypedArrayFromDType("float32",u),f=s.getTypedArrayFromDType("float32",u),m=d.getBroadcastDims(e,l),g=d.getBroadcastDims(n,l),y=d.mergeRealAndImagArrays(r,i),b=d.mergeRealAndImagArrays(a,o),x=e.length,v=s.computeStrides(e),w=n.length,_=s.computeStrides(n);if(m.length+g.length===0)for(let s=0;s<p.length;s++){const e=s%y.length,n=s%b.length,r=t(y[2*e],y[2*e+1],b[2*n],b[2*n+1]);p[s]=r.real,f[s]=r.imag}else for(let d=0;d<p.length;d++){const e=s.indexToLoc(d,c,h),n=e.slice(-x);m.forEach(t=>n[t]=0);const r=s.locToIndex(n,x,v),i=e.slice(-w);g.forEach(t=>i[t]=0);const a=s.locToIndex(i,w,_),o=t(y[2*r],y[2*r+1],b[2*a],b[2*a+1]);p[d]=o.real,f[d]=o.imag}return[p,f,l]}}const Vz=kz((t,e)=>t+e),Wz=Bz((t,e,n,s)=>({real:t+n,imag:e+s})),Uz=zz("Add",Vz,Wz),jz={kernelName:"Add",backendName:"cpu",kernelFunc:Uz};function Hz(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:a}=r,o=s.sizeFromShape(i.shape),l=s.inferFromImplicitShape(a,o),u=s.sizeFromShape(l);s.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(i.dataId);const c=n.data.get(i.dataId);if(null!=c.complexTensorInfos){const t=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=l,t.shape=l}return{dataId:i.dataId,shape:l,dtype:i.dtype}}const Gz={kernelName:"Reshape",backendName:"cpu",kernelFunc:Hz};function qz(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:a}=e,{transposeA:o,transposeB:l}=r;dz([i,a],"matMul");const u=i.shape.length,c=a.shape.length,h=o?i.shape[u-2]:i.shape[u-1],d=l?a.shape[c-1]:a.shape[c-2],p=o?i.shape[u-1]:i.shape[u-2],f=l?a.shape[c-2]:a.shape[c-1],m=i.shape.slice(0,-2),g=a.shape.slice(0,-2),y=s.sizeFromShape(m),b=s.sizeFromShape(g);s.assert(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const x=(y>b?i.shape.slice(0,-2):a.shape.slice(0,-2)).concat([p,f]);s.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${o} and transposeB=${l} must match.`);const v=l?[b,f,d]:[b,d,f],w=Hz({inputs:{x:i},backend:n,attrs:{shape:o?[y,h,p]:[y,p,h]}}),_=Hz({inputs:{x:a},backend:n,attrs:{shape:v}}),k=o?w.shape[1]:w.shape[2],S=o?w.shape[2]:w.shape[1],C=l?_.shape[1]:_.shape[2],I=Math.max(y,b),N=n.data.get(w.dataId).values,E=n.data.get(_.dataId).values,T=s.computeStrides(w.shape),A=s.computeStrides(_.shape),[R,$,F]=o?[T[0],1,T[1]]:[T[0],T[1],1],[D,O,L]=l?[1,A[1],A[0]]:[A[1],1,A[0]],M=S*C,P=CC([I,S,C],w.dtype),z=P.values,B=n.blockSize;for(let s=0;s<I;s++)for(let t=0;t<S;t+=B)for(let e=0;e<C;e+=B)for(let n=0;n<k;n+=B){const r=Math.min(t+B,S),i=Math.min(e+B,C),a=Math.min(n+B,k);for(let o=t;o<r;o++)for(let t=e;t<i;t++){let e=0;for(let r=n;r<a;r++){const n=Math.min(s,y-1)*R,i=Math.min(s,b-1)*L;e+=N[n+o*$+r*F]*E[r*D+t*O+i]}z[s*M+(o*C+t)]+=e}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(_),n.makeTensorInfo(x,P.dtype,P.values)}const Kz={kernelName:"BatchMatMul",backendName:"cpu",kernelFunc:qz},Xz={kernelName:"_FusedMatMul",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=qz({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=Uz({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),c&&(f=Rz(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function Qz(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const Yz={kernelName:"Abs",backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;dz(e,"abs");let r=new Float32Array(s.sizeFromShape(e.shape));return r=Qz(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,"float32")}},Zz={kernelName:"Acos",backendName:"cpu",kernelFunc:mz("Acos",t=>Math.acos(t))},Jz={kernelName:"Acosh",backendName:"cpu",kernelFunc:mz("Acosh",t=>Math.acosh(t))},tB={kernelName:"AddN",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,s=e;dz(e,"addN");const r=s.map(t=>n.data.get(t.dataId).values),i=CC(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const t=r[o];for(let e=0;e<a.length;e++)a[e]+=t[e]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function eB(t,e,n,r,i){const a=e.length,o=s.sizeFromShape(e),l=s.computeStrides(e),u=s.computeStrides(i),c=s.getTypedArrayFromDType(n,s.sizeFromShape(i));for(let h=0;h<o;++h){const e=s.indexToLoc(h,a,l),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[r[t]];c[s.locToIndex(n,a,u)]=t[h]}return c}function nB(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:i}=n;dz(r,"transpose");const a=new Array(r.shape.length);for(let l=0;l<a.length;l++)a[l]=r.shape[i[l]];const o=eB(s.data.get(r.dataId).values,r.shape,r.dtype,i,a);return{dataId:s.write(o,a,r.dtype),shape:a,dtype:r.dtype}}const sB={kernelName:"Transpose",backendName:"cpu",kernelFunc:nB},rB={kernelName:"All",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;dz(i,"all");const l=s.parseAxisParam(a,i.shape);let u=l;const c=d.getAxesPermutation(u,i.shape.length);let h=i;null!=c&&(h=nB({inputs:{x:i},backend:n,attrs:{perm:c}}),u=d.getInnerMostAxes(u.length,i.shape.length)),d.assertAxesAreInnerMostDims("all",u,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,u),m=s.sizeFromShape(f),g=s.makeZerosTypedArray(s.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let s=0;s<g.length;++s){const t=s*m;let e=y[t];for(let n=0;n<m;++n){const s=y[t+n];e=e&&s}g[s]=e}null!=c&&n.disposeIntermediateTensorInfo(h);const b=n.makeTensorInfo(p,h.dtype,g);if(o){const t=Hz({inputs:{x:b},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(b),t}return b}},iB={kernelName:"Any",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;dz(i,"any");const l=s.parseAxisParam(a,i.shape);let u=l;const c=d.getAxesPermutation(u,i.shape.length);let h=i;null!=c&&(h=nB({inputs:{x:i},backend:n,attrs:{perm:c}}),u=d.getInnerMostAxes(u.length,i.shape.length)),d.assertAxesAreInnerMostDims("any",u,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,u),m=s.sizeFromShape(f),g=s.makeZerosTypedArray(s.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let s=0;s<g.length;++s){const t=s*m;let e=y[t];for(let n=0;n<m;++n){const s=y[t+n];e=e||s}g[s]=e}null!=c&&n.disposeIntermediateTensorInfo(h);const b=n.makeTensorInfo(p,h.dtype,g);if(o){const t=Hz({inputs:{x:b},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(b),t}return b}},aB={kernelName:"ArgMax",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;dz(i,"argMax");let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=nB({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],d.assertAxesAreInnerMostDims("argMax",o,u.shape.length);const[h,p]=d.computeOutAndReduceShapes(u.shape,o),f=s.sizeFromShape(h),m=s.makeZerosTypedArray(f,"int32"),g=s.sizeFromShape(p),y=n.data.get(u.dataId).values;for(let s=0;s<m.length;++s){const t=s*g;let e=y[t],n=0;for(let s=0;s<g;++s){const r=y[t+s];r>e&&(e=r,n=s)}m[s]=n}return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(h,"int32",m)}},oB={kernelName:"ArgMin",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;dz(i,"argMin");let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=nB({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],d.assertAxesAreInnerMostDims("argMin",o,u.shape.length);const[h,p]=d.computeOutAndReduceShapes(u.shape,o),f=s.sizeFromShape(h),m=s.makeZerosTypedArray(f,"int32"),g=s.sizeFromShape(p),y=n.data.get(u.dataId).values;for(let s=0;s<m.length;++s){const t=s*g;let e=y[t],n=0;for(let s=0;s<g;++s){const r=y[t+s];r<e&&(e=r,n=s)}m[s]=n}return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(h,"int32",m)}},lB={kernelName:"Asin",backendName:"cpu",kernelFunc:mz("Asin",t=>Math.asin(t))},uB={kernelName:"Asinh",backendName:"cpu",kernelFunc:mz("Asinh",t=>Math.asinh(t))},cB={kernelName:"Atan",backendName:"cpu",kernelFunc:mz("Atan",t=>Math.atan(t))},hB={kernelName:"Atan2",backendName:"cpu",kernelFunc:zz("Atan2",kz((t,e)=>Math.atan2(t,e)))},dB={kernelName:"Atanh",backendName:"cpu",kernelFunc:mz("Atanh",t=>Math.atanh(t))};function pB(t,e,n,s,r,i){const a=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=CC(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){const e=v*y,n=v*s[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const v=y*a-d,w=Math.max(0,v),_=Math.min(r.inHeight,c+v),k=e+y*b;for(let e=0;e<r.outWidth;++e){const a=e*o-p,c=Math.max(0,a),d=Math.min(r.inWidth,h+a);let y=f,b=0,v=0;for(let e=w;e<_;e+=l){const r=n+e*s[1];for(let e=c;e<d;e+=u){const n=t[r+e*s[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,v++)}if(isNaN(y))break}g[k+e*x+m]="avg"===i?b/v:y}}}return m}function fB(t,e,n,s,r=!1,i=!1){const a=CC(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=CC(e,n,t);for(let g=0;g<s.batchSize;++g)for(let t=0;t<s.inChannels;++t)for(let e=0;e<s.outHeight;++e){const n=e*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(s.inHeight,h+n);for(let o=0;o<s.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const x=Math.min(s.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let e=y;e<b;e+=u){const a=e-n;for(let n=p;n<x;n+=c){const o=n-h,l=m.get(g,e,n,t);l>v&&(v=l,w=r?i?((g*s.inHeight+e)*s.inWidth+n)*s.inChannels+t:(e*s.inWidth+n)*s.inChannels+t:a*d+o)}}a.set(w,g,e,o,t)}}return a}function mB(t,e,n,s,r,i){const a=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=CC(r.outShape,n),v=x.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let C=0;C<r.batchSize;++C){const e=C*w,n=C*s[0];for(let x=0;x<r.inChannels;++x)for(let w=0;w<r.outDepth;++w){const C=w*a-m;let I=C;for(;I<0;)I+=u;const N=Math.min(r.inDepth,d+C),E=e+w*_;for(let e=0;e<r.outHeight;++e){const a=e*o-g;let d=a;for(;d<0;)d+=c;const m=Math.min(r.inHeight,p+a),w=E+e*k;for(let e=0;e<r.outWidth;++e){const a=e*l-y;let o=a;for(;o<0;)o+=h;const p=Math.min(r.inWidth,f+a),g=w+e*S;let _=b,k=0,C=0;for(let e=I;e<N;e+=u){const r=n+e*s[1];for(let e=d;e<m;e+=c){const n=r+e*s[2];for(let e=o;e<p;e+=h){const r=t[n+e*s[3]+x];if("max"===i&&r>_?_=r:"avg"===i&&(k+=r,C++),isNaN(_))break}if(isNaN(_))break}if(isNaN(_))break}v[g+x]="avg"===i?k/C:_}}}}return x}const gB={kernelName:"AvgPool",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;dz(i,"avgPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);let h;if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))h=xz({inputs:{x:i},backend:n});else{const t=n.data.get(i.dataId).values,e=s.computeStrides(i.shape),r=pB(t,0,i.dtype,e,c,"avg");h=n.makeTensorInfo(c.outShape,i.dtype,r.values)}return h}},yB={kernelName:"AvgPool3D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u,dataFormat:c}=r;dz(i,"avgPool3d");const h=d.computePool3DInfo(i.shape,a,o,1,l,u,c),p=mB(n.data.get(i.dataId).values,0,i.dtype,s.computeStrides(i.shape),h,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}},bB={kernelName:"AvgPool3DGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;dz([r,i],"avgPool3DGrad");const c=d.computePool3DInfo(i.shape,a,o,1,l,u),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=c.dilationDepth,x=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,_=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=w-1-c.padInfo.front,C=k-1-c.padInfo.left,I=_-1-c.padInfo.top,N=CC(i.shape,"float32"),E=1/(m*g*y),T=n.bufferSync(r);for(let d=0;d<c.batchSize;++d)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-S,i=n-I,a=s-C;let o=0;for(let e=0;e<w;e+=b){const n=(r+e)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let e=0;e<_;e+=x){const s=(i+e)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let e=0;e<k;e+=v){const r=(a+e)/f;r<0||r>=c.outWidth||Math.floor(r)!==r||(o+=T.get(d,n,s,r,t))}}}N.set(o*E,d,e,n,s,t)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}},xB={kernelName:"AvgPoolGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i;dz([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=d.computePool2DInfo(a.shape,o,l,1,u),h=c.strideHeight,p=c.strideWidth,f=c.filterHeight,m=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterHeight,x=c.effectiveFilterWidth,v=x-1-c.padInfo.left,w=b-1-c.padInfo.top,_=CC(a.shape,"float32"),k=1/(f*m),S=n.data.get(r.dataId).values,C=CC(r.shape,"float32",S);for(let d=0;d<c.batchSize;++d)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inHeight;++e)for(let n=0;n<c.inWidth;++n){const s=e-w,r=n-v;let i=0;for(let e=0;e<b;e+=g){const n=(s+e)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let e=0;e<x;e+=y){const s=(r+e)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(i+=C.get(d,n,s,t))}}_.set(i*k,d,e,n,t)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},vB={kernelName:"FusedBatchNorm",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,scale:a,offset:o,mean:l,variance:u}=e;s.assert(l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),s.assert(null==o||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),s.assert(null==a||l.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),dz([i,l,u,a,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const h=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,p=n.data.get(u.dataId).values,f=a?n.data.get(a.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),y=m.length,b=f.length,x=p.length,v=d.length;let w=0,_=0,k=0,S=0;for(let s=0;s<h.length;++s)g[s]=m[w++]+(h[s]-d[_++])*f[k++]/Math.sqrt(p[S++]+c),w>=y&&(w=0),_>=v&&(_=0),k>=b&&(k=0),S>=x&&(S=0);return n.makeTensorInfo(i.shape,i.dtype,g)}};function wB(t,e,n,r,i){const a=l.isSliceContinous(r,e,n),o=s.sizeFromShape(n),u=s.computeStrides(r);if(a){const n=l.computeFlatOffset(e,u);return"string"===i?t.slice(n,n+o):t.subarray(n,n+o)}const c=CC(r,i,"string"===i?d.fromUint8ToStringArray(t):t),h=CC(n,i);for(let s=0;s<h.size;++s){const t=h.indexToLoc(s),n=t.map((t,n)=>t+e[n]);h.set(c.get(...n),...t)}return"string"===i?d.fromStringArrayToUint8(h.values):h.values}function _B(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:a}=s;dz(r,"slice");const[o,u]=l.parseSliceParams(r,i,a);l.assertParamsValid(r,o,u);const c=wB(n.data.get(r.dataId).values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,c)}const kB={kernelName:"Slice",backendName:"cpu",kernelFunc:_B},SB={kernelName:"BatchToSpaceND",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:a}=s;dz([r],"batchToSpaceND");const o=i.reduce((t,e)=>t*e),l=d.getReshaped(r.shape,i,o),u=d.getPermuted(l.length,i.length),c=d.getReshapedPermuted(r.shape,i,o),h=d.getSliceBeginCoords(a,i.length),p=d.getSliceSize(c,a,i.length),f=Hz({inputs:{x:r},backend:n,attrs:{shape:l}}),m=nB({inputs:{x:f},backend:n,attrs:{perm:u}}),g=Hz({inputs:{x:m},backend:n,attrs:{shape:c}}),y=_B({inputs:{x:g},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}};function CB(t,e,n,r,i){const a=s.sizeFromShape(r),o=s.makeZerosTypedArray(i,n);for(let s=0;s<t.length;s++){const n=t[s];if(n<0)throw new Error("Input x must be non-negative!");n>=i||(o[n]+=a>0?e[s]:1)}return o}function IB(t,e,n,s=!1){const r=t.shape[0],i=t.shape[1],a=CC([r,n],e.dtype);for(let o=0;o<r;o++)for(let r=0;r<i;r++){const i=t.get(o,r);if(i<0)throw new Error("Input x must be non-negative!");i>=n||a.set(s?1:e.size>0?a.get(o,i)+e.get(o,r):a.get(o,i)+1,o,i)}return a}const NB={kernelName:"Bincount",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a}=s,o=CB(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,o)}};function EB(t){return(e,n,r)=>{const i=s.getTypedArrayFromDType(n,e.length);for(let s=0;s<e.length;++s)i[s]=t(e[s],r);return i}}const TB=EB(t=>Math.ceil(t)),AB={kernelName:"Ceil",backendName:"cpu",kernelFunc:gz("Ceil",TB)},RB={kernelName:"ClipByValue",backendName:"cpu",kernelFunc:mz("ClipByValue",(t,e)=>t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t)},$B={kernelName:"ComplexAbs",backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(s.sizeFromShape(e.shape)),i=n.data.get(e.dataId),a=i.complexTensorInfos.imag,o=n.data.get(i.complexTensorInfos.real.dataId).values,l=n.data.get(a.dataId).values;for(let s=0;s<o.length;s++)r[s]=Math.hypot(o[s],l[s]);return n.makeOutput(r,e.shape,"float32")}};function FB(t,e,n,r){const i=s.getArrayFromDType(n,s.sizeFromShape(e));if(r&&"string"!==n){let e=0;t.forEach(t=>{const n=s.sizeFromShape(t.shape);i.set(t.vals,e),e+=n})}else{let s=0;t.forEach(t=>{const r="string"===n?d.fromUint8ToStringArray(t.vals):t.vals;let a=0;for(let n=0;n<t.shape[0];++n){const o=n*e[1]+s;for(let e=0;e<t.shape[1];++e)i[o+e]=r[a++]}s+=t.shape[1]})}return i}function DB(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const OB={kernelName:"Imag",backendName:"cpu",kernelFunc:DB};function LB(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,a=s.parseAxisParam(i,e[0].shape)[0];let o=d.computeOutShape(e.map(t=>t.shape),a);if(0===s.sizeFromShape(o))return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(t=>s.sizeFromShape(t.shape)>0);if(1===l.length)return xz({inputs:{x:l[0]},backend:n});const u=l.map(t=>t.shape);if(d.assertParamsConsistent(u,a),"complex64"===l[0].dtype){const t=l.map(t=>Oz({inputs:{input:t},backend:n})),e=l.map(t=>DB({inputs:{input:t},backend:n})),s=LB({inputs:t,backend:n,attrs:{axis:a}}),r=LB({inputs:e,backend:n,attrs:{axis:a}}),i=$z({inputs:{real:s,imag:r},backend:n});return t.forEach(t=>n.disposeIntermediateTensorInfo(t)),e.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}const c=l.map(t=>{const e=s.sizeFromShape(t.shape.slice(a));return Hz({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})}),h=c.map(t=>({vals:n.data.get(t.dataId).values,shape:t.shape}));o=d.computeOutShape(c.map(t=>t.shape),1);const p=FB(h,o,e[0].dtype,1===c[0].shape[0]),f=d.computeOutShape(l.map(t=>t.shape),a),m=n.makeTensorInfo(f,e[0].dtype,p);return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),m}const MB={kernelName:"Concat",backendName:"cpu",kernelFunc:LB};function PB(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:h}=r;dz([i,a],"conv2d");const p=d.convertConv2DDataFormat(u),f=d.computeConv2DInfo(i.shape,a.shape,o,c,l,h,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.dilationHeight,b=f.dilationWidth,x=f.padInfo.left,v=f.padInfo.top,w="channelsLast"===f.dataFormat,_=new eS(f.outShape,i.dtype),k=s.computeStrides(i.shape),S=s.computeStrides(a.shape),C=k[0],I=w?k[1]:k[2],N=w?k[2]:1,E=w?1:k[1],T=_.strides[0],A=w?_.strides[1]:_.strides[2],R=w?_.strides[2]:1,$=w?1:_.strides[1],F=n.data.get(i.dataId).values,D=n.data.get(a.dataId).values,O=_.values;for(let s=0;s<f.batchSize;++s){const t=s*C,e=s*T;for(let n=0;n<f.outHeight;++n){const s=e+n*A,r=n*f.strideHeight-v;for(let e=0;e<m;++e){const n=r+e*y;if(n<0||n>=f.inHeight)continue;const i=e*S[0],a=t+n*I;for(let t=0;t<f.outWidth;++t){const e=s+t*R,n=t*f.strideWidth-x;for(let t=0;t<g;++t){const s=n+t*b;if(s<0||s>=f.inWidth)continue;const r=a+s*N;let o=i+t*S[1];for(let t=0;t<f.inChannels;++t){const n=F[r+t*E];for(let t=0;t<f.outChannels;++t)O[e+t*$]+=n*D[o+t];o+=f.outChannels}}}}}}return n.makeTensorInfo(_.shape,_.dtype,O)}const zB={kernelName:"Conv2D",backendName:"cpu",kernelFunc:PB},BB={kernelName:"Conv2DBackpropFilter",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;dz([r,i],"conv2dBackpropFilter");const h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,c,a,1,o,u,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:y}=p,b="channelsLast"===p.dataFormat,x=new eS(p.filterShape,"float32"),v=p.padInfo.left,w=p.padInfo.top,_=n.data.get(r.dataId).values,k=n.data.get(i.dataId).values,S=new eS(r.shape,r.dtype,_),C=new eS(i.shape,i.dtype,k);for(let d=0;d<g;++d){const t=Math.max(0,Math.ceil((w-d)/f)),e=Math.min(p.outHeight,(p.inHeight+w-d)/f);for(let n=0;n<y;++n){const s=Math.max(0,Math.ceil((v-n)/m)),r=Math.min(p.outWidth,(p.inWidth+v-n)/m);for(let i=0;i<p.inChannels;++i)for(let a=0;a<p.outChannels;++a){let o=0;for(let l=0;l<p.batchSize;++l)for(let u=t;u<e;++u){const t=d+u*f-w;for(let e=s;e<r;++e){const s=n+e*m-v;o+=b?S.get(l,t,s,i)*C.get(l,u,e,a):S.get(l,i,t,s)*C.get(l,a,u,e)}}x.set(o,d,n,i,a)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},VB={kernelName:"Conv2DBackpropInput",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:a}=e,{inputShape:o,strides:l,pad:u,dataFormat:c,dimRoundingMode:h}=r;dz([i,a],"conv2dBackpropInput");const p=s.computeStrides(a.shape),f=s.computeStrides(i.shape);let m=d.convertConv2DDataFormat(c);const g=d.computeConv2DInfo(o,a.shape,l,1,u,h,!1,m),y=new eS(g.inShape,"float32"),b=y.values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,[w,_,k]=p,{batchSize:S,filterHeight:C,filterWidth:I,inChannels:N,inHeight:E,inWidth:T,outChannels:A,outHeight:R,outWidth:$,strideHeight:F,strideWidth:D}=g;m=g.dataFormat;const O=C-1-g.padInfo.top,L=I-1-g.padInfo.left,M="channelsLast"===m,P=y.strides[0],z=M?y.strides[1]:y.strides[2],B=M?y.strides[2]:1,V=M?1:y.strides[1],W=f[0],U=M?f[1]:f[2],j=M?f[2]:1,H=M?1:f[1];for(let s=0;s<S;++s)for(let t=0;t<N;++t)for(let e=0;e<E;++e){const n=e-O,r=Math.max(0,Math.ceil(n/F)),i=Math.min(R,(C+n)/F);for(let a=0;a<T;++a){const o=a-L,l=Math.max(0,Math.ceil(o/D)),u=Math.min($,(I+o)/D);let c=0;for(let e=r;e<i;++e){const r=e*F-n;for(let n=l;n<u;++n){const i=W*s+U*e+j*n,a=w*(C-1-r)+_*(I-1-(n*D-o))+k*t;for(let t=0;t<A;++t)c+=x[i+H*t]*v[a+t]}}b[P*s+z*e+B*a+V*t]=c}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},WB={kernelName:"Conv3D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dilations:u}=r;dz([i,a],"conv3d");const c=d.computeConv3DInfo(i.shape,a.shape,o,u,l),{filterDepth:h,filterHeight:p,filterWidth:f,dilationDepth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.front,v=b.left,w=b.top,_=new eS(c.outShape,i.dtype),k=n.data.get(i.dataId).values,S=n.data.get(a.dataId).values,C=_.values,I=s.computeStrides(i.shape),N=s.computeStrides(a.shape);for(let s=0;s<c.batchSize;++s){const t=s*I[0],e=s*_.strides[0];for(let n=0;n<c.outDepth;++n){const s=e+n*_.strides[1],r=n*c.strideDepth-x;for(let e=0;e<h;++e){const n=r+e*m;if(n<0||n>=c.inDepth)continue;const i=e*N[0],a=t+n*I[1];for(let t=0;t<c.outHeight;++t){const e=s+t*_.strides[2],n=t*c.strideHeight-w;for(let t=0;t<p;++t){const s=n+t*g;if(s<0||s>=c.inHeight)continue;const r=i+t*N[1],o=a+s*I[2];for(let t=0;t<c.outWidth;++t){const n=e+t*c.outChannels,s=t*c.strideWidth-v;for(let t=0;t<f;++t){const e=s+t*y;if(e<0||e>=c.inWidth)continue;const i=o+e*c.inChannels;let a=r+t*N[2];for(let t=0;t<c.inChannels;++t){const e=k[i+t];for(let t=0;t<c.outChannels;++t)C[n+t]+=e*S[a+t];a+=c.outChannels}}}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},UB={kernelName:"Conv3DBackpropFilterV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:a}=e,{strides:o,pad:l,filterShape:u}=r;dz([i,a],"conv3dBackpropFilterV2");const c=s.computeStrides(i.shape),h=s.computeStrides(a.shape),p=d.computeConv3DInfo(i.shape,u,o,1,l),f=p.strideDepth,m=p.strideHeight,g=p.strideWidth,y=p.filterDepth,b=p.filterHeight,x=p.filterWidth,v=new eS(p.filterShape,"float32"),w=v.values,[_,k,S,C]=v.strides,I=n.data.get(a.dataId).values,[N,E,T,A]=h,R=n.data.get(i.dataId).values,[$,F,D,O]=c,L=p.padInfo.front,M=p.padInfo.left,P=p.padInfo.top;for(let s=0;s<y;++s){const t=Math.max(0,Math.ceil((L-s)/f)),e=Math.min(p.outDepth,(p.inDepth+L-s)/f),n=s*_;for(let r=0;r<b;++r){const i=Math.max(0,Math.ceil((P-r)/m)),a=Math.min(p.outHeight,(p.inHeight+P-r)/m),o=r*k+n;for(let n=0;n<x;++n){const l=Math.max(0,Math.ceil((M-n)/g)),u=Math.min(p.outWidth,(p.inWidth+M-n)/g),c=n*S+o;for(let o=0;o<p.inChannels;++o){const h=o*C+c;for(let c=0;c<p.outChannels;++c){let d=0;for(let h=0;h<p.batchSize;++h){const p=h*$,y=h*N;for(let h=t;h<e;++h){const t=(s+h*f-L)*F+p,e=h*E+y;for(let s=i;s<a;++s){const i=(r+s*m-P)*D+t,a=s*T+e;for(let t=l;t<u;++t)d+=R[(n+t*g-M)*O+i+o]*I[t*A+a+c]}}}w[h+c]=d}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},jB={kernelName:"Conv3DBackpropInputV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:a}=e,{pad:o,strides:l,inputShape:u}=r;dz([i],"conv3dBackpropInputV2");const c=s.computeStrides(i.shape),h=s.computeStrides(a.shape),p=d.computeConv3DInfo(u,a.shape,l,1,o),f=new eS(p.inShape,"float32"),m=f.values,[g,y,b,x]=f.strides,v=n.data.get(i.dataId).values,[w,_,k,S]=c,C=n.data.get(a.dataId).values,[I,N,E,T]=h,{batchSize:A,filterDepth:R,filterHeight:$,filterWidth:F,inChannels:D,inDepth:O,inHeight:L,inWidth:M,outChannels:P,outDepth:z,outHeight:B,outWidth:V,strideDepth:W,strideHeight:U,strideWidth:j}=p,H=R-1-p.padInfo.front,G=$-1-p.padInfo.top,q=F-1-p.padInfo.left;for(let s=0;s<A;++s)for(let t=0;t<D;++t)for(let e=0;e<O;++e){const n=e-H,r=Math.max(0,Math.ceil(n/W)),i=Math.min(z,(R+n)/W);for(let a=0;a<L;++a){const o=a-G,l=Math.max(0,Math.ceil(o/U)),u=Math.min(B,($+o)/U);for(let c=0;c<M;++c){const h=c-q,d=Math.max(0,Math.ceil(h/j)),p=Math.min(V,(F+h)/j);let f=0;for(let e=r;e<i;++e){const r=e*W-n;for(let n=l;n<u;++n){const i=n*U-o;for(let a=d;a<p;++a){const o=w*s+_*e+k*n+S*a,l=I*(R-1-r)+N*($-1-i)+E*(F-1-(a*j-h))+T*t;for(let t=0;t<P;++t)f+=v[o+t]*C[l+t]}}}m[g*s+y*e+b*a+x*c+t]=f}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},HB={kernelName:"Cos",backendName:"cpu",kernelFunc:mz("Cos",t=>Math.cos(t))},GB={kernelName:"Cosh",backendName:"cpu",kernelFunc:mz("Cosh",t=>Math.cosh(t))},qB={kernelName:"CropAndResize",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:a,boxInd:o}=e,{cropSize:l,method:u,extrapolationValue:c}=r,[h,d,p,f]=i.shape,m=a.shape[0],[g,y]=l,b=CC([m,g,y,f],"float32"),x=n.data.get(a.dataId).values,v=n.data.get(o.dataId).values,w=n.data.get(i.dataId).values,_=s.computeStrides(i.shape),k=s.computeStrides(b.shape);for(let s=0;s<m;s++){const t=4*s,e=x[t],n=x[t+1],r=x[t+2],i=x[t+3],a=v[s];if(a>=h)continue;const o=g>1?(r-e)*(d-1)/(g-1):0,l=y>1?(i-n)*(p-1)/(y-1):0;for(let h=0;h<g;h++){const t=g>1?e*(d-1)+h*o:.5*(e+r)*(d-1);if(t<0||t>d-1)for(let e=0;e<y;e++)for(let t=0;t<f;t++)b.values[t+e*k[2]+h*k[1]+s*k[0]]=c;else if("bilinear"===u){const e=Math.floor(t),r=Math.ceil(t),o=t-e;for(let t=0;t<y;t++){const u=y>1?n*(p-1)+t*l:.5*(n+i)*(p-1);if(u<0||u>p-1){for(let e=0;e<f;e++)b.values[e+t*k[2]+h*k[1]+s*k[0]]=c;continue}const d=Math.floor(u),m=Math.ceil(u),g=u-d;for(let n=0;n<f;n++){let i=n+d*_[2]+e*_[1]+a*_[0];const l=w[i];i=n+m*_[2]+e*_[1]+a*_[0];const u=w[i];i=n+d*_[2]+r*_[1]+a*_[0];const c=w[i];i=n+m*_[2]+r*_[1]+a*_[0];const p=w[i],f=l+(u-l)*g;i=n+t*k[2]+h*k[1]+s*k[0],b.values[i]=f+(c+(p-c)*g-f)*o}}}else for(let e=0;e<y;++e){const r=y>1?n*(p-1)+e*l:.5*(n+i)*(p-1);if(r<0||r>p-1){for(let t=0;t<f;t++)b.values[t+e*k[2]+h*k[1]+s*k[0]]=c;continue}const o=Math.round(r),u=Math.round(t);for(let t=0;t<f;t++)b.values[t+e*k[2]+h*k[1]+s*k[0]]=w[t+o*_[2]+u*_[1]+a*_[0]]}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},KB={kernelName:"Cumsum",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,exclusive:o,reverse:l}=r;dz(i,"cumsum");const u=d.getAxesPermutation([a],i.shape.length);let c=i;null!=u&&(c=nB({inputs:{x:i},backend:n,attrs:{perm:u}}));const h=d.getInnerMostAxes(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const p=fS(c.dtype,"int32"),f=s.makeZerosTypedArray(s.sizeFromShape(c.shape),p),m=n.data.get(c.dataId).values,g=c.shape[c.shape.length-1],y=l?(t,e)=>t+g-e-1:(t,e)=>t+e;for(let s=0;s<m.length;s+=g)for(let t=0;t<g;t++){const e=y(s,t);if(0===t)f[e]=o?0:m[e];else{const n=y(s,t-1);f[e]=o?m[n]+f[n]:m[e]+f[n]}}const b=n.makeTensorInfo(c.shape,p,f);if(null!=u){const t=nB({inputs:{x:b},backend:n,attrs:{perm:d.getUndoAxesPermutation(u)}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(c),t}return b}},XB={kernelName:"DenseBincount",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const t=CB(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,t)}if(2===r.shape.length){const t=IB(n.bufferSync(r),n.bufferSync(i),a,o);return n.makeTensorInfo(t.shape,i.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},QB={kernelName:"DepthToSpace",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:a,dataFormat:o}=r;s.assert("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`),s.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const l=i.shape[0],u=i.shape[1],c=i.shape[2],h=i.shape[3],d=u*a,p=c*a,f=h/(a*a),m=n.data.get(i.dataId).values,g=new Float32Array(l*d*p*f);let y=0;for(let s=0;s<l;++s)for(let t=0;t<d;++t){const e=Math.floor(t/a),n=t%a;for(let t=0;t<p;++t){const r=Math.floor(t/a),i=(n*a+t%a)*f;for(let t=0;t<f;++t)g[y++]=m[t+i+h*(r+c*(e+u*s))]}}return n.makeTensorInfo([l,d,p,f],i.dtype,g)}};function YB(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dilations:u,dimRoundingMode:c}=r;dz([i,a],"depthwiseConv2DNative");const h=s.computeStrides(i.shape),p=s.computeStrides(a.shape);let f=u;null==f&&(f=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const m=d.computeConv2DInfo(i.shape,a.shape,o,f,l,c,!0),{filterHeight:g,filterWidth:y,dilationHeight:b,dilationWidth:x,padInfo:v}=m,w=v.left,_=v.top,k=m.outChannels/m.inChannels,S=new eS(m.outShape,i.dtype),C=n.data.get(i.dataId).values,I=n.data.get(a.dataId).values,N=S.values;for(let s=0;s<m.batchSize;++s){const t=s*h[0],e=s*S.strides[0];for(let n=0;n<m.outHeight;++n){const s=e+n*S.strides[1],r=n*m.strideHeight-w;for(let e=0;e<g;++e){const n=r+e*b;if(n<0||n>=m.inHeight)continue;const i=e*p[0],a=t+n*h[1];for(let t=0;t<m.outWidth;++t){const e=s+t*S.strides[2],n=t*m.strideWidth-_;for(let t=0;t<y;++t){const s=n+t*x;if(s<0||s>=m.inWidth)continue;const r=a+s*m.inChannels;let o=e,l=i+t*p[1];for(let t=0;t<m.inChannels;++t){const e=C[r+t];for(let t=0;t<k;++t)N[o+t]+=e*I[l+t];o+=k,l+=k}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const ZB={kernelName:"DepthwiseConv2dNative",backendName:"cpu",kernelFunc:YB},JB={kernelName:"DepthwiseConv2dNativeBackpropFilter",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s;dz([r,i],"depthwiseConv2dNativeBackpropFilter");const h=d.computeConv2DInfo(r.shape,c,a,o,l,u,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=new eS(h.filterShape,"float32"),b=h.padInfo.left,x=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,_=new eS(r.shape,r.dtype,w),k=n.data.get(i.dataId).values,S=new eS(i.shape,i.dtype,k);for(let d=0;d<m;++d){const t=Math.max(0,Math.ceil((x-d)/p)),e=Math.min(h.outHeight,(h.inHeight+x-d)/p);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((b-n)/f)),r=Math.min(h.outWidth,(h.inWidth+b-n)/f);for(let i=0;i<h.outChannels;++i){const a=Math.trunc(i/v),o=i%v;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=t;o<e;++o){const t=d+o*p-x;for(let e=s;e<r;++e)l+=_.get(u,t,n+e*f-b,a)*S.get(u,o,e,i)}y.set(l,d,n,a,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},tV={kernelName:"DepthwiseConv2dNativeBackpropInput",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:a}=e,{strides:o,dilations:l,pad:u,dimRoundingMode:c,inputShape:h}=r;dz([i,a],"depthwiseConv2DNativeBackpropInput");const p=s.computeStrides(i.shape),f=s.computeStrides(a.shape),m=d.computeConv2DInfo(h,a.shape,o,l,u,c,!0),g=new eS(m.inShape,"float32"),y=g.values,[b,x,v]=g.strides,w=n.data.get(i.dataId).values,[_,k,S]=p,C=n.data.get(a.dataId).values,[I,N,E]=f,{batchSize:T,filterHeight:A,filterWidth:R,inChannels:$,inHeight:F,inWidth:D,outChannels:O,outHeight:L,outWidth:M,strideHeight:P,strideWidth:z}=m,B=A-1-m.padInfo.top,V=R-1-m.padInfo.left,W=O/$;for(let s=0;s<T;++s)for(let t=0;t<$;++t)for(let e=0;e<F;++e){const n=e-B,r=Math.max(0,Math.ceil(n/P)),i=Math.min(L,(A+n)/P);for(let a=0;a<D;++a){const o=a-V,l=Math.max(0,Math.ceil(o/z)),u=Math.min(M,(R+o)/z);let c=0;for(let e=r;e<i;++e){const r=e*P-n;for(let n=l;n<u;++n){const i=_*s+k*e+S*n,a=I*(A-1-r)+N*(R-1-(n*z-o))+E*t;for(let e=0;e<W;++e)c+=w[i+(t*W+e)]*C[a+e]}}y[b*s+x*e+v*a+t]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},eV={kernelName:"Diag",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=s.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,o=CC([i,i],r.dtype),l=o.values;for(let s=0;s<a.length;s++)l[s*i+s]=a[s];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,o.dtype,o.values)}},nV={kernelName:"Dilation2D",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=u.data.get(r.dataId).values,h=r.shape.length,p=u.data.get(i.dataId).values,f=i.shape.length,{batchSize:m,inHeight:g,inWidth:y,inChannels:b,outHeight:x,outWidth:v,padInfo:w,strideHeight:_,strideWidth:k,filterHeight:S,filterWidth:C,dilationHeight:I,dilationWidth:N,outShape:E}=d.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l),T=s.sizeFromShape(E),A=E.length,R=s.getArrayFromDType(r.dtype,T);for(let d=0;d<m;++d)for(let t=0;t<x;++t){const e=t*_-w.top;for(let n=0;n<v;++n){const a=n*k-w.left;for(let o=0;o<b;++o){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<S;++t){const n=e+t*I;if(n>=0&&n<g)for(let e=0;e<C;++e){const u=a+e*N;if(u>=0&&u<y){const a=s.locToIndex([d,n,u,o],h,s.computeStrides(r.shape)),m=s.locToIndex([t,e,o],f,s.computeStrides(i.shape)),g=c[a]+p[m];g>l&&(l=g)}}}R[s.locToIndex([d,t,n,o],A,s.computeStrides(E))]=l}}}return{dataId:u.write(s.toTypedArray(R,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}},sV={kernelName:"Dilation2DBackpropFilter",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i,dy:a}=t,{strides:o,pad:l,dilations:u}=n,c=e,h=s.toNestedArray(r.shape,c.data.get(r.dataId).values),p=s.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:_,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=d.computeDilation2DInfo(r.shape,i.shape,o,l,"NHWC",u);s.assert(a.rank===N.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${N.length}, but got ${a.rank}`);const E=s.toNestedArray(N,c.data.get(a.dataId).values),T=s.makeZerosNestedTypedArray(i.shape,i.dtype);for(let s=0;s<f;++s)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<x;++n){const r=n*_-v.left;for(let i=0;i<y;++i){let a=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<k;++t){const n=e+t*C;if(n>=0&&n<m)for(let e=0;e<S;++e){const u=r+e*I;if(u>=0&&u<g){const r=h[s][n][u][i]+p[t][e][i];r>a&&(a=r,o=t,l=e)}}}T[o][l][i]+=E[s][t][n][i]}}}return{dataId:c.write(s.toTypedArray(T,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},rV={kernelName:"Dilation2DBackpropInput",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i,dy:a}=t,{strides:o,pad:l,dilations:u}=n,c=e,h=s.toNestedArray(r.shape,c.data.get(r.dataId).values),p=s.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:_,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=d.computeDilation2DInfo(r.shape,i.shape,o,l,"NHWC",u);s.assert(a.rank===N.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${N.length}, but got ${a.rank}`);const E=s.toNestedArray(N,c.data.get(a.dataId).values),T=s.makeZerosNestedTypedArray(r.shape,r.dtype);for(let s=0;s<f;++s)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<x;++n){const r=n*_-v.left;for(let i=0;i<y;++i){let a=Number.MIN_SAFE_INTEGER,o=e<0?0:e,l=r<0?0:r;for(let t=0;t<k;++t){const n=e+t*C;if(n>=0&&n<m)for(let e=0;e<S;++e){const u=r+e*I;if(u>=0&&u<g){const r=h[s][n][u][i]+p[t][e][i];r>a&&(a=r,o=n,l=u)}}}T[s][o][l][i]+=E[s][t][n][i]}}}return{dataId:c.write(s.toTypedArray(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},iV={kernelName:"EluGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:i}=e;dz([r,i],"eluGrad");const a=new Float32Array(s.sizeFromShape(i.shape)),o=n.data.get(i.dataId).values,l=n.data.get(r.dataId).values;for(let s=0;s<o.length;++s){const t=o[s];a[s]=t>=1?l[s]:l[s]*(t+1)}return n.makeTensorInfo(i.shape,"float32",a)}},aV=zz("Equal",kz((t,e)=>t===e?1:0),null,"bool"),oV={kernelName:"Equal",backendName:"cpu",kernelFunc:aV},lV=d.ERF_P,uV=d.ERF_A1,cV=d.ERF_A2,hV=d.ERF_A3,dV=d.ERF_A4,pV=d.ERF_A5,fV={kernelName:"Erf",backendName:"cpu",kernelFunc:mz("Erf",t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+lV*n);return e*(1-((((pV*s+dV)*s+hV)*s+cV)*s+uV)*s*Math.exp(-n*n))})},mV=EB(t=>Math.exp(t)),gV=gz("Exp",mV),yV={kernelName:"Exp",backendName:"cpu",kernelFunc:gV};function bV(t){const{inputs:e,backend:n,attrs:r}=t,{input:i}=e,{dim:a}=r,o=i.shape.length,l=i.shape.slice();let u=a;return a<0&&(s.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),l.splice(u,0,1),Hz({inputs:{x:i},backend:n,attrs:{shape:l}})}const xV={kernelName:"ExpandDims",backendName:"cpu",kernelFunc:bV},vV=EB(t=>Math.expm1(t)),wV={kernelName:"Expm1",backendName:"cpu",kernelFunc:gz("Expm1",vV)},_V=kz((t,e)=>t*e),kV=Bz((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),SV=zz("Multiply",_V,kV),CV={kernelName:"Multiply",backendName:"cpu",kernelFunc:SV},IV=zz("RealDiv",kz((t,e)=>t/e)),NV={kernelName:"RealDiv",backendName:"cpu",kernelFunc:IV},EV=kz((t,e)=>t-e),TV=Bz((t,e,n,s)=>({real:t-n,imag:e-s})),AV=zz("Sub",EV,TV),RV={kernelName:"Sub",backendName:"cpu",kernelFunc:AV};function $V(t,e,n){const r=t.shape,i=r[0],a=r[1],o=n.data.get(t.dataId),l=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[i,a],h=s.sizeFromShape(c),p=s.getTypedArrayFromDType("float32",h),f=s.getTypedArrayFromDType("float32",h);for(let s=0;s<i;s++){const t=_B({inputs:{x:l},backend:n,attrs:{begin:[s,0],size:[1,a]}}),r=_B({inputs:{x:u},backend:n,attrs:{begin:[s,0],size:[1,a]}}),i=$z({inputs:{real:t,imag:r},backend:n}),{real:o,imag:c}=FV(i,e,n),h=d.mergeRealAndImagArrays(o,c);for(let e=0;e<a;e++){const t=d.getComplexWithIndex(h,e);p[s*a+e]=t.real,f[s*a+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i)}const m=n.makeTensorInfo(c,"float32",p),g=n.makeTensorInfo(c,"float32",f),y=$z({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}function FV(t,e,n){const r=s.sizeFromShape(t.shape),i=n.data.get(t.dataId),a=n.data.get(i.complexTensorInfos.real.dataId).values,o=n.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((l=r)&l-1)){const i=DV(a,o,r,e,n),l=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(l,"float32",i.real),e=n.makeTensorInfo(l,"float32",i.imag),a=n.makeTensorInfo([],"float32",s.createScalarValue(r,"float32")),o=xz({inputs:{x:a},backend:n}),u=NV.kernelFunc({inputs:{a:t,b:a},backend:n}),c=NV.kernelFunc({inputs:{a:e,b:o},backend:n}),h=n.data.get(u.dataId).values,d=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),{real:h,imag:d}}return i}{const t=function(t,e,n){const s=new Float32Array(2*e);for(let r=0;r<e;r++){let i=0,a=0;for(let s=0;s<e;s++){const o=d.exponent(r*s,e,n),l=d.getComplexWithIndex(t,s);i+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(i/=e,a/=e),d.assignToTypedArray(s,i,a,r)}return s}(d.mergeRealAndImagArrays(a,o),r,e);return d.splitRealAndImagArrays(t)}var l}function DV(t,e,n,s,r){if(1===n)return{real:t,imag:e};const i=d.mergeRealAndImagArrays(t,e),a=n/2,o=d.complexWithEvenIndex(i),l=o.real,u=o.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),p=r.makeTensorInfo(c,"float32",u),f=$z({inputs:{real:h,imag:p},backend:r}),m=d.complexWithOddIndex(i),g=m.real,y=m.imag,b=[g.length],x=r.makeTensorInfo(b,"float32",g),v=r.makeTensorInfo(b,"float32",y),w=$z({inputs:{real:x,imag:v},backend:r}),_=DV(l,u,a,s,r),k=_.real,S=_.imag,C=[k.length],I=r.makeTensorInfo(C,"float32",k),N=r.makeTensorInfo(C,"float32",S),E=$z({inputs:{real:I,imag:N},backend:r}),T=DV(g,y,a,s,r),A=T.real,R=T.imag,$=[A.length],F=r.makeTensorInfo($,"float32",A),D=r.makeTensorInfo($,"float32",R),O=$z({inputs:{real:F,imag:D},backend:r}),L=d.exponents(n,s),M=[L.real.length],P=r.makeTensorInfo(M,"float32",L.real),z=r.makeTensorInfo(M,"float32",L.imag),B=$z({inputs:{real:P,imag:z},backend:r}),V=SV({inputs:{a:B,b:O},backend:r}),W=Uz({inputs:{a:E,b:V},backend:r}),U=AV({inputs:{a:E,b:V},backend:r}),j=Oz({inputs:{input:W},backend:r}),H=Oz({inputs:{input:U},backend:r}),G=DB({inputs:{input:W},backend:r}),q=DB({inputs:{input:U},backend:r}),K=LB({inputs:[j,H],backend:r,attrs:{axis:0}}),X=LB({inputs:[G,q],backend:r,attrs:{axis:0}}),Q=r.data.get(K.dataId).values,Y=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(X),{real:Q,imag:Y}}const OV={kernelName:"FFT",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,i=s.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=Hz({inputs:{x:r},backend:n,attrs:{shape:[i/a,a]}}),l=$V(o,!1,n),u=Hz({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};function LV(t){const{backend:e,attrs:n}=t,{shape:r,value:i,dtype:a}=n,o=a||s.inferDtype(i),l=s.getArrayFromDType(o,s.sizeFromShape(r));return function(t,e,n){t.fill(e)}(l,i),e.makeTensorInfo(r,o,l)}const MV={kernelName:"Fill",backendName:"cpu",kernelFunc:LV},PV={kernelName:"FlipLeftRight",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,i=s.getTypedArrayFromDType(n.dtype,s.sizeFromShape(n.shape)),[a,o,l,u]=n.shape,c=r.data.get(n.dataId).values;for(let s=0;s<a;s++){const t=s*l*o*u;for(let e=0;e<o;e++){const n=e*(l*u);for(let s=0;s<l;s++){const r=s*u;for(let o=0;o<u;o++){const h=Math.round(l-[a,e,s,o][2]),d=t+n+r+o;let p=c[d];h>=0&&h<l&&(p=c[t+n+h*u+o]),i[d]=p}}}}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},zV=EB(t=>Math.floor(t)),BV={kernelName:"Floor",backendName:"cpu",kernelFunc:gz("Floor",zV)},VV={kernelName:"FloorDiv",backendName:"cpu",kernelFunc:zz("FloorDiv",kz((t,e)=>Math.floor(t/e)),null,"int32")},WV={kernelName:"FusedConv2D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=PB({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=Uz({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=Rz(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}},UV={kernelName:"FusedDepthwiseConv2D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=YB({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=Uz({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=Rz(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}},jV={kernelName:"GatherNd",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,a=s.sizeFromShape(r.shape),o=i.shape,l=o[o.length-1],[u,c,h,p]=d.prepareAndValidate(r,i);if(0===c)return n.makeTensorInfo(u,r.dtype,[]);const f=CC([c,h],r.dtype),m=n.data.get(i.dataId).values,g=n.data.get(r.dataId).values;for(let s=0;s<c;s++){const t=[];let e=0;for(let n=0;n<l;n++){const r=m[s*l+n];e+=r*p[n],t.push(r)}if(e<0||e>=a/h)throw new Error(`Invalid indices: ${t} does not index into ${r.shape}`);for(let n=0;n<h;n++)f.values[s*h+n]=g[e*h+n]}return n.makeTensorInfo(u,f.dtype,f.values)}};function HV(t,e,n){const s=CC(n,t.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),i=e.locToIndex([n[0],n[2]]);n[2]=e.values[i];const a=t.locToIndex(n);s.values[r]=t.values[a]}return s}const GV={kernelName:"GatherV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:a}=e,{axis:o,batchDims:l}=r;dz([i,a],"gatherV2");let u=l;null==l&&(u=0);const c=s.sizeFromShape(a.shape),h=s.parseAxisParam(o,i.shape)[0],p=d.segment_util.collectGatherOpShapeInfo(i,a,h,u),f=Hz({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Hz({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,c/p.batchSize]}}),g=[p.batchSize,p.outerSize,c/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=HV(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},qV=kz((t,e)=>t>e?1:0),KV={kernelName:"Greater",backendName:"cpu",kernelFunc:zz("Greater",qV,null,"bool")},XV={kernelName:"GreaterEqual",backendName:"cpu",kernelFunc:zz("GreaterEqual",kz((t,e)=>t>=e?1:0),null,"bool")},QV={kernelName:"IFFT",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,i=s.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=Hz({inputs:{x:r},backend:n,attrs:{shape:[i/a,a]}}),l=$V(o,!0,n),u=Hz({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}},YV={kernelName:"IsFinite",backendName:"cpu",kernelFunc:mz("IsFinite",t=>Number.isFinite(t)?1:0,"bool")},ZV={kernelName:"IsInf",backendName:"cpu",kernelFunc:mz("IsInf",t=>Math.abs(t)===1/0?1:0,"bool")},JV={kernelName:"IsNan",backendName:"cpu",kernelFunc:mz("IsNan",t=>Number.isNaN(t)?1:0,"bool")},tW=kz((t,e)=>t<e?1:0),eW={kernelName:"Less",backendName:"cpu",kernelFunc:zz("Less",tW,null,"bool")},nW={kernelName:"LessEqual",backendName:"cpu",kernelFunc:zz("LessEqual",kz((t,e)=>t<=e?1:0),null,"bool")};function sW(t,e,n){const r=(e-t)/(n-1),i=s.makeZerosTypedArray(n,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}const rW={kernelName:"LinSpace",backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,a=sW(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}},iW=EB(t=>Math.log(t)),aW={kernelName:"Log",backendName:"cpu",kernelFunc:gz("Log",iW)},oW={kernelName:"Log1p",backendName:"cpu",kernelFunc:mz("Log1p",t=>Math.log1p(t))},lW={kernelName:"LogicalAnd",backendName:"cpu",kernelFunc:zz("LogicalAnd",kz((t,e)=>t&&e),null,"bool")},uW={kernelName:"LogicalNot",backendName:"cpu",kernelFunc:mz("LogicalNot",t=>t?0:1,"bool")},cW={kernelName:"LogicalOr",backendName:"cpu",kernelFunc:zz("LogicalOr",kz((t,e)=>t||e),null,"bool")},hW={kernelName:"LRN",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:a,bias:o,alpha:l,beta:u}=r;dz(i,"LRN");const c=i.shape[3],h=c-1,d=n.data.get(i.dataId).values,p=s.sizeFromShape(i.shape),f=new Float32Array(p);function m(t){const e=t%c;let n=t-e+Math.max(0,e-a);const s=t-e+Math.min(e+a,h);let r=0;for(;n<=s;n++){const t=d[n];r+=t*t}return r}for(let s=0;s<p;s++){const t=m(s),e=d[s]*Math.pow(o+l*t,-u);f[s]=e}return n.makeTensorInfo(i.shape,i.dtype,f)}},dW={kernelName:"LRNGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,y:a,dy:o}=e,{depthRadius:l,bias:u,alpha:c,beta:h}=r;dz(o,"LRNGrad");const d=s.sizeFromShape(o.shape),p=o.shape[3],f=n.data.get(o.dataId).values,m=n.data.get(i.dataId).values,g=n.data.get(a.dataId).values,y=new Float32Array(d),b=d;for(let s=0;s<b;s++){const t=s%p,e=s-t+Math.max(0,t-l),n=s-t+Math.min(p,t+l+1);let r=0;for(let s=e;s<n;s++)r+=Math.pow(m[s],2);r=c*r+u;for(let i=e;i<n;i++){let t=-2*c*h*m[i]*g[s]/r;s===i&&(t+=Math.pow(r,-h)),t*=f[s],y[i]+=t}}return n.makeTensorInfo(o.shape,i.dtype,y)}};function pW(t,e,n,r){const i=s.getTypedArrayFromDType(r,s.sizeFromShape(n));for(let s=0;s<i.length;++s){const n=s*e;let r=t[n];for(let s=0;s<e;++s){const e=t[n+s];e>r&&(r=e)}i[s]=r}return i}function fW(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:a,keepDims:o}=r,l=n;let u=i.shape;const c=u.length,h=s.parseAxisParam(a,u);let p=h;const f=d.getAxesPermutation(p,c);let m=l.data.get(i.dataId).values;if(null!=f){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=u[f[e]];m=eB(m,u,i.dtype,f,t),p=d.getInnerMostAxes(p.length,c),u=t}dz(i,"max"),d.assertAxesAreInnerMostDims("max",p,c);const[g,y]=d.computeOutAndReduceShapes(u,p),b=pW(m,s.sizeFromShape(y),g,i.dtype),x=l.write(b,g,i.dtype);let v=g;return o&&(v=d.expandShapeToKeepDim(g,h)),{dataId:x,shape:v,dtype:i.dtype}}const mW={kernelName:"Max",backendName:"cpu",kernelFunc:fW},gW=kz((t,e)=>Math.max(t,e)),yW={kernelName:"Maximum",backendName:"cpu",kernelFunc:zz("Maximum",gW)},bW={kernelName:"MaxPool",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;dz(i,"maxPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);let h;if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))h=xz({inputs:{x:i},backend:n});else{const t=n.data.get(i.dataId).values,e=s.computeStrides(i.shape),r=pB(t,0,i.dtype,e,c,"max");h=n.makeTensorInfo(c.outShape,i.dtype,r.values)}return h}},xW={kernelName:"MaxPool3D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u,dataFormat:c}=r;dz(i,"maxPool3d");const h=d.computePool3DInfo(i.shape,a,o,1,l,u,c),p=mB(n.data.get(i.dataId).values,0,i.dtype,s.computeStrides(i.shape),h,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}},vW={kernelName:"MaxPool3DGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;dz([r,i],"maxPool3DGrad");const c=d.computePool3DInfo(i.shape,a,o,1,l,u),h=function(t,e){const n=CC(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*s-d;let x=b;for(;x<0;)x+=a;const v=Math.min(e.inDepth,u+b);for(let s=0;s<e.outHeight;++s){const u=s*r-p;let d=u;for(;d<0;)d+=o;const w=Math.min(e.inHeight,c+u);for(let r=0;r<e.outWidth;++r){const p=r*i-f;let _=p;for(;_<0;)_+=l;const k=Math.min(e.inWidth,h+p);let S=Number.NEGATIVE_INFINITY,C=-1;for(let e=x;e<v;e+=a){const n=e-b;for(let s=d;s<w;s+=o){const r=s-u;for(let i=_;i<k;i+=l){const a=i-p,o=t.get(m,e,s,i,g);o>=S&&(S=o,C=n*c*h+r*c+a)}}}n.set(C,m,y,s,r,g)}}}return n}(n.bufferSync(i),c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,_=x-1-c.padInfo.front,k=w-1-c.padInfo.left,S=v-1-c.padInfo.top,C=CC(i.shape,"float32"),I=n.bufferSync(r);for(let d=0;d<c.batchSize;++d)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-_,i=n-S,a=s-k;let o=0;for(let e=0;e<x;e+=g){const n=(r+e)/p;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<v;s+=y){const r=(i+s)/f;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let i=0;i<w;i+=b){const l=(a+i)/m;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=x*v*w-1-h.get(d,n,r,l,t)===e*v*w+s*w+i?1:0;0!==u&&(o+=I.get(d,n,r,l,t)*u)}}}C.set(o,d,e,n,s,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},wW={kernelName:"MaxPoolGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:a}=e,o=i;dz([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,p=d.computePool2DInfo(o.shape,l,u,1,c,h),f=n.data.get(o.dataId).values,m=CC(p.outShape,o.dtype,fB(f,o.shape,o.dtype,p).values),g=p.strideHeight,y=p.strideWidth,b=p.dilationHeight,x=p.dilationWidth,v=p.effectiveFilterHeight,w=p.effectiveFilterWidth,_=w-1-p.padInfo.left,k=v-1-p.padInfo.top,S=CC(o.shape,"float32"),C=n.data.get(r.dataId).values,I=CC(r.shape,"float32",C);for(let d=0;d<p.batchSize;++d)for(let t=0;t<p.inChannels;++t)for(let e=0;e<p.inHeight;++e)for(let n=0;n<p.inWidth;++n){const s=e-k,r=n-_;let i=0;for(let e=0;e<v;e+=b){const n=(s+e)/g;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let s=0;s<w;s+=x){const a=(r+s)/y;if(a<0||a>=p.outWidth||Math.floor(a)!==a)continue;const o=v*w-1-m.get(d,n,a,t)===e*w+s?1:0;0!==o&&(i+=I.get(d,n,a,t)*o)}}S.set(i,d,e,n,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},_W={kernelName:"MaxPoolWithArgmax",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:a,pad:o,includeBatchInIndex:l}=e,u=n;dz(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,h=d.computePool2DInfo(r.shape,i,a,[1,1],o),[p,f]=function(t,e,n,r,i){const a=pB(t,0,n,s.computeStrides(e),i,"max"),o=fB(t,e,n,i,!0,r);return[a.values,o.values]}(c,r.shape,r.dtype,l,h),m=u.write(p,h.outShape,r.dtype),g=u.write(f,h.outShape,r.dtype);return[{dataId:m,shape:h.outShape,dtype:r.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};function kW(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;let l;dz(i,"sum"),l="bool"===i.dtype?Mz({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):xz({inputs:{x:i},backend:n});const u=l.shape.length,c=s.parseAxisParam(a,l.shape),h=d.getAxesPermutation(c,u);let p=c,f=l;null!=h&&(f=nB({inputs:{x:l},backend:n,attrs:{perm:h}}),p=d.getInnerMostAxes(p.length,u)),d.assertAxesAreInnerMostDims("sum",p,f.shape.length);const[m,g]=d.computeOutAndReduceShapes(f.shape,p);let y=Dz(n,m,d.upcastType(f.dtype,"int32"));const b=s.sizeFromShape(g),x=n.data.get(y.dataId).values,v=n.data.get(f.dataId).values;for(let s=0;s<x.length;++s){const t=s*b;let e=0;for(let n=0;n<b;++n)e+=v[t+n];x[s]=e}if(o){const t=y;y=Hz({inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(y.shape,c)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(l),null!=h&&n.disposeIntermediateTensorInfo(f),y}const SW={kernelName:"Sum",backendName:"cpu",kernelFunc:kW},CW={kernelName:"Mean",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=s.parseAxisParam(a,i.shape),u=d.computeOutAndReduceShapes(i.shape,l),c=s.sizeFromShape(u[1]),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(p);const f=Mz({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});h.push(f);const m=IV({inputs:{a:f,b:p},backend:n});h.push(m);const g=kW({inputs:{x:m},backend:n,attrs:{axis:a,keepDims:o}});return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},IW={kernelName:"Min",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;dz(i,"min");const l=s.parseAxisParam(a,i.shape);let u=l;const c=d.getAxesPermutation(u,i.shape.length);let h=i;null!=c&&(h=nB({inputs:{x:i},backend:n,attrs:{perm:c}}),u=d.getInnerMostAxes(u.length,i.shape.length)),d.assertAxesAreInnerMostDims("min",u,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,u),m=s.sizeFromShape(f),g=s.makeZerosTypedArray(s.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let s=0;s<g.length;++s){const t=s*m;let e=y[t];for(let n=0;n<m;++n){const s=y[t+n];s<e&&(e=s)}g[s]=e}null!=c&&n.disposeIntermediateTensorInfo(h);const b=n.makeTensorInfo(p,h.dtype,g);if(o){const t=Hz({inputs:{x:b},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(b),t}return b}},NW=kz((t,e)=>Math.min(t,e)),EW={kernelName:"Minimum",backendName:"cpu",kernelFunc:zz("Minimum",NW)},TW={kernelName:"MirrorPad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:a,mode:o}=r;dz(i,"mirrorPad");const l=a.map((t,e)=>t[0]+i.shape[e]+t[1]),u=a.map(t=>t[0]),c=a.map((t,e)=>t[0]+i.shape[e]),h="reflect"===o?0:1,d=n.data.get(i.dataId).values,p=i.shape.length,f=s.computeStrides(i.shape),m=s.sizeFromShape(l),g=l.length,y=s.computeStrides(l),b=s.getTypedArrayFromDType(i.dtype,m);for(let x=0;x<m;x++){let t=s.indexToLoc(x,g,y);for(let n=0;n<g;n++)t[n]<u[n]?t[n]=2*u[n]-t[n]-h:t[n]>=c[n]&&(t[n]=2*(c[n]-1)-t[n]+h);t=t.map((t,e)=>t-u[e]);const e=s.locToIndex(t,p,f);b[x]=d[e]}return{dataId:n.write(b,l,i.dtype),shape:l,dtype:i.dtype}}},AW={kernelName:"Mod",backendName:"cpu",kernelFunc:zz("Mod",kz((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}))};function RW(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:a}=r,o=i.shape.length;let l=a;if(-1===l&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const u=s.parseAxisParam([l],i.shape),c=fW({inputs:{x:i},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),h=d.expandShapeToKeepDim(c.shape,u),p=Hz({inputs:{x:c},backend:n,attrs:{shape:h}}),f=AV({inputs:{a:i,b:p},backend:n}),m=gV({inputs:{x:f},backend:n}),g=kW({inputs:{x:m},backend:n,attrs:{axis:u,keepDims:!1}}),y=Hz({inputs:{x:g},backend:n,attrs:{shape:h}}),b=IV({inputs:{a:m,b:y},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}const $W={kernelName:"Softmax",backendName:"cpu",kernelFunc:RW},FW={kernelName:"Multinomial",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:a,seed:o,normalized:l}=r;dz(i,"multinomial");const u=l?i:RW({inputs:{logits:i},backend:n,attrs:{dim:-1}}),c=u.shape[0],h=u.shape[1],d=n.data.get(u.dataId).values,p=[c,a],f=s.makeZerosTypedArray(s.sizeFromShape(p),"int32");for(let s=0;s<c;++s){const t=s*h,e=new Float32Array(h-1);e[0]=d[t];for(let s=1;s<e.length;++s)e[s]=e[s-1]+d[t+s];const n=nE.alea(o.toString()),r=s*a;for(let s=0;s<a;++s){const t=n();f[r+s]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){f[r+s]=n;break}}}return l||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",f)}};function DW(t,e,n){const r=s.createScalarValue(-1,n);return _V([],e,r,t,n)}const OW={kernelName:"Neg",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;dz(s,"neg");const r=n.data.get(s.dataId).values,[i,a]=DW(r,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,i)}},LW=p.nonMaxSuppressionV3Impl,MW={kernelName:"NonMaxSuppressionV3",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;dz(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=LW(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},PW=p.nonMaxSuppressionV4Impl,zW={kernelName:"NonMaxSuppressionV4",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s;dz(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=PW(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},BW=p.nonMaxSuppressionV5Impl,VW={kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s;dz(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=BW(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},WW=kz((t,e)=>t!==e?1:0),UW={kernelName:"NotEqual",backendName:"cpu",kernelFunc:zz("NotEqual",WW,null,"bool")},jW={kernelName:"OneHot",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{depth:a,onValue:o,offValue:l}=r;dz(i,"oneHot");const u=s.sizeFromShape(i.shape),c=new Float32Array(u*a);c.fill(l);const h=n.data.get(i.dataId).values;for(let s=0;s<u;++s)h[s]>=0&&h[s]<a&&(c[s*a+h[s]]=o);return n.makeTensorInfo([...i.shape,a],"int32",c)}};function HW(t){const{inputs:e,backend:n}=t,{x:s}=e;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const t=Oz({inputs:{input:s},backend:n}),e=HW({inputs:{x:t},backend:n}),r=DB({inputs:{input:s},backend:n}),i=HW({inputs:{x:r},backend:n}),a=$z({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return LV({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const GW={kernelName:"ZerosLike",backendName:"cpu",kernelFunc:HW},qW={kernelName:"OnesLike",backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=Oz({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=DB({inputs:{input:r},backend:s}),a=HW({inputs:{x:i},backend:s}),o=$z({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return LV({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function KW(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(1===e.length)return bV({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const a=e[0].shape,o=e[0].dtype;e.forEach(t=>{s.assertShapesMatch(a,t.shape,"All tensors passed to stack must have matching shapes"),s.assert(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=LB({inputs:e.map(t=>{const e=bV({inputs:{input:t},backend:n,attrs:{dim:i}});return l.push(e),e}),backend:n,attrs:{axis:i}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}const XW={kernelName:"Pack",backendName:"cpu",kernelFunc:KW},QW={kernelName:"PadV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:a,constantValue:o}=r;dz(i,"pad");const l=a.map((t,e)=>t[0]+i.shape[e]+t[1]),u=a.map(t=>t[0]),c=n.data.get(i.dataId).values,h=s.sizeFromShape(i.shape),d=i.shape.length,p=s.computeStrides(i.shape),f=s.sizeFromShape(l),m=l.length,g=s.computeStrides(l),y=s.getTypedArrayFromDType(i.dtype,f);0!==o&&y.fill(o);for(let b=0;b<h;b++){const t=s.indexToLoc(b,d,p).map((t,e)=>t+u[e]);y[s.locToIndex(t,m,g)]=c[b]}return{dataId:n.write(y,l,i.dtype),shape:l,dtype:i.dtype}}},YW={kernelName:"Pow",backendName:"cpu",kernelFunc:zz("Pow",kz((t,e)=>Math.pow(t,e)))};function ZW(t,e,n,r){const[i,a]=d.computeOutAndReduceShapes(t,r),o=fS(e,"int32"),l=s.makeZerosTypedArray(s.sizeFromShape(i),o),u=s.sizeFromShape(a);for(let s=0;s<l.length;++s){const t=s*u;let e=1;for(let s=0;s<u;++s)e*=n[t+s];l[s]=e}return{outVals:l,outShape:i,outDtype:o}}const JW={kernelName:"Prod",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;dz(i,"prod");const l=i.shape.length,u=s.parseAxisParam(a,i.shape),c=d.getAxesPermutation(u,l);let h=u,p=i;const f=[];null!=c&&(p=nB({inputs:{x:i},backend:n,attrs:{perm:c}}),f.push(p),h=d.getInnerMostAxes(h.length,l));const m=n.data.get(p.dataId).values,{outVals:g,outShape:y,outDtype:b}=ZW(p.shape,p.dtype,m,h);let x=y;return o&&(x=d.expandShapeToKeepDim(y,u)),f.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(x,b,g)}};function tU(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return s.makeZerosTypedArray(0,r);const i=Math.abs(Math.ceil((e-t)/n)),a=s.makeZerosTypedArray(i,r);e<t&&1===n&&(n=-1),a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const eU={kernelName:"Range",backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:i,step:a}=n,o=tU(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}},nU={kernelName:"Reciprocal",backendName:"cpu",kernelFunc:mz("Reciprocal",t=>1/t)},sU={kernelName:"ResizeBilinear",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:a,halfPixelCenters:o,size:l}=r;dz(i,"resizeBilinear");const u=s.computeStrides(i.shape),[c,h]=l,[d,p,f,m]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(s.sizeFromShape([d,c,h,m])),b=[a&&c>1?p-1:p,a&&h>1?f-1:f],x=[a&&c>1?c-1:c,a&&h>1?h-1:h];let v=0;const w=b[0]/x[0],_=b[1]/x[1];for(let s=0;s<d;s++)for(let t=0;t<c;t++){let e;e=o?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,i=Math.min(p-1,Math.ceil(e)),a=s*u[0]+n*u[1],l=s*u[0]+i*u[1];for(let t=0;t<h;t++){let e;e=o?_*(t+.5)-.5:_*t;const n=Math.max(0,Math.floor(e)),s=e-n,i=Math.min(f-1,Math.ceil(e)),c=a+n*u[2],h=l+n*u[2],d=a+i*u[2],p=l+i*u[2];for(let t=0;t<m;t++){const e=g[c+t],n=g[h+t],i=e+(g[d+t]-e)*s;y[v++]=i+(n+(g[p+t]-n)*s-i)*r}}}return n.makeTensorInfo([d,c,h,m],"float32",y)}},rU={kernelName:"ResizeBilinearGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:a}=e,{alignCorners:o}=r;dz([a,i],"resizeBilinearGrad");const l=s.computeStrides(i.shape),[u,c,h,d]=i.shape,[,p,f]=a.shape,m=new Float32Array(u*c*h*d),g=[o&&p>1?c-1:c,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],b=g[0]/y[0],x=g[1]/y[1],v=n.data.get(a.dataId).values;let w=0;for(let s=0;s<u;s++){const t=s*l[0];for(let e=0;e<p;e++){const n=e*b,s=Math.floor(n),r=Math.min(Math.ceil(n),c-1),i=t+s*l[1],a=t+r*l[1],o=n-s,u=1-o;for(let t=0;t<f;t++){const e=t*x,n=Math.floor(e),s=Math.min(Math.ceil(e),h-1),r=e-n,c=1-r,p=i+n*l[2],f=i+s*l[2],g=a+n*l[2],y=a+s*l[2],b=u*c,_=u*r,k=o*c,S=o*r;for(let t=0;t<d;t++){const e=v[w++];m[p+t]+=e*b,m[f+t]+=e*_,m[g+t]+=e*k,m[y+t]+=e*S}}}}return n.makeTensorInfo([u,h,c,d],"float32",m)}},iU={kernelName:"ResizeNearestNeighbor",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:a,halfPixelCenters:o,size:l}=r;dz(i,"resizeNearestNeighbor");const u=s.computeStrides(i.shape),[c,h]=l,[d,p,f,m]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(d*c*h*m),b=[a&&c>1?p-1:p,a&&h>1?f-1:f],x=[a&&c>1?c-1:c,a&&h>1?h-1:h],v=b[0]/x[0],w=b[1]/x[1];let _=0;for(let s=0;s<d;s++){const t=s*u[0];for(let e=0;e<c;e++){const n=o?v*(e+.5):v*e;let s=Math.min(p-1,a?Math.round(n):Math.floor(n));o&&(s=Math.max(0,s));const r=t+s*u[1];for(let t=0;t<h;t++){const e=o?w*(t+.5):w*t;let n=Math.min(f-1,a?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const s=r+n*u[2];for(let t=0;t<m;t++)y[_++]=g[s+t]}}}return n.makeTensorInfo([d,c,h,m],i.dtype,y)}},aU={kernelName:"ResizeNearestNeighborGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:a}=e,{alignCorners:o}=r;dz([a,i],"resizeNearestNeighborGrad");const l=s.computeStrides(i.shape),u=s.computeStrides(a.shape),[c,h,d,p]=i.shape,[,f,m]=a.shape,g=new Float32Array(c*h*d*p),y=n.data.get(a.dataId).values,b=[o&&f>1?h-1:h,o&&m>1?d-1:d],x=[o&&f>1?f-1:f,o&&m>1?m-1:m],v=b[0]/x[0],w=b[1]/x[1],_=1/v,k=1/w,S=2*Math.ceil(_)+2,C=2*Math.ceil(k)+2;for(let s=0;s<c;s++){const t=s*l[0];for(let e=0;e<h;e++){const n=t+e*l[1],s=Math.floor(e*_),r=Math.floor(s-S/2);for(let i=0;i<d;i++){const s=n+i*l[2],a=Math.floor(i*k),c=Math.floor(a-C/2);for(let n=0;n<p;n++){let a=0;for(let s=0;s<S;s++){const l=s+r;if(l<0||l>=f)continue;const p=t+l*u[1],g=l*v;if(e===Math.min(h-1,o?Math.round(g):Math.floor(g)))for(let t=0;t<C;t++){const e=t+c;if(e<0||e>=m)continue;const s=p+e*u[2],r=e*w;i===Math.min(d-1,o?Math.round(r):Math.floor(r))&&(a+=y[s+n])}}g[s+n]=a}}}}return n.makeTensorInfo(i.shape,i.dtype,g)}},oU={kernelName:"Reverse",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:a}=r;dz(i,"reverse");const o=i.shape.length,l=s.parseAxisParam(a,i.shape);if(0===o)return xz({inputs:{x:i},backend:n});const u=new eS(i.shape,i.dtype),c=n.bufferSync(i);for(let s=0;s<u.size;s++){const t=u.indexToLoc(s),e=t.slice();l.forEach(t=>e[t]=i.shape[t]-1-e[t]),u.set(c.get(...e),...t)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},lU={kernelName:"RotateWithOffset",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:i,fillValue:a,center:o}=e,l=n,u=s.getTypedArrayFromDType(r.dtype,s.sizeFromShape(r.shape)),[c,h,p,f]=r.shape,[m,g]=d.getImageCenter(o,h,p),y=Math.sin(i),b=Math.cos(i),x=l.data.get(r.dataId).values;for(let s=0;s<c;s++){const t=s*p*h*f;for(let e=0;e<h;e++){const n=e*(p*f);for(let s=0;s<p;s++){const r=s*f;for(let i=0;i<f;i++){const o=[c,e,s,i],l=o[2],d=o[1];let v=(l-m)*b-(d-g)*y,w=(l-m)*y+(d-g)*b;v=Math.round(v+m),w=Math.round(w+g);let _=a;"number"!=typeof a&&(_=3===i?255:a[i]),v>=0&&v<p&&w>=0&&w<h&&(_=x[t+w*(p*f)+v*f+i]),u[t+n+r+i]=_}}}}return{dataId:l.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},uU={kernelName:"Round",backendName:"cpu",kernelFunc:mz("Round",t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1})},cU=EB(t=>1/Math.sqrt(t)),hU={kernelName:"Rsqrt",backendName:"cpu",kernelFunc:gz("Rsqrt",cU)};function dU(t,e,n,s,r,i,a,o,l,u){const c=[s/r,r],h=t.values,d=e.values;if(0===s)return CC(n,e.dtype);const p=CC(c,e.dtype);p.values.fill(l);for(let f=0;f<i;f++){const t=[];let i=0;for(let e=0;e<a;e++){const n=h[f*a+e];t.push(n),i+=n*o[e]}if(i<0||i>=s/r)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<r;n++)u?p.values[i*r+n]+=d[f*r+n]:p.values[i*r+n]=0===e.rank?d[0]:d[f*r+n]}return p}const pU={kernelName:"ScatterNd",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=d.calculateShapes(i,r,a),p=dU(n.bufferSync(r),n.bufferSync(i),a,h,u,l,o,c,0,!0);return n.makeTensorInfo(a,p.dtype,p.values)}},fU={kernelName:"Select",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:i,e:a}=e;dz([r,i,a],"select");const o=r.shape.length,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,h=fS(i.dtype,a.dtype),d=s.makeZerosTypedArray(s.sizeFromShape(i.shape),h);let p=0;const f=0===o||o>1||1===i.shape.length?1:s.sizeFromShape(i.shape.slice(1));for(let s=0;s<l.length;s++)for(let t=0;t<f;t++)d[p++]=1===l[s]?u[s]:c[s];return n.makeTensorInfo(i.shape,h,d)}},mU=d.SELU_SCALEALPHA,gU=d.SELU_SCALE,yU={kernelName:"Selu",backendName:"cpu",kernelFunc:mz("Selu",t=>t>=0?gU*t:mU*(Math.exp(t)-1))},bU={kernelName:"Sigmoid",backendName:"cpu",kernelFunc:mz("Sigmoid",t=>1/(1+Math.exp(-t)))},xU={kernelName:"Sign",backendName:"cpu",kernelFunc:mz("Sign",t=>t<0?-1:t>0?1:0)},vU={kernelName:"Sin",backendName:"cpu",kernelFunc:mz("Sin",t=>Math.sin(t))},wU={kernelName:"Sinh",backendName:"cpu",kernelFunc:mz("Sinh",t=>Math.sinh(t))},_U=Math.log(1.1920928955078125e-7)+2,kU={kernelName:"Softplus",backendName:"cpu",kernelFunc:mz("Softplus",t=>{const e=t>-_U,n=t<_U,s=Math.exp(t);let r;return r=n?s:e?t:Math.log(1+s),r})},SU={kernelName:"SpaceToBatchND",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:a,paddings:o}=r;dz([i],"spaceToBatchND");const l=s.sizeFromShape(a),u=[[0,0]];u.push(...o);for(let s=1+a.length;s<i.shape.length;++s)u.push([0,0]);const c=QW.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:u,constantValue:0}}),h=d.getReshaped(c.shape,a,l,!1),p=d.getPermuted(h.length,a.length,!1),f=d.getReshapedPermuted(c.shape,a,l,!1),m=Hz({inputs:{x:c},backend:n,attrs:{shape:h}}),g=nB({inputs:{x:m},backend:n,attrs:{perm:p}}),y=Hz({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}},CU={kernelName:"SparseToDense",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=d.calculateShapes(i,r,o),f=dU(n.bufferSync(r),n.bufferSync(i),o,p,c,u,l,h,n.data.get(a.dataId).values[0],!1);return n.makeTensorInfo(o,f.dtype,f.values)}},IU={kernelName:"SplitV",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:a,axis:o}=r,l=s.parseAxisParam(o,i.shape)[0],u=d.prepareSplitSize(i,a,l),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return u.map(t=>{const e=[...h];e[l]=t;const s=_B({inputs:{x:i},backend:n,attrs:{begin:c,size:e}});return c[l]+=t,s})}},NU={kernelName:"Sqrt",backendName:"cpu",kernelFunc:mz("Sqrt",t=>Math.sqrt(t))},EU={kernelName:"Square",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;dz(n,"square");const r=s.data.get(n.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const t=r[a];i[a]=t*t}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},TU=kz((t,e)=>{const n=t-e;return n*n}),AU={kernelName:"SquaredDifference",backendName:"cpu",kernelFunc:zz("SquaredDifference",TU)},RU={kernelName:"Step",backendName:"cpu",kernelFunc:mz("Step",(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})};function $U(t,e,n,s){const r=CC(t,e.dtype);for(let i=0;i<r.size;i++){const t=r.indexToLoc(i),a=new Array(t.length);for(let e=0;e<a.length;e++)a[e]=t[e]*n[e]+s[e];r.set(e.get(...a),...t)}return r}const FU={kernelName:"StridedSlice",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s;dz(r,"stridedSlice");const{nonStrided:f,$begin:m,$strides:g,size:y,newShape:b,outShape:x}=l.sliceInfo(r.shape,i,a,o,u,c,h,d,p),v=Hz({inputs:{x:r},backend:n,attrs:{shape:b}});let w;if(f){const t=_B({inputs:{x:v},backend:n,attrs:{begin:m,size:y}});w=Hz({inputs:{x:t},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(t)}else if(x.some(t=>0===t))w=n.makeTensorInfo(x,r.dtype,[]);else{const t=$U(x,n.bufferSync(v),g,m);w=n.makeTensorInfo(t.shape,t.dtype,t.values)}const _=Hz({inputs:{x:w},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),_}},DU={kernelName:"Tan",backendName:"cpu",kernelFunc:mz("Tan",t=>Math.tan(t))},OU=mz("Tanh",t=>Math.tanh(t));function LU(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=CC(n,t.dtype);for(let r=0;r<s.values.length;++r){const e=s.indexToLoc(r),n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=e[s]%t.shape[s];const i=t.locToIndex(n);s.values[r]=t.values[i]}return s}function MU(t,e,n,r,i){const a=e[e.length-1],[o,l]=[t.length/a,a],u=s.getTypedArrayFromDType(n,o*r),c=s.getTypedArrayFromDType("int32",o*r);for(let s=0;s<o;s++){const e=s*l,n=t.subarray(e,e+l),i=[];for(let t=0;t<n.length;t++)i.push({value:n[t],index:t});i.sort((t,e)=>e.value-t.value);const a=s*r,o=u.subarray(a,a+r),h=c.subarray(a,a+r);for(let t=0;t<r;t++)o[t]=i[t].value,h[t]=i[t].index}const h=e.slice();return h[h.length-1]=r,[CC(h,n,u),CC(h,"int32",c)]}function PU(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return s.clamp(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;return n<0?e<=1?n=0:n+=e*(Math.trunc(-n/(e-1))+1):n>e-1&&(e<=1?n=0:n-=e*Math.trunc(n/(e-1))),s.clamp(0,n,e-1)}(t,e);case"nearest":return function(t,e){return s.clamp(0,t,e-1)}(t,e);case"constant":default:return function(t,e){return t}(t)}}function zU(t,e,n,s,r,i,a,o,l,u,c){return 0<=o&&o<e&&0<=l&&l<n?t[a*s+o*r+l*i+u]:c}function BU(t,e,n,s,r,i,a,o,l,u,c){return zU(t,e,n,s,r,i,a,Math.round(o),Math.round(l),u,c)}function VU(t,e,n,s,r,i,a,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*zU(t,e,n,s,r,i,a,h,d,u,c)+(l-d)*zU(t,e,n,s,r,i,a,h,f,u,c))+(o-h)*((f-l)*zU(t,e,n,s,r,i,a,p,d,u,c)+(l-d)*zU(t,e,n,s,r,i,a,p,f,u,c))}function WU(t,e,n,r){const i=s.parseAxisParam(e,n)[0],a=[1,n[0],1];for(let s=0;s<i;s++)a[0]*=n[s];a[1]=n[i];for(let s=i+1;s<n.length;s++)a[2]*=n[s];const o={},l=new Int32Array(n[i]),u=new eS(a,r,t),c=[],h=1===a[0]&&1===a[2];for(let s=0;s<n[i];s++){let e;if(h)e=t[s].toString();else{const t=[];for(let e=0;e<a[0];e++)for(let n=0;n<a[2];n++)t.push(u.get(e,s,n));e=t.join(",")}if(void 0!==o[e])l[s]=o[e];else{const t=Object.keys(o).length;o[e]=t,l[s]=t,c.push(s)}}const d=a.slice();d[1]=Object.keys(o).length;const p=new eS(d,r);c.forEach((t,e)=>{for(let n=0;n<a[0];n++)for(let s=0;s<a[2];s++)p.set(u.get(n,t,s),n,e,s)});const f=n.slice();return f[i]=d[1],{outputValues:p.values,outputShape:f,indices:l}}const UU=[Xz,Yz,Zz,Jz,jz,tB,rB,iB,aB,oB,lB,uB,cB,hB,dB,gB,yB,bB,xB,Kz,vB,SB,NB,Pz,AB,RB,Fz,$B,MB,BB,VB,zB,UB,jB,WB,HB,GB,qB,KB,XB,QB,ZB,JB,tV,eV,nV,rV,sV,NV,bz,iV,oV,fV,yV,xV,wV,OV,MV,PV,BV,VV,WV,UV,jV,GV,KV,XV,vz,QV,OB,YV,ZV,JV,_z,eW,nW,rW,aW,oW,lW,uW,cW,hW,dW,yW,bW,xW,vW,wW,_W,mW,CW,IW,EW,TW,AW,FW,CV,OW,MW,zW,VW,UW,jW,qW,XW,QW,YW,Iz,JW,eU,Lz,nU,Ez,Az,Gz,sU,rU,iU,aU,oU,lU,uU,hU,pU,fU,yU,bU,xU,vU,wU,kB,$W,kU,SU,CU,IU,NU,EU,AU,RU,FU,RV,SW,DU,{kernelName:"Tanh",backendName:"cpu",kernelFunc:OU},{kernelName:"Tile",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;dz(r,"tile");const a=LU(n.bufferSync(r),i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:"TopK",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i}=s;dz(r,"topk");const a=n.data.get(r.dataId).values,[o,l]=MU(a,r.shape,r.dtype,i);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},sB,{kernelName:"Transform",backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:i,transforms:a}=e,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=n,[h,d,p,f]=i.shape,[m,g]=null!=c?c:[d,p],y=[h,m,g,f],b=s.computeStrides(i.shape),x=b[0],v=b[1],w=b[2],_=s.getTypedArrayFromDType(i.dtype,s.sizeFromShape(y));_.fill(u);const k=r.data.get(i.dataId).values,S=r.data.get(a.dataId).values;for(let s=0;s<h;++s){const t=1===a.shape[0]?S:S.subarray(8*s,8*s+8);for(let e=0;e<m;++e)for(let n=0;n<g;++n)for(let r=0;r<f;++r){let i;const a=t[6]*n+t[7]*e+1;if(0===a)continue;const c=(t[3]*n+t[4]*e+t[5])/a,h=PU((t[0]*n+t[1]*e+t[2])/a,p,l),f=PU(c,d,l);switch(o){case"nearest":i=BU(k,d,p,x,v,w,s,f,h,r,u);break;case"bilinear":i=VU(k,d,p,x,v,w,s,f,h,r,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}_[s*x+e*v+n*w+r]=i}return r.makeTensorInfo(y,i.dtype,_)}return{dataId:r.write(_,y,i.dtype),shape:i.shape,dtype:i.dtype}}},{kernelName:"Unique",backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;dz(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=WU(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}},{kernelName:"Unpack",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],l=new Array(a-1);let u=0;for(let p=0;p<a;p++)p!==i&&(l[u++]=r.shape[p]);const c=new Array(a).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[i]=p;const t=_B({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[p]=Hz({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},{kernelName:"UnsortedSegmentSum",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:a}=e,{numSegments:o}=r;dz(i,"unsortedSegmentSum");const l=[],u=[],c=i.shape.length-a.shape.length;let h=a;for(let s=0;s<c;++s){const t=bV({inputs:{input:h},backend:n,attrs:{dim:s+1}});h=t,u.push(t)}for(let p=0;p<o;++p){const t=s.createScalarValue(p,"int32"),e=n.makeTensorInfo([],"int32",t),r=aV({inputs:{a:e,b:h},backend:n}),a=Mz({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),o=SV({inputs:{a,b:i},backend:n}),c=kW({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});l.push(c),u.push(e),u.push(r),u.push(a),u.push(o),u.push(c)}const d=KW({inputs:l,backend:n,attrs:{axis:0}});return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}},GW];for(const pY of UU)Pk(pY);const jU={},HU={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function GU(t){if(!(t in jU)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete jU[t]},!1),1===t?e.getContext("webgl",HU)||e.getContext("experimental-webgl",HU):e.getContext("webgl2",HU)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;jU[t]=e}const e=jU[t];return e.isContextLost()?(delete jU[t],GU(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),jU[t])}var qU,KU,XU;function QU(t,e){return[e,t]}function YU(t){const e=s.sizeFromShape(t),n=Math.ceil(e/4);return s.sizeToSquarishShape(n)}function ZU(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function JU(t,e){const n=t;let s,r,i,a,o,l,u,c,h,d;return 2===Ek().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,i=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(s=t.RGBA,r=t.RGBA,i=t.RGBA,a=n.RGBA,o=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function tj(t,e){const n=e();return Ek().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function ej(t){return!!(Ek().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function nj(t,e){return uj(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(qU||(qU={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(KU||(KU={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(XU||(XU={}));const sj=/ERROR: [0-9]+:([0-9]+):/g;function rj(t,e){if(tj(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function ij(t,e,n,s,r,i,a){const o=t.getAttribLocation(e,n);return-1!==o&&(tj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),tj(t,()=>t.vertexAttribPointer(o,r,t.FLOAT,!1,i,a)),tj(t,()=>t.enableVertexAttribArray(o)),!0)}function aj(t,e,n){tj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),tj(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function oj(t,e){tj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),tj(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function lj(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function uj(t,e,n){const s=tj(t,()=>e());if(null==s)throw new Error(n);return s}function cj(t,e=2){return s.sizeFromShape(t.slice(0,t.length-e))}function hj(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function dj(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[cj(t),...hj(t)]),e}function pj(t){return t%2==0}function fj(t,e){if(t=t.slice(-2),e=e.slice(-2),s.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],s=e.slice(-1)[0];if(n===s)return!0;if(pj(n)&&pj(s)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&pj(t[0])&&pj(e[0])}let mj,gj;function yj(t,e){return null!=t.getExtension(e)}function bj(t){try{if(null!=GU(t))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function xj(t){const e=JU(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const r=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(s),r}function vj(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&s.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const wj=Ek();function _j(){let t,e,n,s,r,i,a,o,l,u;return 2===Ek().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function kj(t,e,n="index"){const r=s.computeStrides(e);return r.map((e,s)=>`int ${t[s]} = ${n} / ${e}; ${s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${e}`:`index -= ${t[s]} * ${e}`};`).join("")}function Sj(t){const e=s.computeStrides(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}wj.registerFlag("HAS_WEBGL",()=>wj.getNumber("WEBGL_VERSION")>0),wj.registerFlag("WEBGL_VERSION",()=>bj(2)?2:bj(1)?1:0),wj.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),wj.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===wj.get("WEBGL_VERSION")),wj.registerFlag("WEBGL_CPU_FORWARD",()=>!0),wj.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),wj.registerFlag("WEBGL_PACK",()=>wj.getBool("HAS_WEBGL")),wj.registerFlag("WEBGL_PACK_NORMALIZATION",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_PACK_CLIP",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),wj.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_PACK_REDUCE",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_LAZILY_UNPACK",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_CONV_IM2COL",()=>wj.getBool("WEBGL_PACK")),wj.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==mj){const e=GU(t);mj=e.getParameter(e.MAX_TEXTURE_SIZE)}return mj}(wj.getNumber("WEBGL_VERSION"))),wj.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==gj){const e=GU(t);gj=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,gj)}(wj.getNumber("WEBGL_VERSION"))),wj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=wj.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=GU(t);return e=yj(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:yj(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),wj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>wj.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.isMobile()),wj.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=GU(t);if(1===t){if(!yj(e,"OES_texture_float"))return!1}else if(!yj(e,"EXT_color_buffer_float"))return!1;return xj(e)}(wj.getNumber("WEBGL_VERSION"))),wj.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!wj.getBool("WEBGL_FORCE_F16_TEXTURES")&&wj.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),wj.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=GU(t);if(1!==t){if(yj(e,"EXT_color_buffer_float"))return xj(e);const t="EXT_color_buffer_half_float";if(yj(e,t)){const n=e.getExtension(t);return function(t,e){const n=JU(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(r),i}(e,n)}return!1}return!!yj(e,"OES_texture_float")&&!!yj(e,"WEBGL_color_buffer_float")&&xj(e)}(wj.getNumber("WEBGL_VERSION"))),wj.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=wj.getNumber("WEBGL_VERSION"))&&null!=GU(t).fenceSync;var t}),wj.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>wj.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),wj.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),wj.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>i.isMobile()&&wj.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});const Cj="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class Ij{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=qU.DENSE;const e=YU(t),n=_j();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${kj(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Nj{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=qU.DENSE;const e=YU(t),n=_j();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${kj(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Ej{constructor(t){this.variableNames=["A"],this.outTexUsage=KU.DOWNLOAD;const e=_j();this.outputShape=t,this.userCode=`\n      ${Cj}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Tj{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=KU.DOWNLOAD;const e=_j();this.outputShape=t,this.userCode=`\n      ${Cj}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class Aj{constructor(t,e,n=!1){this.variableNames=["A"];const s=_j(),[r,i]=e;this.outputShape=t;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Sj(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class Rj{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=_j(),[r,i]=e;this.outputShape=t;let a="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Sj(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${s.output} = ${o};\n      }\n    `}}function $j(t,e,n,s,r,i){!function(t,e){const n=Ek().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const a=function(t){return uj(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),o=t.TEXTURE_2D;return tj(t,()=>t.bindTexture(o,a)),tj(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),tj(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),tj(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),tj(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),tj(t,()=>t.texImage2D(o,0,s,e,n,0,r,i,null)),tj(t,()=>t.bindTexture(t.TEXTURE_2D,null)),a}function Fj(t){return t.internalFormatFloat}function Dj(t){return t.internalFormatHalfFloat}function Oj(t){return t.downloadTextureFormat}function Lj(t){return t.internalFormatPackedFloat}function Mj(t){return t.internalFormatPackedHalfFloat}class Pj{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Ek().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){jU[t]=e}(e,t)):this.gl=GU(e);let n="WEBGL_color_buffer_float";if(1===Ek().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=nj(this.gl,"OES_texture_float"),yj(this.gl,t))this.textureHalfFloatExtension=nj(this.gl,t);else if(Ek().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),yj(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=nj(this.gl,"EXT_color_buffer_half_float");else if(Ek().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",yj(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!yj(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=function(t){return function(t,e){const n=uj(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return tj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),tj(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=uj(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return tj(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),tj(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return uj(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=JU(this.gl,this.textureHalfFloatExtension)}get debug(){return Ek().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;tj(t,()=>t.finish()),tj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),tj(t,()=>t.deleteFramebuffer(this.framebuffer)),tj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),tj(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),tj(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=QU(e,n);return $j(t,r,i,Fj(s),s.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=QU(e,n);return $j(t,r,i,Dj(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=QU(e,n);return $j(t,r,i,Oj(s),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){tj(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?tj(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):tj(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),tj(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,s){this.throwIfDisposed(),function(t,e,n,s,r,i){let a,o,l;tj(t,()=>t.bindTexture(t.TEXTURE_2D,e)),r instanceof Uint8Array?(a=new Uint8Array(n*s*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*s*4),o=t.FLOAT,l=i.internalFormatPackedFloat),a.set(r),tj(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,o,a)),tj(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=ZU(e,n);return $j(t,r,i,Mj(s),t.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=ZU(e,n);return $j(t,r,i,Lj(s),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(oj(this.gl,this.framebuffer),this.outputTexture=null),tj(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,s){const[r,i]=QU(e,n),a=new Uint8Array(e*n*4);return tj(t,()=>t.readPixels(0,0,r,i,s.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,s,r,i){return function(t,e,n,s,r,i,a,o){const l=t,u=new Float32Array(function(t,e){const[n,s]=ZU(t,e);return n*s*4}(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,r,i)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const s=function(t,e,n,s){const r=t.createBuffer();tj(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const i=16*e*n;return tj(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),tj(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),tj(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Ek().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=s.clientWaitSync(r,0,0);return t===s.ALREADY_SIGNALED||t===s.CONDITION_SATISFIED},e=r}else Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const s=new Float32Array(e*n*4);return tj(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=uj(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(tj(t,()=>t.shaderSource(n,e)),tj(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=sj.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],i=t.split("\n"),a=i.length.toString().length+2,o=i.map((t,e)=>s.rightPad((e+1).toString(),a)+t);let l=0;for(let s=0;s<o.length;s++)l=Math.max(o[s].length,l);const u=o.slice(0,r-1),c=o.slice(r-1,r),h=o.slice(r);console.log(u.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${s.rightPad(c[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t),r=function(t){const e=_j();return function(t,e){const n=uj(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(tj(t,()=>t.shaderSource(n,e)),tj(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),i=function(t){return uj(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return tj(e,()=>e.attachShader(i,r)),tj(e,()=>e.attachShader(i,n)),function(t,e){if(tj(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,i),this.debug&&rj(e,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=function(t,e,n){return tj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),ij(t,e,"clipSpacePos",n,3,20,0)&&ij(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&tj(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&rj(this.gl,this.program),tj(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return uj(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),tj(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,s){tj(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),tj(t,()=>t.activeTexture(t.TEXTURE0+n)),tj(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,s)),tj(t,()=>t.uniform1i(n,s))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[s,r]=ZU(e,n);this.setOutputMatrixTextureDriver(t,s,r)}setOutputMatrixWriteRegion(t,e,n,s){this.setOutputMatrixWriteRegionDriver(n,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&rj(this.gl,this.program),lj(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),tj(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),tj(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=nj(this.gl,2===Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await s.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||s.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),aj(this.gl,t,this.framebuffer),this.debug&&lj(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(aj(this.gl,this.outputTexture,this.framebuffer),this.debug&&lj(this.gl)):oj(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const s=this.gl;aj(s,t,this.framebuffer),this.debug&&lj(s),this.outputTexture=t,tj(s,()=>s.viewport(0,0,e,n)),tj(s,()=>s.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,s){this.throwIfDisposed(),tj(this.gl,()=>this.gl.scissor(t,e,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:zj}=d;function Bj(t,e,n,r){const i=[];t.forEach(t=>{const e=s.sizeFromShape(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?i.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(i.push(`uniform sampler2D ${t.name};`),i.push(`uniform int offset${t.name};`))});const a=i.join("\n"),o=t.map(t=>function(t,e,n=!1){let r="";return r+=n?Wj(t):Vj(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(r+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,l=zj(t.shapeInfo.logicalShape,e.logicalShape),u=Xj(o),c=o-a;let h;const d=["x","y","z","w","u","v"];h=0===a?"":o<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";p=o<2&&a>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+c]}`).join(", ");let f="return outputValue;";const m=1===s.sizeFromShape(t.shapeInfo.logicalShape),g=1===s.sizeFromShape(e.logicalShape);if(1!==a||m||g){if(m&&!g)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const t=a-2,e=a-1;l.indexOf(t)>-1&&l.indexOf(e)>-1?f="return vec4(outputValue.x);":l.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${r}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,o=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===o&&null==t.shapeInfo.flatOffset&&s.arraysEqual(t.shapeInfo.texShape,e.texShape))return`\n      float ${i}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=Xj(o),u=zj(t.shapeInfo.logicalShape,e.logicalShape),c=o-a;let h;const d=["x","y","z","w","u","v"];h=0===a?"":o<2&&u.length>=1?"coords = 0;":u.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";return p=o<2&&a>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+c]}`).join(", "),`\n    float ${i}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(t,e)),r}(t,e,r)).join("\n"),l=e.texShape,u=_j(),c=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let h,d,p=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Uj}\n    ${jj}\n    ${Hj}\n  `}(u);return e.isPacked?(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(s.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),r=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),r=s*Math.ceil(t[t.length-2]/2);let i=r,a="",o="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],a=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+a,o=`b${l}, `+o;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${o});\n    }\n  `}(t,e)}}(e.logicalShape,l),d=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(u)):(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return s.arraysEqual(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=kj(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=kj(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=kj(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=kj(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}var n}(e.logicalShape,l),d=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(p+=Gj),[p,c,d,a,h,o,n].join("\n")}function Vj(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[s,r]=t.shapeInfo.texShape;if(1===s&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[i,a]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${a}, ${qj(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Kj(t)}\n      }\n    `;const s=t.shapeInfo.texShape,r=s[0],i=s[1];if(1===i&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=qj(e);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape;if(null!=i&&s.arraysEqual(e,i))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:a,keptDims:o}=s.squeezeShape(e);if(a.length<e.length){const e=["row","col"];return`\n      ${Vj(Qj(t,a))}\n      float ${r}(int row, int col) {\n        return ${r}(${Yj(e,o)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Kj(t)}\n      }\n    `;const l=i[0],u=i[1],c=qj(n);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[1]*e[2],a=e[2],{newShape:o,keptDims:l}=s.squeezeShape(e);if(o.length<e.length){const e=["row","col","depth"];return`\n        ${Vj(Qj(t,o))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Yj(e,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${a}, 1)));\n        ${Kj(t)}\n      }\n    `;const u=t.shapeInfo.texShape,c=u[0],h=u[1],d=t.shapeInfo.flatOffset;return h===i&&null==d?`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${c}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:h===a&&null==d?`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${a} + depth + ${qj(n)};\n        vec2 uv = uvFromFlat(${c}, ${h}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[3],a=e[2]*i,o=e[1]*a,{newShape:l,keptDims:u}=s.squeezeShape(e);if(l.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${Vj(Qj(t,l))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Yj(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${i}, 1)));\n        ${Kj(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===i&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${qj(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[4],a=e[3]*i,o=e[2]*a,l=e[1]*o,{newShape:u,keptDims:c}=s.squeezeShape(e);if(u.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${Vj(Qj(t,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Yj(e,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${o}, ${a}, ${i})) +\n          depth3;\n        ${Kj(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];return f===l&&null==h?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===i&&null==h?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${o} + depth * ${a} +\n          depth2 * ${i} + depth3 + ${qj(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:a}=s.squeezeShape(e);if(i.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Vj(Qj(t,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Yj(e,a)});\n      }\n    `}const o=e[5],l=e[4]*o,u=e[3]*l,c=e[2]*u,h=e[1]*c;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${c}, ${u}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Kj(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],m=p[1];return m===h&&null==d?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:m===o&&null==d?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${c} + depth * ${u} +\n          depth2 * ${l} + depth3 * ${o} + depth4 + ${qj(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function Wj(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${_j().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=_j();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,a=i[0],o=i[1],l=_j();if(null!=i&&s.arraysEqual(e,i))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===e[0]){const n=[1,2],r=["b","row","col"];return`\n        ${Wj(Qj(t,e.slice(1)))}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Yj(r,n)});\n        }\n      `}const a=i[0],o=i[1],l=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${o}, ${l*Math.ceil(e[1]/2)}, ${l}, b, row, col);\n      return ${_j().texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],o=a[0],l=a[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=e[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${r}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${o});\n      return ${_j().texture2D}(${s}, uv);\n    }\n  `}(t)}}const Uj="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",jj="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Hj="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Gj="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function qj(t){return`offset${t}`}function Kj(t){const e=t.name,n=s.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function Xj(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Qj(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Yj(t,e){return e.map(e=>t[e]).join(", ")}function Zj(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const r=t.logicalShape,i=e[n],a=i.shape;if(!s.arraysEqual(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const o=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!s.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}const{addImpl:Jj,bincountImpl:tH,bincountReduceImpl:eH,ceilImpl:nH,concatImpl:sH,expImpl:rH,expm1Impl:iH,floorImpl:aH,gatherV2Impl:oH,greaterImpl:lH,lessImpl:uH,linSpaceImpl:cH,logImpl:hH,maxImpl:dH,maximumImpl:pH,minimumImpl:fH,multiplyImpl:mH,negImpl:gH,prodImpl:yH,rangeImpl:bH,rsqrtImpl:xH,simpleAbsImpl:vH,sliceImpl:wH,stridedSliceImpl:_H,subImpl:kH,tileImpl:SH,topKImpl:CH,transposeImpl:IH,uniqueImpl:NH}=R;function EH(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function TH(t,e){return 1===e?[t]:EH(t,e)}class AH{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=TH("rc",e),s=Xj(e),r=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let s="";for(let r=t-2;r<t;r++)s+=`${n[r]} >= ${e[r]}`,r<t-1&&(s+="||");return s}(e,t,n),i=function(t,e,n,s){if(1===t)return"";const r=s.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),a=function(t,e){const n=t.length,s=function(t,e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<t;n++)i=`${e[e.length-1-n]},`+i;n.push(i)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${s[0]}),\n          cEdge ? 0. : getA(${s[1]}),\n          rEdge ? 0. : getA(${s[2]}),\n          rEdge || cEdge ? 0. : getA(${s[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class RH{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2==1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var s;this.userCode=`\n      ${s=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${kj(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Sj(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class $H{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const s=DH(e,n),r=OH(t,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const i=FH(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const t=this.freeTextures[r].shift();return this.usedTextures[r].push(t),t}let a;return s===XU.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===XU.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===XU.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===XU.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===XU.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,s){if(null==this.freeTextures)return;const r=DH(n,s),i=OH(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=FH(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),o=Ek().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function FH(t,e,n,s,r){const i=function(t,e){switch(t){case XU.PACKED_2X2_FLOAT32:return Lj(e);case XU.PACKED_2X2_FLOAT16:return Mj(e);case XU.UNPACKED_FLOAT32:return Fj(e);case XU.UNPACKED_FLOAT16:return Dj(e);case XU.PACKED_4X1_UNSIGNED_BYTE:return Oj(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,s);let a;if(r){const[e,n]=ZU(t[0],t[1]);a=e*n}else{const[e,n]=QU(t[0],t[1]);a=e*n}return a*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,i)}function DH(t,e){if(t===KU.UPLOAD)return XU.PACKED_2X2_FLOAT32;if(t===KU.RENDER||null==t)return function(t){return Ek().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?XU.PACKED_2X2_FLOAT32:XU.UNPACKED_FLOAT32:t?XU.PACKED_2X2_FLOAT16:XU.UNPACKED_FLOAT16}(e);if(t===KU.DOWNLOAD||t===KU.PIXELS)return XU.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function OH(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class LH{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const MH="return abs(x);",PH="return x;";class zH{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class BH{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=TH("rc",e),s=Xj(e),r=function(t,e){if(1===t)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const VH=p.whereImpl,WH={};class UH extends $_{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!Ek().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=GU(Ek().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Ek().getNumber("WEBGL_VERSION"))in WH||(WH[e]={}),WH[e]),this.gpgpu=new Pj(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new $H(this.gpgpu),this.numMBBeforeWarning=null==Ek().global.screen?1024:Ek().global.screen.height*Ek().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new R_(this,mI())}nextDataId(){return UH.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((Ek().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ek().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:e,dtype:n,values:t,usage:KU.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,s,r){if(Ek().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:s,values:e,usage:KU.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:l}=e;if(null!=a){let e;e=l?new zH(o,PH):new LH(o,PH);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const u=null!=this.activeTimers;let c,h;if(u&&(c=s.now()),"complex64"===r){const t=this.readSync(i.real.dataId),e=this.readSync(i.imag.dataId);h=d.mergeRealAndImagArrays(t,e)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=s.now()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:l}=e;if(null!=i){let e;e=l?new zH(r,PH):new LH(r,PH);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(t);if(!Ek().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ek().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==a&&Ek().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const e=this.texData.get(u.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...YU(r))}if(this.pendingRead.set(t,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);c=d.mergeRealAndImagArrays(t[0],t[1])}else if(null==h)c=this.getValuesFromTexture(t);else{const t=s.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=u&&this.disposeIntermediateTensorInfo(u);const p=this.convertAndCacheOnCPU(t,c),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(t=>t(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&mI().removeDataId(t,this),this.pendingDeletes--),p}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>s.decodeString(t))}catch(hY){throw new Error("Failed to decode encoded string bytes into utf-8")}return CC(t.shape,t.dtype,n)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!ej(n)){if(Ek().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),i=s.sizeFromShape(e);if(Ek().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),s=this.texData.get(n.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(s.texture,...YU(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),r}const a=Ek().getBool("WEBGL_PACK")&&!0===r,o=a?dj(e):e,l=a?new Tj(o):new Ej(o),u=this.runWebGLProgram(l,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const i=s.flatten(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),a=s.flatten(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(i);o.kernelMs=s.sum(t),o.getExtraProfileInfo=()=>t.map((t,e)=>({name:a[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:s.now(),endMs:null}}endTimer(t){return Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=s.now(),t)}async getQueryTime(t){return Ek().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:s,usage:r,isPacked:i,slice:a}=this.texData.get(t),o=a&&a.origDataId||t,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=e&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(e,s,r,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return Ek().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=mI().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return Ek().getBool("IS_TEST")||this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every(t=>null==this.texData.get(t.dataId).texture&&s.sizeFromShape(t.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){d.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return VH(t.shape,e)}packedUnaryOp(t,e,n){const s=new zH(t.shape,e),r=this.compileAndRun(s,[t],n);return mI().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=vH(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Ek().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,MH,t.dtype);const e=new LH(t.shape,MH),n=this.compileAndRun(e,[t]);return mI().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&s.isString(n[0])){const i=n.map(t=>s.encodeString(t));r=this.write(i,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:s}=this.makeTensorInfo(t,e,n);return mI().makeTensorFromDataId(s,t,e,this)}unpackTensor(t){const e=new BH(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new AH(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[cj(t.shape),...hj(t.shape)],s={dtype:t.dtype,shape:n,dataId:t.dataId},r=[cj(e),...hj(e)],i=new RH(r,n),a=this.runWebGLProgram(i,[s],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:s,dtype:r}=e,i=dj(s);let a;return a=n?new Nj(i):new Ij(i),{dtype:r,shape:s,dataId:this.runWebGLProgram(a,[{shape:i,dtype:r,dataId:t}],r,null,!0).dataId}}runWebGLProgram(t,e,n,r,i=!1){const a=this.makeTensorInfo(t.outputShape,n),o=this.texData.get(a.dataId);if(t.packedOutput&&(o.isPacked=!0),t.outPackingScheme===qU.DENSE){const e=YU(t.outputShape);o.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(o.usage=t.outTexUsage),0===s.sizeFromShape(a.shape))return o.values=s.getTypedArrayFromDType(a.dtype,0),a;const l=[],u=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&s.sizeFromShape(e.shape)<=Ek().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!fj(n.shape,e.shape)){const t=e,s=e.shape;e.shape=n.shape,e=this.packedReshape(e,s),l.push(e),n=this.texData.get(e.dataId),t.shape=s}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:o,isUniform:!1},h=function(t,e,n){let s="";e.concat(n).forEach(t=>{s+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let r=t.constructor.name;return r+="_"+s+"_"+t.userCode,r}(t,u,c),d=this.getAndSaveBinary(h,()=>function(t,e,n,s){const r=e.userCode,i=n.map((t,n)=>{const s={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(s.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:s}}),a=i.map(t=>t.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=Bj(i,o,r,e.packedInputs),u=t.createProgram(l);let c=null;const h=t.getUniformLocation(u,"NAN",!1);1===Ek().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const d={};for(let p=0;p<e.variableNames.length;p++){const n=e.variableNames[p],s=!1;d[n]=t.getUniformLocation(u,n,s),d[`offset${n}`]=t.getUniformLocation(u,`offset${n}`,s)}return{program:e,source:l,webGLProgram:u,uniformLocations:d,inShapeInfos:a,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,t,u,c)),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),function(t,e,n,r,i){Zj(e.inShapeInfos,n),Zj([e.outShapeInfo],[r]);const a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a,o[0],o[1]):t.setOutputMatrixTexture(a,o[0],o[1]),t.setProgram(e.webGLProgram),1===Ek().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,r)=>{const i=e.program.variableNames[r],a=e.uniformLocations[i],o=e.uniformLocations[`offset${i}`];if(null!=a)if(n.isUniform)if(s.sizeFromShape(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=n.texData.slice&&null!=o&&t.gl.uniform1i(o,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)}),null!=i&&i(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach(t=>this.disposeIntermediateTensorInfo(t)),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const m=Ek().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const t=s.now();t-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Ek().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===i){const t=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),t}return a}compileAndRun(t,e,n,s,r=!1){return this.runWebGLProgram(t,e,n=n||e[0].dtype,s,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ek().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=yI(()=>{if(!Ek().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Ek().getBool("DEBUG");Ek().set("DEBUG",!1);const e=this.abs(_I(1e-8)).dataSync()[0];if(Ek().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:i,texture:a,usage:o,isPacked:l}=e;if(null!=a)return;const u=null!=this.activeTimers;let c;u&&(c=s.now());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=Ek().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?s.nearestLargerEven(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=s.squeezeShape(t);t=e.newShape}let r=s.sizeFromShape(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=cj(t);let n=2,i=2;return t.length&&([n,i]=hj(t)),r=e*(n/2)*(i/2),s.sizeToSquarishShape(r).map(t=>2*t)}return s.sizeToSquarishShape(r)}(n,l),e.texShape=h),null!=i){const t=dj(n);let a,o=h[1],d=h[0];const p=i instanceof Uint8Array;l?([o,d]=ZU(h[0],h[1]),a=new Rj(t,[d,o],p)):a=new Aj(t,[d,o],p);const f=this.makeTensorInfo([d,o],r);this.texData.get(f.dataId).usage=p?KU.PIXELS:KU.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,d,i);const m=this.runWebGLProgram(a,[f],r,null,!0),g=this.texData.get(m.dataId);e.texture=g.texture,e.texShape=g.texShape,e.isPacked=g.isPacked,e.usage=g.usage,this.disposeIntermediateTensorInfo(f),this.texData.delete(m.dataId),e.values=null,u&&(this.uploadWaitMs+=s.now()-c)}else{const t=this.acquireTexture(h,o,r,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:s}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,s)),n.values}acquireTexture(t,e,n,s){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,s)}computeBytes(t,e){return t[0]*t[1]*s.bytesPerElement(e)}}UH.nextDataId=0,i.isBrowser()&&vI("webgl",()=>new UH,2);class jH{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=d.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class HH{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d.assertAndGetBroadcastShape(e,n);const i=this.outputShape.length;let a="";if(r)if(0===i||1===s.sizeFromShape(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${Xj(i)} coords = getOutputCoords();\n        `,1===i)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=TH("coords",i);a+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function GH(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const qH={kernelName:"Identity",backendName:"webgl",kernelFunc:GH};function KH(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.makeTensorInfo(s.shape,"complex64"),a=n.texData.get(i.dataId),o=GH({inputs:{x:s},backend:n}),l=GH({inputs:{x:r},backend:n});return a.complexTensorInfos={real:o,imag:l},i}const XH={kernelName:"Complex",backendName:"webgl",kernelFunc:KH},QH="return (a < 0.) ? b * a : a;",YH="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ZH={kernelName:"LeakyRelu",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:a}=r,o=n.makeTensorInfo([],"float32",s.createScalarValue(a,"float32")),l=Ek().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HH(YH,i.shape,o.shape):new jH(QH,i.shape,o.shape),u=n.runWebGLProgram(l,[i,o],i.dtype);return n.disposeIntermediateTensorInfo(o),u}},JH="return (a < 0.) ? b * a : a;",tG="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",eG={kernelName:"Prelu",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,i=Ek().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HH(tG,s.shape,r.shape):new jH(JH,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}};function nG({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const t=o.texData.get(a.dataId),e=n(t.values,l);return o.makeTensorInfo(a.shape,l,e)}let u;return u=Ek().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new zH(a.shape,e):new LH(a.shape,t),o.runWebGLProgram(u,[a],l)}}function sG({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:l,b:u}=a,c=o;if(s&&"complex64"===l.dtype){const e=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[s,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,s]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:s.dataId,dtype:s.dtype,shape:u.shape},a=new jH(t,l.shape,u.shape);return c.runWebGLProgram(a,[r,i],fS(n.dtype,s.dtype))}),i=KH({inputs:{real:s,imag:r},backend:c});return c.disposeIntermediateTensorInfo(s),c.disposeIntermediateTensorInfo(r),i}const h=i||fS(l.dtype,u.dtype);if(c.shouldExecuteOnCPU([l,u])&&null!=r){const t=c.texData.get(l.dataId),e=c.texData.get(u.dataId),[n,s]=r(l.shape,u.shape,t.values,e.values,h),i=c.makeTensorInfo(s,h);return c.texData.get(i.dataId).values=n,i}let d;return d=Ek().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new HH(e,l.shape,u.shape,n):new jH(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function rG(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return e?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return e?tG:JH;if("leakyrelu"===t)return e?YH:QH;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class iG{constructor(t,e,n,s=!1,r=!1,i=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=Math.ceil((s?t[1]:t[2])/2),c=s?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";a&&(f=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,m="result = activation(result);");const g=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",b="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(b=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          int batchA = ${y};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class aG{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=d.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const oG="return a * b;";function lG(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,i=d.upcastType(s.dtype,r.dtype);if("complex64"===s.dtype){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),i=new aG("return areal * breal - aimag * bimag;",s.shape,r.shape),a=new aG("return areal * bimag + aimag * breal;",s.shape,r.shape),o=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(i,o,"float32"),u=n.runWebGLProgram(a,o,"float32"),c=KH({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([s,r])){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),[a,o]=mH(s.shape,r.shape,t.values,e.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=a,l}let a;return a=Ek().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HH(oG,s.shape,r.shape):new jH(oG,s.shape,r.shape),n.runWebGLProgram(a,[s,r],i)}const uG={kernelName:"Multiply",backendName:"webgl",kernelFunc:lG};function cG(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:a}=r,o=n,l=s.sizeFromShape(i.shape),u=s.inferFromImplicitShape(a,l),c=s.sizeFromShape(u);s.assert(l===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${i.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(i.dataId);return!h.isPacked||fj(i.shape,u)||null!==h.texture&&fj(h.shape,u)?(o.incRef(i.dataId),{dataId:i.dataId,shape:u,dtype:i.dtype}):function(t,e,n){const s=[cj(t.shape),...hj(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[cj(e),...hj(e)],a=new RH(i,s),o=n.runWebGLProgram(a,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}(i,u,o)}const hG={kernelName:"Reshape",backendName:"webgl",kernelFunc:cG};class dG{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:a}=t;this.outputShape=[r,a];const o=4*Math.floor(n/4),l=n%4;let u="sumValue += dot(values, ones);";if(null!=e){const t=1/e;u=`sumValue += dot(values * ${s.isInt(t)?t.toPrecision(2):t}, ones);`}let c="";i%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class pG{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=t;this.outputShape=[s,i];let a="0.0",o="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",o="min"):"max"===e&&(a="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function fG(t,e,n,s){const r=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],s=d.computeOptimalWindowSize(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}(t.shape);let i=t;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:l,outSize:u}=r[a];let c,h;c="mean"===n?0===a?new dG({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new dG({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):new pG({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),h=i,i=s.runWebGLProgram(c,[i],e),h.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(h)}return i}class mG{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const s=Xj(this.rank),r=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class gG{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Xj(this.rank),r=EH("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=r[u];const a=`vec2(${i.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function yG(t,e,n){const s=Ek().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gG(t.shape,e):new mG(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}function bG(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;return function(t,e,n,r){const i=t.shape.length,a=s.parseAxisParam(e,t.shape);let o=a;const l=d.getAxesPermutation(o,i),u=null!=l;let c=t;u&&(c=yG(t,l,r),o=d.getInnerMostAxes(o.length,i)),d.assertAxesAreInnerMostDims("sum",o,i);const[h,p]=d.computeOutAndReduceShapes(c.shape,o);let f=h;n&&(f=d.expandShapeToKeepDim(h,a));const m=s.sizeFromShape(p),g=cG({inputs:{x:c},attrs:{shape:[s.sizeFromShape(t.shape)/m,m]},backend:r}),y=fG(g,mS(t.dtype),"sum",r),b=cG({inputs:{x:y},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(y),u&&r.disposeIntermediateTensorInfo(c),b}(i,a,o,n)}const xG={kernelName:"Sum",backendName:"webgl",kernelFunc:bG};function vG(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:i}=s,a=n,o=new Array(r.shape.length);for(let u=0;u<o.length;u++)o[u]=r.shape[i[u]];let l;if(a.shouldExecuteOnCPU([r])){const t=a.texData.get(r.dataId),e=IH(t.values,r.shape,r.dtype,i,o);l=a.makeTensorInfo(o,r.dtype),a.texData.get(l.dataId).values=e}else l=yG(r,i,a);return l}const wG={kernelName:"Transpose",backendName:"webgl",kernelFunc:vG};function _G({a:t,b:e,transposeA:n,transposeB:r,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}){const c=t.shape.length,h=e.shape.length,d=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[h-1]:e.shape[h-2],f=n?t.shape[c-1]:t.shape[c-2],m=r?e.shape[h-2]:e.shape[h-1],g=t.shape.slice(0,-2),y=e.shape.slice(0,-2),b=s.sizeFromShape(g),x=s.sizeFromShape(y);s.assert(c>=2&&h>=2&&(b===x||1===b||1===x),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${g}) and (${y}).`);const v=(b>x?t.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,m]);s.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[b,d,f]:[b,f,d],_=r?[x,m,p]:[x,p,m],k=cG({inputs:{x:t},backend:i,attrs:{shape:w}}),S=cG({inputs:{x:e},backend:i,attrs:{shape:_}}),C=[k,S],I=Math.max(b,x),N=n?k.shape[1]:k.shape[2],E=null!=a,T=null!=o,A="leakyrelu"===u,R=null!=u?rG(u,!0):null;let $;if((1===f||1===m)&&N>1e3&&!1===(E||T||A||null!=R)){let t=k,e=S;n&&(t=vG({inputs:{x:k},backend:i,attrs:{perm:[0,2,1]}}),C.push(t)),r&&(e=vG({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),C.push(e));const s=1===m;let a=t;1!==m&&(a=cG({inputs:{x:t},backend:i,attrs:{shape:[I,N,1]}}),C.push(a));const o=1===m?2:1;let l=e;s&&(l=cG({inputs:{x:e},backend:i,attrs:{shape:[I,1,N]}}),C.push(l));const u=lG({inputs:{a,b:l},backend:i});$=bG({inputs:{x:u},backend:i,attrs:{axis:o,keepDims:!0}}),C.push(u)}else{const u=fS(t.dtype,e.dtype),c=new iG(w,_,[I,f,m],n,r,E,R,T,A),h=[k,S];if(null!=a&&h.push(a),T&&h.push(o),A){const t=i.makeTensorInfo([],"float32",s.createScalarValue(l,"float32"));h.push(t),C.push(t)}$=i.runWebGLProgram(c,h,u)}const F=cG({inputs:{x:$},backend:i,attrs:{shape:v}});C.push($);for(const s of C)i.disposeIntermediateTensorInfo(s);return F}const kG={kernelName:"_FusedMatMul",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return _G({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},SG={kernelName:"Abs",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const t=n.texData.get(s.dataId),e=vH(t.values);return n.makeTensorInfo(s.shape,s.dtype,e)}let r;return r=Ek().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new zH(s.shape,"return abs(x);"):new LH(s.shape,"return abs(x);"),n.runWebGLProgram(r,[s],s.dtype)}},CG={kernelName:"Acos",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"})},IG={kernelName:"Acosh",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"})},NG="return a + b;",EG={kernelName:"Add",backendName:"webgl",kernelFunc:sG({opSnippet:NG,packedOpSnippet:NG,supportsComplex:!0,cpuKernelImpl:Jj})};class TG{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class AG{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const RG={kernelName:"AddN",backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,r=n;if(1===r.length)return GH({inputs:{x:r[0]},backend:s});if(r.length>Ek().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),n=t({inputs:r.slice(0,e),backend:s}),i=t({inputs:r.slice(e),backend:s});return t({inputs:[n,i],backend:s})}const i=r.map(t=>t.dtype).reduce((t,e)=>fS(t,e)),a=r.map(t=>t.shape),o=Ek().getBool("WEBGL_PACK")?new AG(r[0].shape,a):new TG(r[0].shape,a);return s.runWebGLProgram(o,r,i)}},$G={kernelName:"All",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l);let p=i;null!=h&&(p=vG({inputs:{x:i},backend:n,attrs:{perm:h}}),c=d.getInnerMostAxes(c.length,l)),d.assertAxesAreInnerMostDims("all",c,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,c),g=cG({inputs:{x:p},backend:n,attrs:{shape:[-1,s.sizeFromShape(m)]}}),y=fG(g,g.dtype,"all",n);let b;return b=cG(o?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,u)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),b}},FG={kernelName:"Any",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l);let p=i;null!=h&&(p=vG({inputs:{x:i},backend:n,attrs:{perm:h}}),c=d.getInnerMostAxes(c.length,l)),d.assertAxesAreInnerMostDims("any",c,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,c),g=cG({inputs:{x:p},backend:n,attrs:{shape:[-1,s.sizeFromShape(m)]}}),y=fG(g,g.dtype,"any",n);let b;return b=cG(o?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,u)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),b}};class DG{constructor(t,e,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class OG{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,s.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,l=Xj(o),u=TH("coords",o);let c,h;if(1===i){h=o+1;const t=Xj(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[o-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),m=TH("sourceLocR",h-1).concat("inIdx.r"),g=TH("sourceLocG",h-1).concat("inIdx.g"),y=TH("sourceLocB",h-1).concat("inIdx.b"),b=TH("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,_=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function LG(t,e,n,s=null){let r=e.shape[0],i=e.shape[1];null!=s&&(r=s.shape[0],i=s.shape[1]);const a=d.computeOptimalWindowSize(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},l=new DG(o,n,null==s),u=[e];null!=s&&u.push(s);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=LG(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function MG(t,e,n,s=null){const r=null!=s?s.shape:e.shape,i=d.computeOptimalWindowSize(r[r.length-1]),a=new OG(r,i,n,null==s),o=t.runWebGLProgram(a,null==s?[e]:[e,s],"int32");if(o.shape.length===e.shape.length){const s=MG(t,e,n,o);return t.disposeIntermediateTensorInfo(o),s}return o}function PG(t,e,n,r){const i=[n];if(d.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!Ek().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],[a,o]=d.computeOutAndReduceShapes(e.shape,i),l=s.sizeFromShape(o),u=cG({inputs:{x:e},backend:t,attrs:{shape:[-1,l]}});n.push(u);const c=LG(t,u,r);n.push(c);const h=cG({inputs:{x:c},backend:t,attrs:{shape:a}});return n.forEach(e=>t.disposeIntermediateTensorInfo(e)),h}return MG(t,e,r)}const zG={kernelName:"ArgMax",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=vG({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),d.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);const h=PG(n,u,o[0],"max");return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},BG={kernelName:"ArgMin",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=vG({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),d.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);const h=PG(n,u,o[0],"min");return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},VG={kernelName:"Asin",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"})},WG={kernelName:"Asinh",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"})},UG={kernelName:"Atan",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"})},jG={kernelName:"Atan2",backendName:"webgl",kernelFunc:sG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},HG={kernelName:"Atanh",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"})};class GG{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(i/4),b=i%4,x=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${x}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${x}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class qG{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let x="0.0";if(b||(x="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const w=4*Math.floor(i/4),_=i%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}const KG={kernelName:"AvgPool",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;vj(i,"avgPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))return GH({inputs:{x:i},backend:n});const h=new GG(c,"avg",!1);return n.runWebGLProgram(h,[i],"float32")}},XG={kernelName:"AvgPool3D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s,c=d.computePool3DInfo(r.shape,i,a,[1,1,1],o,l,u),h=new qG(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class QG{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class YG{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const ZG={kernelName:"AvgPool3DGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=d.computePool3DInfo(a.shape,o,l,[1,1,1],u,c),p=new YG(h);return n.runWebGLProgram(p,[r],a.dtype)}},JG={kernelName:"AvgPoolGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i;vj([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=d.computePool2DInfo(a.shape,o,l,1,u),h=new QG(c);return n.runWebGLProgram(h,[r],a.dtype)}},tq={kernelName:"BatchMatMul",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return _G({a:r,b:i,transposeA:a,transposeB:o,backend:n})}};class eq{constructor(t,e,n,s,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],d.assertAndGetBroadcastShape(t,e),d.assertAndGetBroadcastShape(t,n);let a="0.0";null!=s&&(d.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=r&&(d.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class nq{constructor(t,e,n,s,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],d.assertAndGetBroadcastShape(t,e),d.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";null!=s&&(d.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=r&&(d.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const sq={kernelName:"FusedBatchNorm",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:i,variance:a,offset:o,scale:l}=t;s.assert(i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),s.assert(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),s.assert(null==l||i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const c=[r,i,a];let h=null;null!=o&&(h=o.shape,c.push(o));let d=null;null!=l&&(d=l.shape,c.push(l));const p=Ek().getBool("WEBGL_PACK_NORMALIZATION")?new nq(r.shape,i.shape,a.shape,h,d,u):new eq(r.shape,i.shape,a.shape,h,d,u);return e.runWebGLProgram(p,c,c[0].dtype)}};class rq{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Xj(this.rank),n=`uniform int start[${this.rank}];`,s=function(t){if(1===t)return"sourceLoc";if(t<=6)return iq.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${iq[e]} = start[${e}] + coords.${iq[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const iq=["x","y","z","w","u","v"];class aq{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=Xj(this.rank),n=TH("coords",this.rank),s=TH("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${r})`,a=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${s[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}function oq(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:a,size:o}=r,[u,c]=l.parseSliceParams(i,a,o);if(l.assertParamsValid(i,u,c),0===s.sizeFromShape(c))return n.makeTensorInfo(c,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||"string"===i.dtype){const t=n.texData.get(i.dataId),e=wH(t.values,u,c,i.shape,i.dtype);return n.makeTensorInfo(c,i.dtype,e)}const{isPacked:h}=n.texData.get(i.dataId),d=l.isSliceContinous(i.shape,u,c);if(h||!d){const t=Ek().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aq(c):new rq(c),e=t.getCustomSetupFunc(u);return n.runWebGLProgram(t,[i],i.dtype,e)}return n.uploadToGPU(i.dataId),function(t,e,n,r){const i=r.texData.get(t.dataId),a=r.makeTensorInfo(n,t.dtype),o=r.texData.get(a.dataId);Object.assign(o,i),o.refCount=1,o.shape=n,o.dtype=t.dtype;let u=l.computeFlatOffset(e,s.computeStrides(t.shape));i.slice&&(u+=i.slice.flatOffset),o.slice={flatOffset:u,origDataId:i.slice&&i.slice.origDataId||t.dataId};const c=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,c+1),a}(i,u,c,n)}const lq={kernelName:"Slice",backendName:"webgl",kernelFunc:oq},uq={kernelName:"BatchToSpaceND",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:a,crops:o}=r;s.assert(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=a.reduce((t,e)=>t*e),u=d.getReshaped(i.shape,a,l),c=d.getPermuted(u.length,a.length),h=d.getReshapedPermuted(i.shape,a,l),p=d.getSliceBeginCoords(o,a.length),f=d.getSliceSize(h,o,a.length),m=[],g=cG({inputs:{x:i},backend:n,attrs:{shape:u}}),y=vG({inputs:{x:g},backend:n,attrs:{perm:c}}),b=cG({inputs:{x:y},backend:n,attrs:{shape:h}}),x=oq({inputs:{x:b},backend:n,attrs:{begin:p,size:f}});return m.push(g),m.push(y),m.push(b),m.forEach(t=>n.disposeIntermediateTensorInfo(t)),x}},cq={kernelName:"Bincount",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a}=s,o=n.readSync(r.dataId),l=n.readSync(i.dataId),u=tH(o,l,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,u)}},hq=sG({opSnippet:"return float(a != b);",dtype:"bool"}),dq={kernelName:"NotEqual",backendName:"webgl",kernelFunc:hq};function pq(t){const{inputs:e,backend:n}=t,{input:s}=e;return GH({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const fq={kernelName:"Real",backendName:"webgl",kernelFunc:pq},mq={kernelName:"Cast",backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:i}=e,{x:a}=n,{dtype:o}=i;if("complex64"===o){if("complex64"===a.dtype)return GH({inputs:{x:a},backend:r});const e=QN(a.shape),n=t({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=KH({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const e=pq({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(e),n}if(!s.hasEncodingLoss(a.dtype,o)){const t=GH({inputs:{x:a},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:o}}if("int32"===o)return function(t,e){const n=new LH(t.shape,"return float(int(x));"),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(a,r);if("bool"===o){const t=r.makeTensorInfo([],"bool",s.getTypedArrayFromDType("bool",1)),e=hq({inputs:{a,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${o}`)}},gq="return ceil(x);",yq={kernelName:"Ceil",backendName:"webgl",kernelFunc:nG({opSnippet:gq,packedOpSnippet:gq,cpuKernelImpl:nH})};class bq{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class xq{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}const vq={kernelName:"ClipByValue",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;o=Ek().getBool("WEBGL_PACK_CLIP")?new xq(r.shape):new bq(r.shape);const l=o.getCustomSetupFunc(i,a);return n.runWebGLProgram(o,[r],r.dtype,l)}};class wq{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function _q(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const kq={kernelName:"ComplexAbs",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),i=new wq(s.shape),a=[_q(s,r.complexTensorInfos.real),_q(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}};class Sq{constructor(t){this.outputShape=[],this.outputShape=d.computeOutShape(t,1),this.variableNames=t.map((t,e)=>`T${e}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<e.length;s++)n.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${e[s-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Cq{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=d.computeOutShape(t,e);const n=this.outputShape,s=n.length,r=Xj(s),i=TH("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((t,e)=>`T${e}`);const o=new Array(t.length-1);o[0]=t[0][e];for(let d=1;d<o.length;d++)o[d]=o[d-1]+t[d][e];const l=a[e],u=a.slice(-2),c=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let d=1;d<o.length;d++){const t=o[d-1];h+=`\n        if (${l} < ${o[d]}  && ${l} >= ${o[d-1]}) {\n          return getChannel(\n            getT${d}(${Iq(a,l,t)}),\n            vec2(${Iq(u,l,t)}));\n        }`}const p=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${Iq(a,l,p)}),\n          vec2(${Iq(u,l,p)}));`,this.userCode=`\n      float getValue(${a.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${n[s-2]} &&\n            ${i[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Iq(t,e,n){const s=t.indexOf(e);return t.map((t,e)=>e===s?`${t} - ${n}`:t).join()}function Nq(t){const{inputs:e,backend:n}=t,{input:s}=e;return GH({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const Eq={kernelName:"Imag",backendName:"webgl",kernelFunc:Nq};function Tq(t,e,n){const s=t[0].dtype;if("complex64"===s){const s=t.map(t=>pq({inputs:{input:t},backend:n})),r=t.map(t=>Nq({inputs:{input:t},backend:n})),i=Tq(s,e,n),a=Tq(r,e,n),o=KH({inputs:{real:i,imag:a},backend:n});return s.forEach(t=>n.disposeIntermediateTensorInfo(t)),r.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}if("string"===s){const{tensors2D:r,outShape:i}=Aq(t,e,n),a=r.map(t=>({vals:n.readSync(t.dataId),shape:t.shape})),o=sH(a,i,s,1===r[0].shape[0]),l=d.computeOutShape(t.map(t=>t.shape),e),u=n.makeTensorInfo(l,s,o);return r.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}if(t.length>Ek().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(t.length/2),r=Tq(t.slice(0,s),e,n),i=Tq(t.slice(s),e,n),a=Tq([r,i],e,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}if(Ek().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const r=new Cq(t.map(t=>t.shape),e);return n.runWebGLProgram(r,t,s)}const{tensors2D:r,outShape:i}=Aq(t,e,n),a=new Sq(r.map(t=>t.shape)),o=n.runWebGLProgram(a,r,s);r.forEach(t=>n.disposeIntermediateTensorInfo(t));const l=cG({inputs:{x:o},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(o),l}function Aq(t,e,n){const r=d.computeOutShape(t.map(t=>t.shape),e);return{tensors2D:t.map(t=>cG({inputs:{x:t},attrs:{shape:[-1,s.sizeFromShape(t.shape.slice(e))]},backend:n})),outShape:r}}function Rq(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,a=s.parseAxisParam(i,e[0].shape)[0],o=d.computeOutShape(e.map(t=>t.shape),a);if(0===s.sizeFromShape(o))return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(t=>s.sizeFromShape(t.shape)>0);if(1===l.length)return GH({inputs:{x:l[0]},backend:n});const u=l.map(t=>t.shape);return d.assertParamsConsistent(u,a),Tq(l,a,n)}const $q={kernelName:"Concat",backendName:"webgl",kernelFunc:Rq};class Fq{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",v="";n&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class Dq{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,s=t.padInfo.left,r=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Oq{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:s,inChannels:r,strideWidth:i,strideHeight:a,padInfo:o,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=o,f=r*s,m=_j(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let x="";for(let v=0;v<=1;v++)for(let n=0;n<=1;n++)x+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${v};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${a} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${e[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*v+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*v+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${x}\n\n        ${m.output} = result;\n      }\n    `}}function Lq({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape,c=r.texData.get(t.dataId),h="channelsLast"===n.dataFormat;let d;const p=[],f=u[2]%2!=0&&!!c.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&Ek().getBool("WEBGL_LAZILY_UNPACK")&&Ek().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&f){const f={dataId:t.dataId,shape:[1,h?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:t.dtype},m=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,s.assert(fj(c.shape,f.shape),()=>`packed reshape ${c.shape} to ${f.shape} isn't free`);const g=cG({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});p.push(g);const y=_G({a:f,b:g,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:l,preluActivationWeights:a,leakyreluAlpha:o}),b=r.texData.get(y.dataId);s.assert(b.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=m,b.shape=n.outShape,d=GH({inputs:{x:y},backend:r}),d.shape=n.outShape,p.push(y)}else{const s=cG({inputs:{x:t},backend:r,attrs:{shape:[1,h?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),c=cG({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=_G({a:s,b:c,transposeA:!1,transposeB:!1,backend:r,bias:i,activation:l,preluActivationWeights:a,leakyreluAlpha:o});d=cG({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),p.push(s),p.push(c),p.push(f)}for(const s of p)r.disposeIntermediateTensorInfo(s);return d}function Mq({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:u,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=n,m="channelsLast"===f,g=u*c*h,y=p*d,b=[g,y],x=[],v=cG({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),w=cG({inputs:{x:e},backend:r,attrs:{shape:[1,g,s.sizeFromShape(e.shape)/g]}});x.push(v),x.push(w);const _=new Oq(b,v.shape,n),k=r.runWebGLProgram(_,[v],"float32"),S=cG({inputs:{x:k},backend:r,attrs:{shape:[1,b[0],b[1]]}});x.push(k),x.push(S);const C=null!=i,I=null!=a,N="leakyrelu"===l,E=l?rG(l,!0):null,T=new iG(S.shape,w.shape,[1,y,n.outChannels],!0,!1,C,E,I,N),A=[S,w];if(i&&A.push(i),I&&A.push(a),N){const t=r.makeTensorInfo([],"float32",s.createScalarValue(o,"float32"));A.push(t),x.push(t)}const R=r.runWebGLProgram(T,A,"float32"),$=cG({inputs:{x:R},backend:r,attrs:{shape:m?[1,p,d,n.outChannels]:[1,n.outChannels,p,d]}});x.push(R);for(const s of x)r.disposeIntermediateTensorInfo(s);return $}const Pq={kernelName:"Conv2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,i.shape,a,u,o,c,!1,h);let f;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(Ek().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])f=Mq({x:r,filter:i,convInfo:p,backend:n});else{const t=new Fq(p);f=n.runWebGLProgram(t,[r,i],"float32")}else f=Lq({x:r,filter:i,convInfo:p,backend:n});const m=cG({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}};class zq{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Bq{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Vq{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Wq{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Uq={kernelName:"Conv2DBackpropFilter",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,c,a,1,o,u,!1,h),f=new zq(p);return n.runWebGLProgram(f,[r,i],"float32")}},jq={kernelName:"Conv2DBackpropInput",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=d.convertConv2DDataFormat(u),p=d.computeConv2DInfo(a,i.shape,o,1,l,c,!1,h),f=new Bq(p);return n.runWebGLProgram(f,[r,i],"float32")}},Hq={kernelName:"Conv3D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,u=d.computeConv3DInfo(r.shape,i.shape,a,l,o),c=new Dq(u);return n.runWebGLProgram(c,[r,i],"float32")}},Gq={kernelName:"Conv3DBackpropFilterV2",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s,u=d.computeConv3DInfo(r.shape,l,a,1,o),c=new Vq(u);return n.runWebGLProgram(c,[r,i],"float32")}},qq={kernelName:"Conv3DBackpropInputV2",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s,u=d.computeConv3DInfo(l,i.shape,o,1,a),c=new Wq(u);return n.runWebGLProgram(c,[r,i],"float32")}},Kq={kernelName:"Cos",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"})},Xq={kernelName:"Cosh",backendName:"webgl",kernelFunc:nG({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"})};class Qq{constructor(t,e,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,o,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===s?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,x,v]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Yq={kernelName:"CropAndResize",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=s,c=new Qq(r.shape,i.shape,o,l,u);return n.runWebGLProgram(c,[r,i,a],"float32")}};class Zq{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const s=t.length,r=e?"0.0":`getX(${Jq(s,"coords")})`,i=t[t.length-1];let a="",o="";e?(a=n?"end != "+(i-1):"end != 0",o=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Xj(s)} coords = getOutputCoords();\n        int end = ${tK(s,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${o};\n          ${tK(s,"coords")} = idx;\n          val += getX(${Jq(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function Jq(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function tK(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const eK={kernelName:"Cumsum",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s,l=r.shape.length,u=d.getAxesPermutation([i],l);let c=r;null!=u&&(c=vG({inputs:{x:r},backend:n,attrs:{perm:u}}));const h=d.getInnerMostAxes(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${i}`);const p=c.shape[h];let f=GH({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(p))-1;d++){const t=new Zq(c.shape,!1,o),e=t.getCustomSetupFunc(d),s=f;f=n.runWebGLProgram(t,[f],f.dtype,e),n.disposeIntermediateTensorInfo(s)}if(a){const t=new Zq(c.shape,a,o),e=f;f=n.runWebGLProgram(t,[f],f.dtype),n.disposeIntermediateTensorInfo(e)}if(null!=u){const t=vG({inputs:{x:f},backend:n,attrs:{perm:d.getUndoAxesPermutation(u)}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(c),t}return f}},nK={kernelName:"DenseBincount",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const t=n.readSync(r.dataId),e=n.readSync(i.dataId),s=tH(t,e,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,s)}if(2===r.shape.length){const t=n.bufferSync(r),e=n.bufferSync(i),s=eH(t,e,a,o);return n.makeTensorInfo(s.shape,i.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class sK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const rK={kernelName:"DepthToSpace",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:a,dataFormat:o}=r;s.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const l=i.shape[0],u=("NHWC"===o?i.shape[1]:i.shape[2])*a,c=("NHWC"===o?i.shape[2]:i.shape[3])*a,h=("NHWC"===o?i.shape[3]:i.shape[1])/(a*a),d=new sK("NHWC"===o?[l,u,c,h]:[l,h,u,c],a,o);return n.runWebGLProgram(d,[i],i.dtype)}};class iK{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.inHeight,a=t.inWidth,o=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=t.outChannels/t.inChannels;let g="",y="";n&&(g=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${y}\n        setOutput(result);\n      }\n    `}}class aK{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const a=t.inHeight,o=t.inWidth,l=t.padInfo.top,u=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,g=m;let y="int xR; int xC; int xCOffset;";for(let s=0;s<f;s++)for(let t=0;t<m;t++)y+=`\n          vec4 xTexelR${s}C${2*t} = vec4(0.);\n          vec4 wR${s}C${t} = vec4(0.);\n          vec4 xR${s}C${t} = vec4(0.);`;for(let w=0;w<f;w++)for(let t=0;t<g;t++){const e=2*t;if(y+=`\n          xR = xRCorner + ${w*d};\n          xC = xCCorner + ${e*p};\n        `,1===h){if(e<m&&(y+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    xTexelR${w}C${e}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${o}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${w}C${e} = vec4(previous.zw, xTexelR${w}C${e}.xy);\n                } else {\n                  xR${w}C${e} = vec4(0, 0, xTexelR${w}C${e}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${a} && xC >= 0 && xC < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                xR${w}C${e} = xTexelR${w}C${e};\n              `,e+1<m)){const t=u%2==0?s.nearestLargerEven(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if(xR >= 0 && xR < ${a} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${w}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${a} &&\n                      xCOffset >= 0 && xCOffset < ${o}) {\n                      xTexelR${w}C${e} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${w}C${e} = vec4(0.);\n                    }\n                  `),y+=`\n                  xR${w}C${e+1} = vec4(\n                    xTexelR${w}C${e}.zw, xTexelR${w}C${e+2}.xy);\n                `):y+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${a} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${w}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${w}C${e+1} = xTexelR${w}C${e+2};\n                `}}else e<m&&(y+=`\n              if(xR >= 0 && xR < ${a}) {\n            `,u%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o}) {\n                  xTexelR${w}C${e+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${w}C${e+2} = vec4(0.);\n                }\n\n                xR${w}C${e} = vec4(\n                  xTexelR${w}C${e}.zw, xTexelR${w}C${e+2}.zw);\n              `,e+1<m&&(y+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${w}C${e+1} = vec4(xTexelR${w}C${e+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${w}C${e+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${e+2} = vec4(0.);\n                }\n\n                xR${w}C${e} = vec4(\n                  xTexelR${w}C${e}.xy, xTexelR${w}C${e+2}.xy);\n              `,e+1<m&&(y+=`\n                  xR${w}C${e+1} = vec4(\n                    xTexelR${w}C${e}.zw, xTexelR${w}C${e+2}.zw);\n                `)),y+="}");e<m&&(y+=`\n            vec4 wTexelR${w}C${e} = getW(${w}, ${e}, d1, q);\n            wR${w}C${e} = vec4(wTexelR${w}C${e}.xz, wTexelR${w}C${e}.xz);\n          `,e+1<m&&(y+=`\n              vec4 wTexelR${w}C${e+1} = getW(${w}, ${e+1}, d1, q);\n              wR${w}C${e+1} =\n                vec4(wTexelR${w}C${e+1}.xz, wTexelR${w}C${e+1}.xz);`))}for(let s=0;s<f;s++)for(let t=0;t<m;t++)y+=`dotProd += xR${s}C${t} * wR${s}C${t};`;let b="",x="";n&&(b=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,x="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${y}\n\n        vec4 result = dotProd;\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}}const oK={kernelName:"DepthwiseConv2dNative",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dilations:u,dimRoundingMode:c}=r;let h=u;null==h&&(h=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const p=d.computeConv2DInfo(i.shape,a.shape,o,h,l,c,!0);let f;return f=Ek().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new aK(p):new iK(p),n.runWebGLProgram(f,[i,a],"float32")}};class lK{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class uK{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const cK={kernelName:"DepthwiseConv2dNativeBackpropFilter",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s,h=d.computeConv2DInfo(r.shape,c,a,o,l,u,!0),p=new lK(h);return n.runWebGLProgram(p,[r,i],"float32")}},hK={kernelName:"DepthwiseConv2dNativeBackpropInput",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=s,h=d.computeConv2DInfo(c,i.shape,a,o,l,u,!0),p=new uK(h);return n.runWebGLProgram(p,[r,i],"float32")}};class dK{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const pK={kernelName:"Diag",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=[...r.shape,...r.shape],a=s.sizeFromShape(r.shape),o=cG({inputs:{x:r},backend:n,attrs:{shape:[a]}}),l=new dK(a),u=n.runWebGLProgram(l,[o],o.dtype),c=cG({inputs:{x:u},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}};class fK{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:s,strideHeight:r,strideWidth:i,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const mK={kernelName:"Dilation2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,u=d.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l);let c;const h=new fK(u);c=n.runWebGLProgram(h,[r,i],"float32");const p=cG({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}},gK={kernelName:"Elu",backendName:"webgl",kernelFunc:nG({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"})},yK={kernelName:"EluGrad",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,i=Ek().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new HH("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new jH("return (b >= 1.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}},bK={kernelName:"Equal",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"})},xK={kernelName:"Erf",backendName:"webgl",kernelFunc:nG({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${d.ERF_P};\n  float a1 = ${d.ERF_A1};\n  float a2 = ${d.ERF_A2};\n  float a3 = ${d.ERF_A3};\n  float a4 = ${d.ERF_A4};\n  float a5 = ${d.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`})},vK="return exp(x);",wK=nG({opSnippet:vK,packedOpSnippet:vK,cpuKernelImpl:rH}),_K={kernelName:"Exp",backendName:"webgl",kernelFunc:wK};function kK(t){const{inputs:e,attrs:n,backend:r}=t,{dim:i}=n,{input:a}=e,o=a.shape.length,l=a.shape.slice();let u=i;return i<0&&(s.assert(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),l.splice(u,0,1),cG({inputs:{x:a},backend:r,attrs:{shape:l}})}const SK={kernelName:"ExpandDims",backendName:"webgl",kernelFunc:kK},CK="return exp(x) - 1.0;",IK={kernelName:"Expm1",backendName:"webgl",kernelFunc:nG({opSnippet:CK,packedOpSnippet:CK,cpuKernelImpl:iH})};class NK{constructor(t,e,n){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function EK(t,e,n){const r=n.texData.get(t.dataId),i=s.sizeFromShape(t.shape),a=t.shape[t.shape.length-1],o=cG({inputs:{x:t},backend:n,attrs:{shape:[i/a,a]}}),l=o.shape,u=new NK("real",l,e),c=new NK("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,h,"float32"),p=n.runWebGLProgram(c,h,"float32"),f=KH({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const m=cG({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}const TK={kernelName:"FFT",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return EK(s,!1,n)}};class AK{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}function RK(t){const{backend:e,attrs:n}=t,{shape:r,value:i}=n;let{dtype:a}=n;if(a=a||s.inferDtype(i),"string"===a){const t=s.getArrayFromDType(a,s.sizeFromShape(r));return t.fill(i),e.makeTensorInfo(r,a,t)}{const t=new AK(r,i),n=t.getCustomSetupFunc(i);return e.runWebGLProgram(t,[],a,n)}}const $K={kernelName:"Fill",backendName:"webgl",kernelFunc:RK};class FK{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const DK={kernelName:"FlipLeftRight",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new FK(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}},OK="return floor(x);",LK={kernelName:"Floor",backendName:"webgl",kernelFunc:nG({opSnippet:OK,packedOpSnippet:OK,cpuKernelImpl:aH})},MK={kernelName:"FloorDiv",backendName:"webgl",kernelFunc:sG({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"})};class PK{constructor(t){this.variableNames=["A"];const e=_j(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class zK{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=_j(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const BK={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:i}=s,a="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];(o||a)&&(null==VK&&(VK=document.createElement("canvas").getContext("2d")),VK.canvas.width=l,VK.canvas.height=u,VK.drawImage(r,0,0,l,u),r=VK.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=KU.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=Ek().getBool("WEBGL_PACK")?new zK(h):new PK(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let VK;const WK={kernelName:"FusedConv2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a,bias:o,preluActivationWeights:l}=e,{strides:u,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=r,y=d.convertConv2DDataFormat(h),b=d.computeConv2DInfo(i.shape,a.shape,u,p,c,f,!1,y);let x;const v=[];if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(Ek().getBool("WEBGL_CONV_IM2COL")&&1===i.shape[0])x=Mq({x:i,filter:a,convInfo:b,backend:n,bias:o,activation:m,preluActivationWeights:l,leakyreluAlpha:g});else{const t=null!=o,e=null!=l,r="leakyrelu"===m,u=m?rG(m,!1):null,c=new Fq(b,t,u,e,r),h=[i,a];if(o&&h.push(o),l&&h.push(l),r){const t=n.makeTensorInfo([],"float32",s.createScalarValue(g,"float32"));h.push(t),v.push(t)}x=n.runWebGLProgram(c,h,"float32")}else x=Lq({x:i,filter:a,convInfo:b,backend:n,bias:o,activation:m,preluActivationWeights:l,leakyreluAlpha:g});const w=cG({inputs:{x},backend:n,attrs:{shape:b.outShape}});return v.push(x),v.forEach(t=>n.disposeIntermediateTensorInfo(t)),w}},UK={kernelName:"FusedDepthwiseConv2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a,bias:o,preluActivationWeights:l}=e,{strides:u,pad:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=[];let y=h;null==y&&(y=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(u,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${y}'`);const b=d.computeConv2DInfo(i.shape,a.shape,u,y,c,p,!0),x=Ek().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels==1,v=f?rG(f,x):null,w=[i,a],_=null!=o,k=null!=l,S="leakyrelu"===f;if(_&&w.push(o),k&&w.push(l),S){const t=n.makeTensorInfo([],"float32",s.createScalarValue(m,"float32"));w.push(t),g.push(t)}let C;C=x?new aK(b,_,v,k,S):new iK(b,_,v,k,S);const I=n.runWebGLProgram(C,w,"float32");return g.forEach(t=>n.disposeIntermediateTensorInfo(t)),I}};class jK{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const s=Xj(e.length),r=Xj(n.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const HK={kernelName:"GatherNd",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,a=i.shape,o=a[a.length-1],[l,u,c,h]=d.prepareAndValidate(r,i),p=cG({inputs:{x:i},backend:n,attrs:{shape:[u,o]}}),f=cG({inputs:{x:r},backend:n,attrs:{shape:[s.sizeFromShape(r.shape)/c,c]}}),m=new jK(o,h,[u,c]),g=n.runWebGLProgram(m,[f,p],f.dtype),y=cG({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}};class GK{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=Xj(this.rank),s=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)s.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const qK={kernelName:"GatherV2",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:a}=e,{axis:o,batchDims:l}=r,u=s.parseAxisParam(o,i.shape)[0],c=d.segment_util.collectGatherOpShapeInfo(i,a,u,l),h=s.sizeFromShape(a.shape),p=[],f=cG({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=cG({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}});p.push(f),p.push(m);const g=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,a])||"string"===i.dtype){const t=n.bufferSync(m),e=n.bufferSync(f),s=oH(e,t,g);return p.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(c.outputShape,s.dtype,s.values)}const y=new GK(f.shape,g),b=n.runWebGLProgram(y,[f,m],f.dtype);p.push(b);const x=cG({inputs:{x:b},backend:n,attrs:{shape:c.outputShape}});return p.forEach(t=>n.disposeIntermediateTensorInfo(t)),x}},KK={kernelName:"Greater",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:lH,dtype:"bool"})},XK={kernelName:"GreaterEqual",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"})},QK={kernelName:"IFFT",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return EK(s,!0,n)}},YK={kernelName:"IsFinite",backendName:"webgl",kernelFunc:nG({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},ZK={kernelName:"IsInf",backendName:"webgl",kernelFunc:nG({opSnippet:"return float(isinf(x));",dtype:"bool"})},JK={kernelName:"IsNan",backendName:"webgl",kernelFunc:nG({opSnippet:"return float(isnan(x));",dtype:"bool"})},tX={kernelName:"Less",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:uH,dtype:"bool"})},eX={kernelName:"LessEqual",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"})},nX={kernelName:"LinSpace",backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,a=cH(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}},sX={kernelName:"Log",backendName:"webgl",kernelFunc:nG({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:hH})},rX={kernelName:"Log1p",backendName:"webgl",kernelFunc:nG({opSnippet:"return log(1.0 + x);"})},iX={kernelName:"LogicalAnd",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"})},aX={kernelName:"LogicalNot",backendName:"webgl",kernelFunc:nG({opSnippet:"return float(!(x >= 1.0));"})},oX={kernelName:"LogicalOr",backendName:"webgl",kernelFunc:sG({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"})};class lX{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class uX{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const cX={kernelName:"LRN",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s,u=Ek().getBool("WEBGL_PACK_NORMALIZATION")?new uX(r.shape,i,a,o,l):new lX(r.shape,i,a,o,l);return n.runWebGLProgram(u,[r],r.dtype)}};class hX{constructor(t,e,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const dX={kernelName:"LRNGrad",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=s,h=new hX(r.shape,o,l,u,c);return n.runWebGLProgram(h,[r,i,a],r.dtype)}};function pX(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l),p=null!=h,f=n.shouldExecuteOnCPU([i]);let m=i;if(p){if(f){const t=n.texData.get(m.dataId).values,e=new Array(l);for(let n=0;n<e.length;n++)e[n]=i.shape[h[n]];const s=IH(t,i.shape,i.dtype,h,e);m=n.makeTensorInfo(e,i.dtype),n.texData.get(m.dataId).values=s}else m=yG(i,h,n);c=d.getInnerMostAxes(c.length,l)}d.assertAxesAreInnerMostDims("max",c,l);const[g,y]=d.computeOutAndReduceShapes(m.shape,c);let b,x=g;if(o&&(x=d.expandShapeToKeepDim(g,u)),f){const t=n.texData.get(m.dataId),e=dH(t.values,s.sizeFromShape(y),x,i.dtype);b=n.makeTensorInfo(x,i.dtype),n.texData.get(b.dataId).values=e}else b=function(t,e,n,r){const i=s.sizeFromShape(e),a=cG({inputs:{x:t},attrs:{shape:[s.sizeFromShape(t.shape)/i,i]},backend:r}),o=fG(a,t.dtype,"max",r),l=cG({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(o),l}(m,y,x,n);return p&&n.disposeIntermediateTensorInfo(m),b}const fX={kernelName:"Max",backendName:"webgl",kernelFunc:pX},mX={kernelName:"Maximum",backendName:"webgl",kernelFunc:sG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:pH})},gX={kernelName:"MaxPool",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;vj(i,"maxPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))return GH({inputs:{x:i},backend:n});const h=new GG(c,"max",!1);return n.runWebGLProgram(h,[i],i.dtype)}},yX={kernelName:"MaxPool3D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=s,c=d.computePool3DInfo(r.shape,i,a,[1,1,1],o,u,l),h=new qG(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class bX{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xX{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*s-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${s} +\n                  wR * ${s} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const vX={kernelName:"MaxPool3DGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=d.computePool3DInfo(a.shape,o,l,[1,1,1],u,c),p=new qG(h,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),m=new xX(h),g=n.runWebGLProgram(m,[r,f],a.dtype);return n.disposeIntermediateTensorInfo(f),g}},wX={kernelName:"MaxPoolGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:a}=e,o=i;vj([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,p=d.computePool2DInfo(o.shape,l,u,1,c,h),f=new GG(p,"max",!0),m=n.runWebGLProgram(f,[o],o.dtype),g=new bX(p),y=n.runWebGLProgram(g,[r,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}},_X={kernelName:"MaxPoolWithArgmax",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:a,pad:o,includeBatchInIndex:l}=e,u=n;s.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];s.assert(d.eitherStridesOrDilationsAreOne(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=d.computePool2DInfo(r.shape,i,a,c,o),[p,f]=function(t,e,n,s){let r=new GG(n,"max",!1);const i=s.runWebGLProgram(r,[t],"float32");return r=new GG(n,"max",!0,!0,e),[i,s.runWebGLProgram(r,[t],"float32")]}(r,l,h,u);return[p,f]}},kX={kernelName:"Mean",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:i,axis:a}=e,o=n,l=r.shape.length,u=s.parseAxisParam(a,r.shape);let c=u;const h=d.getAxesPermutation(c,l),p=null!=h,f=o.shouldExecuteOnCPU([r]),m=[];let g=r;if(p){if(f){const t=o.texData.get(g.dataId).values,e=new Array(l);for(let s=0;s<e.length;s++)e[s]=r.shape[h[s]];const n=IH(t,r.shape,r.dtype,h,e);g=o.makeTensorInfo(e,r.dtype),o.texData.get(g.dataId).values=n}else g=yG(r,h,o);m.push(g),c=d.getInnerMostAxes(c.length,l)}d.assertAxesAreInnerMostDims("sum",c,l);const[y,b]=d.computeOutAndReduceShapes(g.shape,c);let x=y;i&&(x=d.expandShapeToKeepDim(y,u));const v=function(t,e,n,r){const i=s.sizeFromShape(e),a=cG({inputs:{x:t},attrs:{shape:[s.sizeFromShape(t.shape)/i,i]},backend:r}),o=fG(a,"float32","mean",r),l=cG({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(o),l}(g,b,x,o);for(const s of m)o.disposeIntermediateTensorInfo(s);return v}},SX={kernelName:"Min",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l);let p=i;null!=h&&(p=vG({inputs:{x:i},backend:n,attrs:{perm:h}}),c=d.getInnerMostAxes(c.length,i.shape.length)),d.assertAxesAreInnerMostDims("min",c,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,c),g=cG({inputs:{x:p},backend:n,attrs:{shape:[-1,s.sizeFromShape(m)]}}),y=fG(g,g.dtype,"min",n);let b;return b=cG(o?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,u)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),b}},CX={kernelName:"Minimum",backendName:"webgl",kernelFunc:sG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:fH})};class IX{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=Xj(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class NX{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=Xj(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=TH("rc",s),l=TH("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===s){const t=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const t=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[s-2]} += 1;\n        if(${o[s-2]} < ${this.outputShape[s-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[s-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const EX={kernelName:"MirrorPad",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:i}=n,a=Ek().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NX(s.shape,r,i):new IX(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)}},TX={kernelName:"Mod",backendName:"webgl",kernelFunc:sG({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})};class AX{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}const RX=sG({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),$X={kernelName:"RealDiv",backendName:"webgl",kernelFunc:RX},FX="return a - b;",DX=sG({opSnippet:FX,packedOpSnippet:FX,supportsComplex:!0,cpuKernelImpl:kH}),OX={kernelName:"Sub",backendName:"webgl",kernelFunc:DX};function LX(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:a}=r,o=s.parseAxisParam([a],i.shape),l=pX({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=d.expandShapeToKeepDim(l.shape,o),c=cG({inputs:{x:l},backend:n,attrs:{shape:u}}),h=DX({inputs:{a:i,b:c},backend:n}),p=wK({inputs:{x:h},backend:n}),f=bG({inputs:{x:p},backend:n,attrs:{axis:o,keepDims:!1}}),m=cG({inputs:{x:f},backend:n,attrs:{shape:u}}),g=RX({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const MX={kernelName:"Softmax",backendName:"webgl",kernelFunc:LX},PX={kernelName:"Multinomial",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,l=o?r:LX({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=new AX(l.shape[0],l.shape[1],i),c=u.getCustomSetupFunc(a),h=n.runWebGLProgram(u,[l],"int32",c);return o||n.disposeIntermediateTensorInfo(l),h}},zX="return -x;",BX={kernelName:"Neg",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const t=n.texData.get(s.dataId),[e,r]=gH(t.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,e)}let r;return r=Ek().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new zH(s.shape,zX):new LH(s.shape,zX),n.runWebGLProgram(r,[s],s.dtype)}},VX=p.nonMaxSuppressionV3Impl,WX={kernelName:"NonMaxSuppressionV3",backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=VX(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},UX=p.nonMaxSuppressionV4Impl,jX={kernelName:"NonMaxSuppressionV4",backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:p,validOutputs:f}=UX(c,h,a,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},HX=p.nonMaxSuppressionV5Impl,GX={kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),p=a,f=o,m=l,g=u,{selectedIndices:y,selectedScores:b}=HX(c,h,p,f,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class qX{constructor(t,e,n,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const KX={kernelName:"OneHot",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{depth:a,onValue:o,offValue:l}=r,u=s.sizeFromShape(i.shape),c=new qX(u,a,o,l),h=cG({inputs:{x:i},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],i.dtype);n.disposeIntermediateTensorInfo(h);const p=cG({inputs:{x:d},backend:n,attrs:{shape:[...i.shape,a]}});return n.disposeIntermediateTensorInfo(d),p}};function XX(t){const{inputs:e,backend:n}=t,{x:s}=e;if("complex64"===s.dtype){const t=pq({inputs:{input:s},backend:n}),e=XX({inputs:{x:t},backend:n}),r=Nq({inputs:{input:s},backend:n}),i=XX({inputs:{x:r},backend:n}),a=KH({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return RK({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const QX={kernelName:"ZerosLike",backendName:"webgl",kernelFunc:XX},YX={kernelName:"OnesLike",backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=pq({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=Nq({inputs:{input:r},backend:s}),a=XX({inputs:{x:i},backend:s}),o=KH({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return RK({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}},ZX={kernelName:"Pack",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(1===e.length)return kK({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const a=e[0].shape,o=e[0].dtype;e.forEach(t=>{s.assertShapesMatch(a,t.shape,"All tensors passed to stack must have matching shapes"),s.assert(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=Rq({inputs:e.map(t=>{const e=kK({inputs:{input:t},backend:n,attrs:{dim:i}});return l.push(e),e}),backend:n,attrs:{axis:i}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}};class JX{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=Xj(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class tQ{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=Xj(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=TH("rc",s),l=TH("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${o[s-2]} += 1;\n       if(${o[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${o[s-1]} += 1;\n         if(${u}) {`],d=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===s?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}const eQ=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:a}=s,o=Ek().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tQ(r.shape,i,a):new JX(r.shape,i,a),l=o.getCustomSetupFunc(a);return n.runWebGLProgram(o,[r],r.dtype,l)},nQ={kernelName:"PadV2",backendName:"webgl",kernelFunc:eQ},sQ={kernelName:"Pow",backendName:"webgl",kernelFunc:sG({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},rQ={kernelName:"Prod",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=[],c=s.parseAxisParam(a,i.shape);let h=c;const p=d.getAxesPermutation(h,l);let f,m=i;if(null!=p&&(m=vG({inputs:{x:i},backend:n,attrs:{perm:p}}),h=d.getInnerMostAxes(h.length,l),u.push(m)),d.assertAxesAreInnerMostDims("prod",h,l),n.shouldExecuteOnCPU([m])){const t=n.texData.get(m.dataId).values,{outVals:e,outShape:s,outDtype:r}=yH(m.shape,m.dtype,t,h);f=n.makeTensorInfo(s,r,e)}else{const[t,e]=d.computeOutAndReduceShapes(m.shape,h),r=s.sizeFromShape(e),a=cG({inputs:{x:m},backend:n,attrs:{shape:[-1,r]}}),o=fG(a,mS(i.dtype),"prod",n);f=cG({inputs:{x:o},backend:n,attrs:{shape:t}}),u.push(a),u.push(o)}if(o){u.push(f);const t=d.expandShapeToKeepDim(f.shape,c);f=cG({inputs:{x:f},backend:n,attrs:{shape:t}})}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}},iQ=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:i,dtype:a}=n,o=bH(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},aQ={kernelName:"Range",backendName:"webgl",kernelFunc:iQ},oQ={kernelName:"Reciprocal",backendName:"webgl",kernelFunc:nG({opSnippet:"return 1.0 / x;"})},lQ={kernelName:"Relu",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"})},uQ={kernelName:"Relu6",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"})};class cQ{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class hQ{constructor(t,e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const dQ={kernelName:"ResizeBilinear",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=Ek().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new hQ(r.shape,l,u,i,a):new cQ(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],"float32")}};class pQ{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,a]=t,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const fQ={kernelName:"ResizeBilinearGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s,o=new pQ(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class mQ{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const gQ={kernelName:"ResizeNearestNeighbor",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=new mQ(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],r.dtype)}};class yQ{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,a]=t,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const bQ={kernelName:"ResizeNearestNeighborGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s,o=new yQ(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class xQ{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const s=t.map((n,s)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(s)).join(","),r=Xj(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class vQ{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const s=TH("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Xj(n);function o(n){const s=t.map((s,r)=>function(n,s){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return o(t)}(s.slice())};\n          if(${r}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",o(t)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",o(t)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",o(t)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const wQ={kernelName:"Reverse",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:a}=r,o=i.shape.length,l=s.parseAxisParam(a,i.shape);if(0===o)return GH({inputs:{x:i},backend:n});const u=Ek().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vQ(i.shape,l):new xQ(i.shape,l);return n.runWebGLProgram(u,[i],i.dtype)}};class _Q{constructor(t,e){this.variableNames=["Image"],this.outputShape=[];const n=t[1],s=t[2];this.outputShape=t;let r="";r="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(t,e,n,s){return(r,i)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(i,"params")),r.gl.uniform4f(this.paramsLoc,t,e,n,s)}}}const kQ={kernelName:"RotateWithOffset",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:a}=e,o=n,l=new _Q(s.shape,i),[u,c]=d.getImageCenter(a,s.shape[1],s.shape[2]),h=l.getCustomSetupFunc(u,c,Math.sin(r),Math.cos(r));return o.runWebGLProgram(l,[s],s.dtype,h)}},SQ={kernelName:"Round",backendName:"webgl",kernelFunc:nG({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"})},CQ={kernelName:"Rsqrt",backendName:"webgl",kernelFunc:nG({opSnippet:"return inversesqrt(x);",cpuKernelImpl:xH})};class IQ{constructor(t,e,n,s,r,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const o=Xj(r.length),l=Xj(i.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===s?c="i":2===s&&(c="i, coords[1]"),this.userCode=`\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const NQ={kernelName:"ScatterNd",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=d.calculateShapes(i,r,a),p=[h/u,u];if(0===h)return n.makeTensorInfo(a,r.dtype);const f=cG({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),m=cG({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),y=new IQ(l,o,f.shape.length,m.shape.length,c,p),b=n.runWebGLProgram(y,[m,f,g],m.dtype),x=cG({inputs:{x:b},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),x}};class EQ{constructor(t,e,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let s=0;s<e.length;s++)a.push(`${n[s]}`),s<t&&i.push(`${n[s]}`);s=i.join(),r=a.join()}const i=Xj(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const TQ={kernelName:"Select",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e,a=new EQ(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(a,[s,r,i],fS(r.dtype,i.dtype))}},AQ={kernelName:"Selu",backendName:"webgl",kernelFunc:nG({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${d.SELU_SCALEALPHA};\n  float scale = ${d.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`})},RQ={kernelName:"Sigmoid",backendName:"webgl",kernelFunc:nG({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"})},$Q={kernelName:"Sign",backendName:"webgl",kernelFunc:nG({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"})},FQ={kernelName:"Sin",backendName:"webgl",kernelFunc:nG({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"})},DQ={kernelName:"Sinh",backendName:"webgl",kernelFunc:nG({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"})},OQ={kernelName:"Softplus",backendName:"webgl",kernelFunc:nG({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"})},LQ={kernelName:"SpaceToBatchND",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:a,paddings:o}=r;s.assert(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=a.reduce((t,e)=>t*e),u=[[0,0]];u.push(...o);for(let s=1+a.length;s<i.shape.length;++s)u.push([0,0]);const c=[],h=eQ({inputs:{x:i},backend:n,attrs:{paddings:u,constantValue:0}}),p=d.getReshaped(h.shape,a,l,!1),f=d.getPermuted(p.length,a.length,!1),m=d.getReshapedPermuted(h.shape,a,l,!1),g=cG({inputs:{x:h},backend:n,attrs:{shape:p}}),y=vG({inputs:{x:g},backend:n,attrs:{perm:f}}),b=cG({inputs:{x:y},backend:n,attrs:{shape:m}});return c.push(h),c.push(g),c.push(y),c.forEach(t=>n.disposeIntermediateTensorInfo(t)),b}},MQ={kernelName:"SparseToDense",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:u,strides:c,outputSize:h}=d.calculateShapes(i,r,o),p=new IQ(u,l,r.shape.length,i.shape.length,c,[h,1],!1),f=n.runWebGLProgram(p,[i,r,a],i.dtype),m=cG({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}},PQ={kernelName:"SplitV",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:a,axis:o}=r,l=s.parseAxisParam(o,i.shape)[0],u=d.prepareSplitSize(i,a,l),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return u.map(t=>{const e=[...h];e[l]=t;const s=oq({inputs:{x:i},backend:n,attrs:{begin:c,size:e}});return c[l]+=t,s})}},zQ={kernelName:"Sqrt",backendName:"webgl",kernelFunc:nG({opSnippet:"return sqrt(x);"})},BQ={kernelName:"Square",backendName:"webgl",kernelFunc:nG({opSnippet:"return x * x;"})},VQ={kernelName:"SquaredDifference",backendName:"webgl",kernelFunc:sG({opSnippet:"return (a - b) * (a - b);",packedOpSnippet:"return (a - b) * (a - b);"})},WQ={kernelName:"Step",backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=new LH(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `);return n.runWebGLProgram(r,[s],s.dtype)}};class UQ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=Xj(n.length),i=Xj(n.length);let a="";if(1===s)a="coords * strides + begin";else{let t=0;a=n.map((e,s)=>(t++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${t-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const jQ={kernelName:"StridedSlice",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{nonStrided:f,$begin:m,$strides:g,size:y,newShape:b,outShape:x}=l.sliceInfo(r.shape,i,a,o,u,c,h,d,p),v=cG({inputs:{x:r},backend:n,attrs:{shape:b}});let w;if(f){const t=oq({inputs:{x:v},backend:n,attrs:{begin:m,size:y}});w=cG({inputs:{x:t},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(t)}else if(x.some(t=>0===t))w=n.makeTensorInfo(x,r.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const t=n.texData.get(v.dataId),e=CC(v.shape,v.dtype,t.values),s=_H(x,e,g,m);w=n.makeTensorInfo(x,v.dtype,s.values)}else{const t=new UQ(m,g,x);w=n.runWebGLProgram(t,[v],v.dtype)}const _=cG({inputs:{x:w},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),_}},HQ={kernelName:"Tan",backendName:"webgl",kernelFunc:nG({opSnippet:"return tan(x);"})},GQ={kernelName:"Tanh",backendName:"webgl",kernelFunc:nG({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"})};class qQ{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const s=Xj(this.rank),r=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function KQ(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:a}=r;if("string"===i.dtype){const t=n.readSync(i.dataId).map(t=>s.decodeString(t)),e=CC(i.shape,i.dtype,t),r=SH(e,a);return n.makeTensorInfo(r.shape,r.dtype,r.values)}const o=new qQ(i.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}const XQ={kernelName:"Tile",backendName:"webgl",kernelFunc:KQ},QQ={kernelName:"TopK",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:a}=s,o=n.readSync(r.dataId),[l,u]=CH(o,r.shape,r.dtype,i,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};class YQ{constructor(t,e,n,s,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===n?1:2;let o;switch(s){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const ZQ={kernelName:"Transform",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,m]=null!=u?u:[h,d],g=new YQ(h,d,a,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[r,i],"float32")}},JQ={kernelName:"Unique",backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;vj(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=NH(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}},tY={kernelName:"Unpack",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==i&&(u[c++]=a.shape[m]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;const t=oq({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),e=cG({inputs:{x:t},backend:n,attrs:{shape:u}});f[m]=e,h.push(t)}return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}};class eY{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,s=t.batchSize,r=t.inSize,i=t.numSegments,a=i*Math.ceil(r/n);this.outputShape=[s,a];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const nY=[cX,dX,kG,SG,CG,IG,EG,RG,$G,FG,zG,BG,VG,WG,jG,UG,HG,XG,KG,ZG,JG,tq,sq,uq,cq,mq,yq,vq,kq,XH,$q,Uq,jq,Pq,Gq,qq,Hq,Kq,Xq,Yq,eK,nK,rK,cK,hK,oK,pK,mK,gK,yK,bK,xK,_K,SK,IK,TK,$K,DK,LK,MK,BK,WK,UK,HK,qK,KK,XK,qH,QK,Eq,YK,ZK,JK,ZH,tX,eX,nX,rX,sX,iX,aX,oX,fX,yX,gX,vX,wX,_X,mX,kX,SX,CX,EX,TX,PX,uG,BX,WX,jX,GX,dq,KX,YX,ZX,nQ,sQ,eG,rQ,aQ,fq,$X,oQ,uQ,lQ,hG,dQ,fQ,gQ,bQ,wQ,kQ,SQ,CQ,NQ,TQ,AQ,RQ,$Q,FQ,DQ,lq,MX,OQ,LQ,MQ,PQ,zQ,BQ,VQ,WQ,jQ,OX,xG,HQ,GQ,XQ,QQ,ZQ,wG,JQ,tY,{kernelName:"UnsortedSegmentSum",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:a}=e,{numSegments:o}=r,l=i.shape.length,u=[];let c=0;const h=d.getAxesPermutation([c],l);let p=i;null!=h&&(p=vG({inputs:{x:i},backend:n,attrs:{perm:h}}),u.push(p),c=d.getInnerMostAxes(1,l)[0]);const f=d.segment_util.computeOutShape(p.shape,c,o),m=s.sizeFromShape([p.shape[c]]),g=cG({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}});u.push(g);const y=mS(i.dtype),b=(t,e,s,r,i)=>{const a=t.shape[0],o=t.shape[1],l=d.segment_util.segOpComputeOptimalWindowSize(o,i),c=new eY({windowSize:l,inSize:o,batchSize:a,numSegments:i},e),h=n.compileAndRun(c,[t,s],r);if(u.push(h),h.shape[1]===i)return h;const p=iQ({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=KQ({inputs:{x:p},backend:n,attrs:{reps:[o/l]}});return u.push(p),u.push(f),b(h,e,f,r,i)},x=cG({inputs:{x:b(g,"unsortedSegmentSum",a,y,o)},backend:n,attrs:{shape:f}});let v=x;if(null!=h){u.push(x);const t=d.getUndoAxesPermutation(h);v=vG({inputs:{x:v},backend:n,attrs:{perm:t}})}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),v}},QX];for(const pY of nY)Pk(pY);function sY(t,e){1&t&&(Va(0,"div"),Ua(1,"mat-progress-bar",6),Wa())}function rY(t,e){if(1&t){const t=ja();Va(0,"div"),Va(1,"mat-card"),_o(2," Drop your screenshots below: "),Ua(3,"br"),Ua(4,"br"),Va(5,"ngx-dropzone",7),Ga("change",function(e){return rn(t),Ya().onSelect(e)}),Va(6,"ngx-dropzone-label"),_o(7," Files dropped here are "),Va(8,"span",8),_o(9,"not uploaded anywhere."),Wa(),_o(10," No data leaves your computer at all on this tool. "),Wa(),Wa(),Wa(),Ua(11,"br"),Va(12,"mat-card"),Va(13,"span",8),_o(14,"Note:"),Wa(),_o(15," For best results, ensure your screenshots are taken natively in a "),Va(16,"span",8),_o(17,"16:10 aspect ratio."),Wa(),_o(18," (ie: 1440x900 or other) "),Wa(),Va(19,"mat-card"),_o(20," Source code available at "),Va(21,"a",9),_o(22,"GitHub"),Wa(),Wa(),Wa()}}function iY(t,e){if(1&t&&(Va(0,"div"),Va(1,"mat-card"),Va(2,"h3"),_o(3),Wa(),Ua(4,"mat-progress-bar",10),Wa(),Va(5,"mat-card"),_o(6," This processing is happening in your browser. "),Va(7,"span",8),_o(8,"There is no backend."),Wa(),Wa(),Wa()),2&t){const t=Ya();di(3),Co("Classifying: ",t.eyeballedCount," of ",t.imageCount,""),di(1),za("value",t.eyeballPercent())}}function aY(t,e){if(1&t){const t=ja();Va(0,"div"),Va(1,"div",11),Va(2,"h2"),_o(3,"Results"),Wa(),Va(4,"mat-toolbar"),Va(5,"mat-toolbar-row",12),Ua(6,"span",13),Va(7,"button",14),Ga("click",function(){rn(t);const e=Ya();return e.selected.webapp=0,e.updateSelections()}),_o(8,"Must Include"),Wa(),Va(9,"button",15),Ga("click",function(){rn(t);const e=Ya();return e.selected.webapp=1,e.updateSelections()}),_o(10,"Webapp"),Wa(),Va(11,"button",16),Ga("click",function(){rn(t);const e=Ya();return e.selected.webapp=2,e.updateSelections()}),_o(12,"Never Include"),Wa(),Va(13,"label",17),_o(14),Wa(),Ua(15,"span",13),Wa(),Va(16,"mat-toolbar-row",12),Ua(17,"span",13),Va(18,"button",14),Ga("click",function(){rn(t);const e=Ya();return e.selected.oldLooking=0,e.updateSelections()}),_o(19,"Must Include"),Wa(),Va(20,"button",15),Ga("click",function(){rn(t);const e=Ya();return e.selected.oldLooking=1,e.updateSelections()}),_o(21,"Old Looking"),Wa(),Va(22,"button",16),Ga("click",function(){rn(t);const e=Ya();return e.selected.oldLooking=2,e.updateSelections()}),_o(23,"Never Include"),Wa(),Va(24,"label",17),_o(25),Wa(),Ua(26,"span",13),Wa(),Va(27,"mat-toolbar-row",12),Ua(28,"span",13),Va(29,"button",18),Ga("click",function(){rn(t);const e=Ya();return e.selected.loginPage=0,e.updateSelections()}),_o(30,"Must Include"),Wa(),Va(31,"button",15),Ga("click",function(){rn(t);const e=Ya();return e.selected.loginPage=1,e.updateSelections()}),_o(32,"Login Page"),Wa(),Va(33,"button",16),Ga("click",function(){rn(t);const e=Ya();return e.selected.loginPage=2,e.updateSelections()}),_o(34,"Never Include"),Wa(),Va(35,"label",17),_o(36),Wa(),Ua(37,"span",13),Wa(),Va(38,"mat-toolbar-row",12),Ua(39,"span",13),Va(40,"button",18),Ga("click",function(){rn(t);const e=Ya();return e.selected.custom404=0,e.updateSelections()}),_o(41,"Must Include"),Wa(),Va(42,"button",15),Ga("click",function(){rn(t);const e=Ya();return e.selected.custom404=1,e.updateSelections()}),_o(43,"Custom 404"),Wa(),Va(44,"button",16),Ga("click",function(){rn(t);const e=Ya();return e.selected.custom404=2,e.updateSelections()}),_o(45,"Never Include"),Wa(),Va(46,"label",17),_o(47),Wa(),Ua(48,"span",13),Wa(),Va(49,"mat-toolbar-row",12),Ua(50,"span",13),Va(51,"button",18),Ga("click",function(){rn(t);const e=Ya();return e.selected.parked=0,e.updateSelections()}),_o(52,"Must Include"),Wa(),Va(53,"button",15),Ga("click",function(){rn(t);const e=Ya();return e.selected.parked=1,e.updateSelections()}),_o(54,"Parked Domain"),Wa(),Va(55,"button",16),Ga("click",function(){rn(t);const e=Ya();return e.selected.parked=2,e.updateSelections()}),_o(56,"Never Include"),Wa(),Va(57,"label",17),_o(58),Wa(),Ua(59,"span",13),Wa(),Wa(),Va(60,"mat-card"),Va(61,"span",8),_o(62,"Total Selected:"),Wa(),_o(63),Wa(),Ua(64,"br"),Va(65,"mat-card"),Va(66,"button",19),Ga("click",function(){return rn(t),Ya().exportResults()}),_o(67," Export "),Wa(),Va(68,"a",20),_o(69,"What do these labels mean?"),Wa(),Wa(),Wa(),Wa()}if(2&t){const t=Ya();di(7),za("disabled",0===t.selected.webapp),di(2),za("disabled",1===t.selected.webapp),di(2),za("disabled",2===t.selected.webapp),di(3),ko(t.classifications.webapp.length),di(4),za("disabled",0===t.selected.oldLooking),di(2),za("disabled",1===t.selected.oldLooking),di(2),za("disabled",2===t.selected.oldLooking),di(3),ko(t.classifications.oldLooking.length),di(4),za("disabled",0===t.selected.loginPage),di(2),za("disabled",1===t.selected.loginPage),di(2),za("disabled",2===t.selected.loginPage),di(3),ko(t.classifications.loginPage.length),di(4),za("disabled",0===t.selected.custom404),di(2),za("disabled",1===t.selected.custom404),di(2),za("disabled",2===t.selected.custom404),di(3),ko(t.classifications.custom404.length),di(4),za("disabled",0===t.selected.parked),di(2),za("disabled",1===t.selected.parked),di(2),za("disabled",2===t.selected.parked),di(3),ko(t.classifications.parked.length),di(5),So(" ",t.selectedScreens.length," ")}}const oY=[{path:"",component:(()=>{class t{constructor(){this.offset=_I(127.5),this.confidence=.5,this.width=224,this.height=224,this.tfFilesCompleted=!1,this.tfFiles=[],this.model=null,this.imageCount=0,this.eyeballing=!1,this.eyeballCompleted=!1,this.eyeballedCount=0,this.classifications={custom404:[],loginPage:[],webapp:[],oldLooking:[],parked:[]},this.selected={custom404:2,loginPage:1,webapp:0,oldLooking:1,parked:2},this.selectedScreens=[]}ngOnInit(){this.fetchTfFiles()}onSelect(t){return Km(this,void 0,void 0,function*(){this.imageCount=t.addedFiles.length,this.eyeballing=!0,yield this.classifyImages(t.addedFiles),this.eyeballing=!1,this.eyeballCompleted=!0,yield this.updateSelections()})}classifyImages(t){return Km(this,void 0,void 0,function*(){var e,n;this.model=yield(e=a.browserFiles(this.tfFiles),null==n&&(n={}),async function(t,e){if(null==e&&(e={}),"string"==typeof t){const n=a.getLoadHandlers(t,e);if(0===n.length)n.push(a.browserHTTPRequest(t,e));else if(n.length>1)throw new iF(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return async function(t,e,n){if(null==n&&(n={}),null==t.load)throw new iF("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await t.load();let r=s.modelTopology;null!=r.model_config&&(r=r.model_config);const i=null==n.strict||n.strict,o=null!=s.weightData&&null!=s.weightSpecs&&i,l=bO(jO(r),void 0,o),u=s.trainingConfig;if(null!=u&&l.loadTrainingConfig(u),null!=s.userDefinedMetadata&&l.setUserDefinedMetadata(s.userDefinedMetadata),null!=s.weightData){if(null==s.weightSpecs)throw new iF("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=a.decodeWeights(t,e),s={},r=[];return e.forEach(t=>{"optimizer"===t.group?r.push({name:t.name,tensor:n[t.name]}):s[t.name]=n[t.name]}),{modelWeights:s,optimizerWeights:r}}(s.weightData,s.weightSpecs);l.loadWeights(t,i),null!=l.optimizer&&e.length>0&&await l.optimizer.setWeights(e),bI(t),bI(e.map(t=>t.tensor))}return l}(t,0,e)}(e,n));for(const s of t)yield this.classify(s),this.eyeballedCount++})}classify(t){return Km(this,void 0,void 0,function*(){const e=yield this.dataURI(t),n=new Image(this.width,this.height);n.src=e,n.onerror=()=>{},n.onload=()=>{yI(()=>{const e=o.fromPixels(n).resizeNearestNeighbor([224,224]).toFloat().sub(this.offset).div(this.offset).expandDims(),s=this.model.predict(e),r=s.dataSync();e.dispose(),s.dispose(),r[0]>this.confidence&&this.classifications.custom404.push(t.name),r[1]>this.confidence&&this.classifications.loginPage.push(t.name),r[2]>this.confidence&&this.classifications.webapp.push(t.name),r[3]>this.confidence&&this.classifications.oldLooking.push(t.name),r[4]>this.confidence&&this.classifications.parked.push(t.name)})}})}isWebapp(t){return this.classifications.webapp.includes(t)?"Webapp":""}isCustom404(t){return this.classifications.custom404.includes(t)?"Custom 404":""}isLoginPage(t){return this.classifications.loginPage.includes(t)?"Login Page":""}isOldLooking(t){return this.classifications.oldLooking.includes(t)?"Old Looking":""}isParked(t){return this.classifications.parked.includes(t)?"Parked Domain":""}fetchTfFiles(){var t;return Km(this,void 0,void 0,function*(){let e=yield fetch("assets/tf/model.json");const n=yield e.json(),s=Array.from(null===(t=n.weightsManifest[0])||void 0===t?void 0:t.paths);this.tfFiles=[],e=yield fetch("assets/tf/model.json");const r=yield e.blob();this.tfFiles.push(new File([r],"model.json")),yield Promise.all(s.map(t=>Km(this,void 0,void 0,function*(){const e=yield this.fetchTfFile(t);this.tfFiles.push(e)}))),this.tfFilesCompleted=!0})}fetchTfFile(t){return Km(this,void 0,void 0,function*(){const e=t.split("/").reverse()[0],n=yield fetch(`assets/tf/${e}`),s=yield n.blob();return new File([s],e)})}updateSelections(){return Km(this,void 0,void 0,function*(){let t=new Set([]);for(let n of this.classifications.webapp)t.add(n);for(let n of this.classifications.oldLooking)t.add(n);for(let n of this.classifications.loginPage)t.add(n);for(let n of this.classifications.custom404)t.add(n);for(let n of this.classifications.parked)t.add(n);let e=Array.from(t);if(0===this.selected.webapp){let t=e.filter(t=>this.classifications.webapp.includes(t));e=t}if(0===this.selected.oldLooking){let t=e.filter(t=>this.classifications.oldLooking.includes(t));e=t}if(0===this.selected.loginPage){let t=e.filter(t=>this.classifications.loginPage.includes(t));e=t}if(0===this.selected.custom404){let t=e.filter(t=>this.classifications.custom404.includes(t));e=t}if(0===this.selected.parked){let t=e.filter(t=>this.classifications.parked.includes(t));e=t}if(t=new Set(e),2===this.selected.webapp)for(let n of this.classifications.webapp)t.delete(n);if(2===this.selected.oldLooking)for(let n of this.classifications.oldLooking)t.delete(n);if(2===this.selected.loginPage)for(let n of this.classifications.loginPage)t.delete(n);if(2===this.selected.custom404)for(let n of this.classifications.custom404)t.delete(n);if(2===this.selected.parked)for(let n of this.classifications.parked)t.delete(n);this.selectedScreens=Array.from(t)})}dataURI(t){var e;return Km(this,void 0,void 0,function*(){const n=yield t.arrayBuffer();let s=null===(e=t.name.split(".").reverse()[0])||void 0===e?void 0:e.toLocaleLowerCase();return["jpg","jpeg","png","gif","bmp"].some(t=>t===s)||(s="jpg"),`data:image/${encodeURIComponent(s)};base64,${A_.encode(n)}`})}eyeballPercent(){return this.eyeballedCount/this.imageCount*100}restart(){window.location.reload()}exportResults(){return Km(this,void 0,void 0,function*(){const t=this.selectedScreens.join("\n"),e=new Blob([t],{type:"text/csv"}),n=window.URL.createObjectURL(e);window.open(n)})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["app-eyeballer"]],decls:15,vars:4,consts:[["color","primary","fxLayout","row","fxLayoutAlign","start center",1,"app-toolbar"],["src","assets/eyeballer_logo.png","width","46","height","60"],["fxFlex",""],["mat-raised-button","",3,"click"],[1,"fas","fa-fw","fa-undo"],[4,"ngIf"],["mode","indeterminate"],[3,"change"],[2,"font-weight","bold"],["href","https://github.com/BishopFox/eyeballer","target","_blank","rel","noopener noreferrer"],["mode","determinate",3,"value"],[1,"results-container"],[2,"height","40px"],[1,"button-spacer"],["mat-raised-button","","color","primary",1,"label-button",3,"disabled","click"],["mat-raised-button","","color","basic",1,"label-button",3,"disabled","click"],["mat-raised-button","","color","accent",1,"label-button",3,"disabled","click"],[1,"label-count"],["mat-raised-button","","color","primary","mat-raised-button","",1,"label-button",3,"disabled","click"],["mat-raised-button","","color","primary",1,"export-button",3,"click"],["href","https://github.com/BishopFox/eyeballer#what-the-labels-mean","target","_blank","rel","noopener noreferrer"]],template:function(t,e){1&t&&(Va(0,"mat-toolbar",0),Va(1,"h2"),Ua(2,"img",1),Wa(),_o(3," Eyeballer "),Ua(4,"span",2),Va(5,"span"),_o(6,"Bishop Fox R&D"),Wa(),Ua(7,"span",2),Va(8,"button",3),Ga("click",function(){return e.restart()}),Ua(9,"i",4),_o(10," Restart "),Wa(),Wa(),Ma(11,sY,2,0,"div",5),Ma(12,rY,23,0,"div",5),Ma(13,iY,9,3,"div",5),Ma(14,aY,70,21,"div",5)),2&t&&(di(11),za("ngIf",!e.tfFilesCompleted),di(1),za("ngIf",e.tfFilesCompleted&&!e.eyeballing&&!e.eyeballCompleted),di(1),za("ngIf",e.tfFilesCompleted&&e.eyeballing&&!e.eyeballCompleted),di(1),za("ngIf",e.tfFilesCompleted&&!e.eyeballing&&e.eyeballCompleted))},directives:[bx,Xd,dp,np,ly,Dc,Hb,dy,lg,ng,yx],styles:[".app-toolbar[_ngcontent-%COMP%]{position:fixed;position:-webkit-sticky;top:0;z-index:1000}.not-completed-container[_ngcontent-%COMP%]{display:grid;justify-items:center;align-items:center;grid-template-columns:1fr 1fr 1fr}.not-completed-message[_ngcontent-%COMP%]{grid-column:2/3;grid-row:2/3}.results-container[_ngcontent-%COMP%]{grid-template-columns:1fr}.eyeballed-class-container[_ngcontent-%COMP%], .results-container[_ngcontent-%COMP%]{display:grid;justify-items:center;align-items:center}.eyeballed-class-container[_ngcontent-%COMP%]{grid-template-columns:1fr 1fr 1fr 1fr;grid-gap:1em;margin:1em}.result-card[_ngcontent-%COMP%]{max-width:100%}.result-card[_ngcontent-%COMP%]:hover{background-color:#f5f5f5}.result-card[_ngcontent-%COMP%]:hover   img[_ngcontent-%COMP%]{opacity:.5}.result-card[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:none;position:absolute;top:50%;left:50%;width:70px;height:70px;z-index:10}.fill-remaining-space[_ngcontent-%COMP%]{flex:1 1 auto}.fill-space[_ngcontent-%COMP%]{flex:auto}.img-container[_ngcontent-%COMP%]{position:relative;text-align:center;color:#fff}.preview-image[_ngcontent-%COMP%]{width:100%}.webapp-label[_ngcontent-%COMP%]{background-color:#00f}.old-looking-label[_ngcontent-%COMP%], .webapp-label[_ngcontent-%COMP%]{color:#fff;margin-left:1px;margin-right:1px}.old-looking-label[_ngcontent-%COMP%]{background-color:green}.login-label[_ngcontent-%COMP%]{background-color:purple}.custom-404-label[_ngcontent-%COMP%], .login-label[_ngcontent-%COMP%]{color:#fff;margin-left:1px;margin-right:1px}.custom-404-label[_ngcontent-%COMP%]{background-color:orange}.parked-label[_ngcontent-%COMP%]{background-color:red;color:#fff;margin-left:1px;margin-right:1px}.label-count[_ngcontent-%COMP%]{margin-left:10px;width:50px!important;min-width:unset!important}.label-button[_ngcontent-%COMP%]{width:130px!important;min-width:unset!important}.button-spacer[_ngcontent-%COMP%]{flex:1 1 auto}.export-button[_ngcontent-%COMP%]{margin-right:10px}"]}),t})()}];let lY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[w_.forRoot(oY,{relativeLinkResolution:"legacy"})],w_]}),t})(),uY=(()=>{class t{constructor(){this.title="weballer"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["app-root"]],decls:2,vars:0,template:function(t,e){1&t&&(Va(0,"router-outlet"),Ua(1,"router-outlet"),Wa())},directives:[h_],styles:[""]}),t})(),cY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t,bootstrap:[uY]}),t.\u0275inj=Vt({providers:[],imports:[[xh,lY,cg,qm,Cx,Sp]]}),t})();(function(){if(qu)throw new Error("Cannot enable prod mode after platform setup.");Gu=!1})(),yh().bootstrapModule(cY).catch(t=>console.error(t))},zn8P:function(t,e){function n(t){return Promise.resolve().then(function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}n.keys=function(){return[]},n.resolve=n,t.exports=n,n.id="zn8P"}},[[0,0]]]);