(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(t,e,n){t.exports=n("zUnb")},1:function(t,e){},2:function(t,e){},3:function(t,e){},4:function(t,e){},5:function(t,e){},B9Yq:function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},EhIR:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e,n=this,s=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var s=.02519603282416938*(e+=t.charCodeAt(n));s-=e=s>>>0,e=(s*=e)>>>0,e+=4294967296*(s-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(t),n.s0<0&&(n.s0+=1),n.s1-=s(t),n.s1<0&&(n.s1+=1),n.s2-=s(t),n.s2<0&&(n.s2+=1),s=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),s=e&&e.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},PDX0:function(t,e){(function(e){t.exports=e}).call(this,{})},YSVl:function(t,e,n){var s=n("EhIR"),r=n("uDiL"),i=n("pJ6O"),a=n("yuCN"),o=n("euyF"),l=n("ie1u"),u=n("pJ3+");u.alea=s,u.xor128=r,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},YuTi:function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},euyF:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this;e.next=function(){var t,n,s=e.w,r=e.X,i=e.i;return e.w=s=s+1640531527|0,n=r[i+34&127],t=r[i=i+1&127],n^=n<<13,t^=t<<17,n=r[i]=(n^=n>>>15)^(t^=t>>>12),e.i=i,n+(s^s>>>16)|0},function(t,e){var n,s,r,i,a,o=[],l=128;for(e===(0|e)?(s=e,e=null):(e+="\0",s=0,l=Math.max(l,e.length)),r=0,i=-32;i<l;++i)e&&(s^=e.charCodeAt((i+32)%e.length)),0===i&&(a=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,i>=0&&(r=0==(n=o[127&i]^=s+(a=a+1640531527|0))?r+1:0);for(r>=128&&(o[127&(e&&e.length||0)]=-1),r=127,i=512;i>0;--i)s=o[r+34&127],n=o[r=r+1&127],s^=s<<13,n^=n<<17,o[r]=(s^=s>>>15)^(n^=n>>>12);t.w=a,t.X=o,t.i=r}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.X&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},g5Dd:function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),s=0;s<t.length;s++)n[t.charCodeAt(s)]=s;e.encode=function(e){var n,s=new Uint8Array(e),r=s.length,i="";for(n=0;n<r;n+=3)i+=t[s[n]>>2],i+=t[(3&s[n])<<4|s[n+1]>>4],i+=t[(15&s[n+1])<<2|s[n+2]>>6],i+=t[63&s[n+2]];return r%3==2?i=i.substring(0,i.length-1)+"=":r%3==1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,s,r,i,a,o=.75*t.length,l=t.length,u=0;"="===t[t.length-1]&&(o--,"="===t[t.length-2]&&o--);var c=new ArrayBuffer(o),h=new Uint8Array(c);for(e=0;e<l;e+=4)s=n[t.charCodeAt(e)],r=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],a=n[t.charCodeAt(e+3)],h[u++]=s<<2|r>>4,h[u++]=(15&r)<<4|i>>2,h[u++]=(3&i)<<6|63&a;return c}}()},ie1u:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,s=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-s|0,e.d=s<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var s=0;s<n.length+20;s++)e.b^=0|n.charCodeAt(s),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},"pJ3+":function(t,e,n){var s;!function(r,i){var a,o=this,l=i.pow(256,6),u=i.pow(2,52),c=2*u;function h(t,e,n){var s=[],h=m(f((e=1==e?{entropy:!0}:e||{}).entropy?[t,g(r)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(256):(t=new Uint8Array(256),(o.crypto||o.msCrypto).getRandomValues(t)),g(t)}catch(s){var e=o.navigator,n=e&&e.plugins;return[+new Date,o,n,o.screen,g(r)]}}():t,3),s),y=new d(s),b=function(){for(var t=y.g(6),e=l,n=0;t<u;)t=256*(t+n),e*=256,n=y.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return b.int32=function(){return 0|y.g(4)},b.quick=function(){return y.g(4)/4294967296},b.double=b,m(g(y.S),r),(e.pass||n||function(t,e,n,s){return s&&(s.S&&p(s,y),t.state=function(){return p(y,{})}),n?(i.random=t,e):t})(b,h,"global"in e?e.global:this==i,e.state)}function d(t){var e,n=t.length,s=this,r=0,i=s.i=s.j=0,a=s.S=[];for(n||(t=[n++]);r<256;)a[r]=r++;for(r=0;r<256;r++)a[r]=a[i=255&i+t[r%n]+(e=a[r])],a[i]=e;(s.g=function(t){for(var e,n=0,r=s.i,i=s.j,a=s.S;t--;)e=a[r=255&r+1],n=256*n+a[255&(a[r]=a[i=255&i+e])+(a[i]=e)];return s.i=r,s.j=i,n})(256)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){var n,s=[],r=typeof t;if(e&&"object"==r)for(n in t)try{s.push(f(t[n],e-1))}catch(i){}return s.length?s:"string"==r?t:t+"\0"}function m(t,e){for(var n,s=t+"",r=0;r<s.length;)e[255&r]=255&(n^=19*e[255&r])+s.charCodeAt(r++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=h,m(i.random(),r),t.exports){t.exports=h;try{a=n(3)}catch(y){}}else void 0===(s=(function(){return h}).call(e,n,e,t))||(t.exports=s)}([],Math)},pJ6O:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),s==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},uDiL:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var s=0;s<n.length+64;s++)e.x^=0|n.charCodeAt(s),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},yuCN:function(t,e,n){(function(t){var s;!function(t,r,i){function a(t){var e=this;e.next=function(){var t,n,s=e.x,r=e.i;return t=s[r],n=(t^=t>>>7)^t<<24,n^=(t=s[r+1&7])^t>>>10,n^=(t=s[r+3&7])^t>>>3,n^=(t=s[r+4&7])^t<<7,t=s[r+7&7],s[r]=n^=(t^=t<<13)^t<<9,e.i=r+1&7,n},function(t,e){var n,s=[];if(e===(0|e))s[0]=e;else for(e=""+e,n=0;n<e.length;++n)s[7&n]=s[7&n]<<15^e.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n&&(s[7]=-1),t.x=s,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),s=e&&e.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},r.int32=n.next,r.quick=r,s&&(s.x&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=l:n("B9Yq")&&n("PDX0")?void 0===(s=(function(){return l}).call(e,n,e,r))||(r.exports=s):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},zUnb:function(t,e,n){"use strict";n.r(e);var s={};n.r(s),n.d(s,"shuffle",function(){return G_}),n.d(s,"shuffleCombo",function(){return q_}),n.d(s,"clamp",function(){return K_}),n.d(s,"nearestLargerEven",function(){return X_}),n.d(s,"sum",function(){return Q_}),n.d(s,"randUniform",function(){return Y_}),n.d(s,"distSquared",function(){return Z_}),n.d(s,"assert",function(){return J_}),n.d(s,"assertShapesMatch",function(){return tk}),n.d(s,"assertNonNull",function(){return ek}),n.d(s,"flatten",function(){return nk}),n.d(s,"sizeFromShape",function(){return sk}),n.d(s,"isScalarShape",function(){return rk}),n.d(s,"arraysEqual",function(){return ik}),n.d(s,"isInt",function(){return ak}),n.d(s,"tanh",function(){return ok}),n.d(s,"sizeToSquarishShape",function(){return lk}),n.d(s,"createShuffledIndices",function(){return uk}),n.d(s,"rightPad",function(){return ck}),n.d(s,"repeatedTry",function(){return hk}),n.d(s,"inferFromImplicitShape",function(){return dk}),n.d(s,"parseAxisParam",function(){return pk}),n.d(s,"squeezeShape",function(){return fk}),n.d(s,"getTypedArrayFromDType",function(){return mk}),n.d(s,"getArrayFromDType",function(){return gk}),n.d(s,"checkConversionForErrors",function(){return yk}),n.d(s,"isValidDtype",function(){return bk}),n.d(s,"hasEncodingLoss",function(){return xk}),n.d(s,"isTypedArray",function(){return vk}),n.d(s,"bytesPerElement",function(){return wk}),n.d(s,"bytesFromStringArray",function(){return _k}),n.d(s,"isString",function(){return kk}),n.d(s,"isBoolean",function(){return Sk}),n.d(s,"isNumber",function(){return Ck}),n.d(s,"inferDtype",function(){return Ik}),n.d(s,"isFunction",function(){return Nk}),n.d(s,"nearestDivisor",function(){return Ek}),n.d(s,"computeStrides",function(){return Tk}),n.d(s,"toNestedArray",function(){return $k}),n.d(s,"makeOnesTypedArray",function(){return Rk}),n.d(s,"makeZerosTypedArray",function(){return Fk}),n.d(s,"makeZerosNestedTypedArray",function(){return Dk}),n.d(s,"assertNonNegativeIntegerDimensions",function(){return Ok}),n.d(s,"locToIndex",function(){return Lk}),n.d(s,"indexToLoc",function(){return Mk}),n.d(s,"isPromise",function(){return Pk}),n.d(s,"createScalarValue",function(){return Jk}),n.d(s,"toTypedArray",function(){return tS}),n.d(s,"now",function(){return eS}),n.d(s,"fetch",function(){return nS}),n.d(s,"encodeString",function(){return sS}),n.d(s,"decodeString",function(){return rS});var r={};n.r(r),n.d(r,"makeTypesMatch",function(){return ES}),n.d(r,"assertTypesMatch",function(){return TS}),n.d(r,"isTensorInList",function(){return AS}),n.d(r,"getTensorsInContainer",function(){return $S});var i={};n.r(i),n.d(i,"isMobile",function(){return zS}),n.d(i,"isBrowser",function(){return BS});var a={};n.r(a),n.d(a,"copyModel",function(){return FC}),n.d(a,"listModels",function(){return $C}),n.d(a,"moveModel",function(){return DC}),n.d(a,"removeModel",function(){return RC}),n.d(a,"browserFiles",function(){return UC}),n.d(a,"browserHTTPRequest",function(){return ZC}),n.d(a,"concatenateArrayBuffers",function(){return sC}),n.d(a,"decodeWeights",function(){return JS}),n.d(a,"encodeWeights",function(){return ZS}),n.d(a,"fromMemory",function(){return eI}),n.d(a,"getLoadHandlers",function(){return hC}),n.d(a,"getModelArtifactsInfoForJSON",function(){return iC}),n.d(a,"getSaveHandlers",function(){return cC}),n.d(a,"http",function(){return YC}),n.d(a,"isHTTPScheme",function(){return XC}),n.d(a,"loadWeights",function(){return GC}),n.d(a,"registerLoadRouter",function(){return uC}),n.d(a,"registerSaveRouter",function(){return lC}),n.d(a,"weightsLoaderFactory",function(){return qC}),n.d(a,"withSaveHandler",function(){return nI});var o={};n.r(o),n.d(o,"fromPixelsAsync",function(){return iI}),n.d(o,"toPixels",function(){return aI}),n.d(o,"fromPixels",function(){return oI});var l={};n.r(l),n.d(l,"assertParamsValid",function(){return lI}),n.d(l,"maskToAxes",function(){return uI}),n.d(l,"computeOutShape",function(){return cI}),n.d(l,"stridesWithElidedDims",function(){return hI}),n.d(l,"getNormalizedAxes",function(){return fI}),n.d(l,"startIndicesWithElidedDims",function(){return mI}),n.d(l,"stopIndicesWithElidedDims",function(){return gI}),n.d(l,"stridesForAxis",function(){return yI}),n.d(l,"startForAxis",function(){return bI}),n.d(l,"stopForAxis",function(){return xI}),n.d(l,"isSliceContinous",function(){return vI}),n.d(l,"computeFlatOffset",function(){return wI}),n.d(l,"parseSliceParams",function(){return _I}),n.d(l,"sliceInfo",function(){return kI});var u={};n.r(u),n.d(u,"Serializable",function(){return SI}),n.d(u,"SerializationMap",function(){return CI}),n.d(u,"registerClass",function(){return II});var c={};n.r(c),n.d(c,"conv2d",function(){return rT}),n.d(c,"depthwiseConv2d",function(){return oT}),n.d(c,"matMul",function(){return uT});var h={};n.r(h),n.d(h,"segOpComputeOptimalWindowSize",function(){return TA}),n.d(h,"computeOutShape",function(){return AA}),n.d(h,"collectGatherOpShapeInfo",function(){return $A});var d={};n.r(d),n.d(d,"axesAreInnerMostDims",function(){return XN}),n.d(d,"combineLocations",function(){return QN}),n.d(d,"computeOutAndReduceShapes",function(){return YN}),n.d(d,"expandShapeToKeepDim",function(){return ZN}),n.d(d,"assertAxesAreInnerMostDims",function(){return JN}),n.d(d,"getAxesPermutation",function(){return tE}),n.d(d,"getUndoAxesPermutation",function(){return eE}),n.d(d,"getInnerMostAxes",function(){return nE}),n.d(d,"getBroadcastDims",function(){return _N}),n.d(d,"getReductionAxes",function(){return kN}),n.d(d,"assertAndGetBroadcastShape",function(){return SN}),n.d(d,"assertParamsConsistent",function(){return QT}),n.d(d,"computeOutShape",function(){return YT}),n.d(d,"computeDilation2DInfo",function(){return VI}),n.d(d,"computePool2DInfo",function(){return WI}),n.d(d,"computePool3DInfo",function(){return UI}),n.d(d,"computeConv2DInfo",function(){return jI}),n.d(d,"computeConv3DInfo",function(){return HI}),n.d(d,"computeDefaultPad",function(){return GI}),n.d(d,"tupleValuesAreOne",function(){return YI}),n.d(d,"eitherStridesOrDilationsAreOne",function(){return ZI}),n.d(d,"convertConv2DDataFormat",function(){return JI}),n.d(d,"getFusedDyActivation",function(){return tT}),n.d(d,"getFusedBiasGradient",function(){return eT}),n.d(d,"applyActivation",function(){return nT}),n.d(d,"shouldFuse",function(){return sT}),n.d(d,"PARALLELIZE_THRESHOLD",function(){return ZT}),n.d(d,"computeOptimalWindowSize",function(){return JT}),n.d(d,"slice_util",function(){return l}),n.d(d,"upcastType",function(){return IS}),n.d(d,"getImageCenter",function(){return tA}),n.d(d,"getReshaped",function(){return eA}),n.d(d,"getPermuted",function(){return nA}),n.d(d,"getReshapedPermuted",function(){return sA}),n.d(d,"getSliceBeginCoords",function(){return rA}),n.d(d,"getSliceSize",function(){return iA}),n.d(d,"prepareAndValidate",function(){return aA}),n.d(d,"validateUpdateShape",function(){return oA}),n.d(d,"validateInput",function(){return lA}),n.d(d,"calculateShapes",function(){return uA}),n.d(d,"SELU_SCALEALPHA",function(){return cA}),n.d(d,"SELU_SCALE",function(){return hA}),n.d(d,"ERF_P",function(){return dA}),n.d(d,"ERF_A1",function(){return pA}),n.d(d,"ERF_A2",function(){return fA}),n.d(d,"ERF_A3",function(){return mA}),n.d(d,"ERF_A4",function(){return gA}),n.d(d,"ERF_A5",function(){return yA}),n.d(d,"warn",function(){return bA}),n.d(d,"log",function(){return xA}),n.d(d,"mergeRealAndImagArrays",function(){return vA}),n.d(d,"splitRealAndImagArrays",function(){return wA}),n.d(d,"complexWithEvenIndex",function(){return _A}),n.d(d,"complexWithOddIndex",function(){return kA}),n.d(d,"getComplexWithIndex",function(){return SA}),n.d(d,"assignToTypedArray",function(){return CA}),n.d(d,"exponents",function(){return IA}),n.d(d,"exponent",function(){return NA}),n.d(d,"prepareSplitSize",function(){return EA}),n.d(d,"segment_util",function(){return h}),n.d(d,"fromUint8ToStringArray",function(){return RA}),n.d(d,"fromStringArrayToUint8",function(){return FA});var p={};n.r(p),n.d(p,"nonMaxSuppressionV3Impl",function(){return gT}),n.d(p,"nonMaxSuppressionV4Impl",function(){return yT}),n.d(p,"nonMaxSuppressionV5Impl",function(){return bT}),n.d(p,"whereImpl",function(){return DA});var f={};n.r(f),n.d(f,"json",function(){return RP});var m={};n.r(m),n.d(m,"json",function(){return FP});var g={};n.r(g),n.d(g,"json",function(){return DP});var y={};n.r(y),n.d(y,"json",function(){return OP});var b={};n.r(b),n.d(b,"json",function(){return LP});var x={};n.r(x),n.d(x,"json",function(){return MP});var v={};n.r(v),n.d(v,"json",function(){return PP});var w={};n.r(w),n.d(w,"json",function(){return zP});var _={};n.r(_),n.d(_,"json",function(){return BP});var k={};n.r(k),n.d(k,"json",function(){return VP});var S={};n.r(S),n.d(S,"json",function(){return WP});var C={};n.r(C),n.d(C,"json",function(){return UP});var I={};n.r(I),n.d(I,"json",function(){return jP});var N={};n.r(N),n.d(N,"json",function(){return HP});var E={};n.r(E),n.d(E,"json",function(){return GP});var T={};n.r(T),n.d(T,"json",function(){return qP});var A={};n.r(A),n.d(A,"json",function(){return KP});var $={};function R(t){return"function"==typeof t}n.r($),n.d($,"simpleAbsImpl",function(){return lB}),n.d($,"addImpl",function(){return Jz}),n.d($,"bincountImpl",function(){return MB}),n.d($,"bincountReduceImpl",function(){return PB}),n.d($,"ceilImpl",function(){return VB}),n.d($,"concatImpl",function(){return HB}),n.d($,"expImpl",function(){return NV}),n.d($,"expm1Impl",function(){return RV}),n.d($,"floorImpl",function(){return YV}),n.d($,"gatherV2Impl",function(){return sW}),n.d($,"greaterImpl",function(){return iW}),n.d($,"lessImpl",function(){return dW}),n.d($,"linSpaceImpl",function(){return mW}),n.d($,"logImpl",function(){return yW}),n.d($,"maxImpl",function(){return CW}),n.d($,"maximumImpl",function(){return EW}),n.d($,"minimumImpl",function(){return zW}),n.d($,"multiplyImpl",function(){return DV}),n.d($,"negImpl",function(){return GW}),n.d($,"notEqualImpl",function(){return tU}),n.d($,"prodImpl",function(){return cU}),n.d($,"rangeImpl",function(){return dU}),n.d($,"rsqrtImpl",function(){return _U}),n.d($,"sliceImpl",function(){return FB}),n.d($,"squaredDifferenceImpl",function(){return VU}),n.d($,"stridedSliceImpl",function(){return jU}),n.d($,"subImpl",function(){return BV}),n.d($,"tileImpl",function(){return KU}),n.d($,"topKImpl",function(){return XU}),n.d($,"transposeImpl",function(){return pB}),n.d($,"uniqueImpl",function(){return tj});let F=!1;const D={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else F&&console.log("RxJS: Back to a better error behavior. Thank you. <3");F=t},get useDeprecatedSynchronousErrorHandling(){return F}};function O(t){setTimeout(()=>{throw t},0)}const L={closed:!0,next(t){},error(t){if(D.useDeprecatedSynchronousErrorHandling)throw t;O(t)},complete(){}},M=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function P(t){return null!==t&&"object"==typeof t}const z=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let B=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:s,_unsubscribe:r,_subscriptions:i}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if(R(r)){s&&(this._unsubscribe=void 0);try{r.call(this)}catch(a){e=a instanceof z?V(a.errors):[a]}}if(M(i)){let t=-1,n=i.length;for(;++t<n;){const n=i[t];if(P(n))try{n.unsubscribe()}catch(a){e=e||[],a instanceof z?e=e.concat(V(a.errors)):e.push(a)}}}if(e)throw new z(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:s}=n;if(null===s)n._parentOrParents=this;else if(s instanceof t){if(s===this)return n;n._parentOrParents=[s,this]}else{if(-1!==s.indexOf(this))return n;s.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function V(t){return t.reduce((t,e)=>t.concat(e instanceof z?e.errors:e),[])}const W=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class U extends B{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=L;break;case 1:if(!t){this.destination=L;break}if("object"==typeof t){t instanceof U?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new j(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new j(this,t,e,n)}}[W](){return this}static create(t,e,n){const s=new U(t,e,n);return s.syncErrorThrowable=!1,s}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class j extends U{constructor(t,e,n,s){let r;super(),this._parentSubscriber=t;let i=this;R(e)?r=e:e&&(r=e.next,n=e.error,s=e.complete,e!==L&&(i=Object.create(e),R(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=r,this._error=n,this._complete=s}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;D.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=D;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):O(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;O(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);D.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),D.useDeprecatedSynchronousErrorHandling)throw n;O(n)}}__tryOrSetError(t,e,n){if(!D.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(s){return D.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=s,t.syncErrorThrown=!0,!0):(O(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const H=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function G(t){return t}let q=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:s}=this,r=function(t,e,n){if(t){if(t instanceof U)return t;if(t[W])return t[W]()}return t||e||n?new U(t,e,n):new U(L)}(t,e,n);if(r.add(s?s.call(r,this.source):this.source||D.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),D.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(t){try{return this._subscribe(t)}catch(e){D.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:s}=t;if(e||s)return!1;t=n&&n instanceof U?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=K(e))((e,n)=>{let s;s=this.subscribe(e=>{try{t(e)}catch(r){n(r),s&&s.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[H](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?G:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=K(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function K(t){if(t||(t=D.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const X=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class Q extends B{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class Y extends U{constructor(t){super(t),this.destination=t}}let Z=(()=>{class t extends q{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[W](){return new Y(this)}lift(t){const e=new J(this,this);return e.operator=t,e}next(t){if(this.closed)throw new X;if(!this.isStopped){const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].next(t)}}error(t){if(this.closed)throw new X;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,s=e.slice();for(let r=0;r<n;r++)s[r].error(t);this.observers.length=0}complete(){if(this.closed)throw new X;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let s=0;s<e;s++)n[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new X;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new X;return this.hasError?(t.error(this.thrownError),B.EMPTY):this.isStopped?(t.complete(),B.EMPTY):(this.observers.push(t),new Q(this,t))}asObservable(){const t=new q;return t.source=this,t}}return t.create=(t,e)=>new J(t,e),t})();class J extends Z{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):B.EMPTY}}function tt(t){return t&&"function"==typeof t.schedule}function et(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new nt(t,e))}}class nt{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new st(t,this.project,this.thisArg))}}class st extends U{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const rt=t=>e=>{for(let n=0,s=t.length;n<s&&!e.closed;n++)e.next(t[n]);e.complete()};function it(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const at=it(),ot=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function lt(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const ut=t=>{if(t&&"function"==typeof t[H])return s=t,t=>{const e=s[H]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(ot(t))return rt(t);if(lt(t))return n=t,t=>(n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,O),t);if(t&&"function"==typeof t[at])return e=t,t=>{const n=e[at]();for(;;){let e;try{e=n.next()}catch(s){return t.error(s),t}if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=P(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n,s};function ct(t,e){return new q(n=>{const s=new B;let r=0;return s.add(e.schedule(function(){r!==t.length?(n.next(t[r++]),n.closed||s.add(this.schedule())):n.complete()})),s})}function ht(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[H]}(t))return function(t,e){return new q(n=>{const s=new B;return s.add(e.schedule(()=>{const r=t[H]();s.add(r.subscribe({next(t){s.add(e.schedule(()=>n.next(t)))},error(t){s.add(e.schedule(()=>n.error(t)))},complete(){s.add(e.schedule(()=>n.complete()))}}))})),s})}(t,e);if(lt(t))return function(t,e){return new q(n=>{const s=new B;return s.add(e.schedule(()=>t.then(t=>{s.add(e.schedule(()=>{n.next(t),s.add(e.schedule(()=>n.complete()))}))},t=>{s.add(e.schedule(()=>n.error(t)))}))),s})}(t,e);if(ot(t))return ct(t,e);if(function(t){return t&&"function"==typeof t[at]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new q(n=>{const s=new B;let r;return s.add(()=>{r&&"function"==typeof r.return&&r.return()}),s.add(e.schedule(()=>{r=t[at](),s.add(e.schedule(function(){if(n.closed)return;let t,e;try{const n=r.next();t=n.value,e=n.done}catch(s){return void n.error(s)}e?n.complete():(n.next(t),this.schedule())}))})),s})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof q?t:new q(ut(t))}class dt extends U{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class pt extends U{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function ft(t,e){if(!e.closed)return t instanceof q?t.subscribe(e):ut(t)(e)}function mt(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?s=>s.pipe(mt((n,s)=>ht(t(n,s)).pipe(et((t,r)=>e(n,t,s,r))),n)):("number"==typeof e&&(n=e),e=>e.lift(new gt(t,n)))}class gt{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new yt(t,this.project,this.concurrent))}}class yt extends pt{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(e)}_innerSub(t){const e=new dt(this),n=this.destination;n.add(e);const s=ft(t,e);s!==e&&n.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function bt(t=Number.POSITIVE_INFINITY){return mt(G,t)}function xt(t,e){return e?ct(t,e):new q(rt(t))}function vt(...t){let e=Number.POSITIVE_INFINITY,n=null,s=t[t.length-1];return tt(s)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof s&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof q?t[0]:bt(e)(xt(t,n))}function wt(){return function(t){return t.lift(new _t(t))}}class _t{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const s=new kt(t,n),r=e.subscribe(s);return s.closed||(s.connection=n.connect()),r}}class kt extends U{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,s=t._connection;this.connection=null,!s||n&&s!==n||s.unsubscribe()}}class St extends q{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new B,t.add(this.source.subscribe(new It(this.getSubject(),this))),t.closed&&(this._connection=null,t=B.EMPTY)),t}refCount(){return wt()(this)}}const Ct=(()=>{const t=St.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class It extends Y{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function Nt(){return new Z}function Et(t){for(let e in t)if(t[e]===Et)return e;throw Error("Could not find renamed property on target object.")}function Tt(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function At(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(At).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function $t(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const Rt=Et({__forward_ref__:Et});function Ft(t){return t.__forward_ref__=Ft,t.toString=function(){return At(this())},t}function Dt(t){return Ot(t)?t():t}function Ot(t){return"function"==typeof t&&t.hasOwnProperty(Rt)&&t.__forward_ref__===Ft}class Lt extends Error{constructor(t,e){super(function(t,e){return`${t?`NG0${t}: `:""}${e}`}(t,e)),this.code=t}}function Mt(t){return"string"==typeof t?t:null==t?"":String(t)}function Pt(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():Mt(t)}function zt(t,e){const n=e?` in ${e}`:"";throw new Lt("201",`No provider for ${Pt(t)} found${n}`)}function Bt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Vt(t){return{providers:t.providers||[],imports:t.imports||[]}}function Wt(t){return Ut(t,Ht)||Ut(t,qt)}function Ut(t,e){return t.hasOwnProperty(e)?t[e]:null}function jt(t){return t&&(t.hasOwnProperty(Gt)||t.hasOwnProperty(Kt))?t[Gt]:null}const Ht=Et({"\u0275prov":Et}),Gt=Et({"\u0275inj":Et}),qt=Et({ngInjectableDef:Et}),Kt=Et({ngInjectorDef:Et});var Xt=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});let Qt;function Yt(t){const e=Qt;return Qt=t,e}function Zt(t,e,n){const s=Wt(t);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:n&Xt.Optional?null:void 0!==e?e:void zt(At(t),"Injector")}function Jt(t){return{toString:t}.toString()}var te=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),ee=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const ne="undefined"!=typeof globalThis&&globalThis,se="undefined"!=typeof window&&window,re="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,ie="undefined"!=typeof global&&global,ae=ne||ie||se||re,oe={},le=[],ue=[],ce=Et({"\u0275cmp":Et}),he=Et({"\u0275dir":Et}),de=Et({"\u0275pipe":Et}),pe=Et({"\u0275mod":Et}),fe=Et({"\u0275loc":Et}),me=Et({"\u0275fac":Et}),ge=Et({__NG_ELEMENT_ID__:Et});let ye=0;function be(t){return Jt(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===te.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||ue,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||ee.Emulated,id:"c",styles:t.styles||ue,_:null,setInput:null,schemas:t.schemas||null,tView:null},s=t.directives,r=t.features,i=t.pipes;return n.id+=ye++,n.inputs=ke(t.inputs,e),n.outputs=ke(t.outputs),r&&r.forEach(t=>t(n)),n.directiveDefs=s?()=>("function"==typeof s?s():s).map(xe):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(ve):null,n})}function xe(t){return Ce(t)||function(t){return t[he]||null}(t)}function ve(t){return function(t){return t[de]||null}(t)}const we={};function _e(t){const e={type:t.type,bootstrap:t.bootstrap||ue,declarations:t.declarations||ue,imports:t.imports||ue,exports:t.exports||ue,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&Jt(()=>{we[t.id]=t.type}),e}function ke(t,e){if(null==t)return oe;const n={};for(const s in t)if(t.hasOwnProperty(s)){let r=t[s],i=r;Array.isArray(r)&&(i=r[1],r=r[0]),n[r]=s,e&&(e[r]=i)}return n}const Se=be;function Ce(t){return t[ce]||null}function Ie(t,e){const n=t[pe]||null;if(!n&&!0===e)throw new Error(`Type ${At(t)} does not have '\u0275mod' property.`);return n}function Ne(t){return Array.isArray(t)&&"object"==typeof t[1]}function Ee(t){return Array.isArray(t)&&!0===t[1]}function Te(t){return 0!=(8&t.flags)}function Ae(t){return 2==(2&t.flags)}function $e(t){return 1==(1&t.flags)}function Re(t){return null!==t.template}function Fe(t,e){return t.hasOwnProperty(me)?t[me]:null}class De{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function Oe(){return Le}function Le(t){return t.type.prototype.ngOnChanges&&(t.setInput=Pe),Me}function Me(){const t=ze(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===oe)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function Pe(t,e,n,s){const r=ze(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:oe,current:null}),i=r.current||(r.current={}),a=r.previous,o=this.declaredInputs[n],l=a[o];i[o]=new De(l&&l.currentValue,e,a===oe),t[s]=e}function ze(t){return t.__ngSimpleChanges__||null}let Be;function Ve(t){return!!t.listen}Oe.ngInherit=!0;const We={createRenderer:(t,e)=>void 0!==Be?Be:"undefined"!=typeof document?document:void 0};function Ue(t){for(;Array.isArray(t);)t=t[0];return t}function je(t,e){return Ue(e[t])}function He(t,e){return Ue(e[t.index])}function Ge(t,e){return t.data[e]}function qe(t,e){const n=e[t];return Ne(n)?n:n[0]}function Ke(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function Xe(t){return 4==(4&t[2])}function Qe(t){return 128==(128&t[2])}function Ye(t,e){return null==e?null:t[e]}function Ze(t){t[18]=0}function Je(t,e){t[5]+=e;let n=t,s=t[3];for(;null!==s&&(1===e&&1===n[5]||-1===e&&0===n[5]);)s[5]+=e,n=s,s=s[3]}const tn={lFrame:Sn(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function en(){return tn.bindingsEnabled}function nn(){return tn.lFrame.lView}function sn(){return tn.lFrame.tView}function rn(t){tn.lFrame.contextLView=t}function an(){let t=on();for(;null!==t&&64===t.type;)t=t.parent;return t}function on(){return tn.lFrame.currentTNode}function ln(t,e){const n=tn.lFrame;n.currentTNode=t,n.isParent=e}function un(){return tn.lFrame.isParent}function cn(){tn.lFrame.isParent=!1}function hn(){return tn.isInCheckNoChangesMode}function dn(t){tn.isInCheckNoChangesMode=t}function pn(){return tn.lFrame.bindingIndex++}function fn(t){const e=tn.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+t,n}function mn(t,e){const n=tn.lFrame;n.bindingIndex=n.bindingRootIndex=t,gn(e)}function gn(t){tn.lFrame.currentDirectiveIndex=t}function yn(t){const e=tn.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function bn(){return tn.lFrame.currentQueryIndex}function xn(t){tn.lFrame.currentQueryIndex=t}function vn(t){const e=t[1];return 2===e.type?e.declTNode:1===e.type?t[6]:null}function wn(t,e,n){if(n&Xt.SkipSelf){let s=e,r=t;for(;s=s.parent,!(null!==s||n&Xt.Host||(s=vn(r),null===s)||(r=r[15],10&s.type)););if(null===s)return!1;e=s,t=r}const s=tn.lFrame=kn();return s.currentTNode=e,s.lView=t,!0}function _n(t){const e=kn(),n=t[1];tn.lFrame=e,e.currentTNode=n.firstChild,e.lView=t,e.tView=n,e.contextLView=t,e.bindingIndex=n.bindingStartIndex,e.inI18n=!1}function kn(){const t=tn.lFrame,e=null===t?null:t.child;return null===e?Sn(t):e}function Sn(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function Cn(){const t=tn.lFrame;return tn.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const In=Cn;function Nn(){const t=Cn();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function En(){return tn.lFrame.selectedIndex}function Tn(t){tn.lFrame.selectedIndex=t}function An(){const t=tn.lFrame;return Ge(t.tView,t.selectedIndex)}function $n(){tn.lFrame.currentNamespace="http://www.w3.org/2000/svg"}function Rn(t,e){for(let n=e.directiveStart,s=e.directiveEnd;n<s;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:r,ngAfterViewInit:i,ngAfterViewChecked:a,ngOnDestroy:o}=e;s&&(t.contentHooks||(t.contentHooks=[])).push(-n,s),r&&((t.contentHooks||(t.contentHooks=[])).push(n,r),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,r)),i&&(t.viewHooks||(t.viewHooks=[])).push(-n,i),a&&((t.viewHooks||(t.viewHooks=[])).push(n,a),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,a)),null!=o&&(t.destroyHooks||(t.destroyHooks=[])).push(n,o)}}function Fn(t,e,n){Ln(t,e,3,n)}function Dn(t,e,n,s){(3&t[2])===n&&Ln(t,e,n,s)}function On(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function Ln(t,e,n,s){const r=null!=s?s:-1,i=e.length-1;let a=0;for(let o=void 0!==s?65535&t[18]:0;o<i;o++)if("number"==typeof e[o+1]){if(a=e[o],null!=s&&a>=s)break}else e[o]<0&&(t[18]+=65536),(a<r||-1==r)&&(Mn(t,n,e,o),t[18]=(4294901760&t[18])+o+2),o++}function Mn(t,e,n,s){const r=n[s]<0,i=n[s+1],a=t[r?-n[s]:n[s]];r?t[2]>>11<t[18]>>16&&(3&t[2])===e&&(t[2]+=2048,i.call(a)):i.call(a)}class Pn{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function zn(t,e,n){const s=Ve(t);let r=0;for(;r<n.length;){const i=n[r];if("number"==typeof i){if(0!==i)break;r++;const a=n[r++],o=n[r++],l=n[r++];s?t.setAttribute(e,o,l,a):e.setAttributeNS(a,o,l)}else{const a=i,o=n[++r];Vn(a)?s&&t.setProperty(e,a,o):s?t.setAttribute(e,a,o):e.setAttribute(a,o),r++}}return r}function Bn(t){return 3===t||4===t||6===t}function Vn(t){return 64===t.charCodeAt(0)}function Wn(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let s=0;s<e.length;s++){const r=e[s];"number"==typeof r?n=r:0===n||Un(t,n,r,null,-1===n||2===n?e[++s]:null)}}return t}function Un(t,e,n,s,r){let i=0,a=t.length;if(-1===e)a=-1;else for(;i<t.length;){const n=t[i++];if("number"==typeof n){if(n===e){a=-1;break}if(n>e){a=i-1;break}}}for(;i<t.length;){const e=t[i];if("number"==typeof e)break;if(e===n){if(null===s)return void(null!==r&&(t[i+1]=r));if(s===t[i+1])return void(t[i+2]=r)}i++,null!==s&&i++,null!==r&&i++}-1!==a&&(t.splice(a,0,e),i=a+1),t.splice(i++,0,n),null!==s&&t.splice(i++,0,s),null!==r&&t.splice(i++,0,r)}function jn(t){return-1!==t}function Hn(t){return 32767&t}function Gn(t,e){let n=t>>16,s=e;for(;n>0;)s=s[15],n--;return s}let qn=!0;function Kn(t){const e=qn;return qn=t,e}let Xn=0;function Qn(t,e){const n=Zn(t,e);if(-1!==n)return n;const s=e[1];s.firstCreatePass&&(t.injectorIndex=e.length,Yn(s.data,t),Yn(e,null),Yn(s.blueprint,null));const r=Jn(t,e),i=t.injectorIndex;if(jn(r)){const t=Hn(r),n=Gn(r,e),s=n[1].data;for(let r=0;r<8;r++)e[i+r]=n[t+r]|s[t+r]}return e[i+8]=r,i}function Yn(t,e){t.push(0,0,0,0,0,0,0,0,e)}function Zn(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function Jn(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=0,s=null,r=e;for(;null!==r;){const t=r[1],e=t.type;if(s=2===e?t.declTNode:1===e?r[6]:null,null===s)return-1;if(n++,r=r[15],-1!==s.injectorIndex)return s.injectorIndex|n<<16}return-1}function ts(t,e,n){!function(t,e,n){let s;"string"==typeof n?s=n.charCodeAt(0)||0:n.hasOwnProperty(ge)&&(s=n[ge]),null==s&&(s=n[ge]=Xn++);const r=255&s;e.data[t+(r>>5)]|=1<<r}(t,e,n)}function es(t,e,n){if(n&Xt.Optional)return t;zt(e,"NodeInjector")}function ns(t,e,n,s){if(n&Xt.Optional&&void 0===s&&(s=null),0==(n&(Xt.Self|Xt.Host))){const r=t[9],i=Yt(void 0);try{return r?r.get(e,s,n&Xt.Optional):Zt(e,s,n&Xt.Optional)}finally{Yt(i)}}return es(s,e,n)}function ss(t,e,n,s=Xt.Default,r){if(null!==t){const i=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(ge)?t[ge]:void 0;return"number"==typeof e?e>=0?255&e:is:e}(n);if("function"==typeof i){if(!wn(e,t,s))return s&Xt.Host?es(r,n,s):ns(e,n,s,r);try{const t=i();if(null!=t||s&Xt.Optional)return t;zt(n)}finally{In()}}else if("number"==typeof i){let r=null,a=Zn(t,e),o=-1,l=s&Xt.Host?e[16][6]:null;for((-1===a||s&Xt.SkipSelf)&&(o=-1===a?Jn(t,e):e[a+8],-1!==o&&cs(s,!1)?(r=e[1],a=Hn(o),e=Gn(o,e)):a=-1);-1!==a;){const t=e[1];if(us(i,a,t.data)){const t=as(a,e,n,r,s,l);if(t!==rs)return t}o=e[a+8],-1!==o&&cs(s,e[1].data[a+8]===l)&&us(i,a,e)?(r=t,a=Hn(o),e=Gn(o,e)):a=-1}}}return ns(e,n,s,r)}const rs={};function is(){return new hs(an(),nn())}function as(t,e,n,s,r,i){const a=e[1],o=a.data[t+8],l=os(o,a,n,null==s?Ae(o)&&qn:s!=a&&0!=(3&o.type),r&Xt.Host&&i===o);return null!==l?ls(e,a,l,o):rs}function os(t,e,n,s,r){const i=t.providerIndexes,a=e.data,o=1048575&i,l=t.directiveStart,u=i>>20,c=r?o+u:t.directiveEnd;for(let h=s?o:o+u;h<c;h++){const t=a[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(r){const t=a[l];if(t&&Re(t)&&t.type===n)return l}return null}function ls(t,e,n,s){let r=t[n];const i=e.data;if(r instanceof Pn){const a=r;a.resolving&&function(t,e){throw new Lt("200",`Circular dependency in DI detected for ${t}`)}(Pt(i[n]));const o=Kn(a.canSeeViewProviders);a.resolving=!0;const l=a.injectImpl?Yt(a.injectImpl):null;wn(t,s,Xt.Default);try{r=t[n]=a.factory(void 0,i,t,s),e.firstCreatePass&&n>=s.directiveStart&&function(t,e,n){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:i}=e.type.prototype;if(s){const s=Le(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,r),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i))}(n,i[n],e)}finally{null!==l&&Yt(l),Kn(o),a.resolving=!1,In()}}return r}function us(t,e,n){return!!(n[e+(t>>5)]&1<<t)}function cs(t,e){return!(t&Xt.Self||t&Xt.Host&&e)}class hs{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return ss(this._tNode,this._lView,t,void 0,e)}}function ds(t){return Jt(()=>{const e=t.prototype.constructor,n=e[me]||ps(e),s=Object.prototype;let r=Object.getPrototypeOf(t.prototype).constructor;for(;r&&r!==s;){const t=r[me]||ps(r);if(t&&t!==n)return t;r=Object.getPrototypeOf(r)}return t=>new t})}function ps(t){return Ot(t)?()=>{const e=ps(Dt(t));return e&&e()}:Fe(t)}function fs(t,e,n){return Jt(()=>{const s=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function r(...t){if(this instanceof r)return s.apply(this,t),this;const e=new r(...t);return n.annotation=e,n;function n(t,n,s){const r=t.hasOwnProperty("__parameters__")?t.__parameters__:Object.defineProperty(t,"__parameters__",{value:[]}).__parameters__;for(;r.length<=s;)r.push(null);return(r[s]=r[s]||[]).push(e),t}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=t,r.annotationCls=r,r})}class ms{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Bt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const gs=new ms("AnalyzeForEntryComponents"),ys=Function;function bs(t,e){void 0===e&&(e=t);for(let n=0;n<t.length;n++){let s=t[n];Array.isArray(s)?(e===t&&(e=t.slice(0,n)),bs(s,e)):e!==t&&e.push(s)}return e}function xs(t,e){t.forEach(t=>Array.isArray(t)?xs(t,e):e(t))}function vs(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function ws(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function _s(t,e){const n=[];for(let s=0;s<t;s++)n.push(e);return n}function ks(t,e,n){let s=Cs(t,e);return s>=0?t[1|s]=n:(s=~s,function(t,e,n,s){let r=t.length;if(r==e)t.push(n,s);else if(1===r)t.push(s,t[0]),t[0]=n;else{for(r--,t.push(t[r-1],t[r]);r>e;)t[r]=t[r-2],r--;t[e]=n,t[e+1]=s}}(t,s,e,n)),s}function Ss(t,e){const n=Cs(t,e);if(n>=0)return t[1|n]}function Cs(t,e){return function(t,e,n){let s=0,r=t.length>>1;for(;r!==s;){const n=s+(r-s>>1),i=t[n<<1];if(e===i)return n<<1;i>e?r=n:s=n+1}return~(r<<1)}(t,e)}const Is={},Ns=/\n/gm,Es=Et({provide:String,useValue:Et});let Ts;function As(t){const e=Ts;return Ts=t,e}function $s(t,e=Xt.Default){if(void 0===Ts)throw new Error("inject() must be called from an injection context");return null===Ts?Zt(t,void 0,e):Ts.get(t,e&Xt.Optional?null:void 0,e)}function Rs(t,e=Xt.Default){return(Qt||$s)(Dt(t),e)}const Fs=Rs;function Ds(t){const e=[];for(let n=0;n<t.length;n++){const s=Dt(t[n]);if(Array.isArray(s)){if(0===s.length)throw new Error("Arguments array must have arguments.");let t,n=Xt.Default;for(let e=0;e<s.length;e++){const r=s[e],i=r.__NG_DI_FLAG__;"number"==typeof i?-1===i?t=r.token:n|=i:t=r}e.push(Rs(t,n))}else e.push(Rs(s))}return e}function Os(t,e){return t.__NG_DI_FLAG__=e,t.prototype.__NG_DI_FLAG__=e,t}const Ls=Os(fs("Inject",t=>({token:t})),-1),Ms=Os(fs("Optional"),8),Ps=Os(fs("SkipSelf"),4);let zs;function Bs(t){var e;return(null===(e=function(){if(void 0===zs&&(zs=null,ae.trustedTypes))try{zs=ae.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch(e){}return zs}())||void 0===e?void 0:e.createHTML(t))||t}class Vs{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class Ws extends Vs{getTypeName(){return"HTML"}}class Us extends Vs{getTypeName(){return"Style"}}class js extends Vs{getTypeName(){return"Script"}}class Hs extends Vs{getTypeName(){return"URL"}}class Gs extends Vs{getTypeName(){return"ResourceURL"}}function qs(t){return t instanceof Vs?t.changingThisBreaksApplicationSecurity:t}function Ks(t,e){const n=Xs(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`)}return n===e}function Xs(t){return t instanceof Vs&&t.getTypeName()||null}class Qs{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(Bs(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class Ys{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const t=this.inertDocument.createElement("html");this.inertDocument.appendChild(t);const e=this.inertDocument.createElement("body");t.appendChild(e)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=Bs(t),e;const n=this.inertDocument.createElement("body");return n.innerHTML=Bs(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(n),n}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const n=e.item(s).name;"xmlns:ns1"!==n&&0!==n.indexOf("ns1:")||t.removeAttribute(n)}let n=t.firstChild;for(;n;)n.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(n),n=n.nextSibling}}const Zs=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,Js=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function tr(t){return(t=String(t)).match(Zs)||t.match(Js)?t:"unsafe:"+t}function er(t){const e={};for(const n of t.split(","))e[n]=!0;return e}function nr(...t){const e={};for(const n of t)for(const t in n)n.hasOwnProperty(t)&&(e[t]=!0);return e}const sr=er("area,br,col,hr,img,wbr"),rr=er("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),ir=er("rp,rt"),ar=nr(ir,rr),or=nr(sr,nr(rr,er("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),nr(ir,er("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),ar),lr=er("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),ur=er("srcset"),cr=nr(lr,ur,er("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),er("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),hr=er("script,style,template");class dr{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,n=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?n=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,n&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let t=this.checkClobberedElement(e,e.nextSibling);if(t){e=t;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!or.hasOwnProperty(e))return this.sanitizedSomething=!0,!hr.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const n=t.attributes;for(let r=0;r<n.length;r++){const t=n.item(r),e=t.name,i=e.toLowerCase();if(!cr.hasOwnProperty(i)){this.sanitizedSomething=!0;continue}let a=t.value;lr[i]&&(a=tr(a)),ur[i]&&(s=a,a=(s=String(s)).split(",").map(t=>tr(t.trim())).join(", ")),this.buf.push(" ",e,'="',mr(a),'"')}var s;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();or.hasOwnProperty(e)&&!sr.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(mr(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const pr=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,fr=/([^\#-~ |!])/g;function mr(t){return t.replace(/&/g,"&amp;").replace(pr,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(fr,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let gr;function yr(t){return"content"in t&&function(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var br=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function xr(t){const e=function(){const t=nn();return t&&t[12]}();return e?e.sanitize(br.URL,t)||"":Ks(t,"URL")?qs(t):tr(Mt(t))}function vr(t){return t.ngDebugContext}function wr(t){return t.ngOriginalError}function _r(t,...e){t.error(...e)}class kr{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),s=function(t){return t.ngErrorLogger||_r}(t);s(this._console,"ERROR",t),e&&s(this._console,"ORIGINAL ERROR",e),n&&s(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?vr(t)?vr(t):this._findContext(wr(t)):null}_findOriginalError(t){let e=wr(t);for(;e&&wr(e);)e=wr(e);return e}}function Sr(t,e){t.__ngContext__=e}const Cr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(ae))();function Ir(t){return t instanceof Function?t():t}var Nr=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});function Er(t,e){return(void 0)(t,e)}function Tr(t){const e=t[3];return Ee(e)?e[3]:e}function Ar(t){return Rr(t[13])}function $r(t){return Rr(t[4])}function Rr(t){for(;null!==t&&!Ee(t);)t=t[4];return t}function Fr(t,e,n,s,r){if(null!=s){let i,a=!1;Ee(s)?i=s:Ne(s)&&(a=!0,s=s[0]);const o=Ue(s);0===t&&null!==n?null==r?Vr(e,n,o):Br(e,n,o,r||null,!0):1===t&&null!==n?Br(e,n,o,r||null,!0):2===t?function(t,e,n){const s=Ur(t,e);s&&function(t,e,n,s){Ve(t)?t.removeChild(e,n,s):e.removeChild(n)}(t,s,e,n)}(e,o,a):3===t&&e.destroyNode(o),null!=i&&function(t,e,n,s,r){const i=n[7];i!==Ue(n)&&Fr(e,t,s,i,r);for(let a=10;a<n.length;a++){const r=n[a];Yr(r[1],r,t,e,s,i)}}(e,t,i,n,r)}}function Dr(t,e,n){return Ve(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function Or(t,e){const n=t[9],s=n.indexOf(e),r=e[3];1024&e[2]&&(e[2]&=-1025,Je(r,-1)),n.splice(s,1)}function Lr(t,e){if(t.length<=10)return;const n=10+e,s=t[n];if(s){const i=s[17];null!==i&&i!==t&&Or(i,s),e>0&&(t[n-1][4]=s[4]);const a=ws(t,10+e);Yr(s[1],r=s,r[11],2,null,null),r[0]=null,r[6]=null;const o=a[19];null!==o&&o.detachView(a[1]),s[3]=null,s[4]=null,s[2]&=-129}var r;return s}function Mr(t,e){if(!(256&e[2])){const n=e[11];Ve(n)&&n.destroyNode&&Yr(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return Pr(t[1],t);for(;e;){let n=null;if(Ne(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Ne(e)&&Pr(e[1],e),e=e[3];null===e&&(e=t),Ne(e)&&Pr(e[1],e),n=e&&e[4]}e=n}}(e)}}function Pr(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let s=0;s<n.length;s+=2){const t=e[n[s]];if(!(t instanceof Pn)){const e=n[s+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2)e[n+1].call(t[e[n]]);else e.call(t)}}}(t,e),function(t,e){const n=t.cleanup,s=e[7];let r=-1;if(null!==n)for(let i=0;i<n.length-1;i+=2)if("string"==typeof n[i]){const t=n[i+1],a="function"==typeof t?t(e):Ue(e[t]),o=s[r=n[i+2]],l=n[i+3];"boolean"==typeof l?a.removeEventListener(n[i],o,l):l>=0?s[r=l]():s[r=-l].unsubscribe(),i+=2}else{const t=s[r=n[i+1]];n[i].call(t)}if(null!==s){for(let t=r+1;t<s.length;t++)(0,s[t])();e[7]=null}}(t,e),1===e[1].type&&Ve(e[11])&&e[11].destroy();const n=e[17];if(null!==n&&Ee(e[3])){n!==e[3]&&Or(n,e);const s=e[19];null!==s&&s.detachView(t)}}}function zr(t,e,n){return function(t,e,n){let s=e;for(;null!==s&&40&s.type;)s=(e=s).parent;if(null===s)return n[0];if(2&s.flags){const e=t.data[s.directiveStart].encapsulation;if(e===ee.None||e===ee.Emulated)return null}return He(s,n)}(t,e.parent,n)}function Br(t,e,n,s,r){Ve(t)?t.insertBefore(e,n,s,r):e.insertBefore(n,s,r)}function Vr(t,e,n){Ve(t)?t.appendChild(e,n):e.appendChild(n)}function Wr(t,e,n,s,r){null!==s?Br(t,e,n,s,r):Vr(t,e,n)}function Ur(t,e){return Ve(t)?t.parentNode(e):e.parentNode}function jr(t,e,n){return Hr(t,e,n)}let Hr=function(t,e,n){return 40&t.type?He(t,n):null};function Gr(t,e,n,s){const r=zr(t,s,e),i=e[11],a=jr(s.parent||e[6],s,e);if(null!=r)if(Array.isArray(n))for(let o=0;o<n.length;o++)Wr(i,r,n[o],a,!1);else Wr(i,r,n,a,!1)}function qr(t,e){if(null!==e){const n=e.type;if(3&n)return He(e,t);if(4&n)return Xr(-1,t[e.index]);if(8&n){const n=e.child;if(null!==n)return qr(t,n);{const n=t[e.index];return Ee(n)?Xr(-1,n):Ue(n)}}if(32&n)return Er(e,t)()||Ue(t[e.index]);{const n=Kr(t,e);return null!==n?Array.isArray(n)?n[0]:qr(Tr(t[16]),n):qr(t,e.next)}}return null}function Kr(t,e){return null!==e?t[16][6].projection[e.projection]:null}function Xr(t,e){const n=10+t+1;if(n<e.length){const t=e[n],s=t[1].firstChild;if(null!==s)return qr(t,s)}return e[7]}function Qr(t,e,n,s,r,i,a){for(;null!=n;){const o=s[n.index],l=n.type;if(a&&0===e&&(o&&Sr(Ue(o),s),n.flags|=4),64!=(64&n.flags))if(8&l)Qr(t,e,n.child,s,r,i,!1),Fr(e,t,r,o,i);else if(32&l){const a=Er(n,s);let l;for(;l=a();)Fr(e,t,r,l,i);Fr(e,t,r,o,i)}else 16&l?Zr(t,e,s,n,r,i):Fr(e,t,r,o,i);n=a?n.projectionNext:n.next}}function Yr(t,e,n,s,r,i){Qr(n,s,t.firstChild,e,r,i,!1)}function Zr(t,e,n,s,r,i){const a=n[16],o=a[6].projection[s.projection];if(Array.isArray(o))for(let l=0;l<o.length;l++)Fr(e,t,r,o[l],i);else Qr(t,e,o,a[3],r,i,!0)}function Jr(t,e,n){Ve(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function ti(t,e,n){Ve(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}function ei(t,e,n){let s=t.length;for(;;){const r=t.indexOf(e,n);if(-1===r)return r;if(0===r||t.charCodeAt(r-1)<=32){const n=e.length;if(r+n===s||t.charCodeAt(r+n)<=32)return r}n=r+1}}function ni(t,e,n){let s=0;for(;s<t.length;){let r=t[s++];if(n&&"class"===r){if(r=t[s],-1!==ei(r.toLowerCase(),e,0))return!0}else if(1===r){for(;s<t.length&&"string"==typeof(r=t[s++]);)if(r.toLowerCase()===e)return!0;return!1}}return!1}function si(t){return 4===t.type&&"ng-template"!==t.value}function ri(t,e,n){return e===(4!==t.type||n?t.value:"ng-template")}function ii(t,e,n){let s=4;const r=t.attrs||[],i=function(t){for(let e=0;e<t.length;e++)if(Bn(t[e]))return e;return t.length}(r);let a=!1;for(let o=0;o<e.length;o++){const l=e[o];if("number"!=typeof l){if(!a)if(4&s){if(s=2|1&s,""!==l&&!ri(t,l,n)||""===l&&1===e.length){if(ai(s))return!1;a=!0}}else{const u=8&s?l:e[++o];if(8&s&&null!==t.attrs){if(!ni(t.attrs,u,n)){if(ai(s))return!1;a=!0}continue}const c=oi(8&s?"class":l,r,si(t),n);if(-1===c){if(ai(s))return!1;a=!0;continue}if(""!==u){let t;t=c>i?"":r[c+1].toLowerCase();const e=8&s?t:null;if(e&&-1!==ei(e,u,0)||2&s&&u!==t){if(ai(s))return!1;a=!0}}}}else{if(!a&&!ai(s)&&!ai(l))return!1;if(a&&ai(l))continue;a=!1,s=l|1&s}}return ai(s)||a}function ai(t){return 0==(1&t)}function oi(t,e,n,s){if(null===e)return-1;let r=0;if(s||!n){let n=!1;for(;r<e.length;){const s=e[r];if(s===t)return r;if(3===s||6===s)n=!0;else{if(1===s||2===s){let t=e[++r];for(;"string"==typeof t;)t=e[++r];continue}if(4===s)break;if(0===s){r+=4;continue}}r+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const s=t[n];if("number"==typeof s)return-1;if(s===e)return n;n++}return-1}(e,t)}function li(t,e,n=!1){for(let s=0;s<e.length;s++)if(ii(t,e[s],n))return!0;return!1}function ui(t,e){t:for(let n=0;n<e.length;n++){const s=e[n];if(t.length===s.length){for(let e=0;e<t.length;e++)if(t[e]!==s[e])continue t;return!0}}return!1}function ci(t,e){return t?":not("+e.trim()+")":e}function hi(t){let e=t[0],n=1,s=2,r="",i=!1;for(;n<t.length;){let a=t[n];if("string"==typeof a)if(2&s){const e=t[++n];r+="["+a+(e.length>0?'="'+e+'"':"")+"]"}else 8&s?r+="."+a:4&s&&(r+=" "+a);else""===r||ai(a)||(e+=ci(i,r),r=""),s=a,i=i||!ai(s);n++}return""!==r&&(e+=ci(i,r)),e}const di={};function pi(t){fi(sn(),nn(),En()+t,hn())}function fi(t,e,n,s){if(!s)if(3==(3&e[2])){const s=t.preOrderCheckHooks;null!==s&&Fn(e,s,n)}else{const s=t.preOrderHooks;null!==s&&Dn(e,s,0,n)}Tn(n)}function mi(t,e){return t<<17|e<<2}function gi(t){return t>>17&32767}function yi(t){return 2|t}function bi(t){return(131068&t)>>2}function xi(t,e){return-131069&t|e<<2}function vi(t){return 1|t}function wi(t,e){const n=t.contentQueries;if(null!==n)for(let s=0;s<n.length;s+=2){const r=n[s],i=n[s+1];if(-1!==i){const n=t.data[i];xn(r),n.contentQueries(2,e[i],i)}}}function _i(t,e,n,s,r,i,a,o,l,u){const c=e.blueprint.slice();return c[0]=r,c[2]=140|s,Ze(c),c[3]=c[15]=t,c[8]=n,c[10]=a||t&&t[10],c[11]=o||t&&t[11],c[12]=l||t&&t[12]||null,c[9]=u||t&&t[9]||null,c[6]=i,c[16]=2==e.type?t[16]:c,c}function ki(t,e,n,s,r){let i=t.data[e];if(null===i)i=function(t,e,n,s,r){const i=on(),a=un(),o=t.data[e]=function(t,e,n,s,r,i){return{type:n,index:s,insertBeforeIndex:null,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,a?i:i&&i.parent,n,e,s,r);return null===t.firstChild&&(t.firstChild=o),null!==i&&(a?null==i.child&&null!==o.parent&&(i.child=o):null===i.next&&(i.next=o)),o}(t,e,n,s,r),tn.lFrame.inI18n&&(i.flags|=64);else if(64&i.type){i.type=n,i.value=s,i.attrs=r;const t=function(){const t=tn.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();i.injectorIndex=null===t?-1:t.injectorIndex}return ln(i,!0),i}function Si(t,e,n,s){if(0===n)return-1;const r=e.length;for(let i=0;i<n;i++)e.push(s),t.blueprint.push(s),t.data.push(null);return r}function Ci(t,e,n){_n(e);try{const s=t.viewQuery;null!==s&&ta(1,s,n);const r=t.template;null!==r&&Ei(t,e,r,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&wi(t,e),t.staticViewQueries&&ta(2,t.viewQuery,n);const i=t.components;null!==i&&function(t,e){for(let n=0;n<e.length;n++)Xi(t,e[n])}(e,i)}catch(s){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),s}finally{e[2]&=-5,Nn()}}function Ii(t,e,n,s){const r=e[2];if(256==(256&r))return;_n(e);const i=hn();try{Ze(e),tn.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&Ei(t,e,n,2,s);const a=3==(3&r);if(!i)if(a){const n=t.preOrderCheckHooks;null!==n&&Fn(e,n,null)}else{const n=t.preOrderHooks;null!==n&&Dn(e,n,0,null),On(e,0)}if(function(t){for(let e=Ar(t);null!==e;e=$r(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],s=n[3];0==(1024&n[2])&&Je(s,1),n[2]|=1024}}}(e),function(t){for(let e=Ar(t);null!==e;e=$r(e))for(let t=10;t<e.length;t++){const n=e[t],s=n[1];Qe(n)&&Ii(s,n,s.template,n[8])}}(e),null!==t.contentQueries&&wi(t,e),!i)if(a){const n=t.contentCheckHooks;null!==n&&Fn(e,n)}else{const n=t.contentHooks;null!==n&&Dn(e,n,1),On(e,1)}!function(t,e){const n=t.hostBindingOpCodes;if(null!==n)try{for(let t=0;t<n.length;t++){const s=n[t];if(s<0)Tn(~s);else{const r=s,i=n[++t],a=n[++t];mn(i,r),a(2,e[r])}}}finally{Tn(-1)}}(t,e);const o=t.components;null!==o&&function(t,e){for(let n=0;n<e.length;n++)qi(t,e[n])}(e,o);const l=t.viewQuery;if(null!==l&&ta(2,l,s),!i)if(a){const n=t.viewCheckHooks;null!==n&&Fn(e,n)}else{const n=t.viewHooks;null!==n&&Dn(e,n,2),On(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),i||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,Je(e[3],-1))}finally{Nn()}}function Ni(t,e,n,s){const r=e[10],i=!hn(),a=Xe(e);try{i&&!a&&r.begin&&r.begin(),a&&Ci(t,e,s),Ii(t,e,n,s)}finally{i&&!a&&r.end&&r.end()}}function Ei(t,e,n,s,r){const i=En();try{Tn(-1),2&s&&e.length>20&&fi(t,e,20,hn()),n(s,r)}finally{Tn(i)}}function Ti(t,e,n){en()&&(function(t,e,n,s){const r=n.directiveStart,i=n.directiveEnd;t.firstCreatePass||Qn(n,e),Sr(s,e);const a=n.initialInputs;for(let o=r;o<i;o++){const s=t.data[o],i=Re(s);i&&Ui(e,n,s);const l=ls(e,t,o,n);Sr(l,e),null!==a&&ji(0,o-r,l,s,0,a),i&&(qe(n.index,e)[8]=l)}}(t,e,n,He(n,e)),128==(128&n.flags)&&function(t,e,n){const s=n.directiveStart,r=n.directiveEnd,i=n.index,a=tn.lFrame.currentDirectiveIndex;try{Tn(i);for(let n=s;n<r;n++){const s=t.data[n],r=e[n];gn(n),null===s.hostBindings&&0===s.hostVars&&null===s.hostAttrs||Pi(s,r)}}finally{Tn(-1),gn(a)}}(t,e,n))}function Ai(t,e,n=He){const s=e.localNames;if(null!==s){let r=e.index+1;for(let i=0;i<s.length;i+=2){const a=s[i+1],o=-1===a?n(e,t):t[a];t[r++]=o}}}function $i(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Ri(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function Ri(t,e,n,s,r,i,a,o,l,u){const c=20+s,h=c+r,d=function(t,e){const n=[];for(let s=0;s<e;s++)n.push(s<t?null:di);return n}(c,h),p="function"==typeof u?u():u;return d[1]={type:t,blueprint:d,template:n,queries:null,viewQuery:o,declTNode:e,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof a?a():a,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function Fi(t,e,n,s){const r=na(e);null===n?r.push(s):(r.push(n),t.firstCreatePass&&sa(t).push(s,r.length-1))}function Di(t,e,n){for(let s in t)if(t.hasOwnProperty(s)){const r=t[s];(n=null===n?{}:n).hasOwnProperty(s)?n[s].push(e,r):n[s]=[e,r]}return n}function Oi(t,e,n,s,r,i,a,o){const l=He(e,n);let u,c=e.inputs;var h;!o&&null!=c&&(u=c[s])?(aa(t,n,u,s,r),Ae(e)&&function(t,e){const n=qe(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3&e.type&&(s="class"===(h=s)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,r=null!=a?a(r,e.value||"",s):r,Ve(i)?i.setProperty(l,s,r):Vn(s)||(l.setProperty?l.setProperty(s,r):l[s]=r))}function Li(t,e,n,s){let r=!1;if(en()){const i=function(t,e,n){const s=t.directiveRegistry;let r=null;if(s)for(let i=0;i<s.length;i++){const a=s[i];li(n,a.selectors,!1)&&(r||(r=[]),ts(Qn(n,e),t,a.type),Re(a)?(zi(t,n),r.unshift(a)):r.push(a))}return r}(t,e,n),a=null===s?null:{"":-1};if(null!==i){r=!0,Vi(n,t.data.length,i.length);for(let t=0;t<i.length;t++){const e=i[t];e.providersResolver&&e.providersResolver(e)}let s=!1,o=!1,l=Si(t,e,i.length,null);for(let r=0;r<i.length;r++){const u=i[r];n.mergedAttrs=Wn(n.mergedAttrs,u.hostAttrs),Wi(t,n,e,l,u),Bi(l,u,a),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!s&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index),s=!0),o||!c.ngOnChanges&&!c.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index),o=!0),l++}!function(t,e){const n=e.directiveEnd,s=t.data,r=e.attrs,i=[];let a=null,o=null;for(let l=e.directiveStart;l<n;l++){const t=s[l],n=t.inputs,u=null===r||si(e)?null:Hi(n,r);i.push(u),a=Di(n,l,a),o=Di(t.outputs,l,o)}null!==a&&(a.hasOwnProperty("class")&&(e.flags|=16),a.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=i,e.inputs=a,e.outputs=o}(t,n)}a&&function(t,e,n){if(e){const s=t.localNames=[];for(let t=0;t<e.length;t+=2){const r=n[e[t+1]];if(null==r)throw new Lt("301",`Export of name '${e[t+1]}' not found!`);s.push(e[t],r)}}}(n,s,a)}return n.mergedAttrs=Wn(n.mergedAttrs,n.attrs),r}function Mi(t,e,n,s,r,i){const a=i.hostBindings;if(a){let n=t.hostBindingOpCodes;null===n&&(n=t.hostBindingOpCodes=[]);const i=~e.index;(function(t){let e=t.length;for(;e>0;){const n=t[--e];if("number"==typeof n&&n<0)return n}return 0})(n)!=i&&n.push(i),n.push(s,r,a)}}function Pi(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function zi(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function Bi(t,e,n){if(n){if(e.exportAs)for(let s=0;s<e.exportAs.length;s++)n[e.exportAs[s]]=t;Re(e)&&(n[""]=t)}}function Vi(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function Wi(t,e,n,s,r){t.data[s]=r;const i=r.factory||(r.factory=Fe(r.type)),a=new Pn(i,Re(r),null);t.blueprint[s]=a,n[s]=a,Mi(t,e,0,s,Si(t,n,r.hostVars,di),r)}function Ui(t,e,n){const s=He(e,t),r=$i(n),i=t[10],a=Qi(t,_i(t,r,null,n.onPush?64:16,s,e,i,i.createRenderer(s,n),null,null));t[e.index]=a}function ji(t,e,n,s,r,i){const a=i[e];if(null!==a){const t=s.setInput;for(let e=0;e<a.length;){const r=a[e++],i=a[e++],o=a[e++];null!==t?s.setInput(n,o,r,i):n[i]=o}}}function Hi(t,e){let n=null,s=0;for(;s<e.length;){const r=e[s];if(0!==r)if(5!==r){if("number"==typeof r)break;t.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,t[r],e[s+1])),s+=2}else s+=2;else s+=4}return n}function Gi(t,e,n,s){return new Array(t,!0,!1,e,null,0,s,n,null,null)}function qi(t,e){const n=qe(e,t);if(Qe(n)){const t=n[1];80&n[2]?Ii(t,n,t.template,n[8]):n[5]>0&&Ki(n)}}function Ki(t){for(let n=Ar(t);null!==n;n=$r(n))for(let t=10;t<n.length;t++){const e=n[t];if(1024&e[2]){const t=e[1];Ii(t,e,t.template,e[8])}else e[5]>0&&Ki(e)}const e=t[1].components;if(null!==e)for(let n=0;n<e.length;n++){const s=qe(e[n],t);Qe(s)&&s[5]>0&&Ki(s)}}function Xi(t,e){const n=qe(e,t),s=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(s,n),Ci(s,n,n[8])}function Qi(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function Yi(t){for(;t;){t[2]|=64;const e=Tr(t);if(0!=(512&t[2])&&!e)return t;t=e}return null}function Zi(t,e,n){const s=e[10];s.begin&&s.begin();try{Ii(t,e,t.template,n)}catch(r){throw ia(e,r),r}finally{s.end&&s.end()}}function Ji(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],s=Ke(n),r=s[1];Ni(r,s,r.template,n)}}(t[8])}function ta(t,e,n){xn(0),e(t,n)}const ea=(()=>Promise.resolve(null))();function na(t){return t[7]||(t[7]=[])}function sa(t){return t.cleanup||(t.cleanup=[])}function ra(t,e,n){return(null===t||Re(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function ia(t,e){const n=t[9],s=n?n.get(kr,null):null;s&&s.handleError(e)}function aa(t,e,n,s,r){for(let i=0;i<n.length;){const a=n[i++],o=n[i++],l=e[a],u=t.data[a];null!==u.setInput?u.setInput(l,r,s,o):l[o]=r}}function oa(t,e,n){const s=je(e,t);!function(t,e,n){Ve(t)?t.setValue(e,n):e.textContent=n}(t[11],s,n)}function la(t,e,n){let s=n?t.styles:null,r=n?t.classes:null,i=0;if(null!==e)for(let a=0;a<e.length;a++){const t=e[a];"number"==typeof t?i=t:1==i?r=$t(r,t):2==i&&(s=$t(s,t+": "+e[++a]+";"))}n?t.styles=s:t.stylesWithoutHost=s,n?t.classes=r:t.classesWithoutHost=r}const ua=new ms("INJECTOR",-1);class ca{get(t,e=Is){if(e===Is){const e=new Error(`NullInjectorError: No provider for ${At(t)}!`);throw e.name="NullInjectorError",e}return e}}const ha=new ms("Set Injector scope."),da={},pa={},fa=[];let ma;function ga(){return void 0===ma&&(ma=new ca),ma}function ya(t,e=null,n=null,s){return new ba(t,n,e||ga(),s)}class ba{constructor(t,e,n,s=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];e&&xs(e,n=>this.processProvider(n,t,e)),xs([t],t=>this.processInjectorType(t,[],r)),this.records.set(ua,wa(void 0,this));const i=this.records.get(ha);this.scope=null!=i?i.value:null,this.source=s||("object"==typeof t?null:At(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=Is,n=Xt.Default){this.assertNotDestroyed();const s=As(this);try{if(!(n&Xt.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(r=t)||"object"==typeof r&&r instanceof ms)&&Wt(t);e=n&&this.injectableDefInScope(n)?wa(xa(t),da):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&Xt.Self?ga():this.parent).get(t,e=n&Xt.Optional&&e===Is?null:e)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(At(t)),s)throw i;return function(t,e,n,s){const r=t.ngTempTokenPath;throw e.__source&&r.unshift(e.__source),t.message=function(t,e,n,s=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let r=At(e);if(Array.isArray(e))r=e.map(At).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let s=e[n];t.push(n+":"+("string"==typeof s?JSON.stringify(s):At(s)))}r=`{${t.join(", ")}}`}return`${n}${s?"("+s+")":""}[${r}]: ${t.replace(Ns,"\n  ")}`}("\n"+t.message,r,n,s),t.ngTokenPath=r,t.ngTempTokenPath=null,t}(i,t,"R3InjectorError",this.source)}throw i}finally{As(s)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(At(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=Dt(t)))return!1;let s=jt(t);const r=null==s&&t.ngModule||void 0,i=void 0===r?t:r,a=-1!==n.indexOf(i);if(void 0!==r&&(s=jt(r)),null==s)return!1;if(null!=s.imports&&!a){let t;n.push(i);try{xs(s.imports,s=>{this.processInjectorType(s,e,n)&&(void 0===t&&(t=[]),t.push(s))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:s}=t[e];xs(s,t=>this.processProvider(t,n,s||fa))}}this.injectorDefTypes.add(i);const o=Fe(i)||(()=>new i);this.records.set(i,wa(o,da));const l=s.providers;if(null!=l&&!a){const e=t;xs(l,t=>this.processProvider(t,e,l))}return void 0!==r&&void 0!==t.providers}processProvider(t,e,n){let s=ka(t=Dt(t))?t:Dt(t&&t.provide);const r=function(t,e,n){return _a(t)?wa(void 0,t.useValue):wa(va(t),da)}(t);if(ka(t)||!0!==t.multi)this.records.get(s);else{let e=this.records.get(s);e||(e=wa(void 0,da,!0),e.factory=()=>Ds(e.multi),this.records.set(s,e)),s=t,e.multi.push(t)}this.records.set(s,r)}hydrate(t,e){var n;return e.value===da&&(e.value=pa,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){return!!t.providedIn&&("string"==typeof t.providedIn?"any"===t.providedIn||t.providedIn===this.scope:this.injectorDefTypes.has(t.providedIn))}}function xa(t){const e=Wt(t),n=null!==e?e.factory:Fe(t);if(null!==n)return n;if(t instanceof ms)throw new Error(`Token ${At(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=_s(e,"?");throw new Error(`Can't resolve all parameters for ${At(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[Ht]||t[qt]);if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function va(t,e,n){let s;if(ka(t)){const e=Dt(t);return Fe(e)||xa(e)}if(_a(t))s=()=>Dt(t.useValue);else if((r=t)&&r.useFactory)s=()=>t.useFactory(...Ds(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))s=()=>Rs(Dt(t.useExisting));else{const e=Dt(t&&(t.useClass||t.provide));if(!function(t){return!!t.deps}(t))return Fe(e)||xa(e);s=()=>new e(...Ds(t.deps))}var r;return s}function wa(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function _a(t){return null!==t&&"object"==typeof t&&Es in t}function ka(t){return"function"==typeof t}const Sa=function(t,e,n){return function(t,e=null,n=null,s){const r=ya(t,e,n,s);return r._resolveInjectorDefTypes(),r}({name:n},e,t,n)};let Ca=(()=>{class t{static create(t,e){return Array.isArray(t)?Sa(t,e,""):Sa(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=Is,t.NULL=new ca,t.\u0275prov=Bt({token:t,providedIn:"any",factory:()=>Rs(ua)}),t.__NG_ELEMENT_ID__=-1,t})();function Ia(t,e){Rn(Ke(t)[1],an())}function Na(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const s=[t];for(;e;){let r;if(Re(t))r=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");r=e.\u0275dir}if(r){if(n){s.push(r);const e=t;e.inputs=Ea(t.inputs),e.declaredInputs=Ea(t.declaredInputs),e.outputs=Ea(t.outputs);const n=r.hostBindings;n&&$a(t,n);const i=r.viewQuery,a=r.contentQueries;if(i&&Ta(t,i),a&&Aa(t,a),Tt(t.inputs,r.inputs),Tt(t.declaredInputs,r.declaredInputs),Tt(t.outputs,r.outputs),Re(r)&&r.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(r.data.animation)}}const e=r.features;if(e)for(let s=0;s<e.length;s++){const r=e[s];r&&r.ngInherit&&r(t),r===Na&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let s=t.length-1;s>=0;s--){const r=t[s];r.hostVars=e+=r.hostVars,r.hostAttrs=Wn(r.hostAttrs,n=Wn(n,r.hostAttrs))}}(s)}function Ea(t){return t===oe?{}:t===ue?[]:t}function Ta(t,e){const n=t.viewQuery;t.viewQuery=n?(t,s)=>{e(t,s),n(t,s)}:e}function Aa(t,e){const n=t.contentQueries;t.contentQueries=n?(t,s,r)=>{e(t,s,r),n(t,s,r)}:e}function $a(t,e){const n=t.hostBindings;t.hostBindings=n?(t,s)=>{e(t,s),n(t,s)}:e}let Ra=null;function Fa(){if(!Ra){const t=ae.Symbol;if(t&&t.iterator)Ra=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Ra=n)}}}return Ra}function Da(t){return!!Oa(t)&&(Array.isArray(t)||!(t instanceof Map)&&Fa()in t)}function Oa(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function La(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function Ma(t,e,n,s){const r=nn();return La(r,pn(),e)&&(sn(),function(t,e,n,s,r,i){const a=He(t,e);!function(t,e,n,s,r,i,a){if(null==i)Ve(t)?t.removeAttribute(e,r,n):e.removeAttribute(r);else{const o=null==a?Mt(i):a(i,s||"",r);Ve(t)?t.setAttribute(e,r,o,n):n?e.setAttributeNS(n,r,o):e.setAttribute(r,o)}}(e[11],a,i,t.value,n,s,r)}(An(),r,t,e,n,s)),Ma}function Pa(t,e,n,s){return La(t,pn(),n)?e+Mt(n)+s:di}function za(t,e,n,s,r,i,a,o){const l=nn(),u=sn(),c=t+20,h=u.firstCreatePass?function(t,e,n,s,r,i,a,o,l){const u=e.consts,c=ki(e,t,4,a||null,Ye(u,o));Li(e,n,c,Ye(u,l)),Rn(e,c);const h=c.tViews=Ri(2,c,s,r,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,u);return null!==e.queries&&(e.queries.template(e,c),h.queries=e.queries.embeddedTView(c)),c}(c,u,l,e,n,s,r,i,a):u.data[c];ln(h,!1);const d=l[11].createComment("");Gr(u,l,d,h),Sr(d,l),Qi(l,l[c]=Gi(d,l,d,h)),$e(h)&&Ti(u,l,h),null!=a&&Ai(l,h,o)}function Ba(t,e=Xt.Default){const n=nn();return null===n?Rs(t,e):ss(an(),n,Dt(t),e)}function Va(t,e,n){const s=nn();return La(s,pn(),e)&&Oi(sn(),An(),s,t,e,s[11],n,!1),Va}function Wa(t,e,n,s,r){const i=r?"class":"style";aa(t,n,e.inputs[i],i,s)}function Ua(t,e,n,s){const r=nn(),i=sn(),a=20+t,o=r[11],l=r[a]=Dr(o,e,tn.lFrame.currentNamespace),u=i.firstCreatePass?function(t,e,n,s,r,i,a){const o=e.consts,l=ki(e,t,2,r,Ye(o,i));return Li(e,n,l,Ye(o,a)),null!==l.attrs&&la(l,l.attrs,!1),null!==l.mergedAttrs&&la(l,l.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,l),l}(a,i,r,0,e,n,s):i.data[a];ln(u,!0);const c=u.mergedAttrs;null!==c&&zn(o,l,c);const h=u.classes;null!==h&&ti(o,l,h);const d=u.styles;null!==d&&Jr(o,l,d),64!=(64&u.flags)&&Gr(i,r,l,u),0===tn.lFrame.elementDepthCount&&Sr(l,r),tn.lFrame.elementDepthCount++,$e(u)&&(Ti(i,r,u),function(t,e,n){if(Te(e)){const s=e.directiveEnd;for(let r=e.directiveStart;r<s;r++){const e=t.data[r];e.contentQueries&&e.contentQueries(1,n[r],r)}}}(i,u,r)),null!==s&&Ai(r,u)}function ja(){let t=an();un()?cn():(t=t.parent,ln(t,!1));const e=t;tn.lFrame.elementDepthCount--;const n=sn();n.firstCreatePass&&(Rn(n,t),Te(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&Wa(n,e,nn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&Wa(n,e,nn(),e.stylesWithoutHost,!1)}function Ha(t,e,n,s){Ua(t,e,n,s),ja()}function Ga(){return nn()}function qa(t){return!!t&&"function"==typeof t.then}function Ka(t,e,n=!1,s){const r=nn(),i=sn(),a=an();return Qa(i,r,r[11],a,t,e,n,s),Ka}function Xa(t,e,n=!1,s){const r=an(),i=nn(),a=sn();return Qa(a,i,ra(yn(a.data),r,i),r,t,e,n,s),Xa}function Qa(t,e,n,s,r,i,a=!1,o){const l=$e(s),u=t.firstCreatePass&&sa(t),c=na(e);let h=!0;if(3&s.type){const d=He(s,e),p=o?o(d):oe,f=p.target||d,m=c.length,g=o?t=>o(Ue(t[s.index])).target:s.index;if(Ve(n)){let a=null;if(!o&&l&&(a=function(t,e,n,s){const r=t.cleanup;if(null!=r)for(let i=0;i<r.length-1;i+=2){const t=r[i];if(t===n&&r[i+1]===s){const t=e[7],n=r[i+2];return t.length>n?t[n]:null}"string"==typeof t&&(i+=2)}return null}(t,e,r,s.index)),null!==a)(a.__ngLastListenerFn__||a).__ngNextListenerFn__=i,a.__ngLastListenerFn__=i,h=!1;else{i=Za(s,e,i,!1);const t=n.listen(p.name||f,r,i);c.push(i,t),u&&u.push(r,g,m,m+1)}}else i=Za(s,e,i,!0),f.addEventListener(r,i,a),c.push(i),u&&u.push(r,g,m,a)}else i=Za(s,e,i,!1);const d=s.outputs;let p;if(h&&null!==d&&(p=d[r])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(i),a=c.length;c.push(i,t),u&&u.push(r,s.index,a,-(a+1))}}}function Ya(t,e,n){try{return!1!==e(n)}catch(s){return ia(t,s),!1}}function Za(t,e,n,s){return function r(i){if(i===Function)return n;const a=2&t.flags?qe(t.index,e):e;0==(32&e[2])&&Yi(a);let o=Ya(e,n,i),l=r.__ngNextListenerFn__;for(;l;)o=Ya(e,l,i)&&o,l=l.__ngNextListenerFn__;return s&&!1===o&&(i.preventDefault(),i.returnValue=!1),o}}function Ja(t=1){return function(t){return(tn.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,tn.lFrame.contextLView))[8]}(t)}function to(t,e){let n=null;const s=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let r=0;r<e.length;r++){const i=e[r];if("*"!==i){if(null===s?li(t,i,!0):ui(s,i))return r}else n=r}return n}function eo(t){const e=nn()[16][6];if(!e.projection){const n=e.projection=_s(t?t.length:1,null),s=n.slice();let r=e.child;for(;null!==r;){const e=t?to(r,t):0;null!==e&&(s[e]?s[e].projectionNext=r:n[e]=r,s[e]=r),r=r.next}}}function no(t,e=0,n){const s=nn(),r=sn(),i=ki(r,20+t,16,null,n||null);null===i.projection&&(i.projection=e),cn(),64!=(64&i.flags)&&function(t,e,n){Zr(e[11],0,e,n,zr(t,n,e),jr(n.parent||e[6],n,e))}(r,s,i)}function so(t,e,n){return ro(t,"",e,"",n),so}function ro(t,e,n,s,r){const i=nn(),a=Pa(i,e,n,s);return a!==di&&Oi(sn(),An(),i,t,a,i[11],r,!1),ro}function io(t,e,n,s,r){const i=t[n+1],a=null===e;let o=s?gi(i):bi(i),l=!1;for(;0!==o&&(!1===l||a);){const n=t[o+1];ao(t[o],e)&&(l=!0,t[o+1]=s?vi(n):yi(n)),o=s?gi(n):bi(n)}l&&(t[n+1]=s?yi(i):vi(i))}function ao(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Cs(t,e)>=0}const oo={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function lo(t){return t.substring(oo.key,oo.keyEnd)}function uo(t){return t.substring(oo.value,oo.valueEnd)}function co(t,e){const n=oo.textEnd;let s=oo.key=ho(t,e,n);return n===s?-1:(s=oo.keyEnd=function(t,e,n){let s;for(;e<n&&(45===(s=t.charCodeAt(e))||95===s||(-33&s)>=65&&(-33&s)<=90||s>=48&&s<=57);)e++;return e}(t,s,n),s=po(t,s,n),s=oo.value=ho(t,s,n),s=oo.valueEnd=function(t,e,n){let s=-1,r=-1,i=-1,a=e,o=a;for(;a<n;){const l=t.charCodeAt(a++);if(59===l)return o;34===l||39===l?o=a=fo(t,l,a,n):e===a-4&&85===i&&82===r&&76===s&&40===l?o=a=fo(t,41,a,n):l>32&&(o=a),i=r,r=s,s=-33&l}return o}(t,s,n),po(t,s,n))}function ho(t,e,n){for(;e<n&&t.charCodeAt(e)<=32;)e++;return e}function po(t,e,n,s){return(e=ho(t,e,n))<n&&e++,e}function fo(t,e,n,s){let r=-1,i=n;for(;i<s;){const n=t.charCodeAt(i++);if(n==e&&92!==r)return i;r=92==n&&92===r?0:n}throw new Error}function mo(t,e){return function(t,e,n,s){const r=nn(),i=sn(),a=fn(2);i.firstUpdatePass&&bo(i,t,a,true),e!==di&&La(r,a,e)&&_o(i,i.data[En()],r,r[11],t,r[a+1]=function(t,e){return null==t||"object"==typeof t&&(t=At(qs(t))),t}(e),true,a)}(t,e),mo}function go(t,e){for(let n=function(t){return function(t){oo.key=0,oo.keyEnd=0,oo.value=0,oo.valueEnd=0,oo.textEnd=t.length}(t),co(t,ho(t,0,oo.textEnd))}(e);n>=0;n=co(e,n))wo(t,lo(e),uo(e))}function yo(t,e){return e>=t.expandoStartIndex}function bo(t,e,n,s){const r=t.data;if(null===r[n+1]){const i=r[En()],a=yo(t,n);Co(i,s)&&null===e&&!a&&(e=!1),e=function(t,e,n,s){const r=yn(t);let i=s?e.residualClasses:e.residualStyles;if(null===r)0===(s?e.classBindings:e.styleBindings)&&(n=vo(n=xo(null,t,e,n,s),e.attrs,s),i=null);else{const a=e.directiveStylingLast;if(-1===a||t[a]!==r)if(n=xo(r,t,e,n,s),null===i){let n=function(t,e,n){const s=n?e.classBindings:e.styleBindings;if(0!==bi(s))return t[gi(s)]}(t,e,s);void 0!==n&&Array.isArray(n)&&(n=xo(null,t,e,n[1],s),n=vo(n,e.attrs,s),function(t,e,n,s){t[gi(n?e.classBindings:e.styleBindings)]=s}(t,e,s,n))}else i=function(t,e,n){let s;const r=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<r;i++)s=vo(s,t[i].hostAttrs,n);return vo(s,e.attrs,n)}(t,e,s)}return void 0!==i&&(s?e.residualClasses=i:e.residualStyles=i),n}(r,i,e,s),function(t,e,n,s,r,i){let a=i?e.classBindings:e.styleBindings,o=gi(a),l=bi(a);t[s]=n;let u,c=!1;if(Array.isArray(n)){const t=n;u=t[1],(null===u||Cs(t,u)>0)&&(c=!0)}else u=n;if(r)if(0!==l){const e=gi(t[o+1]);t[s+1]=mi(e,o),0!==e&&(t[e+1]=xi(t[e+1],s)),t[o+1]=131071&t[o+1]|s<<17}else t[s+1]=mi(o,0),0!==o&&(t[o+1]=xi(t[o+1],s)),o=s;else t[s+1]=mi(l,0),0===o?o=s:t[l+1]=xi(t[l+1],s),l=s;c&&(t[s+1]=yi(t[s+1])),io(t,u,s,!0),io(t,u,s,!1),function(t,e,n,s,r){const i=r?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&Cs(i,e)>=0&&(n[s+1]=vi(n[s+1]))}(e,u,t,s,i),a=mi(o,l),i?e.classBindings=a:e.styleBindings=a}(r,i,e,n,a,s)}}function xo(t,e,n,s,r){let i=null;const a=n.directiveEnd;let o=n.directiveStylingLast;for(-1===o?o=n.directiveStart:o++;o<a&&(i=e[o],s=vo(s,i.hostAttrs,r),i!==t);)o++;return null!==t&&(n.directiveStylingLast=o),s}function vo(t,e,n){const s=n?1:2;let r=-1;if(null!==e)for(let i=0;i<e.length;i++){const a=e[i];"number"==typeof a?r=a:r===s&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),ks(t,a,!!n||e[++i]))}return void 0===t?null:t}function wo(t,e,n){ks(t,e,qs(n))}function _o(t,e,n,s,r,i,a,o){if(!(3&e.type))return;const l=t.data,u=l[o+1];So(1==(1&u)?ko(l,e,n,r,bi(u),a):void 0)||(So(i)||2==(2&u)&&(i=ko(l,null,n,r,o,a)),function(t,e,n,s,r){const i=Ve(t);if(e)r?i?t.addClass(n,s):n.classList.add(s):i?t.removeClass(n,s):n.classList.remove(s);else{let e=-1===s.indexOf("-")?void 0:Nr.DashCase;if(null==r)i?t.removeStyle(n,s,e):n.style.removeProperty(s);else{const a="string"==typeof r&&r.endsWith("!important");a&&(r=r.slice(0,-10),e|=Nr.Important),i?t.setStyle(n,s,r,e):n.style.setProperty(s,r,a?"important":"")}}}(s,a,je(En(),n),r,i))}function ko(t,e,n,s,r,i){const a=null===e;let o;for(;r>0;){const e=t[r],i=Array.isArray(e),l=i?e[1]:e,u=null===l;let c=n[r+1];c===di&&(c=u?le:void 0);let h=u?Ss(c,s):l===s?c:void 0;if(i&&!So(h)&&(h=Ss(e,s)),So(h)&&(o=h,a))return o;const d=t[r+1];r=a?gi(d):bi(d)}if(null!==e){let t=i?e.residualClasses:e.residualStyles;null!=t&&(o=Ss(t,s))}return o}function So(t){return void 0!==t}function Co(t,e){return 0!=(t.flags&(e?16:32))}function Io(t,e=""){const n=nn(),s=sn(),r=t+20,i=s.firstCreatePass?ki(s,r,1,e,null):s.data[r],a=n[r]=function(t,e){return Ve(t)?t.createText(e):t.createTextNode(e)}(n[11],e);Gr(s,n,a,i),ln(i,!1)}function No(t){return Eo("",t,""),No}function Eo(t,e,n){const s=nn(),r=Pa(s,t,e,n);return r!==di&&oa(s,En(),r),Eo}function To(t,e,n,s,r){const i=nn(),a=function(t,e,n,s,r,i){const a=function(t,e,n,s){const r=La(t,e,n);return La(t,e+1,s)||r}(t,tn.lFrame.bindingIndex,n,r);return fn(2),a?e+Mt(n)+s+Mt(r)+i:di}(i,t,e,n,s,r);return a!==di&&oa(i,En(),a),To}function Ao(t,e,n){const s=nn();return La(s,pn(),e)&&Oi(sn(),An(),s,t,e,s[11],n,!0),Ao}function $o(t,e,n){const s=nn();if(La(s,pn(),e)){const r=sn(),i=An();Oi(r,i,s,t,e,ra(yn(r.data),i,s),n,!0)}return $o}const Ro=void 0;var Fo=["en",[["a","p"],["AM","PM"],Ro],[["AM","PM"],Ro,Ro],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Ro,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Ro,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Ro,"{1} 'at' {0}",Ro],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let Do={};function Oo(t){return t in Do||(Do[t]=ae.ng&&ae.ng.common&&ae.ng.common.locales&&ae.ng.common.locales[t]),Do[t]}var Lo=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});let Mo="en-US";function Po(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,s){throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(Mo=t.toLowerCase().replace(/_/g,"-"))}function zo(t,e,n,s,r){if(t=Dt(t),Array.isArray(t))for(let i=0;i<t.length;i++)zo(t[i],e,n,s,r);else{const i=sn(),a=nn();let o=ka(t)?t:Dt(t.provide),l=va(t);const u=an(),c=1048575&u.providerIndexes,h=u.directiveStart,d=u.providerIndexes>>20;if(ka(t)||!t.multi){const s=new Pn(l,r,Ba),p=Wo(o,e,r?c:c+d,h);-1===p?(ts(Qn(u,a),i,o),Bo(i,t,e.length),e.push(o),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(s),a.push(s)):(n[p]=s,a[p]=s)}else{const p=Wo(o,e,c+d,h),f=Wo(o,e,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(r&&!g||!r&&!m){ts(Qn(u,a),i,o);const c=function(t,e,n,s,r){const i=new Pn(t,n,Ba);return i.multi=[],i.index=e,i.componentProviders=0,Vo(i,r,s&&!n),i}(r?jo:Uo,n.length,r,s,l);!r&&g&&(n[f].providerFactory=c),Bo(i,t,e.length,0),e.push(o),u.directiveStart++,u.directiveEnd++,r&&(u.providerIndexes+=1048576),n.push(c),a.push(c)}else Bo(i,t,p>-1?p:f,Vo(n[r?f:p],l,!r&&s));!r&&s&&g&&n[f].componentProviders++}}}function Bo(t,e,n,s){const r=ka(e);if(r||e.useClass){const i=(e.useClass||e).prototype.ngOnDestroy;if(i){const a=t.destroyHooks||(t.destroyHooks=[]);if(!r&&e.multi){const t=a.indexOf(n);-1===t?a.push(n,[s,i]):a[t+1].push(s,i)}else a.push(n,i)}}}function Vo(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function Wo(t,e,n,s){for(let r=n;r<s;r++)if(e[r]===t)return r;return-1}function Uo(t,e,n,s){return Ho(this.multi,[])}function jo(t,e,n,s){const r=this.multi;let i;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=ls(n,n[1],this.providerFactory.index,s);i=e.slice(0,t),Ho(r,i);for(let n=t;n<e.length;n++)i.push(e[n])}else i=[],Ho(r,i);return i}function Ho(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function Go(t,e=[]){return n=>{n.providersResolver=(n,s)=>function(t,e,n){const s=sn();if(s.firstCreatePass){const r=Re(t);zo(n,s.data,s.blueprint,r,!0),zo(e,s.data,s.blueprint,r,!1)}}(n,s?s(t):t,e)}}class qo{}class Ko{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${At(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let Xo=(()=>{class t{}return t.NULL=new Ko,t})();function Qo(...t){}function Yo(t,e){return new Jo(He(t,e))}const Zo=function(){return Yo(an(),nn())};let Jo=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=Zo,t})();function tl(t){return t instanceof Jo?t.nativeElement:t}class el{}let nl=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>sl(),t})();const sl=function(){const t=nn(),e=qe(an().index,t);return function(t){return t[11]}(Ne(e)?e:t)};let rl=(()=>{class t{}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:()=>null}),t})();class il{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const al=new il("11.2.6");class ol{constructor(){}supports(t){return Da(t)}create(t){return new ul(t)}}const ll=(t,e)=>e;class ul{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||ll}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,s=0,r=null;for(;e||n;){const i=!n||e&&e.currentIndex<pl(n,s,r)?e:n,a=pl(i,s,r),o=i.currentIndex;if(i===n)s--,n=n._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{r||(r=[]);const t=a-s,e=o-s;if(t!=e){for(let n=0;n<t;n++){const s=n<r.length?r[n]:r[n]=0,i=s+n;e<=i&&i<t&&(r[n]=s+1)}r[i.previousIndex]=e-t}}a!==o&&t(i,a,o)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Da(t))throw new Error(`Error trying to diff '${At(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,s,r=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],s=this._trackByFn(e,n),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,n,s,e)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,s,e),i=!0),r=r._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[Fa()]();let s;for(;!(s=n.next()).done;)e(s.value)}}(t,t=>{s=this._trackByFn(e,t),null!==r&&Object.is(r.trackById,s)?(i&&(r=this._verifyReinsertion(r,t,s,e)),Object.is(r.item,t)||this._addIdentityChange(r,t)):(r=this._mismatch(r,t,s,e),i=!0),r=r._next,e++}),this.length=e;return this._truncate(r),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,s){let r;return null===t?r=this._itTail:(r=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,r,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,r,s)):t=this._addAfter(new cl(e,n),r,s),t}_verifyReinsertion(t,e,n,s){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?t=this._reinsertAfter(r,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,r=t._nextRemoved;return null===s?this._removalsHead=r:s._nextRemoved=r,null===r?this._removalsTail=s:r._prevRemoved=s,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new dl),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new dl),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class cl{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class hl{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class dl{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new hl,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function pl(t,e,n){const s=t.previousIndex;if(null===s)return s;let r=0;return n&&s<n.length&&(r=n[s]),s+e+r}class fl{constructor(){}supports(t){return t instanceof Map||Oa(t)}create(){return new ml}}class ml{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Oa(t)))throw new Error(`Error trying to diff '${At(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const s=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,s)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const s=n._prev,r=n._next;return s&&(s._next=r),r&&(r._prev=s),n._next=null,n._prev=null,n}const n=new gl(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class gl{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function yl(){return new bl([new ol])}let bl=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||yl()),deps:[[t,new Ps,new Ms]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:yl}),t})();function xl(){return new vl([new fl])}let vl=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>t.create(e,n||xl()),deps:[[t,new Ps,new Ms]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:xl}),t})();function wl(t,e,n,s,r=!1){for(;null!==n;){const i=e[n.index];if(null!==i&&s.push(Ue(i)),Ee(i))for(let t=10;t<i.length;t++){const e=i[t],n=e[1].firstChild;null!==n&&wl(e[1],e,n,s)}const a=n.type;if(8&a)wl(t,e,n.child,s);else if(32&a){const t=Er(n,e);let r;for(;r=t();)s.push(r)}else if(16&a){const t=Kr(e,n);if(Array.isArray(t))s.push(...t);else{const n=Tr(e[16]);wl(n[1],n,t,s,!0)}}n=r?n.projectionNext:n.next}return s}class _l{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return wl(e,t,e.firstChild,[])}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Ee(t)){const e=t[8],n=e?e.indexOf(this):-1;n>-1&&(Lr(t,n),ws(e,n))}this._attachedToViewContainer=!1}Mr(this._lView[1],this._lView)}onDestroy(t){Fi(this._lView[1],this._lView,null,t)}markForCheck(){Yi(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Zi(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){dn(!0);try{Zi(t,e,n)}finally{dn(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var t;this._appRef=null,Yr(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class kl extends _l{constructor(t){super(t),this._view=t}detectChanges(){Ji(this._view)}checkNoChanges(){!function(t){dn(!0);try{Ji(t)}finally{dn(!1)}}(this._view)}get context(){return null}}const Sl=function(t=!1){return function(t,e,n){if(!n&&Ae(t)){const n=qe(t.index,e);return new _l(n,n)}return 47&t.type?new _l(e[16],e):null}(an(),nn(),t)};let Cl=(()=>{class t{}return t.__NG_ELEMENT_ID__=Sl,t.__ChangeDetectorRef__=!0,t})();const Il=[new fl],Nl=new bl([new ol]),El=new vl(Il),Tl=function(){return Fl(an(),nn())};let Al=(()=>{class t{}return t.__NG_ELEMENT_ID__=Tl,t})();const $l=Al,Rl=class extends $l{constructor(t,e,n){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=_i(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&&(n[19]=s.createEmbeddedView(e)),Ci(e,n,t),new _l(n)}};function Fl(t,e){return 4&t.type?new Rl(e,t,Yo(t,e)):null}class Dl{}class Ol{}const Ll=function(){return Wl(an(),nn())};let Ml=(()=>{class t{}return t.__NG_ELEMENT_ID__=Ll,t})();const Pl=Ml,zl=class extends Pl{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=n}get element(){return Yo(this._hostTNode,this._hostLView)}get injector(){return new hs(this._hostTNode,this._hostLView)}get parentInjector(){const t=Jn(this._hostTNode,this._hostLView);if(jn(t)){const e=Gn(t,this._hostLView),n=Hn(t);return new hs(e[1].data[n+8],e)}return new hs(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=Bl(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,n){const s=t.createEmbeddedView(e||{});return this.insert(s,n),s}createComponent(t,e,n,s,r){const i=n||this.parentInjector;if(!r&&null==t.ngModule&&i){const t=i.get(Dl,null);t&&(r=t)}const a=t.create(i,s,void 0,r);return this.insert(a.hostView,e),a}insert(t,e){const n=t._lView,s=n[1];if(Ee(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],s=new zl(e,e[6],e[3]);s.detach(s.indexOf(t))}}const r=this._adjustIndex(e),i=this._lContainer;!function(t,e,n,s){const r=10+s,i=n.length;s>0&&(n[r-1][4]=e),s<i-10?(e[4]=n[r],vs(n,10+s,e)):(n.push(e),e[4]=null),e[3]=n;const a=e[17];null!==a&&n!==a&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(a,e);const o=e[19];null!==o&&o.insertView(t),e[2]|=128}(s,n,i,r);const a=Xr(r,i),o=n[11],l=Ur(o,i[7]);return null!==l&&function(t,e,n,s,r,i){s[0]=r,s[6]=e,Yr(t,s,n,1,r,i)}(s,i[6],o,n,l,a),t.attachToViewContainerRef(),vs(Vl(i),r,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=Bl(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),n=Lr(this._lContainer,e);n&&(ws(Vl(this._lContainer),e),Mr(n[1],n))}detach(t){const e=this._adjustIndex(t,-1),n=Lr(this._lContainer,e);return n&&null!=ws(Vl(this._lContainer),e)?new _l(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function Bl(t){return t[8]}function Vl(t){return t[8]||(t[8]=[])}function Wl(t,e){let n;const s=e[t.index];if(Ee(s))n=s;else{let r;if(8&t.type)r=Ue(s);else{const n=e[11];r=n.createComment("");const s=He(t,e);Br(n,Ur(n,s),r,function(t,e){return Ve(t)?t.nextSibling(e):e.nextSibling}(n,s),!1)}e[t.index]=n=Gi(s,e,r,t),Qi(e,n)}return new zl(n,t,e)}const Ul={};class jl extends Xo{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Ce(t);return new ql(e,this.ngModule)}}function Hl(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const Gl=new ms("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Cr});class ql extends qo{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(hi).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Hl(this.componentDef.inputs)}get outputs(){return Hl(this.componentDef.outputs)}create(t,e,n,s){const r=(s=s||this.ngModule)?function(t,e){return{get:(n,s,r)=>{const i=t.get(n,Ul,r);return i!==Ul||s===Ul?i:e.get(n,s,r)}}}(t,s.injector):t,i=r.get(el,We),a=r.get(rl,null),o=i.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(t,e,n){if(Ve(t))return t.selectRootElement(e,n===ee.ShadowDom);let s="string"==typeof e?t.querySelector(e):e;return s.textContent="",s}(o,n,this.componentDef.encapsulation):Dr(i.createRenderer(null,this.componentDef),l,function(t){const e=t.toLowerCase();return"svg"===e?"http://www.w3.org/2000/svg":"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:Cr,clean:ea,playerHandler:null,flags:0},d=Ri(0,null,null,1,0,null,null,null,null,null),p=_i(null,d,h,c,null,null,i,o,a,r);let f,m;_n(p);try{const t=function(t,e,n,s,r,i){const a=n[1];n[20]=t;const o=ki(a,20,2,"#host",null),l=o.mergedAttrs=e.hostAttrs;null!==l&&(la(o,l,!0),null!==t&&(zn(r,t,l),null!==o.classes&&ti(r,t,o.classes),null!==o.styles&&Jr(r,t,o.styles)));const u=s.createRenderer(t,e),c=_i(n,$i(e),null,e.onPush?64:16,n[20],o,s,u,null,null);return a.firstCreatePass&&(ts(Qn(o,n),a,e.type),zi(a,o),Vi(o,n.length,1)),Qi(n,c),n[20]=c}(u,this.componentDef,p,i,o);if(u)if(n)zn(o,u,["ng-version",al.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let s=1,r=2;for(;s<t.length;){let i=t[s];if("string"==typeof i)2===r?""!==i&&e.push(i,t[++s]):8===r&&n.push(i);else{if(!ai(r))break;r=i}s++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&zn(o,u,t),e&&e.length>0&&ti(o,u,e.join(" "))}if(m=Ge(d,20),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const s=e[n];t.push(null!=s?Array.from(s):null)}}f=function(t,e,n,s,r){const i=n[1],a=function(t,e,n){const s=an();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Wi(t,s,e,Si(t,e,1,null),n));const r=ls(e,t,s.directiveStart,s);Sr(r,e);const i=He(s,e);return i&&Sr(i,e),r}(i,n,e);if(s.components.push(a),t[8]=a,r&&r.forEach(t=>t(a,e)),e.contentQueries){const t=an();e.contentQueries(1,a,t.directiveStart)}const o=an();return!i.firstCreatePass||null===e.hostBindings&&null===e.hostAttrs||(Tn(o.index),Mi(n[1],o,0,o.directiveStart,o.directiveEnd,e),Pi(e,a)),a}(t,this.componentDef,p,h,[Ia]),Ci(d,p,null)}finally{Nn()}return new Kl(this.componentType,f,Yo(m,p),p,m)}}class Kl extends class{}{constructor(t,e,n,s,r){super(),this.location=n,this._rootLView=s,this._tNode=r,this.instance=e,this.hostView=this.changeDetectorRef=new kl(s),this.componentType=t}get injector(){return new hs(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const Xl=new Map;class Ql extends Dl{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new jl(this);const n=Ie(t),s=t[fe]||null;s&&Po(s),this._bootstrapComponents=Ir(n.bootstrap),this._r3Injector=ya(t,e,[{provide:Dl,useValue:this},{provide:Xo,useValue:this.componentFactoryResolver}],At(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Ca.THROW_IF_NOT_FOUND,n=Xt.Default){return t===Ca||t===Dl||t===ua?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Yl extends Ol{constructor(t){super(),this.moduleType=t,null!==Ie(t)&&function(t){const e=new Set;!function t(n){const s=Ie(n,!0),r=s.id;null!==r&&(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${At(e)} vs ${At(e.name)}`)}(r,Xl.get(r),n),Xl.set(r,n));const i=Ir(s.imports);for(const a of i)e.has(a)||(e.add(a),t(a))}(t)}(t)}create(t){return new Ql(this.moduleType,t)}}const Zl=class extends Z{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){let s,r=t=>null,i=()=>null;t&&"object"==typeof t?(s=this.__isAsync?e=>{setTimeout(()=>t.next(e))}:e=>{t.next(e)},t.error&&(r=this.__isAsync?e=>{setTimeout(()=>t.error(e))}:e=>{t.error(e)}),t.complete&&(i=this.__isAsync?()=>{setTimeout(()=>t.complete())}:()=>{t.complete()})):(s=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)},e&&(r=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)}),n&&(i=this.__isAsync?()=>{setTimeout(()=>n())}:()=>{n()}));const a=super.subscribe(s,r,i);return t instanceof B&&t.add(a),a}};function Jl(){return this._results[Fa()]()}class tu{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Fa(),n=tu.prototype;n[e]||(n[e]=Jl)}get changes(){return this._changes||(this._changes=new Zl)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){this.dirty=!1;const n=bs(t);(this._changesDetected=!function(t,e,n){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++){let r=t[s],i=e[s];if(n&&(r=n(r),i=n(i)),i!==r)return!1}return!0}(this._results,n,e))&&(this._results=n,this.length=n.length,this.last=n[this.length-1],this.first=n[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class eu{constructor(t){this.queryList=t,this.matches=null}clone(){return new eu(this.queryList)}setDirty(){this.queryList.setDirty()}}class nu{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);s.push(this.queries[n.indexInDeclarationView].clone())}return new nu(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==gu(t,e).matches&&this.queries[e].setDirty()}}class su{constructor(t,e,n=null){this.predicate=t,this.flags=e,this.read=n}}class ru{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const s=null!==e?e.length:0,r=this.getByIndex(n).embeddedTView(t,s);r&&(r.indexInDeclarationView=n,null!==e?e.push(r):e=[r])}return null!==e?new ru(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class iu{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new iu(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&8&n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let s=0;s<n.length;s++){const r=n[s];this.matchTNodeWithReadOption(t,e,au(e,r)),this.matchTNodeWithReadOption(t,e,os(e,t,r,!1,!1))}else n===Al?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,os(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const s=this.metadata.read;if(null!==s)if(s===Jo||s===Ml||s===Al&&4&e.type)this.addMatch(e.index,-2);else{const n=os(e,t,s,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function au(t,e){const n=t.localNames;if(null!==n)for(let s=0;s<n.length;s+=2)if(n[s]===e)return n[s+1];return null}function ou(t,e,n,s){return-1===n?function(t,e){return 11&t.type?Yo(t,e):4&t.type?Fl(t,e):null}(e,t):-2===n?function(t,e,n){return n===Jo?Yo(e,t):n===Al?Fl(e,t):n===Ml?Wl(e,t):void 0}(t,e,s):ls(t,t[1],n,e)}function lu(t,e,n,s){const r=e[19].queries[s];if(null===r.matches){const s=t.data,i=n.matches,a=[];for(let t=0;t<i.length;t+=2){const r=i[t];a.push(r<0?null:ou(e,s[r],i[t+1],n.metadata.read))}r.matches=a}return r.matches}function uu(t,e,n,s){const r=t.queries.getByIndex(n),i=r.matches;if(null!==i){const a=lu(t,e,r,n);for(let t=0;t<i.length;t+=2){const n=i[t];if(n>0)s.push(a[t/2]);else{const r=i[t+1],a=e[-n];for(let t=10;t<a.length;t++){const e=a[t];e[17]===e[3]&&uu(e[1],e,r,s)}if(null!==a[9]){const t=a[9];for(let e=0;e<t.length;e++){const n=t[e];uu(n[1],n,r,s)}}}}}return s}function cu(t){const e=nn(),n=sn(),s=bn();xn(s+1);const r=gu(n,s);if(t.dirty&&Xe(e)===(2==(2&r.metadata.flags))){if(null===r.matches)t.reset([]);else{const i=r.crossesNgTemplate?uu(n,e,s,[]):lu(n,e,r,s);t.reset(i,tl),t.notifyOnChanges()}return!0}return!1}function hu(t,e,n){const s=sn();s.firstCreatePass&&(mu(s,new su(t,e,n),-1),2==(2&e)&&(s.staticViewQueries=!0)),fu(s,nn(),e)}function du(t,e,n,s){const r=sn();if(r.firstCreatePass){const i=an();mu(r,new su(e,n,s),i.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(n.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(r,t),2==(2&n)&&(r.staticContentQueries=!0)}fu(r,nn(),n)}function pu(){return t=nn(),e=bn(),t[19].queries[e].queryList;var t,e}function fu(t,e,n){const s=new tu(4==(4&n));Fi(t,e,s,s.destroy),null===e[19]&&(e[19]=new nu),e[19].queries.push(new eu(s))}function mu(t,e,n){null===t.queries&&(t.queries=new ru),t.queries.track(new iu(e,n))}function gu(t,e){return t.queries.getByIndex(e)}const yu=new ms("Application Initializer");let bu=(()=>{class t{constructor(t){this.appInits=t,this.resolve=Qo,this.reject=Qo,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();qa(e)&&t.push(e)}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Rs(yu,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const xu=new ms("AppId"),vu={provide:xu,useFactory:function(){return`${wu()}${wu()}${wu()}`},deps:[]};function wu(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const _u=new ms("Platform Initializer"),ku=new ms("Platform ID"),Su=new ms("appBootstrapListener");let Cu=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const Iu=new ms("LocaleId"),Nu=new ms("DefaultCurrencyCode");class Eu{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const Tu=function(t){return new Yl(t)},Au=Tu,$u=function(t){return Promise.resolve(Tu(t))},Ru=function(t){const e=Tu(t),n=Ir(Ie(t).declarations).reduce((t,e)=>{const n=Ce(e);return n&&t.push(new ql(n)),t},[]);return new Eu(e,n)},Fu=Ru,Du=function(t){return Promise.resolve(Ru(t))};let Ou=(()=>{class t{constructor(){this.compileModuleSync=Au,this.compileModuleAsync=$u,this.compileModuleAndAllComponentsSync=Fu,this.compileModuleAndAllComponentsAsync=Du}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const Lu=(()=>Promise.resolve(0))();function Mu(t){"undefined"==typeof Zone?Lu.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Pu{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Zl(!1),this.onMicrotaskEmpty=new Zl(!1),this.onStable=new Zl(!1),this.onError=new Zl(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched(),this._nesting=0,this._outer=this._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(this._inner=this._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(this._inner=this._inner.fork(Zone.longStackTraceZoneSpec)),this.shouldCoalesceEventChangeDetection=!n&&e,this.shouldCoalesceRunChangeDetection=n,this.lastRequestAnimationFrameId=-1,this.nativeRequestAnimationFrame=function(){let t=ae.requestAnimationFrame,e=ae.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const s=e[Zone.__symbol__("OriginalDelegate")];s&&(e=s)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=()=>{!function(t){-1===t.lastRequestAnimationFrameId&&(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(ae,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Vu(t),Bu(t)},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Vu(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,s,r,i,a,o)=>{try{return Wu(t),n.invokeTask(r,i,a,o)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||t.shouldCoalesceRunChangeDetection)&&e(),Uu(t)}},onInvoke:(n,s,r,i,a,o,l)=>{try{return Wu(t),n.invoke(r,i,a,o,l)}finally{t.shouldCoalesceRunChangeDetection&&e(),Uu(t)}},onHasTask:(e,n,s,r)=>{e.hasTask(s,r),n===s&&("microTask"==r.change?(t._hasPendingMicrotasks=r.microTask,Vu(t),Bu(t)):"macroTask"==r.change&&(t.hasPendingMacrotasks=r.macroTask))},onHandleError:(e,n,s,r)=>(e.handleError(s,r),t.runOutsideAngular(()=>t.onError.emit(r)),!1)})}(this)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Pu.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Pu.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,s){const r=this._inner,i=r.scheduleEventTask("NgZoneEvent: "+s,t,zu,Qo,Qo);try{return r.runTask(i,e,n)}finally{r.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}const zu={};function Bu(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Vu(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Wu(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Uu(t){t._nesting--,Bu(t)}class ju{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Zl,this.onMicrotaskEmpty=new Zl,this.onStable=new Zl,this.onError=new Zl}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,s){return t.apply(e,n)}}let Hu=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Pu.assertNotInAngularZone(),Mu(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Mu(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let s=-1;e&&e>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==s),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:s,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Gu=(()=>{class t{constructor(){this._applications=new Map,Xu.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return Xu.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class qu{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let Ku,Xu=new qu,Qu=!0,Yu=!1;function Zu(){return Yu=!0,Qu}const Ju=new ms("AllowMultipleToken");class tc{constructor(t,e){this.name=t,this.token=e}}function ec(t,e,n=[]){const s=`Platform: ${e}`,r=new ms(s);return(e=[])=>{let i=nc();if(!i||i.injector.get(Ju,!1))if(t)t(n.concat(e).concat({provide:r,useValue:!0}));else{const t=n.concat(e).concat({provide:r,useValue:!0},{provide:ha,useValue:"platform"});!function(t){if(Ku&&!Ku.destroyed&&!Ku.injector.get(Ju,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");Ku=t.get(sc);const e=t.get(_u,null);e&&e.forEach(t=>t())}(Ca.create({providers:t,name:s}))}return function(t){const e=nc();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(r)}}function nc(){return Ku&&!Ku.destroyed?Ku:null}let sc=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new ju:("zone.js"===t?void 0:t)||new Pu({enableLongStackTrace:Zu(),shouldCoalesceEventChangeDetection:!!(null==e?void 0:e.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==e?void 0:e.ngZoneRunCoalescing)}),n}(e?e.ngZone:void 0,{ngZoneEventCoalescing:e&&e.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:e&&e.ngZoneRunCoalescing||!1}),s=[{provide:Pu,useValue:n}];return n.run(()=>{const e=Ca.create({providers:s,parent:this.injector,name:t.moduleType.name}),r=t.create(e),i=r.injector.get(kr,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const t=n.onError.subscribe({next:t=>{i.handleError(t)}});r.onDestroy(()=>{ac(this._modules,r),t.unsubscribe()})}),function(t,e,n){try{const s=n();return qa(s)?s.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):s}catch(s){throw e.runOutsideAngular(()=>t.handleError(s)),s}}(i,n,()=>{const t=r.injector.get(bu);return t.runInitializers(),t.donePromise.then(()=>(Po(r.injector.get(Iu,"en-US")||"en-US"),this._moduleDoBootstrap(r),r))})})}bootstrapModule(t,e=[]){const n=rc({},e);return function(t,e,n){const s=new Yl(n);return Promise.resolve(s)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(ic);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${At(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Rs(Ca))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function rc(t,e){return Array.isArray(e)?e.reduce(rc,t):Object.assign(Object.assign({},t),e)}let ic=(()=>{class t{constructor(t,e,n,s,r){this._zone=t,this._injector=e,this._exceptionHandler=n,this._componentFactoryResolver=s,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new q(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),a=new q(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{Pu.assertNotInAngularZone(),Mu(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Pu.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=vt(i,a.pipe(t=>{return wt()((e=Nt,function(t){let n;n="function"==typeof e?e:function(){return e};const s=Object.create(t,Ct);return s.source=t,s.subjectFactory=n,s})(t));var e}))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof qo?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const s=n.isBoundToModule?void 0:this._injector.get(Dl),r=n.create(Ca.NULL,[],e||n.selector,s),i=r.location.nativeElement,a=r.injector.get(Hu,null),o=a&&r.injector.get(Gu);return a&&o&&o.registerApplication(i,a),r.onDestroy(()=>{this.detachView(r.hostView),ac(this.components,r),o&&o.unregisterApplication(i)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;ac(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(Su,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pu),Rs(Ca),Rs(kr),Rs(Xo),Rs(bu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function ac(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class oc{}class lc{}const uc={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let cc=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||uc}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,s]=t.split("#");return void 0===s&&(s="default"),n("zn8P")(e).then(t=>t[s]).then(t=>hc(t,e,s)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,s]=t.split("#"),r="NgFactory";return void 0===s&&(s="default",r=""),n("zn8P")(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[s+r]).then(t=>hc(t,e,s))}}return t.\u0275fac=function(e){return new(e||t)(Rs(Ou),Rs(lc,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function hc(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const dc=ec(null,"core",[{provide:ku,useValue:"unknown"},{provide:sc,deps:[Ca]},{provide:Gu,deps:[]},{provide:Cu,deps:[]}]),pc=[{provide:ic,useClass:ic,deps:[Pu,Ca,kr,Xo,bu]},{provide:Gl,deps:[Pu],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:bu,useClass:bu,deps:[[new Ms,yu]]},{provide:Ou,useClass:Ou,deps:[]},vu,{provide:bl,useFactory:function(){return Nl},deps:[]},{provide:vl,useFactory:function(){return El},deps:[]},{provide:Iu,useFactory:function(t){return Po(t=t||"undefined"!=typeof $localize&&$localize.locale||"en-US"),t},deps:[[new Ls(Iu),new Ms,new Ps]]},{provide:Nu,useValue:"USD"}];let fc=(()=>{class t{constructor(t){}}return t.\u0275fac=function(e){return new(e||t)(Rs(ic))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:pc}),t})(),mc=null;function gc(){return mc}const yc=new ms("DocumentToken");let bc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:xc,token:t,providedIn:"platform"}),t})();function xc(){return Rs(wc)}const vc=new ms("Location Initialized");let wc=(()=>{class t extends bc{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=gc().getLocation(),this._history=gc().getHistory()}getBaseHrefFromDOM(){return gc().getBaseHref(this._doc)}onPopState(t){gc().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",t,!1)}onHashChange(t){gc().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",t,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){_c()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){_c()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({factory:kc,token:t,providedIn:"platform"}),t})();function _c(){return!!window.history.pushState}function kc(){return new wc(Rs(yc))}function Sc(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function Cc(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function Ic(t){return t&&"?"!==t[0]?"?"+t:t}let Nc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:Ec,token:t,providedIn:"root"}),t})();function Ec(t){const e=Rs(yc).location;return new Ac(Rs(bc),e&&e.origin||"")}const Tc=new ms("appBaseHref");let Ac=(()=>{class t extends Nc{constructor(t,e){if(super(),this._platformLocation=t,null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return Sc(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+Ic(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,s){const r=this.prepareExternalUrl(n+Ic(s));this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){const r=this.prepareExternalUrl(n+Ic(s));this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(Rs(bc),Rs(Tc,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),$c=(()=>{class t extends Nc{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",null!=e&&(this._baseHref=e)}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=Sc(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,s){let r=this.prepareExternalUrl(n+Ic(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(t,e,r)}replaceState(t,e,n,s){let r=this.prepareExternalUrl(n+Ic(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(Rs(bc),Rs(Tc,8))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Rc=(()=>{class t{constructor(t,e){this._subject=new Zl,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=Cc(Dc(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+Ic(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,Dc(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Ic(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Ic(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(Rs(Nc),Rs(bc))},t.normalizeQueryParams=Ic,t.joinWithSlash=Sc,t.stripTrailingSlash=Cc,t.\u0275prov=Bt({factory:Fc,token:t,providedIn:"root"}),t})();function Fc(){return new Rc(Rs(Nc),Rs(bc))}function Dc(t){return t.replace(/\/index.html$/,"")}var Oc=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({});class Lc{}let Mc=(()=>{class t extends Lc{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return function(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=Oo(e);if(n)return n;const s=e.split("-")[0];if(n=Oo(s),n)return n;if("en"===s)return Fo;throw new Error(`Missing locale data for the locale "${t}".`)}(t)[Lo.PluralCase]}(e||this.locale)(t)){case Oc.Zero:return"zero";case Oc.One:return"one";case Oc.Two:return"two";case Oc.Few:return"few";case Oc.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(Rs(Iu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Pc{constructor(t,e,n,s){this.$implicit=t,this.ngForOf=e,this.index=n,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let zc=(()=>{class t{constructor(t,e,n){this._viewContainer=t,this._template=e,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(t){this._ngForOf=t,this._ngForOfDirty=!0}set ngForTrackBy(t){this._trackByFn=t}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(t){t&&(this._template=t)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(e){throw new Error(`Cannot find a differ supporting object '${n}' of type '${t=n,t.name||typeof t}'. NgFor only supports binding to Iterables such as Arrays.`)}}var t;if(this._differ){const t=this._differ.diff(this._ngForOf);t&&this._applyChanges(t)}}_applyChanges(t){const e=[];t.forEachOperation((t,n,s)=>{if(null==t.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new Pc(null,this._ngForOf,-1,-1),null===s?void 0:s),r=new Bc(t,n);e.push(r)}else if(null==s)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const r=this._viewContainer.get(n);this._viewContainer.move(r,s);const i=new Bc(t,r);e.push(i)}});for(let n=0;n<e.length;n++)this._perViewChange(e[n].view,e[n].record);for(let n=0,s=this._viewContainer.length;n<s;n++){const t=this._viewContainer.get(n);t.context.index=n,t.context.count=s,t.context.ngForOf=this._ngForOf}t.forEachIdentityChange(t=>{this._viewContainer.get(t.currentIndex).context.$implicit=t.item})}_perViewChange(t,e){t.context.$implicit=e.item}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(Ba(Ml),Ba(Al),Ba(bl))},t.\u0275dir=Se({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),t})();class Bc{constructor(t,e){this.record=t,this.view=e}}let Vc=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new Wc,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){Uc("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){Uc("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(Ba(Ml),Ba(Al))},t.\u0275dir=Se({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class Wc{constructor(){this.$implicit=null,this.ngIf=null}}function Uc(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${At(e)}'.`)}let jc=(()=>{class t{constructor(t,e,n){this._ngEl=t,this._differs=e,this._renderer=n,this._ngStyle=null,this._differ=null}set ngStyle(t){this._ngStyle=t,!this._differ&&t&&(this._differ=this._differs.find(t).create())}ngDoCheck(){if(this._differ){const t=this._differ.diff(this._ngStyle);t&&this._applyChanges(t)}}_setStyle(t,e){const[n,s]=t.split(".");null!=(e=null!=e&&s?`${e}${s}`:e)?this._renderer.setStyle(this._ngEl.nativeElement,n,e):this._renderer.removeStyle(this._ngEl.nativeElement,n)}_applyChanges(t){t.forEachRemovedItem(t=>this._setStyle(t.key,null)),t.forEachAddedItem(t=>this._setStyle(t.key,t.currentValue)),t.forEachChangedItem(t=>this._setStyle(t.key,t.currentValue))}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(vl),Ba(nl))},t.\u0275dir=Se({type:t,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"}}),t})(),Hc=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[{provide:Lc,useClass:Mc}]}),t})();function Gc(t){return"browser"===t}function qc(t){return"server"===t}let Kc=(()=>{class t{}return t.\u0275prov=Bt({token:t,providedIn:"root",factory:()=>new Xc(Rs(yc),window)}),t})();class Xc{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){var e;if(!this.supportsScrolling())return;const n=null!==(e=this.document.getElementById(t))&&void 0!==e?e:this.document.getElementsByName(t)[0];void 0!==n&&(this.scrollToElement(n),this.attemptFocus(n))}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],s-r[1])}attemptFocus(t){return t.focus(),this.document.activeElement===t}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=Qc(this.window.history)||Qc(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function Qc(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class Yc extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var t;t=new Yc,mc||(mc=t)}getProperty(t,e){return t[e]}log(t){window.console&&window.console.log&&window.console.log(t)}logGroup(t){window.console&&window.console.group&&window.console.group(t)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){return t.parentNode&&t.parentNode.removeChild(t),t}getValue(t){return t.value}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(t){const e=Jc||(Jc=document.querySelector("base"),Jc)?Jc.getAttribute("href"):null;return null==e?null:(n=e,Zc||(Zc=document.createElement("a")),Zc.setAttribute("href",n),"/"===Zc.pathname.charAt(0)?Zc.pathname:"/"+Zc.pathname);var n}resetBaseElement(){Jc=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(t){return function(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[s,r]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(s.trim()===e)return decodeURIComponent(r)}return null}(document.cookie,t)}}let Zc,Jc=null;const th=new ms("TRANSITION_ID"),eh=[{provide:yu,useFactory:function(t,e,n){return()=>{n.get(bu).donePromise.then(()=>{const n=gc();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[th,yc,Ca],multi:!0}];class nh{static init(){var t;t=new nh,Xu=t}addToWindow(t){ae.getAngularTestability=(e,n=!0)=>{const s=t.findTestabilityInTree(e,n);if(null==s)throw new Error("Could not find testability for element.");return s},ae.getAllAngularTestabilities=()=>t.getAllTestabilities(),ae.getAllAngularRootElements=()=>t.getAllRootElements(),ae.frameworkStabilizers||(ae.frameworkStabilizers=[]),ae.frameworkStabilizers.push(t=>{const e=ae.getAllAngularTestabilities();let n=e.length,s=!1;const r=function(e){s=s||e,n--,0==n&&t(s)};e.forEach(function(t){t.whenStable(r)})})}findTestabilityInTree(t,e,n){if(null==e)return null;const s=t.getTestability(e);return null!=s?s:n?gc().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}const sh=new ms("EventManagerPlugins");let rh=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let s=0;s<n.length;s++){const e=n[s];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error(`No event manager plugin found for event ${t}`)}}return t.\u0275fac=function(e){return new(e||t)(Rs(sh),Rs(Pu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class ih{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const s=gc().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,n)}}let ah=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),oh=(()=>{class t extends ah{constructor(t){super(),this._doc=t,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(t.head)}_addStylesToHost(t,e){t.forEach(t=>{const n=this._doc.createElement("style");n.textContent=t,this._styleNodes.add(e.appendChild(n))})}addHost(t){this._addStylesToHost(this._stylesSet,t),this._hostNodes.add(t)}removeHost(t){this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach(e=>this._addStylesToHost(t,e))}ngOnDestroy(){this._styleNodes.forEach(t=>gc().remove(t))}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const lh={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},uh=/%COMP%/g;function ch(t,e,n){for(let s=0;s<e.length;s++){let r=e[s];Array.isArray(r)?ch(t,r,n):(r=r.replace(uh,t),n.push(r))}return n}function hh(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let dh=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new ph(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case ee.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new fh(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case 1:case ee.ShadowDom:return new mh(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=ch(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Rs(rh),Rs(oh),Rs(xu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class ph{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(lh[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,s){if(s){e=s+":"+e;const r=lh[s];r?t.setAttributeNS(r,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const s=lh[n];s?t.removeAttributeNS(s,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,s){s&(Nr.DashCase|Nr.Important)?t.style.setProperty(e,n,s&Nr.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&Nr.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,hh(n)):this.eventManager.addEventListener(t,e,hh(n))}}class fh extends ph{constructor(t,e,n,s){super(t),this.component=n;const r=ch(s+"-"+n.id,n.styles,[]);e.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(uh,s+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(uh,s+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class mh extends ph{constructor(t,e,n,s){super(t),this.sharedStylesHost=e,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=ch(s.id,s.styles,[]);for(let i=0;i<r.length;i++){const t=document.createElement("style");t.textContent=r[i],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let gh=(()=>{class t extends ih{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const yh=["alt","control","meta","shift"],bh={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},xh={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},vh={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let wh=(()=>{class t extends ih{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,s){const r=t.parseEventName(n),i=t.eventCallback(r.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>gc().onAndCancel(e,r.domEventName,i))}static parseEventName(e){const n=e.toLowerCase().split("."),s=n.shift();if(0===n.length||"keydown"!==s&&"keyup"!==s)return null;const r=t._normalizeKey(n.pop());let i="";if(yh.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),i+=t+".")}),i+=r,0!=n.length||0===r.length)return null;const a={};return a.domEventName=s,a.fullKey=i,a}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&xh.hasOwnProperty(e)&&(e=xh[e]))}return bh[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),yh.forEach(s=>{s!=n&&(0,vh[s])(t)&&(e+=s+".")}),e+=n,e}static eventCallback(e,n,s){return r=>{t.getEventFullKey(r)===e&&s.runGuarded(()=>n(r))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),_h=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return Rs(kh)},token:t,providedIn:"root"}),t})(),kh=(()=>{class t extends _h{constructor(t){super(),this._doc=t}sanitize(t,e){if(null==e)return null;switch(t){case br.NONE:return e;case br.HTML:return Ks(e,"HTML")?qs(e):function(t,e){let n=null;try{gr=gr||function(t){const e=new Ys(t);return function(){try{return!!(new window.DOMParser).parseFromString(Bs(""),"text/html")}catch(t){return!1}}()?new Qs(e):e}(t);let s=e?String(e):"";n=gr.getInertBodyElement(s);let r=5,i=s;do{if(0===r)throw new Error("Failed to sanitize html because the input is unstable");r--,s=i,i=n.innerHTML,n=gr.getInertBodyElement(s)}while(s!==i);return Bs((new dr).sanitizeChildren(yr(n)||n))}finally{if(n){const t=yr(n)||n;for(;t.firstChild;)t.removeChild(t.firstChild)}}}(this._doc,String(e)).toString();case br.STYLE:return Ks(e,"Style")?qs(e):e;case br.SCRIPT:if(Ks(e,"Script"))return qs(e);throw new Error("unsafe value used in a script context");case br.URL:return Xs(e),Ks(e,"URL")?qs(e):tr(String(e));case br.RESOURCE_URL:if(Ks(e,"ResourceURL"))return qs(e);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(t){return new Ws(t)}bypassSecurityTrustStyle(t){return new Us(t)}bypassSecurityTrustScript(t){return new js(t)}bypassSecurityTrustUrl(t){return new Hs(t)}bypassSecurityTrustResourceUrl(t){return new Gs(t)}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({factory:function(){return t=Rs(ua),new kh(t.get(yc));var t},token:t,providedIn:"root"}),t})();const Sh=ec(dc,"browser",[{provide:ku,useValue:"browser"},{provide:_u,useValue:function(){Yc.makeCurrent(),nh.init()},multi:!0},{provide:yc,useFactory:function(){return function(t){Be=t}(document),document},deps:[]}]),Ch=[[],{provide:ha,useValue:"root"},{provide:kr,useFactory:function(){return new kr},deps:[]},{provide:sh,useClass:gh,multi:!0,deps:[yc,Pu,ku]},{provide:sh,useClass:wh,multi:!0,deps:[yc]},[],{provide:dh,useClass:dh,deps:[rh,oh,xu]},{provide:el,useExisting:dh},{provide:ah,useExisting:oh},{provide:oh,useClass:oh,deps:[yc]},{provide:Hu,useClass:Hu,deps:[Pu]},{provide:rh,useClass:rh,deps:[sh,Pu]},[]];let Ih=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:xu,useValue:e.appId},{provide:th,useExisting:xu},eh]}}}return t.\u0275fac=function(e){return new(e||t)(Rs(t,12))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:Ch,imports:[Hc,fc]}),t})();"undefined"!=typeof window&&window;class Nh extends Z{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new X;return this._value}next(t){super.next(this._value=t)}}class Eh extends B{constructor(t,e){super()}schedule(t,e=0){return this}}class Th extends Eh{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,s=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(s,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n,s=!1;try{this.work(t)}catch(r){s=!0,n=!!r&&r||new Error(r)}if(s)return this.unsubscribe(),n}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,s=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==s&&n.splice(s,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let Ah=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class $h extends Ah{constructor(t,e=Ah.now){super(t,()=>$h.delegate&&$h.delegate!==this?$h.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return $h.delegate&&$h.delegate!==this?$h.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}function Rh(...t){let e=t[t.length-1];return tt(e)?(t.pop(),ct(t,e)):xt(t)}function Fh(t,e,n,s){return R(n)&&(s=n,n=void 0),s?Fh(t,e,n).pipe(et(t=>M(t)?s(...t):s(t))):new q(s=>{Dh(t,e,function(t){s.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},s,n)})}function Dh(t,e,n,s,r){let i;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(t)){const s=t;t.addEventListener(e,n,r),i=()=>s.removeEventListener(e,n,r)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(t)){const s=t;t.on(e,n),i=()=>s.off(e,n)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(t)){const s=t;t.addListener(e,n),i=()=>s.removeListener(e,n)}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(let i=0,a=t.length;i<a;i++)Dh(t[i],e,n,s,r)}s.add(i)}function Oh(t,e){return function(n){return n.lift(new Lh(t,e))}}class Lh{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new Mh(t,this.predicate,this.thisArg))}}class Mh extends U{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}const Ph=new $h(Th);function zh(t,e){return"function"==typeof e?n=>n.pipe(zh((n,s)=>ht(t(n,s)).pipe(et((t,r)=>e(n,t,s,r))))):e=>e.lift(new Bh(t))}class Bh{constructor(t){this.project=t}call(t,e){return e.subscribe(new Vh(t,this.project))}}class Vh extends pt{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(s){return void this.destination.error(s)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&&e.unsubscribe();const n=new dt(this),s=this.destination;s.add(n),this.innerSubscription=ft(t,n),this.innerSubscription!==n&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(t){this.destination.next(t)}}function Wh(t){return e=>e.lift(new Uh(t))}class Uh{constructor(t){this.notifier=t}call(t,e){const n=new jh(t),s=ft(this.notifier,new dt(n));return s&&!n.seenValue?(n.add(s),e.subscribe(n)):n}}class jh extends pt{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}const Hh=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})(),Gh=new q(t=>t.complete());function qh(t){return t?function(t){return new q(e=>t.schedule(()=>e.complete()))}(t):Gh}function Kh(t){return e=>0===t?qh():e.lift(new Xh(t))}class Xh{constructor(t){if(this.total=t,this.total<0)throw new Hh}call(t,e){return e.subscribe(new Qh(t,this.total))}}class Qh extends U{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Yh(){}function Zh(t,e,n){return function(s){return s.lift(new Jh(t,e,n))}}class Jh{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new td(t,this.nextOrObserver,this.error,this.complete))}}class td extends U{constructor(t,e,n,s){super(t),this._tapNext=Yh,this._tapError=Yh,this._tapComplete=Yh,this._tapError=n||Yh,this._tapComplete=s||Yh,R(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||Yh,this._tapError=e.error||Yh,this._tapComplete=e.complete||Yh)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}const ed={provide:Su,useFactory:function(t,e){return()=>{if(Gc(e)){const e=Array.from(t.querySelectorAll(`[class*=${nd}]`)),n=/\bflex-layout-.+?\b/g;e.forEach(t=>{t.classList.contains(`${nd}ssr`)&&t.parentNode?t.parentNode.removeChild(t):t.className.replace(n,"")})}}},deps:[yc,ku],multi:!0},nd="flex-layout-";let sd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[ed]}),t})();class rd{constructor(t=!1,e="all",n="",s="",r=0){this.matches=t,this.mediaQuery=e,this.mqAlias=n,this.suffix=s,this.priority=r,this.property=""}clone(){return new rd(this.matches,this.mediaQuery,this.mqAlias,this.suffix)}}let id=(()=>{class t{constructor(){this.stylesheet=new Map}addStyleToElement(t,e,n){const s=this.stylesheet.get(t);s?s.set(e,n):this.stylesheet.set(t,new Map([[e,n]]))}clearStyles(){this.stylesheet.clear()}getStyleForElement(t,e){const n=this.stylesheet.get(t);let s="";if(n){const t=n.get(e);"number"!=typeof t&&"string"!=typeof t||(s=t+"")}return s}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const ad={addFlexToParent:!0,addOrientationBps:!1,disableDefaultBps:!1,disableVendorPrefixes:!1,serverLoaded:!1,useColumnBasisZero:!0,printWithBreakpoints:[],mediaTriggerAutoRestore:!0,ssrObserveBreakpoints:[]},od=new ms("Flex Layout token, config options for the library",{providedIn:"root",factory:()=>ad}),ld=new ms("FlexLayoutServerLoaded",{providedIn:"root",factory:()=>!1}),ud=new ms("Flex Layout token, collect all breakpoints into one provider",{providedIn:"root",factory:()=>null});function cd(t,e){return t=t?t.clone():new rd,e&&(t.mqAlias=e.alias,t.mediaQuery=e.mediaQuery,t.suffix=e.suffix,t.priority=e.priority),t}const hd=["row","column","row-reverse","column-reverse"];function dd(t){if(t)switch(t.toLowerCase()){case"reverse":case"wrap-reverse":case"reverse-wrap":t="wrap-reverse";break;case"no":case"none":case"nowrap":t="nowrap";break;default:t="wrap"}return t}let pd=(()=>{class t{constructor(t,e,n,s){this.elementRef=t,this.styleBuilder=e,this.styler=n,this.marshal=s,this.DIRECTIVE_KEY="",this.inputs=[],this.mru={},this.destroySubject=new Z,this.styleCache=new Map}get parentElement(){return this.elementRef.nativeElement.parentElement}get nativeElement(){return this.elementRef.nativeElement}get activatedValue(){return this.marshal.getValue(this.nativeElement,this.DIRECTIVE_KEY)}set activatedValue(t){this.marshal.setValue(this.nativeElement,this.DIRECTIVE_KEY,t,this.marshal.activatedAlias)}ngOnChanges(t){Object.keys(t).forEach(e=>{if(-1!==this.inputs.indexOf(e)){const n=e.split(".").slice(1).join(".");this.setValue(t[e].currentValue,n)}})}ngOnDestroy(){this.destroySubject.next(),this.destroySubject.complete(),this.marshal.releaseElement(this.nativeElement)}init(t=[]){this.marshal.init(this.elementRef.nativeElement,this.DIRECTIVE_KEY,this.updateWithValue.bind(this),this.clearStyles.bind(this),t)}addStyles(t,e){const n=this.styleBuilder,s=n.shouldCache;let r=this.styleCache.get(t);r&&s||(r=n.buildStyles(t,e),s&&this.styleCache.set(t,r)),this.mru=Object.assign({},r),this.applyStyleToElement(r),n.sideEffect(t,r,e)}clearStyles(){Object.keys(this.mru).forEach(t=>{this.mru[t]=""}),this.applyStyleToElement(this.mru),this.mru={}}triggerUpdate(){this.marshal.triggerUpdate(this.nativeElement,this.DIRECTIVE_KEY)}getFlexFlowDirection(t,e=!1){if(t){const[n,s]=this.styler.getFlowDirection(t);if(!s&&e){const e=function(t){let[e,n,s]=function(t){t=t?t.toLowerCase():"";let[e,n,s]=t.split(" ");return hd.find(t=>t===e)||(e=hd[0]),"inline"===n&&(n="inline"!==s?s:"",s="inline"),[e,dd(n),!!s]}(t);return function(t,e=null,n=!1){return{display:n?"inline-flex":"flex","box-sizing":"border-box","flex-direction":t,"flex-wrap":e||null}}(e,n,s)}(n);this.styler.applyStyleToElements(e,[t])}return n.trim()}return"row"}hasWrap(t){return this.styler.hasWrap(t)}applyStyleToElement(t,e,n=this.nativeElement){this.styler.applyStyleToElement(n,t,e)}setValue(t,e){this.marshal.setValue(this.nativeElement,this.DIRECTIVE_KEY,t,e)}updateWithValue(t){this.currentValue!==t&&(this.addStyles(t),this.currentValue=t)}}return t.\u0275fac=function(t){!function(){throw new Error("invalid")}()},t.\u0275dir=Se({type:t,features:[Oe]}),t})();const fd=[{alias:"xs",mediaQuery:"screen and (min-width: 0px) and (max-width: 599.98px)",priority:1e3},{alias:"sm",mediaQuery:"screen and (min-width: 600px) and (max-width: 959.98px)",priority:900},{alias:"md",mediaQuery:"screen and (min-width: 960px) and (max-width: 1279.98px)",priority:800},{alias:"lg",mediaQuery:"screen and (min-width: 1280px) and (max-width: 1919.98px)",priority:700},{alias:"xl",mediaQuery:"screen and (min-width: 1920px) and (max-width: 4999.98px)",priority:600},{alias:"lt-sm",overlapping:!0,mediaQuery:"screen and (max-width: 599.98px)",priority:950},{alias:"lt-md",overlapping:!0,mediaQuery:"screen and (max-width: 959.98px)",priority:850},{alias:"lt-lg",overlapping:!0,mediaQuery:"screen and (max-width: 1279.98px)",priority:750},{alias:"lt-xl",overlapping:!0,priority:650,mediaQuery:"screen and (max-width: 1919.98px)"},{alias:"gt-xs",overlapping:!0,mediaQuery:"screen and (min-width: 600px)",priority:-950},{alias:"gt-sm",overlapping:!0,mediaQuery:"screen and (min-width: 960px)",priority:-850},{alias:"gt-md",overlapping:!0,mediaQuery:"screen and (min-width: 1280px)",priority:-750},{alias:"gt-lg",overlapping:!0,mediaQuery:"screen and (min-width: 1920px)",priority:-650}],md="(orientation: portrait) and (max-width: 599.98px)",gd="(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)",yd="(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)",bd="(orientation: portrait) and (min-width: 840px)",xd="(orientation: landscape) and (min-width: 1280px)",vd={HANDSET:`${md}, (orientation: landscape) and (max-width: 959.98px)`,TABLET:`${gd} , ${yd}`,WEB:`${bd}, ${xd} `,HANDSET_PORTRAIT:`${md}`,TABLET_PORTRAIT:`${gd} `,WEB_PORTRAIT:`${bd}`,HANDSET_LANDSCAPE:"(orientation: landscape) and (max-width: 959.98px)",TABLET_LANDSCAPE:`${yd}`,WEB_LANDSCAPE:`${xd}`},wd=[{alias:"handset",priority:2e3,mediaQuery:vd.HANDSET},{alias:"handset.landscape",priority:2e3,mediaQuery:vd.HANDSET_LANDSCAPE},{alias:"handset.portrait",priority:2e3,mediaQuery:vd.HANDSET_PORTRAIT},{alias:"tablet",priority:2100,mediaQuery:vd.TABLET},{alias:"tablet.landscape",priority:2100,mediaQuery:vd.TABLET_LANDSCAPE},{alias:"tablet.portrait",priority:2100,mediaQuery:vd.TABLET_PORTRAIT},{alias:"web",priority:2200,mediaQuery:vd.WEB,overlapping:!0},{alias:"web.landscape",priority:2200,mediaQuery:vd.WEB_LANDSCAPE,overlapping:!0},{alias:"web.portrait",priority:2200,mediaQuery:vd.WEB_PORTRAIT,overlapping:!0}],_d=/(\.|-|_)/g;function kd(t){let e=t.length>0?t.charAt(0):"",n=t.length>1?t.slice(1):"";return e.toUpperCase()+n}const Sd=new ms("Token (@angular/flex-layout) Breakpoints",{providedIn:"root",factory:()=>{const t=Fs(ud),e=Fs(od),n=[].concat.apply([],(t||[]).map(t=>Array.isArray(t)?t:[t]));return function(t,e=[]){const n={};return t.forEach(t=>{n[t.alias]=t}),e.forEach(t=>{n[t.alias]?function(t,...e){if(null==t)throw TypeError("Cannot convert undefined or null to object");for(let n of e)if(null!=n)for(let e in n)n.hasOwnProperty(e)&&(t[e]=n[e])}(n[t.alias],t):n[t.alias]=t}),(s=Object.keys(n).map(t=>n[t])).forEach(t=>{t.suffix||(t.suffix=t.alias.replace(_d,"|").split("|").map(kd).join(""),t.overlapping=!!t.overlapping)}),s;var s}((e.disableDefaultBps?[]:fd).concat(e.addOrientationBps?wd:[]),n)}});function Cd(t,e){return(e&&e.priority||0)-(t&&t.priority||0)}function Id(t,e){return(t.priority||0)-(e.priority||0)}let Nd=(()=>{class t{constructor(t){this.findByMap=new Map,this.items=[...t].sort(Id)}findByAlias(t){return t?this.findWithPredicate(t,e=>e.alias==t):null}findByQuery(t){return this.findWithPredicate(t,e=>e.mediaQuery==t)}get overlappings(){return this.items.filter(t=>1==t.overlapping)}get aliases(){return this.items.map(t=>t.alias)}get suffixes(){return this.items.map(t=>t.suffix?t.suffix:"")}findWithPredicate(t,e){let n=this.findByMap.get(t);return n||(n=this.items.find(e)||null,this.findByMap.set(t,n)),n||null}}return t.\u0275fac=function(e){return new(e||t)(Rs(Sd))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Sd))},token:t,providedIn:"root"}),t})(),Ed=(()=>{class t{constructor(t,e,n){this._zone=t,this._platformId=e,this._document=n,this.source=new Nh(new rd(!0)),this.registry=new Map,this.pendingRemoveListenerFns=[],this._observable$=this.source.asObservable()}get activations(){const t=[];return this.registry.forEach((e,n)=>{e.matches&&t.push(n)}),t}isActive(t){const e=this.registry.get(t);return e?e.matches:this.registerQuery(t).some(t=>t.matches)}observe(t,e=!1){if(t&&t.length){const n=this._observable$.pipe(Oh(n=>!e||t.indexOf(n.mediaQuery)>-1));return vt(new q(e=>{const n=this.registerQuery(t);if(n.length){const t=n.pop();n.forEach(t=>{e.next(t)}),this.source.next(t)}e.complete()}),n)}return this._observable$}registerQuery(t){const e=Array.isArray(t)?t:[t],n=[];return function(t,e){const n=t.filter(t=>!Td[t]);if(n.length>0){const t=n.join(", ");try{const s=e.createElement("style");s.setAttribute("type","text/css"),s.styleSheet||s.appendChild(e.createTextNode(`\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${t} {.fx-query-test{ }}\n`)),e.head.appendChild(s),n.forEach(t=>Td[t]=s)}catch(s){console.error(s)}}}(e,this._document),e.forEach(t=>{const e=e=>{this._zone.run(()=>this.source.next(new rd(e.matches,t)))};let s=this.registry.get(t);s||(s=this.buildMQL(t),s.addListener(e),this.pendingRemoveListenerFns.push(()=>s.removeListener(e)),this.registry.set(t,s)),s.matches&&n.push(new rd(!0,t))}),n}ngOnDestroy(){let t;for(;t=this.pendingRemoveListenerFns.pop();)t()}buildMQL(t){return function(t,e){return e&&window.matchMedia("all").addListener?window.matchMedia(t):{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{},onchange:null,addEventListener(){},removeEventListener(){},dispatchEvent:()=>!1}}(t,Gc(this._platformId))}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pu),Rs(ku),Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Pu),Rs(ku),Rs(yc))},token:t,providedIn:"root"}),t})();const Td={},Ad={alias:"print",mediaQuery:"print",priority:1e3};let $d=(()=>{class t{constructor(t,e,n){this.breakpoints=t,this.layoutConfig=e,this._document=n,this.registeredBeforeAfterPrintHooks=!1,this.isPrintingBeforeAfterEvent=!1,this.beforePrintEventListeners=[],this.afterPrintEventListeners=[],this.isPrinting=!1,this.queue=new Rd,this.deactivations=[]}withPrintQuery(t){return[...t,"print"]}isPrintEvent(t){return t.mediaQuery.startsWith("print")}get printAlias(){return this.layoutConfig.printWithBreakpoints||[]}get printBreakPoints(){return this.printAlias.map(t=>this.breakpoints.findByAlias(t)).filter(t=>null!==t)}getEventBreakpoints({mediaQuery:t}){const e=this.breakpoints.findByQuery(t);return(e?[...this.printBreakPoints,e]:this.printBreakPoints).sort(Cd)}updateEvent(t){let e=this.breakpoints.findByQuery(t.mediaQuery);return this.isPrintEvent(t)&&(e=this.getEventBreakpoints(t)[0],t.mediaQuery=e?e.mediaQuery:""),cd(t,e)}registerBeforeAfterPrintHooks(t){if(!this._document.defaultView||this.registeredBeforeAfterPrintHooks)return;this.registeredBeforeAfterPrintHooks=!0;const e=()=>{this.isPrinting||(this.isPrintingBeforeAfterEvent=!0,this.startPrinting(t,this.getEventBreakpoints(new rd(!0,"print"))),t.updateStyles())},n=()=>{this.isPrintingBeforeAfterEvent=!1,this.isPrinting&&(this.stopPrinting(t),t.updateStyles())};this._document.defaultView.addEventListener("beforeprint",e),this._document.defaultView.addEventListener("afterprint",n),this.beforePrintEventListeners.push(e),this.afterPrintEventListeners.push(n)}interceptEvents(t){return this.registerBeforeAfterPrintHooks(t),e=>{this.isPrintEvent(e)?e.matches&&!this.isPrinting?(this.startPrinting(t,this.getEventBreakpoints(e)),t.updateStyles()):e.matches||!this.isPrinting||this.isPrintingBeforeAfterEvent||(this.stopPrinting(t),t.updateStyles()):this.collectActivations(e)}}blockPropagation(){return t=>!(this.isPrinting||this.isPrintEvent(t))}startPrinting(t,e){this.isPrinting=!0,t.activatedBreakpoints=this.queue.addPrintBreakpoints(e)}stopPrinting(t){t.activatedBreakpoints=this.deactivations,this.deactivations=[],this.queue.clear(),this.isPrinting=!1}collectActivations(t){if(!this.isPrinting||this.isPrintingBeforeAfterEvent)if(t.matches)this.isPrintingBeforeAfterEvent||(this.deactivations=[]);else{const e=this.breakpoints.findByQuery(t.mediaQuery);e&&(this.deactivations.push(e),this.deactivations.sort(Cd))}}ngOnDestroy(){this.beforePrintEventListeners.forEach(t=>this._document.defaultView.removeEventListener("beforeprint",t)),this.afterPrintEventListeners.forEach(t=>this._document.defaultView.removeEventListener("afterprint",t))}}return t.\u0275fac=function(e){return new(e||t)(Rs(Nd),Rs(od),Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Nd),Rs(od),Rs(yc))},token:t,providedIn:"root"}),t})();class Rd{constructor(){this.printBreakpoints=[]}addPrintBreakpoints(t){return t.push(Ad),t.sort(Cd),t.forEach(t=>this.addBreakpoint(t)),this.printBreakpoints}addBreakpoint(t){t&&void 0===this.printBreakpoints.find(e=>e.mediaQuery===t.mediaQuery)&&(this.printBreakpoints=function(t){return!!t&&t.mediaQuery.startsWith("print")}(t)?[t,...this.printBreakpoints]:[...this.printBreakpoints,t])}clear(){this.printBreakpoints=[]}}function Fd(t){for(let e in t){let n=t[e]||"";switch(e){case"display":t.display="flex"===n?["-webkit-flex","flex"]:"inline-flex"===n?["-webkit-inline-flex","inline-flex"]:n;break;case"align-items":case"align-self":case"align-content":case"flex":case"flex-basis":case"flex-flow":case"flex-grow":case"flex-shrink":case"flex-wrap":case"justify-content":t["-webkit-"+e]=n;break;case"flex-direction":n=n||"row",t["-webkit-flex-direction"]=n,t["flex-direction"]=n;break;case"order":t.order=t["-webkit-"+e]=isNaN(+n)?"0":n}}return t}let Dd=(()=>{class t{constructor(t,e,n,s){this._serverStylesheet=t,this._serverModuleLoaded=e,this._platformId=n,this.layoutConfig=s}applyStyleToElement(t,e,n=null){let s={};"string"==typeof e&&(s[e]=n,e=s),s=this.layoutConfig.disableVendorPrefixes?e:Fd(e),this._applyMultiValueStyleToElement(s,t)}applyStyleToElements(t,e=[]){const n=this.layoutConfig.disableVendorPrefixes?t:Fd(t);e.forEach(t=>{this._applyMultiValueStyleToElement(n,t)})}getFlowDirection(t){let e=this.lookupStyle(t,"flex-direction");return[e||"row",this.lookupInlineStyle(t,"flex-direction")||qc(this._platformId)&&this._serverModuleLoaded?e:""]}hasWrap(t){return"wrap"===this.lookupStyle(t,"flex-wrap")}lookupAttributeValue(t,e){return t.getAttribute(e)||""}lookupInlineStyle(t,e){return Gc(this._platformId)?t.style.getPropertyValue(e):this._getServerStyle(t,e)}lookupStyle(t,e,n=!1){let s="";return t&&((s=this.lookupInlineStyle(t,e))||(Gc(this._platformId)?n||(s=getComputedStyle(t).getPropertyValue(e)):this._serverModuleLoaded&&(s=this._serverStylesheet.getStyleForElement(t,e)))),s?s.trim():""}_applyMultiValueStyleToElement(t,e){Object.keys(t).sort().forEach(n=>{const s=t[n],r=Array.isArray(s)?s:[s];r.sort();for(let t of r)t=t?t+"":"",Gc(this._platformId)||!this._serverModuleLoaded?Gc(this._platformId)?e.style.setProperty(n,t):this._setServerStyle(e,n,t):this._serverStylesheet.addStyleToElement(e,n,t)})}_setServerStyle(t,e,n){e=e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();const s=this._readStyleAttribute(t);s[e]=n||"",this._writeStyleAttribute(t,s)}_getServerStyle(t,e){return this._readStyleAttribute(t)[e]||""}_readStyleAttribute(t){const e={},n=t.getAttribute("style");if(n){const t=n.split(/;+/g);for(let n=0;n<t.length;n++){const s=t[n].trim();if(s.length>0){const t=s.indexOf(":");if(-1===t)throw new Error(`Invalid CSS style: ${s}`);e[s.substr(0,t).trim()]=s.substr(t+1).trim()}}}return e}_writeStyleAttribute(t,e){let n="";for(const s in e)e[s]&&(n+=s+":"+e[s]+";");t.setAttribute("style",n)}}return t.\u0275fac=function(e){return new(e||t)(Rs(id),Rs(ld),Rs(ku),Rs(od))},t.\u0275prov=Bt({factory:function(){return new t(Rs(id),Rs(ld),Rs(ku),Rs(od))},token:t,providedIn:"root"}),t})();class Od{constructor(){this.shouldCache=!0}sideEffect(t,e,n){}}function Ld(t,e="1",n="1"){let s=[e,n,t],r=t.indexOf("calc");if(r>0){s[2]=Md(t.substring(r).trim());let e=t.substr(0,r).trim().split(" ");2==e.length&&(s[0]=e[0],s[1]=e[1])}else if(0==r)s[2]=Md(t.trim());else{let r=t.split(" ");s=3===r.length?r:[e,n,t]}return s}function Md(t){return t.replace(/[\s]/g,"").replace(/[\/\*\+\-]/g," $& ")}let Pd=(()=>{class t{constructor(t,e,n){this.matchMedia=t,this.breakpoints=e,this.hook=n,this.activatedBreakpoints=[],this.elementMap=new Map,this.elementKeyMap=new WeakMap,this.watcherMap=new WeakMap,this.updateMap=new WeakMap,this.clearMap=new WeakMap,this.subject=new Z,this.observeActivations()}get activatedAlias(){return this.activatedBreakpoints[0]?this.activatedBreakpoints[0].alias:""}onMediaChange(t){const e=this.findByQuery(t.mediaQuery);e&&((t=cd(t,e)).matches&&-1===this.activatedBreakpoints.indexOf(e)?(this.activatedBreakpoints.push(e),this.activatedBreakpoints.sort(Cd),this.updateStyles()):t.matches||-1===this.activatedBreakpoints.indexOf(e)||(this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(e),1),this.activatedBreakpoints.sort(Cd),this.updateStyles()))}init(t,e,n,s,r=[]){zd(this.updateMap,t,e,n),zd(this.clearMap,t,e,s),this.buildElementKeyMap(t,e),this.watchExtraTriggers(t,e,r)}getValue(t,e,n){const s=this.elementMap.get(t);if(s){const t=void 0!==n?s.get(n):this.getActivatedValues(s,e);if(t)return t.get(e)}}hasValue(t,e){const n=this.elementMap.get(t);if(n){const t=this.getActivatedValues(n,e);if(t)return void 0!==t.get(e)||!1}return!1}setValue(t,e,n,s){let r=this.elementMap.get(t);if(r){const i=(r.get(s)||new Map).set(e,n);r.set(s,i),this.elementMap.set(t,r)}else r=(new Map).set(s,(new Map).set(e,n)),this.elementMap.set(t,r);const i=this.getValue(t,e);void 0!==i&&this.updateElement(t,e,i)}trackValue(t,e){return this.subject.asObservable().pipe(Oh(n=>n.element===t&&n.key===e))}updateStyles(){this.elementMap.forEach((t,e)=>{const n=new Set(this.elementKeyMap.get(e));let s=this.getActivatedValues(t);s&&s.forEach((t,s)=>{this.updateElement(e,s,t),n.delete(s)}),n.forEach(n=>{if(s=this.getActivatedValues(t,n),s){const t=s.get(n);this.updateElement(e,n,t)}else this.clearElement(e,n)})})}clearElement(t,e){const n=this.clearMap.get(t);if(n){const s=n.get(e);s&&(s(),this.subject.next({element:t,key:e,value:""}))}}updateElement(t,e,n){const s=this.updateMap.get(t);if(s){const r=s.get(e);r&&(r(n),this.subject.next({element:t,key:e,value:n}))}}releaseElement(t){const e=this.watcherMap.get(t);e&&(e.forEach(t=>t.unsubscribe()),this.watcherMap.delete(t));const n=this.elementMap.get(t);n&&(n.forEach((t,e)=>n.delete(e)),this.elementMap.delete(t))}triggerUpdate(t,e){const n=this.elementMap.get(t);if(n){const s=this.getActivatedValues(n,e);s&&(e?this.updateElement(t,e,s.get(e)):s.forEach((e,n)=>this.updateElement(t,n,e)))}}buildElementKeyMap(t,e){let n=this.elementKeyMap.get(t);n||(n=new Set,this.elementKeyMap.set(t,n)),n.add(e)}watchExtraTriggers(t,e,n){if(n&&n.length){let s=this.watcherMap.get(t);if(s||(s=new Map,this.watcherMap.set(t,s)),!s.get(e)){const r=vt(...n).subscribe(()=>{const n=this.getValue(t,e);this.updateElement(t,e,n)});s.set(e,r)}}}findByQuery(t){return this.breakpoints.findByQuery(t)}getActivatedValues(t,e){for(let s=0;s<this.activatedBreakpoints.length;s++){const n=t.get(this.activatedBreakpoints[s].alias);if(n&&(void 0===e||n.has(e)&&null!=n.get(e)))return n}const n=t.get("");return void 0===e||n&&n.has(e)?n:void 0}observeActivations(){const t=this.breakpoints.items.map(t=>t.mediaQuery);this.matchMedia.observe(this.hook.withPrintQuery(t)).pipe(Zh(this.hook.interceptEvents(this)),Oh(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this))}}return t.\u0275fac=function(e){return new(e||t)(Rs(Ed),Rs(Nd),Rs($d))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Ed),Rs(Nd),Rs($d))},token:t,providedIn:"root"}),t})();function zd(t,e,n,s){if(void 0!==s){let r=t.get(e);r||(r=new Map,t.set(e,r)),r.set(n,s)}}function Bd(t){return null!=t&&"false"!=`${t}`}function Vd(t){return Array.isArray(t)?t:[t]}function Wd(t){return null==t?"":"string"==typeof t?t:`${t}px`}function Ud(t){return t instanceof Jo?t.nativeElement:t}new Map,new WeakMap;let jd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[sd]]}),t})();const Hd=new ms("cdk-dir-doc",{providedIn:"root",factory:function(){return Fs(yc)}});let Gd=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new Zl,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)(Rs(Hd,8))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Hd,8))},token:t,providedIn:"root"}),t})(),qd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();const Kd=["row","column","row-reverse","column-reverse"];function Xd(t){t=t?t.toLowerCase():"";let[e,n,s]=t.split(" ");return Kd.find(t=>t===e)||(e=Kd[0]),"inline"===n&&(n="inline"!==s?s:"",s="inline"),[e,Yd(n),!!s]}function Qd(t){let[e]=Xd(t);return e.indexOf("row")>-1}function Yd(t){if(t)switch(t.toLowerCase()){case"reverse":case"wrap-reverse":case"reverse-wrap":t="wrap-reverse";break;case"no":case"none":case"nowrap":t="nowrap";break;default:t="wrap"}return t}let Zd=(()=>{class t extends Od{buildStyles(t){return function(t){let[e,n,s]=Xd(t);return function(t,e=null,n=!1){return{display:n?"inline-flex":"flex","box-sizing":"border-box","flex-direction":t,"flex-wrap":e||null}}(e,n,s)}(t)}}return t.\u0275fac=function(e){return Jd(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const Jd=ds(Zd),tp=["fxLayout","fxLayout.xs","fxLayout.sm","fxLayout.md","fxLayout.lg","fxLayout.xl","fxLayout.lt-sm","fxLayout.lt-md","fxLayout.lt-lg","fxLayout.lt-xl","fxLayout.gt-xs","fxLayout.gt-sm","fxLayout.gt-md","fxLayout.gt-lg"];let ep=(()=>{class t extends pd{constructor(t,e,n,s){super(t,n,e,s),this.DIRECTIVE_KEY="layout",this.styleCache=rp,this.init()}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(Dd),Ba(Zd),Ba(Pd))},t.\u0275dir=Se({type:t,features:[Na]}),t})(),np=(()=>{class t extends ep{constructor(){super(...arguments),this.inputs=tp}}return t.\u0275fac=function(e){return sp(e||t)},t.\u0275dir=Se({type:t,selectors:[["","fxLayout",""],["","fxLayout.xs",""],["","fxLayout.sm",""],["","fxLayout.md",""],["","fxLayout.lg",""],["","fxLayout.xl",""],["","fxLayout.lt-sm",""],["","fxLayout.lt-md",""],["","fxLayout.lt-lg",""],["","fxLayout.lt-xl",""],["","fxLayout.gt-xs",""],["","fxLayout.gt-sm",""],["","fxLayout.gt-md",""],["","fxLayout.gt-lg",""]],inputs:{fxLayout:"fxLayout","fxLayout.xs":"fxLayout.xs","fxLayout.sm":"fxLayout.sm","fxLayout.md":"fxLayout.md","fxLayout.lg":"fxLayout.lg","fxLayout.xl":"fxLayout.xl","fxLayout.lt-sm":"fxLayout.lt-sm","fxLayout.lt-md":"fxLayout.lt-md","fxLayout.lt-lg":"fxLayout.lt-lg","fxLayout.lt-xl":"fxLayout.lt-xl","fxLayout.gt-xs":"fxLayout.gt-xs","fxLayout.gt-sm":"fxLayout.gt-sm","fxLayout.gt-md":"fxLayout.gt-md","fxLayout.gt-lg":"fxLayout.gt-lg"},features:[Na]}),t})();const sp=ds(np),rp=new Map;function ip(t,...e){if(null==t)throw TypeError("Cannot convert undefined or null to object");for(let n of e)if(null!=n)for(let e in n)n.hasOwnProperty(e)&&(t[e]=n[e]);return t}new Map,new Map,new Map,new Map;let ap=(()=>{class t extends Od{constructor(t){super(),this.layoutConfig=t}buildStyles(t,e){let[n,s,...r]=t.split(" "),i=r.join(" ");const a=e.direction.indexOf("column")>-1?"column":"row",o=Qd(a)?"max-width":"max-height",l=Qd(a)?"min-width":"min-height",u=String(i).indexOf("calc")>-1,c=u||"auto"===i,h=String(i).indexOf("%")>-1&&!u,d=String(i).indexOf("px")>-1||String(i).indexOf("rem")>-1||String(i).indexOf("em")>-1||String(i).indexOf("vw")>-1||String(i).indexOf("vh")>-1;let p=u||d;n="0"==n?0:n,s="0"==s?0:s;const f=!n&&!s;let m={};const g={"max-width":null,"max-height":null,"min-width":null,"min-height":null};switch(i||""){case"":const t=!1!==this.layoutConfig.useColumnBasisZero;i="row"===a?"0%":t?"0.000000001px":"auto";break;case"initial":case"nogrow":n=0,i="auto";break;case"grow":i="100%";break;case"noshrink":s=0,i="auto";break;case"auto":break;case"none":n=0,s=0,i="auto";break;default:p||h||isNaN(i)||(i+="%"),"0%"===i&&(p=!0),"0px"===i&&(i="0%"),m=ip(g,u?{"flex-grow":n,"flex-shrink":s,"flex-basis":p?i:"100%"}:{flex:`${n} ${s} ${p?i:"100%"}`})}return m.flex||m["flex-grow"]||(m=ip(g,u?{"flex-grow":n,"flex-shrink":s,"flex-basis":i}:{flex:`${n} ${s} ${i}`})),"0%"!==i&&"0px"!==i&&"0.000000001px"!==i&&"auto"!==i&&(m[l]=f||p&&n?i:null,m[o]=f||!c&&s?i:null),m[l]||m[o]?e.hasWrap&&(m[u?"flex-basis":"flex"]=m[o]?u?m[o]:`${n} ${s} ${m[o]}`:u?m[l]:`${n} ${s} ${m[l]}`):m=ip(g,u?{"flex-grow":n,"flex-shrink":s,"flex-basis":i}:{flex:`${n} ${s} ${i}`}),ip(m,{"box-sizing":"border-box"})}}return t.\u0275fac=function(e){return new(e||t)(Rs(od))},t.\u0275prov=Bt({factory:function(){return new t(Rs(od))},token:t,providedIn:"root"}),t})();const op=["fxFlex","fxFlex.xs","fxFlex.sm","fxFlex.md","fxFlex.lg","fxFlex.xl","fxFlex.lt-sm","fxFlex.lt-md","fxFlex.lt-lg","fxFlex.lt-xl","fxFlex.gt-xs","fxFlex.gt-sm","fxFlex.gt-md","fxFlex.gt-lg"];let lp=(()=>{class t extends pd{constructor(t,e,n,s,r){super(t,s,e,r),this.layoutConfig=n,this.marshal=r,this.DIRECTIVE_KEY="flex",this.direction=void 0,this.wrap=void 0,this.flexGrow="1",this.flexShrink="1",this.init()}get shrink(){return this.flexShrink}set shrink(t){this.flexShrink=t||"1",this.triggerReflow()}get grow(){return this.flexGrow}set grow(t){this.flexGrow=t||"1",this.triggerReflow()}ngOnInit(){this.parentElement&&(this.marshal.trackValue(this.parentElement,"layout").pipe(Wh(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)),this.marshal.trackValue(this.nativeElement,"layout-align").pipe(Wh(this.destroySubject)).subscribe(this.triggerReflow.bind(this)))}onLayoutChange(t){const e=t.value.split(" ");this.direction=e[0],this.wrap=void 0!==e[1]&&"wrap"===e[1],this.triggerUpdate()}updateWithValue(t){void 0===this.direction&&(this.direction=this.getFlexFlowDirection(this.parentElement,!1!==this.layoutConfig.addFlexToParent)),void 0===this.wrap&&(this.wrap=this.hasWrap(this.parentElement));const e=this.direction,n=e.startsWith("row"),s=this.wrap;n&&s?this.styleCache=pp:n&&!s?this.styleCache=hp:!n&&s?this.styleCache=fp:n||s||(this.styleCache=dp);const r=Ld(String(t).replace(";",""),this.flexGrow,this.flexShrink);this.addStyles(r.join(" "),{direction:e,hasWrap:s})}triggerReflow(){const t=this.activatedValue;if(void 0!==t){const e=Ld(t+"",this.flexGrow,this.flexShrink);this.marshal.updateElement(this.nativeElement,this.DIRECTIVE_KEY,e.join(" "))}}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(Dd),Ba(od),Ba(ap),Ba(Pd))},t.\u0275dir=Se({type:t,inputs:{shrink:["fxShrink","shrink"],grow:["fxGrow","grow"]},features:[Na]}),t})(),up=(()=>{class t extends lp{constructor(){super(...arguments),this.inputs=op}}return t.\u0275fac=function(e){return cp(e||t)},t.\u0275dir=Se({type:t,selectors:[["","fxFlex",""],["","fxFlex.xs",""],["","fxFlex.sm",""],["","fxFlex.md",""],["","fxFlex.lg",""],["","fxFlex.xl",""],["","fxFlex.lt-sm",""],["","fxFlex.lt-md",""],["","fxFlex.lt-lg",""],["","fxFlex.lt-xl",""],["","fxFlex.gt-xs",""],["","fxFlex.gt-sm",""],["","fxFlex.gt-md",""],["","fxFlex.gt-lg",""]],inputs:{fxFlex:"fxFlex","fxFlex.xs":"fxFlex.xs","fxFlex.sm":"fxFlex.sm","fxFlex.md":"fxFlex.md","fxFlex.lg":"fxFlex.lg","fxFlex.xl":"fxFlex.xl","fxFlex.lt-sm":"fxFlex.lt-sm","fxFlex.lt-md":"fxFlex.lt-md","fxFlex.lt-lg":"fxFlex.lt-lg","fxFlex.lt-xl":"fxFlex.lt-xl","fxFlex.gt-xs":"fxFlex.gt-xs","fxFlex.gt-sm":"fxFlex.gt-sm","fxFlex.gt-md":"fxFlex.gt-md","fxFlex.gt-lg":"fxFlex.gt-lg"},features:[Na]}),t})();const cp=ds(up),hp=new Map,dp=new Map,pp=new Map,fp=new Map;new Map,new Map,new Map,new Map,new Map,new Map,new Map;let mp=(()=>{class t extends Od{buildStyles(t,e){const n={},[s,r]=t.split(" ");switch(s){case"center":n["justify-content"]="center";break;case"space-around":n["justify-content"]="space-around";break;case"space-between":n["justify-content"]="space-between";break;case"space-evenly":n["justify-content"]="space-evenly";break;case"end":case"flex-end":n["justify-content"]="flex-end";break;case"start":case"flex-start":default:n["justify-content"]="flex-start"}switch(r){case"start":case"flex-start":n["align-items"]=n["align-content"]="flex-start";break;case"center":n["align-items"]=n["align-content"]="center";break;case"end":case"flex-end":n["align-items"]=n["align-content"]="flex-end";break;case"space-between":n["align-content"]="space-between",n["align-items"]="stretch";break;case"space-around":n["align-content"]="space-around",n["align-items"]="stretch";break;case"baseline":n["align-content"]="stretch",n["align-items"]="baseline";break;case"stretch":default:n["align-items"]=n["align-content"]="stretch"}return ip(n,{display:e.inline?"inline-flex":"flex","flex-direction":e.layout,"box-sizing":"border-box","max-width":"stretch"===r?Qd(e.layout)?null:"100%":null,"max-height":"stretch"===r&&Qd(e.layout)?"100%":null})}}return t.\u0275fac=function(e){return gp(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const gp=ds(mp),yp=["fxLayoutAlign","fxLayoutAlign.xs","fxLayoutAlign.sm","fxLayoutAlign.md","fxLayoutAlign.lg","fxLayoutAlign.xl","fxLayoutAlign.lt-sm","fxLayoutAlign.lt-md","fxLayoutAlign.lt-lg","fxLayoutAlign.lt-xl","fxLayoutAlign.gt-xs","fxLayoutAlign.gt-sm","fxLayoutAlign.gt-md","fxLayoutAlign.gt-lg"];let bp=(()=>{class t extends pd{constructor(t,e,n,s){super(t,n,e,s),this.DIRECTIVE_KEY="layout-align",this.layout="row",this.inline=!1,this.init(),this.marshal.trackValue(this.nativeElement,"layout").pipe(Wh(this.destroySubject)).subscribe(this.onLayoutChange.bind(this))}updateWithValue(t){const e=this.layout||"row",n=this.inline;"row"===e&&n?this.styleCache=Cp:"row"!==e||n?"row-reverse"===e&&n?this.styleCache=Np:"row-reverse"!==e||n?"column"===e&&n?this.styleCache=Ip:"column"!==e||n?"column-reverse"===e&&n?this.styleCache=Ep:"column-reverse"!==e||n||(this.styleCache=Sp):this.styleCache=_p:this.styleCache=kp:this.styleCache=wp,this.addStyles(t,{layout:e,inline:n})}onLayoutChange(t){const e=t.value.split(" ");this.layout=e[0],this.inline=t.value.includes("inline"),Kd.find(t=>t===this.layout)||(this.layout="row"),this.triggerUpdate()}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(Dd),Ba(mp),Ba(Pd))},t.\u0275dir=Se({type:t,features:[Na]}),t})(),xp=(()=>{class t extends bp{constructor(){super(...arguments),this.inputs=yp}}return t.\u0275fac=function(e){return vp(e||t)},t.\u0275dir=Se({type:t,selectors:[["","fxLayoutAlign",""],["","fxLayoutAlign.xs",""],["","fxLayoutAlign.sm",""],["","fxLayoutAlign.md",""],["","fxLayoutAlign.lg",""],["","fxLayoutAlign.xl",""],["","fxLayoutAlign.lt-sm",""],["","fxLayoutAlign.lt-md",""],["","fxLayoutAlign.lt-lg",""],["","fxLayoutAlign.lt-xl",""],["","fxLayoutAlign.gt-xs",""],["","fxLayoutAlign.gt-sm",""],["","fxLayoutAlign.gt-md",""],["","fxLayoutAlign.gt-lg",""]],inputs:{fxLayoutAlign:"fxLayoutAlign","fxLayoutAlign.xs":"fxLayoutAlign.xs","fxLayoutAlign.sm":"fxLayoutAlign.sm","fxLayoutAlign.md":"fxLayoutAlign.md","fxLayoutAlign.lg":"fxLayoutAlign.lg","fxLayoutAlign.xl":"fxLayoutAlign.xl","fxLayoutAlign.lt-sm":"fxLayoutAlign.lt-sm","fxLayoutAlign.lt-md":"fxLayoutAlign.lt-md","fxLayoutAlign.lt-lg":"fxLayoutAlign.lt-lg","fxLayoutAlign.lt-xl":"fxLayoutAlign.lt-xl","fxLayoutAlign.gt-xs":"fxLayoutAlign.gt-xs","fxLayoutAlign.gt-sm":"fxLayoutAlign.gt-sm","fxLayoutAlign.gt-md":"fxLayoutAlign.gt-md","fxLayoutAlign.gt-lg":"fxLayoutAlign.gt-lg"},features:[Na]}),t})();const vp=ds(xp),wp=new Map,_p=new Map,kp=new Map,Sp=new Map,Cp=new Map,Ip=new Map,Np=new Map,Ep=new Map;let Tp=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[sd,qd]]}),t})();new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map,new Map;let Ap=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[sd]]}),t})();new il("11.0.0-beta.33");let $p=(()=>{class t{constructor(t,e){qc(e)&&!t&&console.warn("Warning: Flex Layout loaded on the server without FlexLayoutServerModule")}static withConfig(e,n=[]){return{ngModule:t,providers:e.serverLoaded?[{provide:od,useValue:Object.assign(Object.assign({},ad),e)},{provide:ud,useValue:n,multi:!0},{provide:ld,useValue:!0}]:[{provide:od,useValue:Object.assign(Object.assign({},ad),e)},{provide:ud,useValue:n,multi:!0}]}}}return t.\u0275fac=function(e){return new(e||t)(Rs(ld),Rs(ku))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Tp,jd,Ap],Tp,jd,Ap]}),t})();class Rp{}function Fp(t,e){return{type:7,name:t,definitions:e,options:{}}}function Dp(t,e=null){return{type:4,styles:e,timings:t}}function Op(t,e=null){return{type:2,steps:t,options:e}}function Lp(t){return{type:6,styles:t,offset:null}}function Mp(t,e,n){return{type:0,name:t,styles:e,options:n}}function Pp(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function zp(t){Promise.resolve(null).then(t)}class Bp{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){zp(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Vp{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,s=0;const r=this.players.length;0==r?zp(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==r&&this._onFinish()}),t.onDestroy(()=>{++n==r&&this._onDestroy()}),t.onStart(()=>{++s==r&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){const t=this.players.reduce((t,e)=>null===t||e.totalTime>t.totalTime?e:t,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function Wp(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function Up(t){switch(t.length){case 0:return new Bp;case 1:return t[0];default:return new Vp(t)}}function jp(t,e,n,s,r={},i={}){const a=[],o=[];let l=-1,u=null;if(s.forEach(t=>{const n=t.offset,s=n==l,c=s&&u||{};Object.keys(t).forEach(n=>{let s=n,o=t[n];if("offset"!==n)switch(s=e.normalizePropertyName(s,a),o){case"!":o=r[n];break;case"*":o=i[n];break;default:o=e.normalizeStyleValue(n,s,o,a)}c[s]=o}),s||o.push(c),u=c,l=n}),a.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${a.join(t)}`)}return o}function Hp(t,e,n,s){switch(e){case"start":t.onStart(()=>s(n&&Gp(n,"start",t)));break;case"done":t.onDone(()=>s(n&&Gp(n,"done",t)));break;case"destroy":t.onDestroy(()=>s(n&&Gp(n,"destroy",t)))}}function Gp(t,e,n){const s=n.totalTime,r=qp(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==s?t.totalTime:s,!!n.disabled),i=t._data;return null!=i&&(r._data=i),r}function qp(t,e,n,s,r="",i=0,a){return{element:t,triggerName:e,fromState:n,toState:s,phaseName:r,totalTime:i,disabled:!!a}}function Kp(t,e,n){let s;return t instanceof Map?(s=t.get(e),s||t.set(e,s=n)):(s=t[e],s||(s=t[e]=n)),s}function Xp(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let Qp=(t,e)=>!1,Yp=(t,e)=>!1,Zp=(t,e,n)=>[];const Jp=Wp();(Jp||"undefined"!=typeof Element)&&(Qp=(t,e)=>t.contains(e),Yp=(()=>{if(Jp||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):Yp}})(),Zp=(t,e,n)=>{let s=[];if(n){const n=t.querySelectorAll(e);for(let t=0;t<n.length;t++)s.push(n[t])}else{const n=t.querySelector(e);n&&s.push(n)}return s});let tf=null,ef=!1;function nf(t){tf||(tf=("undefined"!=typeof document?document.body:null)||{},ef=!!tf.style&&"WebkitAppearance"in tf.style);let e=!0;return tf.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in tf.style,!e&&ef)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in tf.style),e}const sf=Yp,rf=Qp,af=Zp;function of(t){const e={};return Object.keys(t).forEach(n=>{const s=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[s]=t[n]}),e}let lf=(()=>{class t{validateStyleProperty(t){return nf(t)}matchesElement(t,e){return sf(t,e)}containsElement(t,e){return rf(t,e)}query(t,e,n){return af(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,s,r,i=[],a){return new Bp(n,s)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),uf=(()=>{class t{}return t.NOOP=new lf,t})();function cf(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:hf(parseFloat(e[1]),e[2])}function hf(t,e){switch(e){case"s":return 1e3*t;default:return t}}function df(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let s,r=0,i="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};s=hf(parseFloat(n[1]),n[2]);const a=n[3];null!=a&&(r=hf(parseFloat(a),n[4]));const o=n[5];o&&(i=o)}else s=t;if(!n){let n=!1,i=e.length;s<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),r<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(i,0,`The provided timing value "${t}" is invalid.`)}return{duration:s,delay:r,easing:i}}(t,e,n)}function pf(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function ff(t,e,n={}){if(e)for(let s in t)n[s]=t[s];else pf(t,n);return n}function mf(t,e,n){return n?e+":"+n+";":""}function gf(t){let e="";for(let n=0;n<t.style.length;n++){const s=t.style.item(n);e+=mf(0,s,t.style.getPropertyValue(s))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=mf(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function yf(t,e,n){t.style&&(Object.keys(e).forEach(s=>{const r=Cf(s);n&&!n.hasOwnProperty(s)&&(n[s]=t.style[r]),t.style[r]=e[s]}),Wp()&&gf(t))}function bf(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=Cf(e);t.style[n]=""}),Wp()&&gf(t))}function xf(t){return Array.isArray(t)?1==t.length?t[0]:Op(t):t}const vf=new RegExp("{{\\s*(.+?)\\s*}}","g");function wf(t){let e=[];if("string"==typeof t){let n;for(;n=vf.exec(t);)e.push(n[1]);vf.lastIndex=0}return e}function _f(t,e,n){const s=t.toString(),r=s.replace(vf,(t,s)=>{let r=e[s];return e.hasOwnProperty(s)||(n.push(`Please provide a value for the animation param ${s}`),r=""),r.toString()});return r==s?t:r}function kf(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const Sf=/-+([a-z0-9])/g;function Cf(t){return t.replace(Sf,(...t)=>t[1].toUpperCase())}function If(t,e){return 0===t||0===e}function Nf(t,e,n){const s=Object.keys(n);if(s.length&&e.length){let i=e[0],a=[];if(s.forEach(t=>{i.hasOwnProperty(t)||a.push(t),i[t]=n[t]}),a.length)for(var r=1;r<e.length;r++){let n=e[r];a.forEach(function(e){n[e]=Tf(t,e)})}}return e}function Ef(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error(`Unable to resolve animation metadata node #${e.type}`)}}function Tf(t,e){return window.getComputedStyle(t)[e]}function Af(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const s=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof s)return void e.push(s);t=s}const s=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==s||s.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const r=s[1],i=s[2],a=s[3];e.push(Ff(r,a)),"<"!=i[0]||"*"==r&&"*"==a||e.push(Ff(a,r))}(t,n,e)):n.push(t),n}const $f=new Set(["true","1"]),Rf=new Set(["false","0"]);function Ff(t,e){const n=$f.has(t)||Rf.has(t),s=$f.has(e)||Rf.has(e);return(r,i)=>{let a="*"==t||t==r,o="*"==e||e==i;return!a&&n&&"boolean"==typeof r&&(a=r?$f.has(t):Rf.has(t)),!o&&s&&"boolean"==typeof i&&(o=i?$f.has(e):Rf.has(e)),a&&o}}const Df=new RegExp("s*:selfs*,?","g");function Of(t,e,n){return new Lf(t).build(e,n)}class Lf{constructor(t){this._driver=t}build(t,e){const n=new Mf(e);return this._resetContextStyleTimingState(n),Ef(this,xf(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,s=e.depCount=0;const r=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,s=n.name;s.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,r.push(this.visitState(n,e))}),n.name=s}else if(1==t.type){const r=this.visitTransition(t,e);n+=r.queryCount,s+=r.depCount,i.push(r)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:r,transitions:i,queryCount:n,depCount:s,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(n.containsDynamicStyles){const r=new Set,i=s||{};if(n.styles.forEach(t=>{if(Pf(t)){const e=t;Object.keys(e).forEach(t=>{wf(e[t]).forEach(t=>{i.hasOwnProperty(t)||r.add(t)})})}}),r.size){const n=kf(r.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=Ef(this,xf(t.animation),e);return{type:1,matchers:Af(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:zf(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>Ef(this,t,e)),options:zf(t.options)}}visitGroup(t,e){const n=e.currentTime;let s=0;const r=t.steps.map(t=>{e.currentTime=n;const r=Ef(this,t,e);return s=Math.max(s,e.currentTime),r});return e.currentTime=s,{type:3,steps:r,options:zf(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return Bf(df(t,e).duration,0,"");const s=t;if(s.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=Bf(0,0,"");return t.dynamic=!0,t.strValue=s,t}return n=n||df(s,e),Bf(n.duration,n.delay,n.easing)}(t.timings,e.errors);let s;e.currentAnimateTimings=n;let r=t.styles?t.styles:Lp({});if(5==r.type)s=this.visitKeyframes(r,e);else{let r=t.styles,i=!1;if(!r){i=!0;const t={};n.easing&&(t.easing=n.easing),r=Lp(t)}e.currentTime+=n.duration+n.delay;const a=this.visitStyle(r,e);a.isEmptyStep=i,s=a}return e.currentAnimateTimings=null,{type:4,timings:n,style:s,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?"*"==t?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let s=!1,r=null;return n.forEach(t=>{if(Pf(t)){const e=t,n=e.easing;if(n&&(r=n,delete e.easing),!s)for(let t in e)if(e[t].toString().indexOf("{{")>=0){s=!0;break}}}),{type:6,styles:n,easing:r,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let s=e.currentTime,r=e.currentTime;n&&r>0&&(r-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const i=e.collectedStyles[e.currentQuerySelector],a=i[n];let o=!0;a&&(r!=s&&r>=a.startTime&&s<=a.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${a.startTime}ms" and "${a.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${s}ms"`),o=!1),r=a.startTime),o&&(i[n]={startTime:r,endTime:s}),e.options&&function(t,e,n){const s=e.params||{},r=wf(t);r.length&&r.forEach(t=>{s.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let s=0;const r=[];let i=!1,a=!1,o=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(Pf(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(Pf(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),u=0;return null!=l&&(s++,u=n.offset=l),a=a||u<0||u>1,i=i||u<o,o=u,r.push(u),n});a&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),i&&e.errors.push("Please ensure that all keyframe offsets are in order");const u=t.steps.length;let c=0;s>0&&s<u?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==s&&(c=1/(u-1));const h=u-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,s)=>{const i=c>0?s==h?1:c*s:r[s],a=i*f;e.currentTime=d+p.delay+a,p.duration=a,this._validateStyleAst(t,e),t.offset=i,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:Ef(this,xf(t.animation),e),options:zf(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:zf(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:zf(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[r,i]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(Df,"")),[t=t.replace(/@\*/g,".ng-trigger").replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,".ng-animating"),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+r:r,Kp(e.collectedStyles,e.currentQuerySelector,{});const a=Ef(this,xf(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:r,limit:s.limit||0,optional:!!s.optional,includeSelf:i,animation:a,originalSelector:t.selector,options:zf(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:df(t.timings,e.errors,!0);return{type:12,animation:Ef(this,xf(t.animation),e),timings:n,options:null}}}class Mf{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function Pf(t){return!Array.isArray(t)&&"object"==typeof t}function zf(t){var e;return t?(t=pf(t)).params&&(t.params=(e=t.params)?pf(e):null):t={},t}function Bf(t,e,n){return{duration:t,delay:e,easing:n}}function Vf(t,e,n,s,r,i,a=null,o=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:s,duration:r,delay:i,totalTime:r+i,easing:a,subTimeline:o}}class Wf{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const Uf=new RegExp(":enter","g"),jf=new RegExp(":leave","g");function Hf(t,e,n,s,r,i={},a={},o,l,u=[]){return(new Gf).buildKeyframes(t,e,n,s,r,i,a,o,l,u)}class Gf{buildKeyframes(t,e,n,s,r,i,a,o,l,u=[]){l=l||new Wf;const c=new Kf(t,e,l,s,r,u,[]);c.options=o,c.currentTimeline.setStyles([i],null,c.errors,o),Ef(this,n,c);const h=c.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(a).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([a],null,c.errors,o)}return h.length?h.map(t=>t.buildKeyframes()):[Vf(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const s=e.createSubContext(t.options),r=e.currentTimeline.currentTime,i=this._visitSubInstructions(n,s,s.options);r!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let s=e.currentTimeline.currentTime;const r=null!=n.duration?cf(n.duration):null,i=null!=n.delay?cf(n.delay):null;return 0!==r&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,r,i);s=Math.max(s,n.duration+n.delay)}),s}visitReference(t,e){e.updateOptions(t.options,!0),Ef(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let s=e;const r=t.options;if(r&&(r.params||r.delay)&&(s=e.createSubContext(r),s.transformIntoNewTimeline(),null!=r.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=qf);const t=cf(r.delay);s.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>Ef(this,t,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>n&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let s=e.currentTimeline.currentTime;const r=t.options&&t.options.delay?cf(t.options.delay):0;t.steps.forEach(i=>{const a=e.createSubContext(t.options);r&&a.delayNextStep(r),Ef(this,i,a),s=Math.max(s,a.currentTimeline.currentTime),n.push(a.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return df(e.params?_f(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),s.snapshotCurrentStyles());const r=t.style;5==r.type?this.visitKeyframes(r,e):(e.incrementTime(n.duration),this.visitStyle(r,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,s=e.currentAnimateTimings;!s&&n.getCurrentStyleProperties().length&&n.forwardFrame();const r=s&&s.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(r):n.setStyles(t.styles,r,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,s=e.currentTimeline.duration,r=n.duration,i=e.createSubContext().currentTimeline;i.easing=n.easing,t.styles.forEach(t=>{i.forwardTime((t.offset||0)*r),i.setStyles(t.styles,t.easing,e.errors,e.options),i.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(i),e.transformIntoNewTimeline(s+r),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,s=t.options||{},r=s.delay?cf(s.delay):0;r&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=qf);let i=n;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let o=null;a.forEach((n,s)=>{e.currentQueryIndex=s;const a=e.createSubContext(t.options,n);r&&a.delayNextStep(r),n===e.element&&(o=a.currentTimeline),Ef(this,t.animation,a),a.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,a.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),o&&(e.currentTimeline.mergeTimelineCollectedStyles(o),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,s=e.currentTimeline,r=t.timings,i=Math.abs(r.duration),a=i*(e.currentQueryTotal-1);let o=i*e.currentQueryIndex;switch(r.duration<0?"reverse":r.easing){case"reverse":o=a-o;break;case"full":o=n.currentStaggerTime}const l=e.currentTimeline;o&&l.delayNextStep(o);const u=l.currentTime;Ef(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=s.currentTime-u+(s.startTime-n.currentTimeline.startTime)}}const qf={};class Kf{constructor(t,e,n,s,r,i,a,o){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=s,this._leaveClassName=r,this.errors=i,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=qf,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=o||new Xf(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let s=this.options;null!=n.duration&&(s.duration=cf(n.duration)),null!=n.delay&&(s.delay=cf(n.delay));const r=n.params;if(r){let t=s.params;t||(t=this.options.params={}),Object.keys(r).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=_f(r[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const s=e||this.element,r=new Kf(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,n||0));return r.previousNode=this.previousNode,r.currentAnimateTimings=this.currentAnimateTimings,r.options=this._copyOptions(),r.updateOptions(t),r.currentQueryIndex=this.currentQueryIndex,r.currentQueryTotal=this.currentQueryTotal,r.parentContext=this,this.subContextCount++,r}transformIntoNewTimeline(t){return this.previousNode=qf,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},r=new Qf(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(r),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,s,r,i){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(Uf,"."+this._enterClassName)).replace(jf,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),a.push(...e)}return r||0!=a.length||i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),a}}class Xf{constructor(t,e,n,s){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Xf(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||"*",this._currentKeyframe[t]="*"}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,s){e&&(this._previousKeyframe.easing=e);const r=s&&s.params||{},i=function(t,e){const n={};let s;return t.forEach(t=>{"*"===t?(s=s||Object.keys(e),s.forEach(t=>{n[t]="*"})):ff(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(i).forEach(t=>{const e=_f(i[t],r,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:"*"),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],s=t._styleSummary[e];(!n||s.time>n.time)&&this._updateStyle(e,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((r,i)=>{const a=ff(r,!0);Object.keys(a).forEach(n=>{const s=a[n];"!"==s?t.add(n):"*"==s&&e.add(n)}),n||(a.offset=i/this.duration),s.push(a)});const r=t.size?kf(t.values()):[],i=e.size?kf(e.values()):[];if(n){const t=s[0],e=pf(t);t.offset=0,e.offset=1,s=[t,e]}return Vf(this.element,s,r,i,this.duration,this.startTime,this.easing,!1)}}class Qf extends Xf{constructor(t,e,n,s,r,i,a=!1){super(t,e,i.delay),this.element=e,this.keyframes=n,this.preStyleProps=s,this.postStyleProps=r,this._stretchStartingKeyframe=a,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const r=[],i=n+e,a=e/i,o=ff(t[0],!1);o.offset=0,r.push(o);const l=ff(t[0],!1);l.offset=Yf(a),r.push(l);const u=t.length-1;for(let s=1;s<=u;s++){let a=ff(t[s],!1);a.offset=Yf((e+a.offset*n)/i),r.push(a)}n=i,e=0,s="",t=r}return Vf(this.element,t,this.preStyleProps,this.postStyleProps,n,e,s,!0)}}function Yf(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class Zf{}class Jf extends Zf{normalizePropertyName(t,e){return Cf(t)}normalizeStyleValue(t,e,n,s){let r="";const i=n.toString().trim();if(tm[e]&&0!==n&&"0"!==n)if("number"==typeof n)r="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&s.push(`Please provide a CSS unit value for ${t}:${n}`)}return i+r}}const tm=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function em(t,e,n,s,r,i,a,o,l,u,c,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:r,fromState:n,fromStyles:i,toState:s,toStyles:a,timelines:o,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:h,errors:d}}const nm={};class sm{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,s){return function(t,e,n,s,r){return t.some(t=>t(e,n,s,r))}(this.ast.matchers,t,e,n,s)}buildStyles(t,e,n){const s=this._stateStyles["*"],r=this._stateStyles[t],i=s?s.buildStyles(e,n):{};return r?r.buildStyles(e,n):i}build(t,e,n,s,r,i,a,o,l,u){const c=[],h=this.ast.options&&this.ast.options.params||nm,d=this.buildStyles(n,a&&a.params||nm,c),p=o&&o.params||nm,f=this.buildStyles(s,p,c),m=new Set,g=new Map,y=new Map,b="void"===s,x={params:Object.assign(Object.assign({},h),p)},v=u?[]:Hf(t,e,this.ast.animation,r,i,d,f,x,l,c);let w=0;if(v.forEach(t=>{w=Math.max(t.duration+t.delay,w)}),c.length)return em(e,this._triggerName,n,s,b,d,f,[],[],g,y,w,c);v.forEach(t=>{const n=t.element,s=Kp(g,n,{});t.preStyleProps.forEach(t=>s[t]=!0);const r=Kp(y,n,{});t.postStyleProps.forEach(t=>r[t]=!0),n!==e&&m.add(n)});const _=kf(m.values());return em(e,this._triggerName,n,s,b,d,f,v,_,g,y,w)}}class rm{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},s=pf(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(s[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const r=t;Object.keys(r).forEach(t=>{let i=r[t];i.length>1&&(i=_f(i,s,e)),n[t]=i})}}),n}}class im{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new rm(t.style,t.options&&t.options.params||{})}),am(this.states,"true","1"),am(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new sm(t,e,this.states))}),this.fallbackTransition=new sm(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,s){return this.transitionFactories.find(r=>r.match(t,e,n,s))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function am(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const om=new Wf;class lm{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],s=Of(this._driver,e,n);if(n.length)throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);this._animations[t]=s}_buildPlayer(t,e,n){const s=t.element,r=jp(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(s,r,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const s=[],r=this._animations[t];let i;const a=new Map;if(r?(i=Hf(this._driver,e,r,"ng-enter","ng-leave",{},{},n,om,s),i.forEach(t=>{const e=Kp(a,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(s.push("The requested animation doesn't exist or has already been destroyed"),i=[]),s.length)throw new Error(`Unable to create the animation due to the following errors: ${s.join("\n")}`);a.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,"*")})});const o=Up(i.map(t=>{const e=a.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=o,o.onDestroy(()=>this.destroy(t)),this.players.push(o),o}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,n,s){const r=qp(e,"","","");return Hp(this._getPlayer(t),n,r,s),()=>{}}command(t,e,n,s){if("register"==n)return void this.register(t,s[0]);if("create"==n)return void this.create(t,e,s[0]||{});const r=this._getPlayer(t);switch(n){case"play":r.play();break;case"pause":r.pause();break;case"reset":r.reset();break;case"restart":r.restart();break;case"finish":r.finish();break;case"init":r.init();break;case"setPosition":r.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const um=[],cm={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},hm={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class dm{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(s=n?t.value:t)?s:null,n){const e=pf(t);delete e.value,this.options=e}else this.options={};var s;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const pm=new dm("void");class fm{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,wm(e,this._hostClassName)}listen(t,e,n,s){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(r=n)&&"done"!=r)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var r;const i=Kp(this._elementListeners,t,[]),a={name:e,phase:n,callback:s};i.push(a);const o=Kp(this._engine.statesByElement,t,{});return o.hasOwnProperty(e)||(wm(t,"ng-trigger"),wm(t,"ng-trigger-"+e),o[e]=pm),()=>{this._engine.afterFlush(()=>{const t=i.indexOf(a);t>=0&&i.splice(t,1),this._triggers[e]||delete o[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,s=!0){const r=this._getTrigger(e),i=new gm(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(wm(t,"ng-trigger"),wm(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,a={}));let o=a[e];const l=new dm(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&o&&l.absorbOptions(o.options),a[e]=l,o||(o=pm),"void"!==l.value&&o.value===l.value){if(!function(t,e){const n=Object.keys(t),s=Object.keys(e);if(n.length!=s.length)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(!e.hasOwnProperty(s)||t[s]!==e[s])return!1}return!0}(o.params,l.params)){const e=[],n=r.matchStyles(o.value,o.params,e),s=r.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{bf(t,n),yf(t,s)})}return}const u=Kp(this._engine.playersByElement,t,[]);u.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let c=r.matchTransition(o.value,l.value,t,l.params),h=!1;if(!c){if(!s)return;c=r.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:c,fromState:o,toState:l,player:i,isFallbackTransition:h}),h||(wm(t,"ng-animate-queued"),i.onStart(()=>{_m(t,"ng-animate-queued")})),i.onDone(()=>{let e=this.players.indexOf(i);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(i);t>=0&&n.splice(t,1)}}),this.players.push(i),u.push(i),i}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,".ng-trigger",!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,s){const r=this._engine.statesByElement.get(t);if(r){const i=[];if(Object.keys(r).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,"void",s);n&&i.push(n)}}),i.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&Up(i).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),n=this._engine.statesByElement.get(t);if(e&&n){const s=new Set;e.forEach(e=>{const r=e.name;if(s.has(r))return;s.add(r);const i=this._triggers[r].fallbackTransition,a=n[r]||pm,o=new dm("void"),l=new gm(this.id,r,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:r,transition:i,fromState:a,toState:o,player:l,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)s=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)n.markElementAsRemoved(this.id,t,!1,e);else{const s=t.__ng_removed;s&&s!==cm||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){wm(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const s=n.player;if(s.destroyed)return;const r=n.element,i=this._elementListeners.get(r);i&&i.forEach(e=>{if(e.name==n.triggerName){const s=qp(r,n.triggerName,n.fromState.value,n.toState.value);s._data=t,Hp(n.player,e.phase,s,e.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,s=e.transition.ast.depCount;return 0==n||0==s?n-s:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class mm{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new fm(t,e,this);return e.parentNode?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let s=!1;for(let r=n;r>=0;r--)if(this.driver.containsElement(this._namespaceList[r].hostElement,e)){this._namespaceList.splice(r+1,0,t),s=!0;break}s||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let s=this._namespaceLookup[t];s&&s.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let s=0;s<t.length;s++){const r=n[t[s]].namespaceId;if(r){const t=this._fetchNamespace(r);t&&e.add(t)}}}return e}trigger(t,e,n,s){if(ym(e)){const r=this._fetchNamespace(t);if(r)return r.trigger(e,n,s),!0}return!1}insertNode(t,e,n,s){if(!ym(e))return;const r=e.__ng_removed;if(r&&r.setForRemoval){r.setForRemoval=!1,r.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const s=this._fetchNamespace(t);s&&s.insertNode(e,n)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),wm(t,"ng-animate-disabled")):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),_m(t,"ng-animate-disabled"))}removeNode(t,e,n,s){if(ym(e)){const r=t?this._fetchNamespace(t):null;if(r?r.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,n,s){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:s,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,s,r){return ym(e)?this._fetchNamespace(t).listen(e,n,s,r):()=>{}}_buildInstruction(t,e,n,s,r){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,s,t.fromState.options,t.toState.options,e,r)}destroyInnerAnimations(t){let e=this.driver.query(t,".ng-trigger",!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,".ng-animating",!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Up(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=cm,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,".ng-animate-disabled")&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)wm(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?Up(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`)}_flushAnimations(t,e){const n=new Wf,s=[],r=new Map,i=[],a=new Map,o=new Map,l=new Map,u=new Set;this.disabledNodes.forEach(t=>{u.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)u.add(e[n])});const c=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=vm(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n="ng-enter"+f++;p.set(e,n),t.forEach(t=>wm(t,n))});const m=[],g=new Set,y=new Set;for(let A=0;A<this.collectedLeaveElements.length;A++){const t=this.collectedLeaveElements[A],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const b=new Map,x=vm(h,Array.from(g));x.forEach((t,e)=>{const n="ng-leave"+f++;b.set(e,n),t.forEach(t=>wm(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>_m(t,n))}),x.forEach((t,e)=>{const n=b.get(e);t.forEach(t=>_m(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const v=[],w=[];for(let A=this._namespaceList.length-1;A>=0;A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t=>{const e=t.player,r=t.element;if(v.push(e),this.collectedEnterElements.length){const t=r.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const u=!c||!this.driver.containsElement(c,r),h=b.get(r),d=p.get(r),f=this._buildInstruction(t,n,d,h,u);if(f.errors&&f.errors.length)w.push(f);else{if(u)return e.onStart(()=>bf(r,f.fromStyles)),e.onDestroy(()=>yf(r,f.toStyles)),void s.push(e);if(t.isFallbackTransition)return e.onStart(()=>bf(r,f.fromStyles)),e.onDestroy(()=>yf(r,f.toStyles)),void s.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(r,f.timelines),i.push({instruction:f,player:e,element:r}),f.queriedElements.forEach(t=>Kp(a,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=o.get(e);t||o.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let s=l.get(e);s||l.set(e,s=new Set),n.forEach(t=>s.add(t))})}});if(w.length){const t=[];w.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),v.forEach(t=>t.destroy()),this.reportError(t)}const _=new Map,k=new Map;i.forEach(t=>{const e=t.element;n.has(e)&&(k.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,_))}),s.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{Kp(_,e,[]).push(t),t.destroy()})});const S=m.filter(t=>Cm(t,o,l)),C=new Map;xm(C,this.driver,y,l,"*").forEach(t=>{Cm(t,o,l)&&S.push(t)});const I=new Map;d.forEach((t,e)=>{xm(I,this.driver,new Set(t),o,"!")}),S.forEach(t=>{const e=C.get(t),n=I.get(t);C.set(t,Object.assign(Object.assign({},e),n))});const N=[],E=[],T={};i.forEach(t=>{const{element:e,player:i,instruction:a}=t;if(n.has(e)){if(u.has(e))return i.onDestroy(()=>yf(e,a.toStyles)),i.disabled=!0,i.overrideTotalTime(a.totalTime),void s.push(i);let t=T;if(k.size>1){let n=e;const s=[];for(;n=n.parentNode;){const e=k.get(n);if(e){t=e;break}s.push(n)}s.forEach(e=>k.set(e,t))}const n=this._buildAnimation(i.namespaceId,a,_,r,I,C);if(i.setRealPlayer(n),t===T)N.push(i);else{const e=this.playersByElement.get(t);e&&e.length&&(i.parentPlayer=Up(e)),s.push(i)}}else bf(e,a.fromStyles),i.onDestroy(()=>yf(e,a.toStyles)),E.push(i),u.has(e)&&s.push(i)}),E.forEach(t=>{const e=r.get(t.element);if(e&&e.length){const n=Up(e);t.setRealPlayer(n)}}),s.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let A=0;A<m.length;A++){const t=m[A],e=t.__ng_removed;if(_m(t,"ng-leave"),e&&e.hasAnimation)continue;let n=[];if(a.size){let e=a.get(t);e&&e.length&&n.push(...e);let s=this.driver.query(t,".ng-animating",!0);for(let t=0;t<s.length;t++){let e=a.get(s[t]);e&&e.length&&n.push(...e)}}const s=n.filter(t=>!t.destroyed);s.length?km(this,t,s):this.processLeaveNode(t)}return m.length=0,N.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),N}elementContainsData(t,e){let n=!1;const s=e.__ng_removed;return s&&s.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,s,r){let i=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(i=e)}else{const e=this.playersByElement.get(t);if(e){const t=!r||"void"==r;e.forEach(e=>{e.queued||(t||e.triggerName==s)&&i.push(e)})}}return(n||s)&&(i=i.filter(t=>!(n&&n!=t.namespaceId||s&&s!=t.triggerName))),i}_beforeAnimationBuild(t,e,n){const s=e.element,r=e.isRemovalTransition?void 0:t,i=e.isRemovalTransition?void 0:e.triggerName;for(const a of e.timelines){const t=a.element,o=t!==s,l=Kp(n,t,[]);this._getPreviousPlayers(t,o,r,i,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}bf(s,e.fromStyles)}_buildAnimation(t,e,n,s,r,i){const a=e.triggerName,o=e.element,l=[],u=new Set,c=new Set,h=e.timelines.map(e=>{const h=e.element;u.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new Bp(e.duration,e.delay);const p=h!==o,f=function(t){const e=[];return Sm(t,e),e}((n.get(h)||um).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=r.get(h),g=i.get(h),y=jp(0,this._normalizer,0,e.keyframes,m,g),b=this._buildPlayer(e,y,f);if(e.subTimeline&&s&&c.add(h),p){const e=new gm(t,a,h);e.setRealPlayer(b),l.push(e)}return b});l.forEach(t=>{Kp(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let s;if(t instanceof Map){if(s=t.get(e),s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&t.delete(e)}}else if(s=t[e],s){if(s.length){const t=s.indexOf(n);s.splice(t,1)}0==s.length&&delete t[e]}return s}(this.playersByQueriedElement,t.element,t))}),u.forEach(t=>wm(t,"ng-animating"));const d=Up(h);return d.onDestroy(()=>{u.forEach(t=>_m(t,"ng-animating")),yf(o,e.toStyles)}),c.forEach(t=>{Kp(s,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new Bp(t.duration,t.delay)}}class gm{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new Bp,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>Hp(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Kp(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function ym(t){return t&&1===t.nodeType}function bm(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function xm(t,e,n,s,r){const i=[];n.forEach(t=>i.push(bm(t)));const a=[];s.forEach((n,s)=>{const i={};n.forEach(t=>{const n=i[t]=e.computeStyle(s,t,r);n&&0!=n.length||(s.__ng_removed=hm,a.push(s))}),t.set(s,i)});let o=0;return n.forEach(t=>bm(t,i[o++])),a}function vm(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const s=new Set(e),r=new Map;function i(t){if(!t)return 1;let e=r.get(t);if(e)return e;const a=t.parentNode;return e=n.has(a)?a:s.has(a)?1:i(a),r.set(t,e),e}return e.forEach(t=>{const e=i(t);1!==e&&n.get(e).push(t)}),n}function wm(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function _m(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function km(t,e,n){Up(n).onDone(()=>t.processLeaveNode(e))}function Sm(t,e){for(let n=0;n<t.length;n++){const s=t[n];s instanceof Vp?Sm(s.players,e):e.push(s)}}function Cm(t,e,n){const s=n.get(t);if(!s)return!1;let r=e.get(t);return r?s.forEach(t=>r.add(t)):e.set(t,s),n.delete(t),!0}class Im{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new mm(t,e,n),this._timelineEngine=new lm(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,s,r){const i=t+"-"+s;let a=this._triggerCache[i];if(!a){const t=[],e=Of(this._driver,r,t);if(t.length)throw new Error(`The animation trigger "${s}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);a=function(t,e){return new im(t,e)}(s,e),this._triggerCache[i]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,s){this._transitionEngine.insertNode(t,e,n,s)}onRemove(t,e,n,s){this._transitionEngine.removeNode(t,e,s||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,s){if("@"==n.charAt(0)){const[t,r]=Xp(n);this._timelineEngine.command(t,e,r,s)}else this._transitionEngine.trigger(t,e,n,s)}listen(t,e,n,s,r){if("@"==n.charAt(0)){const[t,s]=Xp(n);return this._timelineEngine.listen(t,e,s,r)}return this._transitionEngine.listen(t,e,n,s,r)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function Nm(t,e){let n=null,s=null;return Array.isArray(e)&&e.length?(n=Tm(e[0]),e.length>1&&(s=Tm(e[e.length-1]))):e&&(n=Tm(e)),n||s?new Em(t,n,s):null}let Em=(()=>{class t{constructor(e,n,s){this._element=e,this._startStyles=n,this._endStyles=s,this._state=0;let r=t.initialStylesByElement.get(e);r||t.initialStylesByElement.set(e,r={}),this._initialStyles=r}start(){this._state<1&&(this._startStyles&&yf(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(yf(this._element,this._initialStyles),this._endStyles&&(yf(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(bf(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(bf(this._element,this._endStyles),this._endStyles=null),yf(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function Tm(t){let e=null;const n=Object.keys(t);for(let s=0;s<n.length;s++){const r=n[s];Am(r)&&(e=e||{},e[r]=t[r])}return e}function Am(t){return"display"===t||"position"===t}class $m{constructor(t,e,n,s,r,i,a){this._element=t,this._name=e,this._duration=n,this._delay=s,this._easing=r,this._fillMode=i,this._onDoneFn=a,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=Mm(t,"").trim();n.length&&(function(t,e){let n=0;for(let s=0;s<t.length;s++)","===t.charAt(s)&&n++}(n),e=`${n}, ${e}`),Lm(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),Om(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){Rm(this._element,this._name,"paused")}resume(){Rm(this._element,this._name,"running")}setPosition(t){const e=Fm(this._element,this._name);this._position=t*this._duration,Lm(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),Om(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=Mm(t,"").split(","),s=Dm(n,e);s>=0&&(n.splice(s,1),Lm(t,"",n.join(",")))}(this._element,this._name))}}function Rm(t,e,n){Lm(t,"PlayState",n,Fm(t,e))}function Fm(t,e){const n=Mm(t,"");return n.indexOf(",")>0?Dm(n.split(","),e):Dm([n],e)}function Dm(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function Om(t,e,n){n?t.removeEventListener("animationend",e):t.addEventListener("animationend",e)}function Lm(t,e,n,s){const r="animation"+e;if(null!=s){const e=t.style[r];if(e.length){const t=e.split(",");t[s]=n,n=t.join(",")}}t.style[r]=n}function Mm(t,e){return t.style["animation"+e]||""}class Pm{constructor(t,e,n,s,r,i,a,o){this.element=t,this.keyframes=e,this.animationName=n,this._duration=s,this._delay=r,this._finalStyles=a,this._specialStyles=o,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this.currentSnapshot={},this._state=0,this.easing=i||"linear",this.totalTime=s+r,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new $m(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:Tf(this.element,n))})}this.currentSnapshot=t}}class zm extends Bp{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=of(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class Bm{constructor(){this._count=0,this._head=document.querySelector("head")}validateStyleProperty(t){return nf(t)}matchesElement(t,e){return sf(t,e)}containsElement(t,e){return rf(t,e)}query(t,e,n){return af(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>of(t));let s=`@keyframes ${e} {\n`,r="";n.forEach(t=>{r=" ";const e=parseFloat(t.offset);s+=`${r}${100*e}% {\n`,r+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(s+=`${r}animation-timing-function: ${n};\n`));default:return void(s+=`${r}${e}: ${n};\n`)}}),s+=`${r}}\n`}),s+="}\n";const i=document.createElement("style");return i.textContent=s,i}animate(t,e,n,s,r,i=[],a){const o=i.filter(t=>t instanceof Pm),l={};If(n,s)&&o.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=Nf(t,e,l));if(0==n)return new zm(t,u);const c="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,c,e);document.querySelector("head").appendChild(h);const d=Nm(t,e),p=new Pm(t,e,c,n,s,r,u,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}}class Vm{constructor(t,e,n,s){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:Tf(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Wm{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(Um().toString()),this._cssKeyframesDriver=new Bm}validateStyleProperty(t){return nf(t)}matchesElement(t,e){return sf(t,e)}containsElement(t,e){return rf(t,e)}query(t,e,n){return af(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,s,r,i=[],a){if(!a&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,s,r,i);const o={duration:n,delay:s,fill:0==s?"both":"forwards"};r&&(o.easing=r);const l={},u=i.filter(t=>t instanceof Vm);If(n,s)&&u.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=Nm(t,e=Nf(t,e=e.map(t=>ff(t,!1)),l));return new Vm(t,e,o,c)}}function Um(){return"undefined"!=typeof window&&void 0!==window.document&&Element.prototype.animate||{}}let jm=(()=>{class t extends Rp{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:ee.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?Op(t):t;return qm(this._renderer,null,e,"register",[n]),new Hm(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)(Rs(el),Rs(yc))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Hm extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new Gm(this._id,t,e||{},this._renderer)}}class Gm{constructor(t,e,n,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return qm(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset")}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function qm(t,e,n,s,r){return t.setProperty(e,`@@${n}:${s}`,r)}let Km=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new Xm("",n,this.engine),this._rendererCache.set(n,t)),t}const s=e.id,r=e.id+"-"+this._currentId;this._currentId++,this.engine.register(r,t);const i=e=>{Array.isArray(e)?e.forEach(i):this.engine.registerTrigger(s,r,t,e.name,e)};return e.data.animation.forEach(i),new Qm(this,r,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)(Rs(el),Rs(Im),Rs(Pu))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();class Xm{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n,s=!0){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,s){this.delegate.setAttribute(t,e,n,s)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,s){this.delegate.setStyle(t,e,n,s)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){"@"==e.charAt(0)&&"@.disabled"==e?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class Qm extends Xm{constructor(t,e,n,s){super(e,n,s),this.factory=t,this.namespaceId=e}setProperty(t,e,n){"@"==e.charAt(0)?"."==e.charAt(1)&&"@.disabled"==e?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if("@"==e.charAt(0)){const s=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let r=e.substr(1),i="";return"@"!=r.charAt(0)&&([r,i]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(r)),this.engine.listen(this.namespaceId,s,r,i,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let Ym=(()=>{class t extends Im{constructor(t,e,n){super(t.body,e,n)}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc),Rs(uf),Rs(Zf))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const Zm=new ms("AnimationModuleType"),Jm=[{provide:uf,useFactory:function(){return"function"==typeof Um()?new Wm:new Bm}},{provide:Zm,useValue:"BrowserAnimations"},{provide:Rp,useClass:jm},{provide:Zf,useFactory:function(){return new Jf}},{provide:Im,useClass:Ym},{provide:el,useFactory:function(t,e,n){return new Km(t,e,n)},deps:[dh,Im,Pu]}];let tg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:Jm,imports:[Ih]}),t})();function eg(t,e,n,s){return new(n||(n=Promise))(function(r,i){function a(t){try{l(s.next(t))}catch(e){i(e)}}function o(t){try{l(s.throw(t))}catch(e){i(e)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n(function(t){t(e)})).then(a,o)}l((s=s.apply(t,e||[])).next())})}function ng(t,e){if(1&t){const t=Ga();Ua(0,"ngx-dropzone-remove-badge",1),Ka("click",function(e){return rn(t),Ja()._remove(e)}),ja()}}const sg=[[["ngx-dropzone-label"]]],rg=["ngx-dropzone-label"],ig=["fileInput"];function ag(t,e){1&t&&no(0,2,["*ngIf","!_hasPreviews"])}const og=[[["ngx-dropzone-preview"]],"*",[["ngx-dropzone-label"]]],lg=["ngx-dropzone-preview","*","ngx-dropzone-label"];let ug=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Se({type:t,selectors:[["ngx-dropzone-label"]]}),t})();function cg(t){return null!=t&&"false"!=`${t}`}var hg=function(t){return t[t.BACKSPACE=8]="BACKSPACE",t[t.DELETE=46]="DELETE",t}({});let dg,pg=(()=>{class t{constructor(t){this.sanitizer=t,this._removable=!1,this.removed=new Zl,this.tabIndex=0}set file(t){this._file=t}get file(){return this._file}get removable(){return this._removable}set removable(t){this._removable=cg(t)}keyEvent(t){switch(t.keyCode){case hg.BACKSPACE:case hg.DELETE:this.remove()}}get hostStyle(){return this.sanitizer.bypassSecurityTrustStyle("\n\t\t\tdisplay: flex;\n\t\t\theight: 140px;\n\t\t\tmin-height: 140px;\n\t\t\tmin-width: 180px;\n\t\t\tmax-width: 180px;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t\tpadding: 0 20px;\n\t\t\tmargin: 10px;\n\t\t\tborder-radius: 5px;\n\t\t\tposition: relative;\n\t\t")}_remove(t){t.stopPropagation(),this.remove()}remove(){this._removable&&this.removed.next(this.file)}readFile(){return eg(this,void 0,void 0,function*(){return new Promise((t,e)=>{const n=new FileReader;if(n.onload=e=>{t(e.target.result)},n.onerror=t=>{console.error(`FileReader failed on file ${this.file.name}.`),e(t)},!this.file)return e("No file to read. Please provide a file using the [file] Input property.");n.readAsDataURL(this.file)})})}}return t.\u0275fac=function(e){return new(e||t)(Ba(_h))},t.\u0275cmp=be({type:t,selectors:[["ngx-dropzone-preview"]],hostVars:3,hostBindings:function(t,e){1&t&&Ka("keyup",function(t){return e.keyEvent(t)}),2&t&&(Ao("tabindex",e.tabIndex),function(t,e,n,s){const r=sn(),i=fn(2);r.firstUpdatePass&&bo(r,null,i,!1);const a=nn();if(n!==di&&La(a,i,n)){const s=r.data[En()];if(Co(s,!1)&&!yo(r,i)){let t=s.stylesWithoutHost;null!==t&&(n=$t(t,n||"")),Wa(r,s,a,n,!1)}else!function(t,e,n,s,r,i,a,o){r===di&&(r=le);let l=0,u=0,c=0<r.length?r[0]:null,h=0<i.length?i[0]:null;for(;null!==c||null!==h;){const a=l<r.length?r[l+1]:void 0,d=u<i.length?i[u+1]:void 0;let p,f=null;c===h?(l+=2,u+=2,a!==d&&(f=h,p=d)):null===h||null!==c&&c<h?(l+=2,f=c):(u+=2,f=h,p=d),null!==f&&_o(t,e,n,s,f,p,!1,o),c=l<r.length?r[l]:null,h=u<i.length?i[u]:null}}(r,s,a,a[11],a[i+1],a[i+1]=function(t,e,n){if(null==n||""===n)return le;const s=[],r=qs(n);if(Array.isArray(r))for(let i=0;i<r.length;i++)t(s,r[i],!0);else if("object"==typeof r)for(const i in r)r.hasOwnProperty(i)&&t(s,i,r[i]);else"string"==typeof r&&e(s,r);return s}(t,e,n),0,i)}}(wo,go,e.hostStyle))},inputs:{file:"file",removable:"removable"},outputs:{removed:"removed"},ngContentSelectors:rg,decls:2,vars:1,consts:[[3,"click",4,"ngIf"],[3,"click"]],template:function(t,e){1&t&&(eo(sg),no(0),za(1,ng,1,0,"ngx-dropzone-remove-badge",0)),2&t&&(pi(1),Va("ngIf",e.removable))},directives:function(){return[Vc,gg]},styles:["[_nghost-%COMP%]{background-image:linear-gradient(0deg,#ededed,#efefef,#f1f1f1,#f4f4f4,#f6f6f6)}[_nghost-%COMP%]:focus, [_nghost-%COMP%]:hover{background-image:linear-gradient(0deg,#e3e3e3,#ebeaea,#e8e7e7,#ebeaea,#f4f4f4);outline:0}[_nghost-%COMP%]:focus   ngx-dropzone-remove-badge[_ngcontent-%COMP%], [_nghost-%COMP%]:hover   ngx-dropzone-remove-badge[_ngcontent-%COMP%]{opacity:1}[_nghost-%COMP%]   ngx-dropzone-remove-badge[_ngcontent-%COMP%]{opacity:0}[_nghost-%COMP%]     ngx-dropzone-label{overflow-wrap:break-word}"]}),t})(),fg=(()=>{class t{parseFileList(t,e,n,s){const r=[],i=[];for(let a=0;a<t.length;a++){const o=t.item(a);this.isAccepted(o,e)?n&&o.size>n?this.rejectFile(i,o,"size"):!s&&r.length>=1?this.rejectFile(i,o,"no_multiple"):r.push(o):this.rejectFile(i,o,"type")}return{addedFiles:r,rejectedFiles:i}}isAccepted(t,e){if("*"===e)return!0;const n=e.split(",").map(t=>t.toLowerCase().trim()),s=t.type.toLowerCase(),r=t.name.toLowerCase();return!!n.find(t=>t.endsWith("/*")?s.split("/")[0]===t.split("/")[0]:t.startsWith(".")?r.endsWith(t):t==s)}rejectFile(t,e,n){const s=e;s.reason=n,t.push(s)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),mg=(()=>{class t{constructor(t){this.service=t,this.change=new Zl,this.accept="*",this._disabled=!1,this._multiple=!0,this._maxFileSize=void 0,this._expandable=!1,this._disableClick=!1,this._isHovered=!1}get _hasPreviews(){return!!this._previewChildren.length}get disabled(){return this._disabled}set disabled(t){this._disabled=cg(t),this._isHovered&&(this._isHovered=!1)}get multiple(){return this._multiple}set multiple(t){this._multiple=cg(t)}get maxFileSize(){return this._maxFileSize}set maxFileSize(t){this._maxFileSize=function(t){return isNaN(parseFloat(t))||isNaN(Number(t))?null:Number(t)}(t)}get expandable(){return this._expandable}set expandable(t){this._expandable=cg(t)}get disableClick(){return this._disableClick}set disableClick(t){this._disableClick=cg(t)}_onClick(){this.disableClick||this.showFileSelector()}_onDragOver(t){this.disabled||(this.preventDefault(t),this._isHovered=!0)}_onDragLeave(){this._isHovered=!1}_onDrop(t){this.disabled||(this.preventDefault(t),this._isHovered=!1,this.handleFileDrop(t.dataTransfer.files))}showFileSelector(){this.disabled||this._fileInput.nativeElement.click()}_onFilesSelected(t){this.handleFileDrop(t.target.files),this._fileInput.nativeElement.value="",this.preventDefault(t)}handleFileDrop(t){const e=this.service.parseFileList(t,this.accept,this.maxFileSize,this.multiple);this.change.next({addedFiles:e.addedFiles,rejectedFiles:e.rejectedFiles,source:this})}preventDefault(t){t.preventDefault(),t.stopPropagation()}}return t.\u0275fac=function(e){return new(e||t)(Ba(fg,2))},t.\u0275cmp=be({type:t,selectors:[["ngx-dropzone"],["","ngx-dropzone",""]],contentQueries:function(t,e,n){if(1&t&&du(n,pg,1),2&t){let t;cu(t=pu())&&(e._previewChildren=t)}},viewQuery:function(t,e){if(1&t&&hu(ig,3),2&t){let t;cu(t=pu())&&(e._fileInput=t.first)}},hostVars:8,hostBindings:function(t,e){1&t&&Ka("click",function(){return e._onClick()})("dragover",function(t){return e._onDragOver(t)})("dragleave",function(){return e._onDragLeave()})("drop",function(t){return e._onDrop(t)}),2&t&&mo("ngx-dz-hovered",e._isHovered)("ngx-dz-disabled",e.disabled)("expandable",e.expandable)("unclickable",e.disableClick)},inputs:{accept:"accept",disabled:"disabled",multiple:"multiple",maxFileSize:"maxFileSize",expandable:"expandable",disableClick:"disableClick",id:"id",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],ariaDescribedBy:["aria-describedby","ariaDescribedBy"]},outputs:{change:"change"},features:[Go([fg])],ngContentSelectors:lg,decls:5,vars:8,consts:[["type","file",3,"id","multiple","accept","disabled","change"],["fileInput",""],[4,"ngIf"]],template:function(t,e){1&t&&(eo(og),Ua(0,"input",0,1),Ka("change",function(t){return e._onFilesSelected(t)}),ja(),za(2,ag,1,0,"ng-content",2),no(3),no(4,1)),2&t&&(Va("id",e.id)("multiple",e.multiple)("accept",e.accept)("disabled",e.disabled),Ma("aria-label",e.ariaLabel)("aria-labelledby",e.ariaLabelledby)("aria-describedby",e.ariaDescribedBy),pi(2),Va("ngIf",!e._hasPreviews))},directives:[Vc],styles:["[_nghost-%COMP%]{align-items:center;background:#fff;border:2px dashed #717386;border-radius:5px;color:#717386;cursor:pointer;display:flex;font-size:16px;height:180px;overflow-x:auto}.ngx-dz-hovered[_nghost-%COMP%]{border-style:solid}.ngx-dz-disabled[_nghost-%COMP%]{cursor:no-drop;opacity:.5;pointer-events:none}.expandable[_nghost-%COMP%]{flex-wrap:wrap;height:unset;min-height:180px;overflow:hidden}.unclickable[_nghost-%COMP%]{cursor:default}[_nghost-%COMP%]     ngx-dropzone-label{margin:10px auto;text-align:center;z-index:10}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{height:.1px;opacity:0;overflow:hidden;position:absolute;width:.1px;z-index:-1}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus +   ngx-dropzone-label{outline:1px dotted #000;outline:5px auto -webkit-focus-ring-color}"]}),t})(),gg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["ngx-dropzone-remove-badge"]],decls:3,vars:0,consts:[["x1","0","y1","0","x2","10","y2","10"],["x1","0","y1","10","x2","10","y2","0"]],template:function(t,e){1&t&&($n(),Ua(0,"svg"),Ha(1,"line",0),Ha(2,"line",1),ja())},styles:["[_nghost-%COMP%]{align-items:center;background:#bbb;border-radius:50%;color:#333;cursor:pointer;display:flex;height:22px;justify-content:center;position:absolute;right:5px;top:5px;width:22px}[_nghost-%COMP%]:hover{background:#aeaeae}[_nghost-%COMP%] > svg[_ngcontent-%COMP%]{height:10px;width:10px}[_nghost-%COMP%] > svg[_ngcontent-%COMP%] > line[_ngcontent-%COMP%]{stroke:#fff;stroke-width:2px}"]}),t})(),yg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Hc]]}),t})();try{dg="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(SY){dg=!1}let bg,xg,vg,wg=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?Gc(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!dg)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)(Rs(ku))},t.\u0275prov=Bt({factory:function(){return new t(Rs(ku))},token:t,providedIn:"root"}),t})(),_g=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();function kg(t){return function(){if(null==bg&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>bg=!0}))}finally{bg=bg||!1}return bg}()?t:!!t.capture}function Sg(){if(null==xg){if("object"!=typeof document||!document)return xg=!1,xg;if("scrollBehavior"in document.documentElement.style)xg=!0;else{const t=Element.prototype.scrollTo;xg=!!t&&!/\{\s*\[native code\]\s*\}/.test(t.toString())}}return xg}let Cg=(()=>{class t{create(t){return"undefined"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),Ig=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Cg]}),t})(),Ng=(()=>{class t{constructor(t){this._platform=t}isDisabled(t){return t.hasAttribute("disabled")}isVisible(t){return function(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(t)&&"visible"===getComputedStyle(t).visibility}isTabbable(t){if(!this._platform.isBrowser)return!1;const e=function(t){try{return t.frameElement}catch(SY){return null}}((n=t).ownerDocument&&n.ownerDocument.defaultView||window);var n;if(e){if(-1===Tg(e))return!1;if(!this.isVisible(e))return!1}let s=t.nodeName.toLowerCase(),r=Tg(t);return t.hasAttribute("contenteditable")?-1!==r:"iframe"!==s&&"object"!==s&&!(this._platform.WEBKIT&&this._platform.IOS&&!function(t){let e=t.nodeName.toLowerCase(),n="input"===e&&t.type;return"text"===n||"password"===n||"select"===e||"textarea"===e}(t))&&("audio"===s?!!t.hasAttribute("controls")&&-1!==r:"video"===s?-1!==r&&(null!==r||this._platform.FIREFOX||t.hasAttribute("controls")):t.tabIndex>=0)}isFocusable(t,e){return function(t){return!function(t){return function(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function(t){return function(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||Eg(t))}(t)&&!this.isDisabled(t)&&((null==e?void 0:e.ignoreVisibility)||this.isVisible(t))}}return t.\u0275fac=function(e){return new(e||t)(Rs(wg))},t.\u0275prov=Bt({factory:function(){return new t(Rs(wg))},token:t,providedIn:"root"}),t})();function Eg(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return"-32768"!=e&&!(!e||isNaN(parseInt(e,10)))}function Tg(t){if(!Eg(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class Ag{constructor(t,e,n,s,r=!1){this._element=t,this._checker=e,this._ngZone=n,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,r||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.parentNode&&t.parentNode.removeChild(t)),e&&(e.removeEventListener("focus",this.endAnchorListener),e.parentNode&&e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusInitialElement()))})}focusFirstTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusFirstTabbableElement()))})}focusLastTabbableElementWhenReady(){return new Promise(t=>{this._executeOnStable(()=>t(this.focusLastTabbableElement()))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let n=0;n<e.length;n++)e[n].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]):e[n].hasAttribute(`cdk-focus-region-${t}`)&&console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,e[n]);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(){const t=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(t){if(t.hasAttribute("cdk-focus-initial")&&console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",t),!this._checker.isFocusable(t)){const e=this._getFirstTabbableElement(t);return null==e||e.focus(),!!e}return t.focus(),!0}return this.focusFirstTabbableElement()}focusFirstTabbableElement(){const t=this._getRegionBoundary("start");return t&&t.focus(),!!t}focusLastTabbableElement(){const t=this._getRegionBoundary("end");return t&&t.focus(),!!t}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=0;n<e.length;n++){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[n]):null;if(t)return t}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let n=e.length-1;n>=0;n--){let t=e[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[n]):null;if(t)return t}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Kh(1)).subscribe(t)}}let $g=(()=>{class t{constructor(t,e,n){this._checker=t,this._ngZone=e,this._document=n}create(t,e=!1){return new Ag(t,this._checker,this._ngZone,this._document,e)}}return t.\u0275fac=function(e){return new(e||t)(Rs(Ng),Rs(Pu),Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Ng),Rs(Pu),Rs(yc))},token:t,providedIn:"root"}),t})();function Rg(t){return 0===t.buttons}function Fg(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}"undefined"!=typeof Element&&Element;const Dg=new ms("cdk-focus-monitor-default-options"),Og=kg({passive:!0,capture:!0});let Lg=(()=>{class t{constructor(t,e,n,s){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=Rg(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{Fg(t)?this._lastTouchTarget||this._setOriginForCurrentEventQueue("keyboard"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=Mg(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=Mg(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let s=e;s;s=s.parentElement)n.call(this,t,s)},this._document=n,this._detectionMode=(null==s?void 0:s.detectionMode)||0}monitor(t,e=!1){const n=Ud(t);if(!this._platform.isBrowser||1!==n.nodeType)return Rh(null);const s=function(t){if(function(){if(null==vg){const t="undefined"!=typeof document?document.head:null;vg=!(!t||!t.createShadowRoot&&!t.attachShadow)}return vg}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}(n)||this._getDocument(),r=this._elementInfo.get(n);if(r)return e&&(r.checkChildren=!0),r.subject;const i={checkChildren:e,subject:new Z,rootNode:s};return this._elementInfo.set(n,i),this._registerGlobalListeners(i),i.subject}stopMonitoring(t){const e=Ud(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const s=Ud(t);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([t,n])=>this._originChanged(t,e,n)):(this._setOriginForCurrentEventQueue(e),"function"==typeof s.focus&&s.focus(n))}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=Mg(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);n&&(n.checkChildren||e===Mg(t))&&this._originChanged(e,this._getFocusOrigin(t),n)}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,Og),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,Og)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,Og),t.addEventListener("mousedown",this._documentMousedownListener,Og),t.addEventListener("touchstart",this._documentTouchstartListener,Og),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Og),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Og),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,Og),t.removeEventListener("mousedown",this._documentMousedownListener,Og),t.removeEventListener("touchstart",this._documentTouchstartListener,Og),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(t,e,n){this._setClasses(t,e),this._emitOrigin(n.subject,e),this._lastFocusOrigin=e}_getClosestElementsInfo(t){const e=[];return this._elementInfo.forEach((n,s)=>{(s===t||n.checkChildren&&s.contains(t))&&e.push([s,n])}),e}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pu),Rs(wg),Rs(yc,8),Rs(Dg,8))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Pu),Rs(wg),Rs(yc,8),Rs(Dg,8))},token:t,providedIn:"root"}),t})();function Mg(t){return t.composedPath?t.composedPath()[0]:t.target}let Pg=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,s=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),s){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove("cdk-high-contrast-active"),t.remove("cdk-high-contrast-black-on-white"),t.remove("cdk-high-contrast-white-on-black");const e=this.getHighContrastMode();1===e?(t.add("cdk-high-contrast-active"),t.add("cdk-high-contrast-black-on-white")):2===e&&(t.add("cdk-high-contrast-active"),t.add("cdk-high-contrast-white-on-black"))}}}return t.\u0275fac=function(e){return new(e||t)(Rs(wg),Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(wg),Rs(yc))},token:t,providedIn:"root"}),t})(),zg=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pg))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[_g,Ig]]}),t})();const Bg=new il("11.2.5");function Vg(...t){return bt(1)(Rh(...t))}function Wg(...t){const e=t[t.length-1];return tt(e)?(t.pop(),n=>Vg(t,n,e)):e=>Vg(t,e)}const Ug=new il("11.2.5"),jg=new ms("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let Hg,Gg=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const t=this._document.defaultView||window;return"object"==typeof t&&t?t:null}_checksAreEnabled(){return Zu()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||"function"!=typeof getComputedStyle)return;const t=this._document.createElement("div");t.classList.add("mat-theme-loaded-marker"),this._document.body.appendChild(t);const e=getComputedStyle(t);e&&"none"!==e.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),this._document.body.removeChild(t)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&Ug.full!==Bg.full&&console.warn("The Angular Material version ("+Ug.full+") does not match the Angular CDK version ("+Bg.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pg),Rs(jg,8),Rs(yc))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[qd],qd]}),t})();function qg(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Bd(t)}}}function Kg(t,e){return class extends t{constructor(...t){super(...t),this.defaultColor=e,this.color=e}get color(){return this._color}set color(t){const e=t||this.defaultColor;e!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),e&&this._elementRef.nativeElement.classList.add(`mat-${e}`),this._color=e)}}}function Xg(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Bd(t)}}}try{Hg="undefined"!=typeof Intl}catch(SY){Hg=!1}let Qg=(()=>{class t{isErrorState(t,e){return!!(t&&t.invalid&&(t.touched||e&&e.submitted))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})(),Yg=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg],Gg]}),t})();class Zg{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const Jg={enterDuration:450,exitDuration:400},ty=kg({passive:!0}),ey=["mousedown","touchstart"],ny=["mouseup","mouseleave","touchend","touchcancel"];class sy{constructor(t,e,n,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=Ud(n))}fadeInRipple(t,e,n={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),r=Object.assign(Object.assign({},Jg),n.animation);n.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const i=n.radius||function(t,e,n){const s=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),r=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(s*s+r*r)}(t,e,s),a=t-s.left,o=e-s.top,l=r.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-i+"px",u.style.top=o-i+"px",u.style.height=2*i+"px",u.style.width=2*i+"px",null!=n.color&&(u.style.backgroundColor=n.color),u.style.transitionDuration=`${l}ms`,this._containerElement.appendChild(u),window.getComputedStyle(u).getPropertyValue("opacity"),u.style.transform="scale(1)";const c=new Zg(this,u,n);return c.state=0,this._activeRipples.add(c),n.persistent||(this._mostRecentTransientRipple=c),this._runTimeoutOutsideZone(()=>{const t=c===this._mostRecentTransientRipple;c.state=1,n.persistent||t&&this._isPointerDown||c.fadeOut()},l),c}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,s=Object.assign(Object.assign({},Jg),t.config.animation);n.style.transitionDuration=`${s.exitDuration}ms`,n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}setupTriggerEvents(t){const e=Ud(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(ey))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(ny),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=Rg(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!Fg(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,ty)})})}_removeTriggerEvents(){this._triggerElement&&(ey.forEach(t=>{this._triggerElement.removeEventListener(t,this,ty)}),this._pointerUpEventsRegistered&&ny.forEach(t=>{this._triggerElement.removeEventListener(t,this,ty)}))}}const ry=new ms("mat-ripple-global-options");let iy=(()=>{class t{constructor(t,e,n,s,r){this._elementRef=t,this._animationMode=r,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new sy(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(Pu),Ba(wg),Ba(ry,8),Ba(Zm,8))},t.\u0275dir=Se({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&mo("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),ay=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg,_g],Gg]}),t})(),oy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg]]}),t})(),ly=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[ay,Hc,Gg,oy]]}),t})(),uy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[zg,Gg],Gg]}),t})();const cy=["mat-button",""],hy=["*"],dy=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class py{constructor(t){this._elementRef=t}}const fy=Kg(qg(Xg(py)));let my=(()=>{class t extends fy{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const s of dy)this._hasHostAttributes(s)&&this._getHostElement().classList.add(s);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t,e){t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(Lg),Ba(Zm,8))},t.\u0275cmp=be({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){if(1&t&&hu(iy,1),2&t){let t;cu(t=pu())&&(e.ripple=t.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(Ma("disabled",e.disabled||null),mo("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Na],attrs:cy,ngContentSelectors:hy,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(eo(),Ua(0,"span",0),no(1),ja(),Ha(2,"span",1),Ha(3,"span",2)),2&t&&(pi(2),mo("mat-button-ripple-round",e.isRoundButton||e.isIconButton),Va("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[iy],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),t})(),gy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[ay,Gg],Gg]}),t})();const yy=["*",[["mat-card-footer"]]],by=["*","mat-card-footer"],xy=[[["","mat-card-avatar",""],["","matCardAvatar",""]],[["mat-card-title"],["mat-card-subtitle"],["","mat-card-title",""],["","mat-card-subtitle",""],["","matCardTitle",""],["","matCardSubtitle",""]],"*"],vy=["[mat-card-avatar], [matCardAvatar]","mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]","*"];let wy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Se({type:t,selectors:[["mat-card-title"],["","mat-card-title",""],["","matCardTitle",""]],hostAttrs:[1,"mat-card-title"]}),t})(),_y=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Se({type:t,selectors:[["","mat-card-image",""],["","matCardImage",""]],hostAttrs:[1,"mat-card-image"]}),t})(),ky=(()=>{class t{constructor(t){this._animationMode=t}}return t.\u0275fac=function(e){return new(e||t)(Ba(Zm,8))},t.\u0275cmp=be({type:t,selectors:[["mat-card"]],hostAttrs:[1,"mat-card","mat-focus-indicator"],hostVars:2,hostBindings:function(t,e){2&t&&mo("_mat-animation-noopable","NoopAnimations"===e._animationMode)},exportAs:["matCard"],ngContentSelectors:by,decls:2,vars:0,template:function(t,e){1&t&&(eo(yy),no(0),no(1,1))},styles:[".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"],encapsulation:2,changeDetection:0}),t})(),Sy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["mat-card-header"]],hostAttrs:[1,"mat-card-header"],ngContentSelectors:vy,decls:4,vars:0,consts:[[1,"mat-card-header-text"]],template:function(t,e){1&t&&(eo(xy),no(0),Ua(1,"div",0),no(2,1),ja(),no(3,2))},encapsulation:2,changeDetection:0}),t})(),Cy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg],Gg]}),t})(),Iy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),Ny=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[ay,Gg,Ig,Iy],Gg,Iy]}),t})();class Ey{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new Ty(t,this.durationSelector))}}class Ty extends pt{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let n;try{const{durationSelector:e}=this;n=e(t)}catch(e){return this.destination.error(e)}const s=ft(n,new dt(this));!s||s.closed?this.clearThrottle():this.add(this.throttled=s)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=void 0,n.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function Ay(t){return!M(t)&&t-parseFloat(t)+1>=0}function $y(t){const{index:e,period:n,subscriber:s}=t;if(s.next(e),!s.closed){if(-1===n)return s.complete();t.index=e+1,this.schedule(t,n)}}function Ry(t,e=Ph){return n=()=>function(t=0,e,n){let s=-1;return Ay(e)?s=Number(e)<1?1:Number(e):tt(e)&&(n=e),tt(n)||(n=Ph),new q(e=>{const r=Ay(t)?t:+t-n.now();return n.schedule($y,r,{index:0,period:s,subscriber:e})})}(t,e),function(t){return t.lift(new Ey(n))};var n}let Fy=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new Z,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new q(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(Ry(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Rh()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(Oh(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,s)=>{this._scrollableContainsElement(s,t)&&e.push(s)}),e}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(t,e){let n=Ud(e),s=t.getElementRef().nativeElement;do{if(n==s)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>Fh(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)(Rs(Pu),Rs(wg),Rs(yc,8))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Pu),Rs(wg),Rs(yc,8))},token:t,providedIn:"root"}),t})(),Dy=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new Z,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._document,e=this._getWindow(),n=t.documentElement,s=n.getBoundingClientRect();return{top:-s.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-s.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(Ry(t)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)(Rs(wg),Rs(Pu),Rs(yc,8))},t.\u0275prov=Bt({factory:function(){return new t(Rs(wg),Rs(Pu),Rs(yc,8))},token:t,providedIn:"root"}),t})(),Oy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),Ly=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[qd,_g,Oy],qd,Oy]}),t})();class My{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class Py extends My{constructor(t,e,n,s){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=s}}class zy extends My{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class By extends My{constructor(t){super(),this.element=t instanceof Jo?t.nativeElement:t}}class Vy{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof Py?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof zy?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof By?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class Wy extends Vy{constructor(t,e,n,s,r){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=s,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=r}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let Uy=(()=>{class t extends Vy{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new Zl,this.attachDomPortal=t=>{const e=t.element,n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),s=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(s.hostView.rootNodes[0]),super.setDisposeFn(()=>s.destroy()),this._attachedPortal=t,this._attachedRef=s,this.attached.emit(s),s}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(Ba(Xo),Ba(Ml),Ba(yc))},t.\u0275dir=Se({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Na]}),t})(),jy=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();const Hy=Sg();class Gy{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=Wd(-this._previousScrollPosition.left),t.style.top=Wd(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,s=e.scrollBehavior||"",r=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),Hy&&(e.scrollBehavior=n.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),Hy&&(e.scrollBehavior=s,n.scrollBehavior=r)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}class qy{constructor(t,e,n,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class Ky{enable(){}disable(){}attach(){}}function Xy(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function Qy(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class Yy{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();Xy(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let Zy=(()=>{class t{constructor(t,e,n,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new Ky,this.close=t=>new qy(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new Gy(this._viewportRuler,this._document),this.reposition=t=>new Yy(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=s}}return t.\u0275fac=function(e){return new(e||t)(Rs(Fy),Rs(Dy),Rs(Pu),Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Fy),Rs(Dy),Rs(Pu),Rs(yc))},token:t,providedIn:"root"}),t})();class Jy{constructor(t){if(this.scrollStrategy=new Ky,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class tb{constructor(t,e,n,s,r){this.offsetX=n,this.offsetY=s,this.panelClass=r,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class eb{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let nb=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(yc))},token:t,providedIn:"root"}),t})(),sb=(()=>{class t extends nb{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc))},t.\u0275prov=Bt({factory:function(){return new t(Rs(yc))},token:t,providedIn:"root"}),t})(),rb=(()=>{class t extends nb{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays.slice();for(let s=n.length-1;s>-1;s--){const r=n[s];if(!(r._outsidePointerEvents.observers.length<1)&&r.hasAttached()){if(r.overlayElement.contains(e))break;r._outsidePointerEvents.next(t)}}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("click",this._clickListener,!0),this._document.body.addEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=this._document.body.style.cursor,this._document.body.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("click",this._clickListener,!0),this._document.body.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(this._document.body.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc),Rs(wg))},t.\u0275prov=Bt({factory:function(){return new t(Rs(yc),Rs(wg))},token:t,providedIn:"root"}),t})();const ib=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let ab=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){if(this._platform.isBrowser||ib){const t=this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]');for(let e=0;e<t.length;e++)t[e].parentNode.removeChild(t[e])}const t=this._document.createElement("div");t.classList.add("cdk-overlay-container"),ib?t.setAttribute("platform","test"):this._platform.isBrowser||t.setAttribute("platform","server"),this._document.body.appendChild(t),this._containerElement=t}}return t.\u0275fac=function(e){return new(e||t)(Rs(yc),Rs(wg))},t.\u0275prov=Bt({factory:function(){return new t(Rs(yc),Rs(wg))},token:t,providedIn:"root"}),t})();class ob{constructor(t,e,n,s,r,i,a,o,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=s,this._ngZone=r,this._keyboardDispatcher=i,this._document=a,this._location=o,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new Z,this._attachments=new Z,this._detachments=new Z,this._locationChanges=B.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new Z,this._outsidePointerEvents=new Z,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Kh(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=Wd(this._config.width),t.height=Wd(this._config.height),t.minWidth=Wd(this._config.minWidth),t.minHeight=Wd(this._config.minHeight),t.maxWidth=Wd(this._config.maxWidth),t.maxHeight=Wd(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add("cdk-overlay-backdrop-showing")})}):this._backdropElement.classList.add("cdk-overlay-backdrop-showing")}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const s=t.classList;Vd(e).forEach(t=>{t&&(n?s.add(t):s.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(Wh(vt(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const lb=/([A-Za-z%]+)$/;class ub{constructor(t,e,n,s,r){this._viewportRuler=e,this._document=n,this._platform=s,this._overlayContainer=r,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Z,this._resizeSubscription=B.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,s=[];let r;for(let i of this._preferredPositions){let a=this._getOriginPoint(t,i),o=this._getOverlayPoint(a,e,i),l=this._getOverlayFit(o,e,n,i);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(i,a);this._canFitWithFlexibleDimensions(l,o,n)?s.push({position:i,origin:a,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(a,i)}):(!r||r.overlayFit.visibleArea<l.visibleArea)&&(r={overlayFit:l,overlayPoint:o,originPoint:a,position:i,overlayRect:e})}if(s.length){let t=null,e=-1;for(const n of s){const s=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);s>e&&(e=s,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(r.position,r.originPoint);this._applyPosition(r.position,r.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&cb(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,s;if("center"==e.originX)n=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,r=this._isRtl()?t.left:t.right;n="start"==e.originX?s:r}return s="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:s}}_getOverlayPoint(t,e,n){let s,r;return s="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,r="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+s,y:t.y+r}}_getOverlayFit(t,e,n,s){const r=db(e);let{x:i,y:a}=t,o=this._getOffset(s,"x"),l=this._getOffset(s,"y");o&&(i+=o),l&&(a+=l);let u=0-a,c=a+r.height-n.height,h=this._subtractOverflows(r.width,0-i,i+r.width-n.width),d=this._subtractOverflows(r.height,u,c),p=h*d;return{visibleArea:p,isCompletelyWithinViewport:r.width*r.height===p,fitsInViewportVertically:d===r.height,fitsInViewportHorizontally:h==r.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const s=n.bottom-e.y,r=n.right-e.x,i=hb(this._overlayRef.getConfig().minHeight),a=hb(this._overlayRef.getConfig().minWidth),o=t.fitsInViewportHorizontally||null!=a&&a<=r;return(t.fitsInViewportVertically||null!=i&&i<=s)&&o}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=db(e),r=this._viewportRect,i=Math.max(t.x+s.width-r.width,0),a=Math.max(t.y+s.height-r.height,0),o=Math.max(r.top-n.top-t.y,0),l=Math.max(r.left-n.left-t.x,0);let u=0,c=0;return u=s.width<=r.width?l||-i:t.x<this._viewportMargin?r.left-n.left-t.x:0,c=s.height<=r.height?o||-a:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:u,y:c},{x:t.x+u,y:t.y+c}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new eb(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,s=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let r=0;r<e.length;r++)e[r].style.transformOrigin=`${n} ${s}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,s=this._isRtl();let r,i,a,o,l,u;if("top"===e.overlayY)i=t.y,r=n.height-i+this._viewportMargin;else if("bottom"===e.overlayY)a=n.height-t.y+2*this._viewportMargin,r=n.height-a+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),s=this._lastBoundingBoxSize.height;r=2*e,i=t.y-e,r>s&&!this._isInitialRender&&!this._growAfterOpen&&(i=t.y-s/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)u=n.width-t.x+this._viewportMargin,o=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)l=t.x,o=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),s=this._lastBoundingBoxSize.width;o=2*e,l=t.x-e,o>s&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-s/2)}return{top:i,left:l,bottom:a,right:u,width:o,height:r}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,r=this._overlayRef.getConfig().maxWidth;s.height=Wd(n.height),s.top=Wd(n.top),s.bottom=Wd(n.bottom),s.width=Wd(n.width),s.left=Wd(n.left),s.right=Wd(n.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(s.maxHeight=Wd(t)),r&&(s.maxWidth=Wd(r))}this._lastBoundingBoxSize=n,cb(this._boundingBox.style,s)}_resetBoundingBoxStyles(){cb(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){cb(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},s=this._hasExactPosition(),r=this._hasFlexibleDimensions,i=this._overlayRef.getConfig();if(s){const s=this._viewportRuler.getViewportScrollPosition();cb(n,this._getExactOverlayY(e,t,s)),cb(n,this._getExactOverlayX(e,t,s))}else n.position="static";let a="",o=this._getOffset(e,"x"),l=this._getOffset(e,"y");o&&(a+=`translateX(${o}px) `),l&&(a+=`translateY(${l}px)`),n.transform=a.trim(),i.maxHeight&&(s?n.maxHeight=Wd(i.maxHeight):r&&(n.maxHeight="")),i.maxWidth&&(s?n.maxWidth=Wd(i.maxWidth):r&&(n.maxWidth="")),cb(this._pane.style,n)}_getExactOverlayY(t,e,n){let s={top:"",bottom:""},r=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(r=this._pushOverlayOnScreen(r,this._overlayRect,n));let i=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return r.y-=i,"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(r.y+this._overlayRect.height)+"px":s.top=Wd(r.y),s}_getExactOverlayX(t,e,n){let s,r={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),s=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===s?r.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":r.left=Wd(i.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:Qy(t,n),isOriginOutsideView:Xy(t,n),isOverlayClipped:Qy(e,n),isOverlayOutsideView:Xy(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Vd(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Jo)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function cb(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function hb(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split(lb);return n&&"px"!==n?null:parseFloat(e)}return t||null}function db(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}class pb{constructor(t,e,n,s,r,i,a){this._preferredPositions=[],this._positionStrategy=new ub(n,s,r,i,a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,s){const r=new tb(t,e,n,s);return this._preferredPositions.push(r),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}class fb{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add("cdk-global-overlay-wrapper"),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:s,height:r,maxWidth:i,maxHeight:a}=n,o=!("100%"!==s&&"100vw"!==s||i&&"100%"!==i&&"100vw"!==i),l=!("100%"!==r&&"100vh"!==r||a&&"100%"!==a&&"100vh"!==a);t.position=this._cssPosition,t.marginLeft=o?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,o?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove("cdk-global-overlay-wrapper"),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let mb=(()=>{class t{constructor(t,e,n,s){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=s}global(){return new fb}connectedTo(t,e,n){return new pb(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new ub(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)(Rs(Dy),Rs(yc),Rs(wg),Rs(ab))},t.\u0275prov=Bt({factory:function(){return new t(Rs(Dy),Rs(yc),Rs(wg),Rs(ab))},token:t,providedIn:"root"}),t})(),gb=0,yb=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l,u,c){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=s,this._keyboardDispatcher=r,this._injector=i,this._ngZone=a,this._document=o,this._directionality=l,this._location=u,this._outsideClickDispatcher=c}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),s=this._createPortalOutlet(n),r=new Jy(t);return r.direction=r.direction||this._directionality.value,new ob(s,e,n,r,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+gb++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(ic)),new Wy(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)(Rs(Zy),Rs(ab),Rs(Xo),Rs(mb),Rs(sb),Rs(Ca),Rs(Pu),Rs(yc),Rs(Gd),Rs(Rc),Rs(rb))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const bb={provide:new ms("cdk-connected-overlay-scroll-strategy"),deps:[yb],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let xb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[yb,bb],imports:[[qd,jy,Ly],Ly]}),t})();function vb(t){return new q(e=>{let n;try{n=t()}catch(s){return void e.error(s)}return(n?ht(n):qh()).subscribe(e)})}function wb(t,e){}class _b{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus=!0,this.restoreFocus=!0,this.closeOnNavigation=!0}}const kb={dialogContainer:Fp("dialogContainer",[Mp("void, exit",Lp({opacity:0,transform:"scale(0.7)"})),Mp("enter",Lp({transform:"none"})),Pp("* => enter",Dp("150ms cubic-bezier(0, 0, 0.2, 1)",Lp({transform:"none",opacity:1}))),Pp("* => void, * => exit",Dp("75ms cubic-bezier(0.4, 0.0, 0.2, 1)",Lp({opacity:0})))])};let Sb=(()=>{class t extends Vy{constructor(t,e,n,s,r,i){super(),this._elementRef=t,this._focusTrapFactory=e,this._changeDetectorRef=n,this._config=r,this._focusMonitor=i,this._animationStateChanged=new Zl,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=t=>(this._portalOutlet.hasAttached(),this._portalOutlet.attachDomPortal(t)),this._ariaLabelledBy=r.ariaLabelledBy||null,this._document=s}_initializeWithAttachedContent(){this._setupFocusTrap(),this._capturePreviouslyFocusedElement(),this._focusDialogContainer()}attachComponentPortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachTemplatePortal(t)}_recaptureFocus(){this._containsFocus()||(!this._config.autoFocus||!this._focusTrap.focusInitialElement())&&this._elementRef.nativeElement.focus()}_trapFocus(){this._config.autoFocus?this._focusTrap.focusInitialElementWhenReady():this._containsFocus()||this._elementRef.nativeElement.focus()}_restoreFocus(){const t=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&t&&"function"==typeof t.focus){const e=this._getActiveElement(),n=this._elementRef.nativeElement;e&&e!==this._document.body&&e!==n&&!n.contains(e)||(this._focusMonitor?(this._focusMonitor.focusVia(t,this._closeInteractionType),this._closeInteractionType=null):t.focus())}this._focusTrap&&this._focusTrap.destroy()}_setupFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)}_capturePreviouslyFocusedElement(){this._document&&(this._elementFocusedBeforeDialogWasOpened=this._getActiveElement())}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const t=this._elementRef.nativeElement,e=this._getActiveElement();return t===e||t.contains(e)}_getActiveElement(){var t;const e=this._document.activeElement;return(null===(t=null==e?void 0:e.shadowRoot)||void 0===t?void 0:t.activeElement)||e}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba($g),Ba(Cl),Ba(yc,8),Ba(_b),Ba(Lg))},t.\u0275dir=Se({type:t,viewQuery:function(t,e){if(1&t&&hu(Uy,3),2&t){let t;cu(t=pu())&&(e._portalOutlet=t.first)}},features:[Na]}),t})(),Cb=(()=>{class t extends Sb{constructor(){super(...arguments),this._state="enter"}_onAnimationDone({toState:t,totalTime:e}){"enter"===t?(this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:e})):"exit"===t&&(this._restoreFocus(),this._animationStateChanged.next({state:"closed",totalTime:e}))}_onAnimationStart({toState:t,totalTime:e}){"enter"===t?this._animationStateChanged.next({state:"opening",totalTime:e}):"exit"!==t&&"void"!==t||this._animationStateChanged.next({state:"closing",totalTime:e})}_startExitAnimation(){this._state="exit",this._changeDetectorRef.markForCheck()}}return t.\u0275fac=function(e){return Ib(e||t)},t.\u0275cmp=be({type:t,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1","aria-modal","true",1,"mat-dialog-container"],hostVars:6,hostBindings:function(t,e){1&t&&Xa("@dialogContainer.start",function(t){return e._onAnimationStart(t)})("@dialogContainer.done",function(t){return e._onAnimationDone(t)}),2&t&&(Ao("id",e._id),Ma("role",e._config.role)("aria-labelledby",e._config.ariaLabel?null:e._ariaLabelledBy)("aria-label",e._config.ariaLabel)("aria-describedby",e._config.ariaDescribedBy||null),$o("@dialogContainer",e._state))},features:[Na],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&za(0,wb,0,0,"ng-template",0)},directives:[Uy],styles:[".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"],encapsulation:2,data:{animation:[kb.dialogContainer]}}),t})();const Ib=ds(Cb);let Nb=0;class Eb{constructor(t,e,n="mat-dialog-"+Nb++){this._overlayRef=t,this._containerInstance=e,this.id=n,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new Z,this._afterClosed=new Z,this._beforeClosed=new Z,this._state=0,e._id=n,e._animationStateChanged.pipe(Oh(t=>"opened"===t.state),Kh(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(Oh(t=>"closed"===t.state),Kh(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(Oh(t=>27===t.keyCode&&!this.disableClose&&!function(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}(t))).subscribe(t=>{t.preventDefault(),Tb(this,"keyboard")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():Tb(this,"mouse")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(Oh(t=>"closing"===t.state),Kh(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._afterClosed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t="",e=""){return this._overlayRef.updateSize({width:t,height:e}),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function Tb(t,e,n){return void 0!==t._containerInstance&&(t._containerInstance._closeInteractionType=e),t.close(n)}const Ab=new ms("MatDialogData"),$b=new ms("mat-dialog-default-options"),Rb=new ms("mat-dialog-scroll-strategy"),Fb={provide:Rb,deps:[yb],useFactory:function(t){return()=>t.scrollStrategies.block()}};let Db=(()=>{class t{constructor(t,e,n,s,r,i,a,o,l){this._overlay=t,this._injector=e,this._defaultOptions=n,this._parentDialog=s,this._overlayContainer=r,this._dialogRefConstructor=a,this._dialogContainerType=o,this._dialogDataToken=l,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Z,this._afterOpenedAtThisLevel=new Z,this._ariaHiddenElements=new Map,this.afterAllClosed=vb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Wg(void 0))),this._scrollStrategy=i}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const t=this._parentDialog;return t?t._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(t,e){(e=function(t,e){return Object.assign(Object.assign({},e),t)}(e,this._defaultOptions||new _b)).id&&this.getDialogById(e.id);const n=this._createOverlay(e),s=this._attachDialogContainer(n,e),r=this._attachDialogContent(t,s,n,e);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(r),r.afterClosed().subscribe(()=>this._removeOpenDialog(r)),this.afterOpened.next(r),s._initializeWithAttachedContent(),r}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(t){return this.openDialogs.find(e=>e.id===t)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(t){const e=this._getOverlayConfig(t);return this._overlay.create(e)}_getOverlayConfig(t){const e=new Jy({positionStrategy:this._overlay.position().global(),scrollStrategy:t.scrollStrategy||this._scrollStrategy(),panelClass:t.panelClass,hasBackdrop:t.hasBackdrop,direction:t.direction,minWidth:t.minWidth,minHeight:t.minHeight,maxWidth:t.maxWidth,maxHeight:t.maxHeight,disposeOnNavigation:t.closeOnNavigation});return t.backdropClass&&(e.backdropClass=t.backdropClass),e}_attachDialogContainer(t,e){const n=Ca.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:_b,useValue:e}]}),s=new Py(this._dialogContainerType,e.viewContainerRef,n,e.componentFactoryResolver);return t.attach(s).instance}_attachDialogContent(t,e,n,s){const r=new this._dialogRefConstructor(n,e,s.id);if(t instanceof Al)e.attachTemplatePortal(new zy(t,null,{$implicit:s.data,dialogRef:r}));else{const n=this._createInjector(s,r,e),i=e.attachComponentPortal(new Py(t,s.viewContainerRef,n));r.componentInstance=i.instance}return r.updateSize(s.width,s.height).updatePosition(s.position),r}_createInjector(t,e,n){const s=t&&t.viewContainerRef&&t.viewContainerRef.injector,r=[{provide:this._dialogContainerType,useValue:n},{provide:this._dialogDataToken,useValue:t.data},{provide:this._dialogRefConstructor,useValue:e}];return!t.direction||s&&s.get(Gd,null)||r.push({provide:Gd,useValue:{value:t.direction,change:Rh()}}),Ca.create({parent:s||this._injector,providers:r})}_removeOpenDialog(t){const e=this.openDialogs.indexOf(t);e>-1&&(this.openDialogs.splice(e,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((t,e)=>{t?e.setAttribute("aria-hidden",t):e.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const t=this._overlayContainer.getContainerElement();if(t.parentElement){const e=t.parentElement.children;for(let n=e.length-1;n>-1;n--){let s=e[n];s===t||"SCRIPT"===s.nodeName||"STYLE"===s.nodeName||s.hasAttribute("aria-live")||(this._ariaHiddenElements.set(s,s.getAttribute("aria-hidden")),s.setAttribute("aria-hidden","true"))}}}_closeDialogs(t){let e=t.length;for(;e--;)t[e].close()}}return t.\u0275fac=function(e){return new(e||t)(Ba(yb),Ba(Ca),Ba(void 0),Ba(void 0),Ba(ab),Ba(void 0),Ba(ys),Ba(ys),Ba(ms))},t.\u0275dir=Se({type:t}),t})(),Ob=(()=>{class t extends Db{constructor(t,e,n,s,r,i,a){super(t,e,s,i,a,r,Eb,Cb,Ab)}}return t.\u0275fac=function(e){return new(e||t)(Rs(yb),Rs(Ca),Rs(Rc,8),Rs($b,8),Rs(Rb),Rs(t,12),Rs(ab))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),Lb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Ob,Fb],imports:[[xb,jy,Gg],Gg]}),t})(),Mb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg],Gg]}),t})(),Pb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Hc,Gg,Ig],Gg]}),t})(),zb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Yg,Gg],Yg,Gg]}),t})();function Bb(t){return function(e){const n=new Vb(t),s=e.lift(n);return n.caught=s}}class Vb{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Wb(t,this.selector,this.caught))}}class Wb extends pt{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const s=new dt(this);this.add(s);const r=ft(n,s);r!==s&&this.add(r)}}}class Ub{constructor(t){this.callback=t}call(t,e){return e.subscribe(new jb(t,this.callback))}}class jb extends U{constructor(t,e){super(t),this.add(new B(e))}}function Hb(t,e){return mt(t,e,1)}let Gb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg],Gg]}),t})(),qb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[_g]]}),t})(),Kb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Qg],imports:[[qb,Pb,Gg],qb,Pb]}),t})();const Xb={provide:new ms("mat-menu-scroll-strategy"),deps:[yb],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let Qb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Xb],imports:[Gg]}),t})(),Yb=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Xb],imports:[[Hc,Gg,ay,xb,Qb],Oy,Gg,Qb]}),t})();const Zb=["primaryValueBar"];class Jb{constructor(t){this._elementRef=t}}const tx=Kg(Jb,"primary"),ex=new ms("mat-progress-bar-location",{providedIn:"root",factory:function(){const t=Fs(yc),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}});let nx=0,sx=(()=>{class t extends tx{constructor(t,e,n,s){super(t),this._elementRef=t,this._ngZone=e,this._animationMode=n,this._isNoopAnimation=!1,this._value=0,this._bufferValue=0,this.animationEnd=new Zl,this._animationEndSubscription=B.EMPTY,this.mode="determinate",this.progressbarId="mat-progress-bar-"+nx++;const r=s?s.getPathname().split("#")[0]:"";this._rectangleFillValue=`url('${r}#${this.progressbarId}')`,this._isNoopAnimation="NoopAnimations"===n}get value(){return this._value}set value(t){this._value=rx(function(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}(t)||0)}get bufferValue(){return this._bufferValue}set bufferValue(t){this._bufferValue=rx(t||0)}_primaryTransform(){return{transform:`scale3d(${this.value/100}, 1, 1)`}}_bufferTransform(){return"buffer"===this.mode?{transform:`scale3d(${this.bufferValue/100}, 1, 1)`}:null}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{const t=this._primaryValueBar.nativeElement;this._animationEndSubscription=Fh(t,"transitionend").pipe(Oh(e=>e.target===t)).subscribe(()=>{"determinate"!==this.mode&&"buffer"!==this.mode||this._ngZone.run(()=>this.animationEnd.next({value:this.value}))})})}ngOnDestroy(){this._animationEndSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(Pu),Ba(Zm,8),Ba(ex,8))},t.\u0275cmp=be({type:t,selectors:[["mat-progress-bar"]],viewQuery:function(t,e){if(1&t&&hu(Zb,1),2&t){let t;cu(t=pu())&&(e._primaryValueBar=t.first)}},hostAttrs:["role","progressbar","aria-valuemin","0","aria-valuemax","100",1,"mat-progress-bar"],hostVars:4,hostBindings:function(t,e){2&t&&(Ma("aria-valuenow","indeterminate"===e.mode||"query"===e.mode?null:e.value)("mode",e.mode),mo("_mat-animation-noopable",e._isNoopAnimation))},inputs:{color:"color",mode:"mode",value:"value",bufferValue:"bufferValue"},outputs:{animationEnd:"animationEnd"},exportAs:["matProgressBar"],features:[Na],decls:9,vars:4,consts:[["width","100%","height","4","focusable","false",1,"mat-progress-bar-background","mat-progress-bar-element"],["x","4","y","0","width","8","height","4","patternUnits","userSpaceOnUse",3,"id"],["cx","2","cy","2","r","2"],["width","100%","height","100%"],[1,"mat-progress-bar-buffer","mat-progress-bar-element",3,"ngStyle"],[1,"mat-progress-bar-primary","mat-progress-bar-fill","mat-progress-bar-element",3,"ngStyle"],["primaryValueBar",""],[1,"mat-progress-bar-secondary","mat-progress-bar-fill","mat-progress-bar-element"]],template:function(t,e){1&t&&($n(),Ua(0,"svg",0),Ua(1,"defs"),Ua(2,"pattern",1),Ha(3,"circle",2),ja(),ja(),Ha(4,"rect",3),ja(),tn.lFrame.currentNamespace=null,Ha(5,"div",4),Ha(6,"div",5,6),Ha(8,"div",7)),2&t&&(pi(2),Va("id",e.progressbarId),pi(2),Ma("fill",e._rectangleFillValue),pi(1),Va("ngStyle",e._bufferTransform()),pi(1),Va("ngStyle",e._primaryTransform()))},directives:[jc],styles:['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'],encapsulation:2,changeDetection:0}),t})();function rx(t,e=0,n=100){return Math.max(e,Math.min(n,t))}let ix=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Hc,Gg],Gg]}),t})(),ax=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg,Hc],Gg]}),t})();const ox={provide:new ms("mat-select-scroll-strategy"),deps:[yb],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let lx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[ox],imports:[[Hc,xb,ly,Gg],Oy,Pb,ly,Gg]}),t})(),ux=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Hc,Gg,_g,Oy],Oy,Gg]}),t})(),cx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),hx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[cx,ay,Gg,Ig],cx,Gg]}),t})();class dx extends U{notifyNext(t,e,n,s,r){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class px extends U{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function fx(t,e,n,s,r=new px(t,n,s)){if(!r.closed)return e instanceof q?e.subscribe(r):ut(e)(r)}const mx={};class gx{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new yx(t,this.resultSelector))}}class yx extends dx{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(mx),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++)this.add(fx(this,t[n],void 0,n))}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n){const s=this.values,r=this.toRespond?s[n]===mx?--this.toRespond:this.toRespond:0;s[n]=e,0===r&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}let bx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[xb,jy,Hc,gy,Gg],Gg]}),t})(),xx=(()=>{class t{constructor(){this.changes=new Z,this.sortButtonLabel=t=>`Change sorting for ${t}`}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Bt({factory:function(){return new t},token:t,providedIn:"root"}),t})();const vx={provide:xx,deps:[[new Ms,new Ps,xx]],useFactory:function(t){return t||new xx}};let wx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[vx],imports:[[Hc,Gg]]}),t})(),_x=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Ly]]}),t})(),kx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[_x,Gg],Gg]}),t})(),Sx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Hc,Gg,jy,ay,Ig,zg],Gg]}),t})();const Cx=["*",[["mat-toolbar-row"]]],Ix=["*","mat-toolbar-row"];class Nx{constructor(t){this._elementRef=t}}const Ex=Kg(Nx);let Tx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Se({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),Ax=(()=>{class t extends Ex{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return t.\u0275fac=function(e){return new(e||t)(Ba(Jo),Ba(wg),Ba(yc))},t.\u0275cmp=be({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){if(1&t&&du(n,Tx,1),2&t){let t;cu(t=pu())&&(e._toolbarRows=t)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&mo("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[Na],ngContentSelectors:Ix,decls:2,vars:0,template:function(t,e){1&t&&(eo(Cx),no(0),no(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),$x=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Gg],Gg]}),t})();const Rx={provide:new ms("mat-tooltip-scroll-strategy"),deps:[yb],useFactory:function(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}};let Fx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({providers:[Rx],imports:[[zg,Hc,xb,Gg],Gg,Oy]}),t})(),Dx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})(),Ox=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[Hc,Gg,Dx,jy]]}),t})();const Lx=[gy,Ny,ly,lx,Yb,Sx,Pb,Fx,$x,Gb,ax,Lb,zb,Cy,kx,wx,Kb,bx,hx,Mb,ix,uy,ux,Ox];let Mx=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[Lx,gy,Ny,ly,lx,Yb,Sx,Pb,Fx,$x,Gb,ax,Lb,zb,Cy,kx,wx,Kb,bx,hx,Mb,ix,uy,ux,Ox]}),t})();const Px=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})();function zx(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(s){return s.lift(new Bx(t,e,n))}}class Bx{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new Vx(t,this.accumulator,this.seed,this.hasSeed))}}class Vx extends U{constructor(t,e,n,s){super(t),this.accumulator=e,this._seed=n,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(s){this.destination.error(s)}this.seed=n,this.destination.next(n)}}function Wx(t){return function(e){return 0===t?qh():e.lift(new Ux(t))}}class Ux{constructor(t){if(this.total=t,this.total<0)throw new Hh}call(t,e){return e.subscribe(new jx(t,this.total))}}class jx extends U{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,s=this.count++;e.length<n?e.push(t):e[s%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,s=this.ring;for(let r=0;r<n;r++){const r=e++%n;t.next(s[r])}}t.complete()}}function Hx(t=Kx){return e=>e.lift(new Gx(t))}class Gx{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new qx(t,this.errorFactory))}}class qx extends U{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function Kx(){return new Px}function Xx(t=null){return e=>e.lift(new Qx(t))}class Qx{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new Yx(t,this.defaultValue))}}class Yx extends U{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Zx(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Oh((e,n)=>t(e,n,s)):G,Kh(1),n?Xx(e):Hx(()=>new Px))}class Jx{constructor(t,e){this.id=t,this.url=e}}class tv extends Jx{constructor(t,e,n="imperative",s=null){super(t,e),this.navigationTrigger=n,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class ev extends Jx{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class nv extends Jx{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class sv extends Jx{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class rv extends Jx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class iv extends Jx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class av extends Jx{constructor(t,e,n,s,r){super(t,e),this.urlAfterRedirects=n,this.state=s,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class ov extends Jx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class lv extends Jx{constructor(t,e,n,s){super(t,e),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class uv{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class cv{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class hv{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class dv{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class pv{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class fv{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class mv{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class gv{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function yv(t){return new gv(t)}function bv(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function xv(t,e,n){const s=n.path.split("/");if(s.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||s.length<t.length))return null;const r={};for(let i=0;i<s.length;i++){const e=s[i],n=t[i];if(e.startsWith(":"))r[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,s.length),posParams:r}}function vv(t,e){const n=t?Object.keys(t):void 0,s=e?Object.keys(e):void 0;if(!n||!s||n.length!=s.length)return!1;let r;for(let i=0;i<n.length;i++)if(r=n[i],!wv(t[r],e[r]))return!1;return!0}function wv(t,e){if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;const n=[...t].sort(),s=[...e].sort();return n.every((t,e)=>s[e]===t)}return t===e}function _v(t){return Array.prototype.concat.apply([],t)}function kv(t){return t.length>0?t[t.length-1]:null}function Sv(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function Cv(t){return(e=t)&&"function"==typeof e.subscribe?t:qa(t)?ht(Promise.resolve(t)):Rh(t);var e}function Iv(t,e,n){return n?function(t,e){return vv(t,e)}(t.queryParams,e.queryParams)&&Nv(t.root,e.root):function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>wv(t[n],e[n]))}(t.queryParams,e.queryParams)&&Ev(t.root,e.root)}function Nv(t,e){if(!Fv(t.segments,e.segments))return!1;if(t.numberOfChildren!==e.numberOfChildren)return!1;for(const n in e.children){if(!t.children[n])return!1;if(!Nv(t.children[n],e.children[n]))return!1}return!0}function Ev(t,e){return Tv(t,e,e.segments)}function Tv(t,e,n){if(t.segments.length>n.length)return!!Fv(t.segments.slice(0,n.length),n)&&!e.hasChildren();if(t.segments.length===n.length){if(!Fv(t.segments,n))return!1;for(const n in e.children){if(!t.children[n])return!1;if(!Ev(t.children[n],e.children[n]))return!1}return!0}{const s=n.slice(0,t.segments.length),r=n.slice(t.segments.length);return!!Fv(t.segments,s)&&!!t.children.primary&&Tv(t.children.primary,e,r)}}class Av{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=yv(this.queryParams)),this._queryParamMap}toString(){return Lv.serialize(this)}}class $v{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Sv(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Mv(this)}}class Rv{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=yv(this.parameters)),this._parameterMap}toString(){return jv(this)}}function Fv(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}class Dv{}class Ov{parse(t){const e=new Xv(t);return new Av(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){var e;return`/${Pv(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${Bv(e)}=${Bv(t)}`).join("&"):`${Bv(e)}=${Bv(n)}`});return e.length?`?${e.join("&")}`:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}`}}const Lv=new Ov;function Mv(t){return t.segments.map(t=>jv(t)).join("/")}function Pv(t,e){if(!t.hasChildren())return Mv(t);if(e){const e=t.children.primary?Pv(t.children.primary,!1):"",n=[];return Sv(t.children,(t,e)=>{"primary"!==e&&n.push(`${e}:${Pv(t,!1)}`)}),n.length>0?`${e}(${n.join("//")})`:e}{const e=function(t,e){let n=[];return Sv(t.children,(t,s)=>{"primary"===s&&(n=n.concat(e(t,s)))}),Sv(t.children,(t,s)=>{"primary"!==s&&(n=n.concat(e(t,s)))}),n}(t,(e,n)=>"primary"===n?[Pv(t.children.primary,!1)]:[`${n}:${Pv(e,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children.primary?`${Mv(t)}/${e[0]}`:`${Mv(t)}/(${e.join("//")})`}}function zv(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Bv(t){return zv(t).replace(/%3B/gi,";")}function Vv(t){return zv(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Wv(t){return decodeURIComponent(t)}function Uv(t){return Wv(t.replace(/\+/g,"%20"))}function jv(t){return`${Vv(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${Vv(t)}=${Vv(e[t])}`).join("")}`;var e}const Hv=/^[^\/()?;=#]+/;function Gv(t){const e=t.match(Hv);return e?e[0]:""}const qv=/^[^=?&#]+/,Kv=/^[^?&#]+/;class Xv{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new $v([],{}):new $v([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new $v(t,e)),n}parseSegment(){const t=Gv(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new Rv(Wv(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Gv(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=Gv(this.remaining);t&&(n=t,this.capture(n))}t[Wv(e)]=Wv(n)}parseQueryParam(t){const e=function(t){const e=t.match(qv);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(Kv);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const s=Uv(e),r=Uv(n);if(t.hasOwnProperty(s)){let e=t[s];Array.isArray(e)||(e=[e],t[s]=e),e.push(r)}else t[s]=r}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=Gv(this.remaining),s=this.remaining[n.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):t&&(r="primary");const i=this.parseChildren();e[r]=1===Object.keys(i).length?i.primary:new $v([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class Qv{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=Yv(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=Yv(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=Zv(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return Zv(t,this._root).map(t=>t.value)}}function Yv(t,e){if(t===e.value)return e;for(const n of e.children){const e=Yv(t,n);if(e)return e}return null}function Zv(t,e){if(t===e.value)return[e];for(const n of e.children){const s=Zv(t,n);if(s.length)return s.unshift(e),s}return[]}class Jv{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function tw(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class ew extends Qv{constructor(t,e){super(t),this.snapshot=e,ow(this,t)}toString(){return this.snapshot.toString()}}function nw(t,e){const n=function(t,e){const n=new iw([],{},{},"",{},"primary",e,null,t.root,-1,{});return new aw("",new Jv(n,[]))}(t,e),s=new Nh([new Rv("",{})]),r=new Nh({}),i=new Nh({}),a=new Nh({}),o=new Nh(""),l=new sw(s,r,a,o,i,"primary",e,n.root);return l.snapshot=n.root,new ew(new Jv(l,[]),n)}class sw{constructor(t,e,n,s,r,i,a,o){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=a,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(et(t=>yv(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(et(t=>yv(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function rw(t,e="emptyOnly"){const n=t.pathFromRoot;let s=0;if("always"!==e)for(s=n.length-1;s>=1;){const t=n[s],e=n[s-1];if(t.routeConfig&&""===t.routeConfig.path)s--;else{if(e.component)break;s--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(s))}class iw{constructor(t,e,n,s,r,i,a,o,l,u,c){this.url=t,this.params=e,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=i,this.component=a,this.routeConfig=o,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=yv(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=yv(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class aw extends Qv{constructor(t,e){super(e),this.url=t,ow(this,e)}toString(){return lw(this._root)}}function ow(t,e){e.value._routerState=t,e.children.forEach(e=>ow(t,e))}function lw(t){const e=t.children.length>0?` { ${t.children.map(lw).join(", ")} } `:"";return`${t.value}${e}`}function uw(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,vv(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),vv(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!vv(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),vv(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function cw(t,e){var n,s;return vv(t.params,e.params)&&Fv(n=t.url,s=e.url)&&n.every((t,e)=>vv(t.parameters,s[e].parameters))&&!(!t.parent!=!e.parent)&&(!t.parent||cw(t.parent,e.parent))}function hw(t,e,n){if(n&&t.shouldReuseRoute(e.value,n.value.snapshot)){const s=n.value;s._futureSnapshot=e.value;const r=function(t,e,n){return e.children.map(e=>{for(const s of n.children)if(t.shouldReuseRoute(e.value,s.value.snapshot))return hw(t,e,s);return hw(t,e)})}(t,e,n);return new Jv(s,r)}{const n=t.retrieve(e.value);if(n){const t=n.route;return dw(e,t),t}{const n=new sw(new Nh((s=e.value).url),new Nh(s.params),new Nh(s.queryParams),new Nh(s.fragment),new Nh(s.data),s.outlet,s.component,s),r=e.children.map(e=>hw(t,e));return new Jv(n,r)}}var s}function dw(t,e){if(t.value.routeConfig!==e.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(t.children.length!==e.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");e.value._futureSnapshot=t.value;for(let n=0;n<t.children.length;++n)dw(t.children[n],e.children[n])}function pw(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function fw(t){return"object"==typeof t&&null!=t&&t.outlets}function mw(t,e,n,s,r){let i={};return s&&Sv(s,(t,e)=>{i[e]=Array.isArray(t)?t.map(t=>`${t}`):`${t}`}),new Av(n.root===t?e:gw(n.root,t,e),i,r)}function gw(t,e,n){const s={};return Sv(t.children,(t,r)=>{s[r]=t===e?n:gw(t,e,n)}),new $v(t.segments,s)}class yw{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&pw(n[0]))throw new Error("Root segment cannot have matrix parameters");const s=n.find(fw);if(s&&s!==kv(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class bw{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function xw(t,e,n){if(t||(t=new $v([],{})),0===t.segments.length&&t.hasChildren())return vw(t,e,n);const s=function(t,e,n){let s=0,r=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;r<t.segments.length;){if(s>=n.length)return i;const e=t.segments[r],a=n[s];if(fw(a))break;const o=`${a}`,l=s<n.length-1?n[s+1]:null;if(r>0&&void 0===o)break;if(o&&l&&"object"==typeof l&&void 0===l.outlets){if(!Sw(o,l,e))return i;s+=2}else{if(!Sw(o,{},e))return i;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(t,e,n),r=n.slice(s.commandIndex);if(s.match&&s.pathIndex<t.segments.length){const e=new $v(t.segments.slice(0,s.pathIndex),{});return e.children.primary=new $v(t.segments.slice(s.pathIndex),t.children),vw(e,0,r)}return s.match&&0===r.length?new $v(t.segments,{}):s.match&&!t.hasChildren()?ww(t,e,n):s.match?vw(t,0,r):ww(t,e,n)}function vw(t,e,n){if(0===n.length)return new $v(t.segments,{});{const s=function(t){return fw(t[0])?t[0].outlets:{primary:t}}(n),r={};return Sv(s,(n,s)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[s]=xw(t.children[s],e,n))}),Sv(t.children,(t,e)=>{void 0===s[e]&&(r[e]=t)}),new $v(t.segments,r)}}function ww(t,e,n){const s=t.segments.slice(0,e);let r=0;for(;r<n.length;){const i=n[r];if(fw(i)){const t=_w(i.outlets);return new $v(s,t)}if(0===r&&pw(n[0])){s.push(new Rv(t.segments[e].path,kw(n[0]))),r++;continue}const a=fw(i)?i.outlets.primary:`${i}`,o=r<n.length-1?n[r+1]:null;a&&o&&pw(o)?(s.push(new Rv(a,kw(o))),r+=2):(s.push(new Rv(a,{})),r++)}return new $v(s,{})}function _w(t){const e={};return Sv(t,(t,n)=>{"string"==typeof t&&(t=[t]),null!==t&&(e[n]=ww(new $v([],{}),0,t))}),e}function kw(t){const e={};return Sv(t,(t,n)=>e[n]=`${t}`),e}function Sw(t,e,n){return t==n.path&&vv(e,n.parameters)}class Cw{constructor(t,e,n,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=s}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),uw(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const s=tw(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,s[e],n),delete s[e]}),Sv(s,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(s===r)if(s.component){const r=n.getContext(s.outlet);r&&this.deactivateChildRoutes(t,e,r.children)}else this.deactivateChildRoutes(t,e,n);else r&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),s=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:s})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet),s=n&&t.value.component?n.children:e,r=tw(t);for(const i of Object.keys(r))this.deactivateRouteAndItsChildren(r[i],s);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated())}activateChildRoutes(t,e,n){const s=tw(e);t.children.forEach(t=>{this.activateRoutes(t,s[t.value.outlet],n),this.forwardEvent(new fv(t.value.snapshot))}),t.children.length&&this.forwardEvent(new dv(t.value.snapshot))}activateRoutes(t,e,n){const s=t.value,r=e?e.value:null;if(uw(s),s===r)if(s.component){const r=n.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,r.children)}else this.activateChildRoutes(t,e,n);else if(s.component){const e=n.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const t=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),Iw(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(s.snapshot),r=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=s,e.resolver=r,e.outlet&&e.outlet.activateWith(s,r),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function Iw(t){uw(t.value),t.children.forEach(Iw)}class Nw{constructor(t,e){this.routes=t,this.module=e}}function Ew(t){return"function"==typeof t}function Tw(t){return t instanceof Av}const Aw=Symbol("INITIAL_VALUE");function $w(){return zh(t=>function(...t){let e,n;return tt(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&M(t[0])&&(t=t[0]),xt(t,n).lift(new gx(e))}(t.map(t=>t.pipe(Kh(1),Wg(Aw)))).pipe(zx((t,e)=>{let n=!1;return e.reduce((t,s,r)=>{if(t!==Aw)return t;if(s===Aw&&(n=!0),!n){if(!1===s)return s;if(r===e.length-1||Tw(s))return s}return t},t)},Aw),Oh(t=>t!==Aw),et(t=>Tw(t)?t:!0===t),Kh(1)))}let Rw=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&Ha(0,"router-outlet")},directives:function(){return[k_]},encapsulation:2}),t})();function Fw(t,e=""){for(let n=0;n<t.length;n++){const s=t[n];Dw(s,Ow(e,s))}}function Dw(t,e){t.children&&Fw(t.children,e)}function Ow(t,e){return e?t||e.path?t&&!e.path?`${t}/`:!t&&e.path?e.path:`${t}/${e.path}`:"":t}function Lw(t){const e=t.children&&t.children.map(Lw),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&"primary"!==n.outlet&&(n.component=Rw),n}function Mw(t){return t.outlet||"primary"}function Pw(t,e){const n=t.filter(t=>Mw(t)===e);return n.push(...t.filter(t=>Mw(t)!==e)),n}const zw={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function Bw(t,e,n){var s;if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?Object.assign({},zw):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(e.matcher||xv)(n,t,e);if(!r)return Object.assign({},zw);const i={};Sv(r.posParams,(t,e)=>{i[e]=t.path});const a=r.consumed.length>0?Object.assign(Object.assign({},i),r.consumed[r.consumed.length-1].parameters):i;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:a,positionalParamSegments:null!==(s=r.posParams)&&void 0!==s?s:{}}}function Vw(t,e,n,s,r="corrected"){if(n.length>0&&function(t,e,n){return n.some(n=>Ww(t,e,n)&&"primary"!==Mw(n))}(t,n,s)){const r=new $v(e,function(t,e,n,s){const r={};r.primary=s,s._sourceSegment=t,s._segmentIndexShift=e.length;for(const i of n)if(""===i.path&&"primary"!==Mw(i)){const n=new $v([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,r[Mw(i)]=n}return r}(t,e,s,new $v(n,t.children)));return r._sourceSegment=t,r._segmentIndexShift=e.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>Ww(t,e,n))}(t,n,s)){const i=new $v(t.segments,function(t,e,n,s,r,i){const a={};for(const o of s)if(Ww(t,n,o)&&!r[Mw(o)]){const n=new $v([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===i?t.segments.length:e.length,a[Mw(o)]=n}return Object.assign(Object.assign({},r),a)}(t,e,n,s,t.children,r));return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}const i=new $v(t.segments,t.children);return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}function Ww(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path}function Uw(t,e,n,s){return!!(Mw(t)===s||"primary"!==s&&Ww(e,n,t))&&("**"===t.path||Bw(e,t,n).matched)}function jw(t,e,n){return 0===e.length&&!t.children[n]}class Hw{constructor(t){this.segmentGroup=t||null}}class Gw{constructor(t){this.urlTree=t}}function qw(t){return new q(e=>e.error(new Hw(t)))}function Kw(t){return new q(e=>e.error(new Gw(t)))}function Xw(t){return new q(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class Qw{constructor(t,e,n,s,r){this.configLoader=e,this.urlSerializer=n,this.urlTree=s,this.config=r,this.allowRedirects=!0,this.ngModule=t.get(Dl)}apply(){const t=Vw(this.urlTree.root,[],[],this.config).segmentGroup,e=new $v(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,"primary").pipe(et(t=>this.createUrlTree(Yw(t),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Bb(t=>{if(t instanceof Gw)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof Hw)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,"primary").pipe(et(e=>this.createUrlTree(Yw(e),t.queryParams,t.fragment))).pipe(Bb(t=>{if(t instanceof Hw)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const s=t.segments.length>0?new $v([],{primary:t}):t;return new Av(s,e,n)}expandSegmentGroup(t,e,n,s){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe(et(t=>new $v([],t))):this.expandSegment(t,n,e,n.segments,s,!0)}expandChildren(t,e,n){const s=[];for(const r of Object.keys(n.children))"primary"===r?s.unshift(r):s.push(r);return ht(s).pipe(Hb(s=>{const r=n.children[s],i=Pw(e,s);return this.expandSegmentGroup(t,i,r,s).pipe(et(t=>({segment:t,outlet:s})))}),zx((t,e)=>(t[e.outlet]=e.segment,t),{}),function(t,e){const n=arguments.length>=2;return s=>s.pipe(t?Oh((e,n)=>t(e,n,s)):G,Wx(1),n?Xx(e):Hx(()=>new Px))}())}expandSegment(t,e,n,s,r,i){return ht(n).pipe(Hb(a=>this.expandSegmentAgainstRoute(t,e,n,a,s,r,i).pipe(Bb(t=>{if(t instanceof Hw)return Rh(null);throw t}))),Zx(t=>!!t),Bb((t,n)=>{if(t instanceof Px||"EmptyError"===t.name){if(jw(e,s,r))return Rh(new $v([],{}));throw new Hw(e)}throw t}))}expandSegmentAgainstRoute(t,e,n,s,r,i,a){return Uw(s,e,r,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,r,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i):qw(e):qw(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,s){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?Kw(r):this.lineralizeSegments(n,r).pipe(mt(n=>{const r=new $v(n,{});return this.expandSegment(t,r,e,n,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,s,r,i){const{matched:a,consumedSegments:o,lastChild:l,positionalParamSegments:u}=Bw(e,s,r);if(!a)return qw(e);const c=this.applyRedirectCommands(o,s.redirectTo,u);return s.redirectTo.startsWith("/")?Kw(c):this.lineralizeSegments(s,c).pipe(mt(s=>this.expandSegment(t,e,n,s.concat(r.slice(l)),i,!1)))}matchSegmentAgainstRoute(t,e,n,s,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Rh(n._loadedConfig):this.configLoader.load(t.injector,n)).pipe(et(t=>(n._loadedConfig=t,new $v(s,{})))):Rh(new $v(s,{}));const{matched:i,consumedSegments:a,lastChild:o}=Bw(e,n,s);if(!i)return qw(e);const l=s.slice(o);return this.getChildConfig(t,n,s).pipe(mt(t=>{const s=t.module,i=t.routes,{segmentGroup:o,slicedSegments:u}=Vw(e,a,l,i),c=new $v(o.segments,o.children);if(0===u.length&&c.hasChildren())return this.expandChildren(s,i,c).pipe(et(t=>new $v(a,t)));if(0===i.length&&0===u.length)return Rh(new $v(a,{}));const h=Mw(n)===r;return this.expandSegment(s,c,i,u,h?"primary":r,!0).pipe(et(t=>new $v(a.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?Rh(new Nw(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?Rh(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(mt(n=>n?this.configLoader.load(t.injector,e).pipe(et(t=>(e._loadedConfig=t,t))):function(t){return new q(e=>e.error(bv(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):Rh(new Nw([],t))}runCanLoadGuards(t,e,n){const s=e.canLoad;return s&&0!==s.length?Rh(s.map(s=>{const r=t.get(s);let i;if(function(t){return t&&Ew(t.canLoad)}(r))i=r.canLoad(e,n);else{if(!Ew(r))throw new Error("Invalid CanLoad guard");i=r(e,n)}return Cv(i)})).pipe($w(),Zh(t=>{if(!Tw(t))return;const e=bv(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),et(t=>!0===t)):Rh(!0)}lineralizeSegments(t,e){let n=[],s=e.root;for(;;){if(n=n.concat(s.segments),0===s.numberOfChildren)return Rh(n);if(s.numberOfChildren>1||!s.children.primary)return Xw(t.redirectTo);s=s.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,s){const r=this.createSegmentGroup(t,e.root,n,s);return new Av(r,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return Sv(t,(t,s)=>{if("string"==typeof t&&t.startsWith(":")){const r=t.substring(1);n[s]=e[r]}else n[s]=t}),n}createSegmentGroup(t,e,n,s){const r=this.createSegments(t,e.segments,n,s);let i={};return Sv(e.children,(e,r)=>{i[r]=this.createSegmentGroup(t,e,n,s)}),new $v(r,i)}createSegments(t,e,n,s){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,s):this.findOrReturn(e,n))}findPosParam(t,e,n){const s=n[e.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return s}findOrReturn(t,e){let n=0;for(const s of e){if(s.path===t.path)return e.splice(n),s;n++}return t}}function Yw(t){const e={};for(const n of Object.keys(t.children)){const s=Yw(t.children[n]);(s.segments.length>0||s.hasChildren())&&(e[n]=s)}return function(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new $v(t.segments.concat(e.segments),e.children)}return t}(new $v(t.segments,e))}class Zw{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Jw{constructor(t,e){this.component=t,this.route=e}}function t_(t,e,n){const s=t._root;return n_(s,e?e._root:null,n,[s.value])}function e_(t,e,n){const s=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(s?s.module.injector:n).get(t)}function n_(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=tw(e);return t.children.forEach(t=>{!function(t,e,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=t.value,a=e?e.value:null,o=n?n.getContext(t.value.outlet):null;if(a&&i.routeConfig===a.routeConfig){const l=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!Fv(t.url,e.url);case"pathParamsOrQueryParamsChange":return!Fv(t.url,e.url)||!vv(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!cw(t,e)||!vv(t.queryParams,e.queryParams);case"paramsChange":default:return!cw(t,e)}}(a,i,i.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new Zw(s)):(i.data=a.data,i._resolvedData=a._resolvedData),n_(t,e,i.component?o?o.children:null:n,s,r),l&&o&&o.outlet&&o.outlet.isActivated&&r.canDeactivateChecks.push(new Jw(o.outlet.component,a))}else a&&s_(e,o,r),r.canActivateChecks.push(new Zw(s)),n_(t,null,i.component?o?o.children:null:n,s,r)}(t,i[t.value.outlet],n,s.concat([t.value]),r),delete i[t.value.outlet]}),Sv(i,(t,e)=>s_(t,n.getContext(e),r)),r}function s_(t,e,n){const s=tw(t),r=t.value;Sv(s,(t,s)=>{s_(t,r.component?e?e.children.getContext(s):null:e,n)}),n.canDeactivateChecks.push(new Jw(r.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,r))}class r_{}function i_(t){return new q(e=>e.error(t))}class a_{constructor(t,e,n,s,r,i){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=s,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=i}recognize(){const t=Vw(this.urlTree.root,[],[],this.config.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,"primary");if(null===e)return null;const n=new iw([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},"primary",this.rootComponentType,null,this.urlTree.root,-1,{}),s=new Jv(n,e),r=new aw(this.url,s);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(t){const e=t.value,n=rw(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=[];for(const r of Object.keys(e.children)){const s=e.children[r],i=Pw(t,r),a=this.processSegmentGroup(i,s,r);if(null===a)return null;n.push(...a)}const s=function(t){const e=[];for(const n of t){if(!o_(n)){e.push(n);continue}const t=e.find(t=>n.value.routeConfig===t.value.routeConfig);void 0!==t?t.children.push(...n.children):e.push(n)}return e}(n);return s.sort((t,e)=>"primary"===t.value.outlet?-1:"primary"===e.value.outlet?1:t.value.outlet.localeCompare(e.value.outlet)),s}processSegment(t,e,n,s){for(const r of t){const t=this.processSegmentAgainstRoute(r,e,n,s);if(null!==t)return t}return jw(e,n,s)?[]:null}processSegmentAgainstRoute(t,e,n,s){if(t.redirectTo||!Uw(t,e,n,s))return null;let r,i=[],a=[];if("**"===t.path){const s=n.length>0?kv(n).parameters:{};r=new iw(n,s,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,c_(t),Mw(t),t.component,t,l_(e),u_(e)+n.length,h_(t))}else{const s=Bw(e,t,n);if(!s.matched)return null;i=s.consumedSegments,a=n.slice(s.lastChild),r=new iw(i,s.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,c_(t),Mw(t),t.component,t,l_(e),u_(e)+i.length,h_(t))}const o=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:u}=Vw(e,i,a,o.filter(t=>void 0===t.redirectTo),this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const t=this.processChildren(o,l);return null===t?null:[new Jv(r,t)]}if(0===o.length&&0===u.length)return[new Jv(r,[])];const c=Mw(t)===s,h=this.processSegment(o,l,u,c?"primary":s);return null===h?null:[new Jv(r,h)]}}function o_(t){const e=t.value.routeConfig;return e&&""===e.path&&void 0===e.redirectTo}function l_(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function u_(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function c_(t){return t.data||{}}function h_(t){return t.resolve||{}}function d_(t){return zh(e=>{const n=t(e);return n?ht(n).pipe(et(()=>e)):Rh(e)})}class p_ extends class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const f_=new ms("ROUTES");class m_{constructor(t,e,n,s){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=s}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const n=this.loadModuleFactory(e.loadChildren).pipe(et(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const s=n.create(t);return new Nw(_v(s.injector.get(f_,void 0,Xt.Self|Xt.Optional)).map(Lw),s)}),Bb(t=>{throw e._loader$=void 0,t}));return e._loader$=new St(n,()=>new Z).pipe(wt()),e._loader$}loadModuleFactory(t){return"string"==typeof t?ht(this.loader.load(t)):Cv(t()).pipe(mt(t=>t instanceof Ol?Rh(t):ht(this.compiler.compileModuleAsync(t))))}}class g_{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new y_,this.attachRef=null}}class y_{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new g_,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class b_{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function x_(t){throw t}function v_(t,e,n){return e.parse("/")}function w_(t,e){return Rh(null)}let __=(()=>{class t{constructor(t,e,n,s,r,i,a,o){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=s,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new Z,this.errorHandler=x_,this.malformedUriErrorHandler=v_,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:w_,afterPreactivation:w_},this.urlHandlingStrategy=new b_,this.routeReuseStrategy=new p_,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.ngModule=r.get(Dl),this.console=r.get(Cu);const l=r.get(Pu);this.isNgZoneEnabled=l instanceof Pu&&Pu.isInAngularZone(),this.resetConfig(o),this.currentUrlTree=new Av(new $v([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new m_(i,a,t=>this.triggerEvent(new uv(t)),t=>this.triggerEvent(new cv(t))),this.routerState=nw(this.currentUrlTree,this.rootComponentType),this.transitions=new Nh({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(Oh(t=>0!==t.id),et(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),zh(t=>{let n=!1,s=!1;return Rh(t).pipe(Zh(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),zh(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return Rh(t).pipe(zh(t=>{const n=this.transitions.getValue();return e.next(new tv(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?Gh:Promise.resolve(t)}),(s=this.ngModule.injector,r=this.configLoader,i=this.urlSerializer,a=this.config,zh(t=>function(t,e,n,s,r){return new Qw(t,e,n,s,r).apply()}(s,r,i,t.extractedUrl,a).pipe(et(e=>Object.assign(Object.assign({},t),{urlAfterRedirects:e}))))),Zh(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,s,r){return mt(i=>function(t,e,n,s,r="emptyOnly",i="legacy"){try{const a=new a_(t,e,n,s,r,i).recognize();return null===a?i_(new r_):Rh(a)}catch(a){return i_(a)}}(t,e,i.urlAfterRedirects,n(i.urlAfterRedirects),s,r).pipe(et(t=>Object.assign(Object.assign({},i),{targetSnapshot:t}))))}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),Zh(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects);const n=new rv(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));var s,r,i,a;if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:s,source:r,restoredState:i,extras:a}=t,o=new tv(n,this.serializeUrl(s),r,i);e.next(o);const l=nw(s,this.rootComponentType).snapshot;return Rh(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:s,extras:Object.assign(Object.assign({},a),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),Gh}),d_(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:a}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!a})}),Zh(t=>{const e=new iv(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),et(t=>Object.assign(Object.assign({},t),{guards:t_(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return mt(n=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:i,canDeactivateChecks:a}}=n;return 0===a.length&&0===i.length?Rh(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,s){return ht(t).pipe(mt(t=>function(t,e,n,s,r){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?Rh(i.map(i=>{const a=e_(i,e,r);let o;if(function(t){return t&&Ew(t.canDeactivate)}(a))o=Cv(a.canDeactivate(t,e,n,s));else{if(!Ew(a))throw new Error("Invalid CanDeactivate guard");o=Cv(a(t,e,n,s))}return o.pipe(Zx())})).pipe($w()):Rh(!0)}(t.component,t.route,n,e,s)),Zx(t=>!0!==t,!0))}(a,s,r,t).pipe(mt(n=>n&&"boolean"==typeof n?function(t,e,n,s){return ht(e).pipe(Hb(e=>Vg(function(t,e){return null!==t&&e&&e(new hv(t)),Rh(!0)}(e.route.parent,s),function(t,e){return null!==t&&e&&e(new pv(t)),Rh(!0)}(e.route,s),function(t,e,n){const s=e[e.length-1],r=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>vb(()=>Rh(e.guards.map(r=>{const i=e_(r,e.node,n);let a;if(function(t){return t&&Ew(t.canActivateChild)}(i))a=Cv(i.canActivateChild(s,t));else{if(!Ew(i))throw new Error("Invalid CanActivateChild guard");a=Cv(i(s,t))}return a.pipe(Zx())})).pipe($w())));return Rh(r).pipe($w())}(t,e.path,n),function(t,e,n){const s=e.routeConfig?e.routeConfig.canActivate:null;return s&&0!==s.length?Rh(s.map(s=>vb(()=>{const r=e_(s,e,n);let i;if(function(t){return t&&Ew(t.canActivate)}(r))i=Cv(r.canActivate(e,t));else{if(!Ew(r))throw new Error("Invalid CanActivate guard");i=Cv(r(e,t))}return i.pipe(Zx())}))).pipe($w()):Rh(!0)}(t,e.route,n))),Zx(t=>!0!==t,!0))}(s,i,t,e):Rh(n)),et(t=>Object.assign(Object.assign({},n),{guardsResult:t})))})}(this.ngModule.injector,t=>this.triggerEvent(t)),Zh(t=>{if(Tw(t.guardsResult)){const e=bv(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}const e=new av(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),Oh(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new nv(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),d_(t=>{if(t.guards.canActivateChecks.length)return Rh(t).pipe(Zh(t=>{const e=new ov(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),zh(t=>{let n=!1;return Rh(t).pipe((s=this.paramsInheritanceStrategy,r=this.ngModule.injector,mt(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return Rh(t);let i=0;return ht(n).pipe(Hb(t=>function(t,e,n,s){return function(t,e,n,s){const r=Object.keys(t);if(0===r.length)return Rh({});const i={};return ht(r).pipe(mt(r=>function(t,e,n,s){const r=e_(t,e,s);return Cv(r.resolve?r.resolve(e,n):r(e,n))}(t[r],e,n,s).pipe(Zh(t=>{i[r]=t}))),Wx(1),mt(()=>Object.keys(i).length===r.length?Rh(i):Gh))}(t._resolve,t,e,s).pipe(et(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),rw(t,n).resolve),null)))}(t.route,e,s,r)),Zh(()=>i++),Wx(1),mt(e=>i===n.length?Rh(t):Gh))})),Zh({next:()=>n=!0,complete:()=>{if(!n){const n=new nv(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var s,r}),Zh(t=>{const e=new lv(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),d_(t=>{const{targetSnapshot:e,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:i,replaceUrl:a}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!i,replaceUrl:!!a})}),et(t=>{const e=function(t,e,n){const s=hw(t,e._root,n?n._root:void 0);return new ew(s,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),Zh(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(i=this.rootContexts,a=this.routeReuseStrategy,o=t=>this.triggerEvent(t),et(t=>(new Cw(a,t.targetRouterState,t.currentRouterState,o).activate(i),t))),Zh({next(){n=!0},complete(){n=!0}}),(r=()=>{if(!n&&!s){this.resetUrlToCurrentUrlTree();const n=new nv(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null},t=>t.lift(new Ub(r))),Bb(n=>{if(s=!0,(r=n)&&r.ngNavigationCancelingError){const s=Tw(n.url);s||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const r=new nv(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(r),s?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const s=new sv(t.id,this.serializeUrl(t.extractedUrl),n);e.next(s);try{t.resolve(this.errorHandler(n))}catch(i){t.reject(i)}}var r;return Gh}));var r,i,a,o}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{const e=this.extractLocationChangeInfoFromEvent(t);this.shouldScheduleNavigation(this.lastLocationChangeInfo,e)&&setTimeout(()=>{const{source:t,state:n,urlTree:s}=e,r={replaceUrl:!0};if(n){const t=Object.assign({},n);delete t.navigationId,0!==Object.keys(t).length&&(r.state=t)}this.scheduleNavigation(s,t,n,r)},0),this.lastLocationChangeInfo=e}))}extractLocationChangeInfoFromEvent(t){var e;return{source:"popstate"===t.type?"popstate":"hashchange",urlTree:this.parseUrl(t.url),state:(null===(e=t.state)||void 0===e?void 0:e.navigationId)?t.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(t,e){if(!t)return!0;const n=e.urlTree.toString()===t.urlTree.toString();return!(e.transitionId===t.transitionId&&n&&("hashchange"===e.source&&"popstate"===t.source||"popstate"===e.source&&"hashchange"===t.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){Fw(t),this.config=t.map(Lw),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(t,e={}){const{relativeTo:n,queryParams:s,fragment:r,queryParamsHandling:i,preserveFragment:a}=e,o=n||this.routerState.root,l=a?this.currentUrlTree.fragment:r;let u=null;switch(i){case"merge":u=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=s||null}return null!==u&&(u=this.removeEmptyProps(u)),function(t,e,n,s,r){if(0===n.length)return mw(e.root,e.root,e,s,r);const i=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new yw(!0,0,t);let e=0,n=!1;const s=t.reduce((t,s,r)=>{if("object"==typeof s&&null!=s){if(s.outlets){const e={};return Sv(s.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(s.segmentPath)return[...t,s.segmentPath]}return"string"!=typeof s?[...t,s]:0===r?(s.split("/").forEach((s,r)=>{0==r&&"."===s||(0==r&&""===s?n=!0:".."===s?e++:""!=s&&t.push(s))}),t):[...t,s]},[]);return new yw(n,e,s)}(n);if(i.toRoot())return mw(e.root,new $v([],{}),e,s,r);const a=function(t,e,n){if(t.isAbsolute)return new bw(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new bw(t,t===e.root,0)}const s=pw(t.commands[0])?0:1;return function(t,e,n){let s=t,r=e,i=n;for(;i>r;){if(i-=r,s=s.parent,!s)throw new Error("Invalid number of '../'");r=s.segments.length}return new bw(s,!1,r-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+s,t.numberOfDoubleDots)}(i,e,t),o=a.processChildren?vw(a.segmentGroup,a.index,i.commands):xw(a.segmentGroup,a.index,i.commands);return mw(a.segmentGroup,o,e,s,r)}(o,this.currentUrlTree,t,u,l)}navigateByUrl(t,e={skipLocationChange:!1}){const n=Tw(t)?t:this.parseUrl(t),s=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(s,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){if(Tw(t))return Iv(this.currentUrlTree,t,e);const n=this.parseUrl(t);return Iv(this.currentUrlTree,n,e)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const s=t[n];return null!=s&&(e[n]=s),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new ev(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.currentNavigation=null,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,s,r){if(this.disposed)return Promise.resolve(!1);const i=this.getTransition(),a="imperative"!==e&&"imperative"===(null==i?void 0:i.source),o=(this.lastSuccessfulId===i.id||this.currentNavigation?i.rawUrl:i.urlAfterRedirects).toString()===t.toString();if(a&&o)return Promise.resolve(!0);let l,u,c;r?(l=r.resolve,u=r.reject,c=r.promise):c=new Promise((t,e)=>{l=t,u=e});const h=++this.navigationId;return this.setTransition({id:h,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:s,resolve:l,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,s){const r=this.urlSerializer.serialize(t);s=s||{},this.location.isCurrentPathEqualTo(r)||e?this.location.replaceState(r,"",Object.assign(Object.assign({},s),{navigationId:n})):this.location.go(r,"",Object.assign(Object.assign({},s),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)(Rs(ys),Rs(Dv),Rs(y_),Rs(Rc),Rs(Ca),Rs(oc),Rs(Ou),Rs(void 0))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),k_=(()=>{class t{constructor(t,e,n,s,r){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new Zl,this.deactivateEvents=new Zl,this.name=s||"primary",t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),s=this.parentContexts.getOrCreateContext(this.name).children,r=new S_(t,s,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(Ba(y_),Ba(Ml),Ba(Xo),("name",function(t,e){const n=t.attrs;if(n){const t=n.length;let e=0;for(;e<t;){const s=n[e];if(Bn(s))break;if(0===s)e+=2;else if("number"==typeof s)for(e++;e<t&&"string"==typeof n[e];)e++;else{if("name"===s)return n[e+1];e+=2}}}return null}(an())),Ba(Cl))},t.\u0275dir=Se({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class S_{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===sw?this.route:t===y_?this.childContexts:this.parent.get(t,e)}}class C_{}class I_{preload(t,e){return Rh(null)}}let N_=(()=>{class t{constructor(t,e,n,s,r){this.router=t,this.injector=s,this.preloadingStrategy=r,this.loader=new m_(e,n,e=>t.triggerEvent(new uv(e)),e=>t.triggerEvent(new cv(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(Oh(t=>t instanceof ev),Hb(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(Dl);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const s of e)if(s.loadChildren&&!s.canLoad&&s._loadedConfig){const t=s._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else s.loadChildren&&!s.canLoad?n.push(this.preloadConfig(t,s)):s.children&&n.push(this.processRoutes(t,s.children));return ht(n).pipe(bt(),et(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>(e._loadedConfig?Rh(e._loadedConfig):this.loader.load(t.injector,e)).pipe(mt(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)(Rs(__),Rs(oc),Rs(Ou),Rs(Ca),Rs(C_))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})(),E_=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof tv?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof ev&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof mv&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new mv(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Rs(__),Rs(Kc),Rs(void 0))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();const T_=new ms("ROUTER_CONFIGURATION"),A_=new ms("ROUTER_FORROOT_GUARD"),$_=[Rc,{provide:Dv,useClass:Ov},{provide:__,useFactory:function(t,e,n,s,r,i,a,o={},l,u){const c=new __(null,t,e,n,s,r,i,_v(a));if(l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),function(t,e){t.errorHandler&&(e.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(e.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(e.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(e.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.relativeLinkResolution&&(e.relativeLinkResolution=t.relativeLinkResolution),t.urlUpdateStrategy&&(e.urlUpdateStrategy=t.urlUpdateStrategy)}(o,c),o.enableTracing){const t=gc();c.events.subscribe(e=>{t.logGroup(`Router Event: ${e.constructor.name}`),t.log(e.toString()),t.log(e),t.logGroupEnd()})}return c},deps:[Dv,y_,Rc,Ca,oc,Ou,f_,T_,[class{},new Ms],[class{},new Ms]]},y_,{provide:sw,useFactory:function(t){return t.routerState.root},deps:[__]},{provide:oc,useClass:cc},N_,I_,class{preload(t,e){return e().pipe(Bb(()=>Rh(null)))}},{provide:T_,useValue:{enableTracing:!1}}];function R_(){return new tc("Router",__)}let F_=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[$_,M_(e),{provide:A_,useFactory:L_,deps:[[__,new Ms,new Ps]]},{provide:T_,useValue:n||{}},{provide:Nc,useFactory:O_,deps:[bc,[new Ls(Tc),new Ms],T_]},{provide:E_,useFactory:D_,deps:[__,Kc,T_]},{provide:C_,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:I_},{provide:tc,multi:!0,useFactory:R_},[P_,{provide:yu,multi:!0,useFactory:z_,deps:[P_]},{provide:V_,useFactory:B_,deps:[P_]},{provide:Su,multi:!0,useExisting:V_}]]}}static forChild(e){return{ngModule:t,providers:[M_(e)]}}}return t.\u0275fac=function(e){return new(e||t)(Rs(A_,8),Rs(__,8))},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({}),t})();function D_(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new E_(t,e,n)}function O_(t,e,n={}){return n.useHash?new $c(t,e):new Ac(t,e)}function L_(t){return"guarded"}function M_(t){return[{provide:gs,multi:!0,useValue:t},{provide:f_,multi:!0,useValue:t}]}let P_=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new Z}appInitializer(){return this.injector.get(vc,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(__),s=this.injector.get(T_);return"disabled"===s.initialNavigation?(n.setUpLocationChangeListener(),t(!0)):"enabled"===s.initialNavigation||"enabledBlocking"===s.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Rh(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()):t(!0),e})}bootstrapListener(t){const e=this.injector.get(T_),n=this.injector.get(N_),s=this.injector.get(E_),r=this.injector.get(__),i=this.injector.get(ic);t===i.components[0]&&("enabledNonBlocking"!==e.initialNavigation&&void 0!==e.initialNavigation||r.initialNavigation(),n.setUpPreloading(),s.init(),r.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return t.\u0275fac=function(e){return new(e||t)(Rs(Ca))},t.\u0275prov=Bt({token:t,factory:t.\u0275fac}),t})();function z_(t){return t.appInitializer.bind(t)}function B_(t){return t.bootstrapListener.bind(t)}const V_=new ms("Router Initializer");var W_=n("g5Dd");class U_{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class j_{refCount(t){return H_("refCount")}incRef(t){return H_("incRef")}timerAvailable(){return!0}time(t){return H_("time")}read(t){return H_("read")}readSync(t){return H_("readSync")}numDataIds(){return H_("numDataIds")}disposeData(t,e){return H_("disposeData")}write(t,e,n){return H_("write")}move(t,e,n,s,r){return H_("move")}memory(){return H_("memory")}floatPrecision(){return H_("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return H_("dispose")}}function H_(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function G_(t){let e=t.length,n=0,s=0;for(;e>0;)s=Math.random()*e|0,e--,n=t[e],t[e]=t[s],t[s]=n}function q_(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n,s,r=t.length,i=0;for(;r>0;)i=Math.random()*r|0,r--,n=t[r],s=e[r],t[r]=t[i],e[r]=e[i],t[i]=n,e[i]=s}function K_(t,e,n){return Math.max(t,Math.min(e,n))}function X_(t){return t%2==0?t:t+1}function Q_(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function Y_(t,e){const n=Math.random();return e*n+(1-n)*t}function Z_(t,e){let n=0;for(let s=0;s<t.length;s++){const r=Number(t[s])-Number(e[s]);n+=r*r}return n}function J_(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function tk(t,e,n=""){J_(ik(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function ek(t){J_(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function nk(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||vk(t)&&!n)for(let s=0;s<t.length;++s)nk(t[s],e,n);else e.push(t);return e}function sk(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function rk(t){return 0===t.length}function ik(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ak(t){return t%1==0}function ok(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function lk(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function uk(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return G_(e),e}function ck(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function hk(t,e=(t=>0),n){return new Promise((s,r)=>{let i=0;const a=()=>{if(t())return void s();i++;const o=e(i);null!=n&&i>=n?r():setTimeout(a,o)};a()})}function dk(t,e){let n=1,s=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===s){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function pk(t,e){const n=e.length;return J_((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),J_(t.every(t=>ak(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function fk(t,e){const n=[],s=[],r=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||r?null:pk(e,t).sort();let a=0;for(let o=0;o<t.length;++o){if(null!=i){if(i[a]===o&&1!==t[o])throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(null==i[a]||i[a]>o)&&1===t[o]&&(n.push(t[o]),s.push(o)),i[a]<=o&&a++}1!==t[o]&&(n.push(t[o]),s.push(o))}return{newShape:n,keptDims:s}}function mk(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function gk(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function yk(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function bk(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function xk(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function vk(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function wk(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function _k(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function kk(t){return"string"==typeof t||t instanceof String}function Sk(t){return"boolean"==typeof t}function Ck(t){return"number"==typeof t}function Ik(t){return Array.isArray(t)?Ik(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":Ck(t)?"float32":kk(t)?"string":Sk(t)?"bool":"float32"}function Nk(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Ek(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function Tk(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function Ak(t,e,n){const s=new Array;if(1===e.length){const r=e[0];for(let e=0;e<r;e++)s[e]=n[t+e]}else{const r=e[0],i=e.slice(1),a=i.reduce((t,e)=>t*e);for(let e=0;e<r;e++)s[e]=Ak(t+e*a,i,n)}return s}function $k(t,e){if(0===t.length)return e[0];const n=t.reduce((t,e)=>t*e);if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return Ak(0,t,e)}function Rk(t,e){const n=Fk(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function Fk(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Dk(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return $k(t,new Float32Array(n));if("int32"===e)return $k(t,new Int32Array(n));if("bool"===e)return $k(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Ok(t){t.forEach(e=>{J_(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Lk(t,e,n){if(0===e)return 0;if(1===e)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function Mk(t,e,n){if(0===e)return[];if(1===e)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Pk(t){return t&&t.then&&"function"==typeof t.then}class zk{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Pk(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function Bk(){return Wk}let Vk,Wk=null;function Uk(){if(null==Vk){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Vk=t}return Vk}function jk(t,e){const n=function(){const t=Uk();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const Hk=jk("kernelRegistry",()=>new Map),Gk=jk("gradRegistry",()=>new Map);function qk(t,e){const n=Zk(t,e);return Hk.get(n)}function Kk(t){return Gk.get(t)}function Xk(t){const e=Hk.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===t&&n.push(a)}return n}function Qk(t){const{kernelName:e,backendName:n}=t,s=Zk(e,n);Hk.has(s)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),Hk.set(s,t)}function Yk(t){const{kernelName:e}=t;Gk.has(e)&&Bk().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),Gk.set(e,t)}function Zk(t,e){return`${e}_${t}`}function Jk(t,e){return"string"===e?sS(t):tS([t],e)}function tS(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=nk(t)),Bk().getBool("DEBUG")&&yk(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function eS(){return Bk().platform.now()}function nS(t,e){return Bk().platform.fetch(t,e)}function sS(t,e="utf-8"){return e=e||"utf-8",Bk().platform.encode(t,e)}function rS(t,e="utf-8"){return e=e||"utf-8",Bk().platform.decode(t,e)}class iS{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new oS)}profileKernel(t,e,n){let s;const r=()=>{s=n()};let i;const a=eS();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(r);else{r();for(const t of s)t.dataSync();i=Promise.resolve({kernelMs:eS()-a})}if(Bk().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<s.length;o++){const e=s[o];e.data().then(n=>{aS(n,e.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:i.then(t=>t.kernelMs),extraInfo:i.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:s,inputs:r,extraInfo:i}=t;n.forEach(t=>{Promise.all([t.data(),s,i]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],r,n[2])})})}}function aS(t,e,n){if("float32"!==e)return!1;for(let s=0;s<t.length;s++){const e=t[s];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}return!1}class oS{logKernelProfile(t,e,n,s,r,i){const a="number"==typeof s?ck(`${s}ms`,9):s.error,o=ck(t,25),l=e.rank,u=e.size,c=ck(e.shape.toString(),14);let h="";for(const d in r){const t=r[d];if(null!=t){const n=t.shape||e.shape,s=n.length;h+=`${d}: ${s}D ${s>0?n:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function lS(t,e,n,s){const r=Tk(e),i=function(t,e,n,s){const r=sk(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,l="complex64"===n?dS(t):t;if(o>1)for(let u=0;u<r/i;u++){const t=u*i;for(let e=0;e<i;e++)a[e]=Math.max(a[e],uS(l[t+e],0,n).length)}return a}(t,e,n,r),a=e.length,o=hS(t,e,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(t=>"    "+t).join("\n")),l.join("\n")}function uS(t,e,n){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:kk(t)?`'${t}'`:"bool"===n?cS(t):parseFloat(t.toFixed(7)).toString(),ck(s,e)}function cS(t){return 0===t?"false":"true"}function hS(t,e,n,s,r,i=!0){const a="complex64"===n?2:1,o=e[0],l=e.length;if(0===l)return"complex64"===n?[uS(dS(t)[0],0,n)]:"bool"===n?[cS(t[0])]:[t[0].toString()];if(1===l){if(o>20){let e=Array.from(t.slice(0,3*a)),s=Array.from(t.slice((o-3)*a,o*a));return"complex64"===n&&(e=dS(e),s=dS(s)),["["+e.map((t,e)=>uS(t,r[e],n)).join(", ")+", ..., "+s.map((t,e)=>uS(t,r[o-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?dS(t):Array.from(t)).map((t,e)=>uS(t,r[e],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*a,d=[];if(o>20){for(let e=0;e<3;e++){const s=e*h;d.push(...hS(t.slice(s,s+h),u,n,c,r,!1))}d.push("...");for(let e=o-3;e<o;e++){const s=e*h;d.push(...hS(t.slice(s,s+h),u,n,c,r,e===o-1))}}else for(let m=0;m<o;m++){const e=m*h;d.push(...hS(t.slice(e,e+h),u,n,c,r,m===o-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function dS(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class pS{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=sk(t),null!=n){const t=n.length;J_(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||gk(e,this.size),this.strides=Tk(t)}set(t,...e){0===e.length&&(e=[0]),J_(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return fS().makeTensor(this.values,this.shape,this.dtype)}}let fS=null,mS=null,gS=null;class yS{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=sk(t),this.strides=Tk(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return mS.buffer(this.shape,this.dtype,t)}bufferSync(){return mS.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return $k(this.shape,t)}arraySync(){return $k(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=fS().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>rS(t))}catch(SY){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=fS().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>rS(t))}catch(SY){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await fS().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(fS().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return mS.print(this,t)}clone(){return this.throwIfDisposed(),mS.clone(this)}toString(t=!1){return lS(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),mS.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),fS().makeVariable(this,t,e,n)}}function bS(){return jk("Tensor",()=>yS)}Object.defineProperty(yS,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),bS();class xS extends yS{constructor(t,e,n,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!ik(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);fS().disposeTensor(this),this.dataId=t.dataId,fS().incRef(this,null)}dispose(){fS().disposeVariable(this),this.isDisposedInternal=!0}}var vS,wS,_S,kS,SS;Object.defineProperty(xS,Symbol.hasInstance,{value:t=>t instanceof yS&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(vS||(vS={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(wS||(wS={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(_S||(_S={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(kS||(kS={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(SS||(SS={}));const CS={float32:kS,int32:wS,bool:_S,complex64:SS};function IS(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return CS[t][e]}function NS(t){return IS(t,"int32")}function ES(t,e){if(t.dtype===e.dtype)return[t,e];const n=IS(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function TS(t,e){J_(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function AS(t,e){return e.some(e=>e.id===t.id)}function $S(t){const e=[];return RS(t,e,new Set),e}function RS(t,e,n){if(null==t)return;if(t instanceof yS)return void e.push(t);if(s=t,!Array.isArray(s)&&"object"!=typeof s)return;var s;const r=t;for(const i in r){const t=r[i];n.has(t)||(n.add(t),RS(t,e,n))}}function FS(t){return null!=t.kernelName}class DS{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class OS{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new DS}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new iS(this.backendInstance),!0}setupRegisteredKernels(){Xk(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Xk(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof j_||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,s=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),s=n.backend,r=this.readSync(e),i=s.refCount(e);s.disposeData(e,!0),n.backend=t,t.move(e,r,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,s=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(s){throw e(),s}}nextTensorId(){return OS.nextTensorId++}nextVariableId(){return OS.nextVariableId++}clone(t){const e=MS.runKernel("Identity",{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>MS.runKernel("Cast",{x:t},{dtype:"float32"})}),[],{}),e}runKernel(t,e,n){if(null==qk(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const s=this.backend.numDataIds();let r=0;n.forEach(t=>{r+="complex64"===t.dtype?3:1});const i=s-e-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const s=this.isTapeOn(),r=this.state.numBytes,i=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const l=FS(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(FS(t)){const{kernelName:e,inputs:r,attrs:i}=t,l=qk(e,this.backendName);J_(null!=l,()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`),a=()=>{const t=this.backend.numDataIds();o=l.kernelFunc({inputs:r,attrs:i,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,a);const u=a.map(t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:s}=t;return this.makeTensorFromDataId(e,n,s)});if(s){const t=this.getTensorsForGradient(e,r,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,r=t=>{s&&(n=t.map(t=>this.keep(this.clone(t))))};a=()=>{const t=this.backend.numDataIds();o=this.tidy(()=>e(this.backend,r));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,h=FS(t)?null:t.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=a()}),s&&this.addTapeNode(l,u,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(t=>null!=u[t]?u[t].shape:null),outputShapes:e.map(t=>t.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const s=Kk(t);if(null!=s){const t=s.inputsToSave||[],r=s.outputsToSave||[];let i;s.saveAllInputs?(J_(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(t=>e[t])):i=t.map(t=>e[t]);const a=n.filter((t,e)=>r[e]);return i.concat(a)}return[]}makeTensor(t,e,n,s){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let r=t;"string"===(n=n||"float32")&&kk(t[0])&&(r=t.map(t=>sS(t)));const i=s.write(r,e,n),a=new yS(e,n,i,this.nextTensorId());if(this.trackTensor(a,s),"string"===n){const t=this.state.tensorInfo.get(i),e=_k(r);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,s){const r=new yS(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(r,s),r}makeVariable(t,e=!0,n,s){n=n||this.nextVariableId().toString(),null!=s&&s!==t.dtype&&(t=t.cast(s));const r=new xS(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*wk(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof xS||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*wk(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,s,r,i){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:r},o=Kk(t);null!=o&&(s=o.gradFunc),null!=s&&(a.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],s=Fk(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t}),s(t.length>1?t:t[0],r,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=$S(t),n=new Set(e.map(t=>t.id));for(let r=0;r<this.state.activeScope.track.length;r++){const t=this.state.activeScope.track[r];t.kept||n.has(t.id)||t.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==s.id||this.track(t)})}gradients(t,e,n,s=!1){if(J_(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));J_(r instanceof yS,()=>"The result y returned by f() must be a tensor.");const i=function(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],i=n.inputs;for(const t in i){const a=i[t];let o=!1;for(let t=0;t<e.length;t++)if(s[a.id]){n.outputs.forEach(t=>s[t.id]=!0),o=!0,r[n.id]=!0;break}if(o)break}}const i={};i[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,a[e.id]=!0;break}}const o=[];for(let l=0;l<t.length;l++){const e=t[l];if(r[e.id]&&a[e.id]){const t={};for(const r in e.inputs){const n=e.inputs[r];s[n.id]&&(t[r]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,o.push(n)}}return o}(this.state.activeTape,e,r);if(!s&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[r.id]=null==n?function(t){const e=Rk(sk(t),"float32");return MS.makeTensor(e,t,"float32")}(r.shape):n,function(t,e,n,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(e=>{const n=t[e.id];a.push(null!=n?n:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const e in i.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const r=n(()=>o[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const a=i.inputs[e];if(!ik(r.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=r;else{const e=t[a.id];t[a.id]=s(e,r),e.dispose()}}}}(t,i,t=>this.tidy(t),PS);const s=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:r,grads:s}})}customGrad(t){return J_(Nk(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;J_(e.every(t=>t instanceof yS),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return e.forEach((t,e)=>{s[e]=t}),this.runKernelFunc({forwardFunc:(s,r)=>(n=t(...e,r),J_(n.value instanceof yS,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),J_(Nk(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(t,s)=>{const r=n.gradFunc(t,s),i=Array.isArray(r)?r:[r];J_(i.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),J_(i.every(t=>t instanceof yS),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const a={};return i.forEach((t,e)=>{a[e]=()=>t}),a},inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=eS(),n=await this.backend.time(t);return n.wallMs=eS()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new DS;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function LS(){const t=Uk();if(null==t._tfengine){const e=new zk(t);t._tfengine=new OS(e)}return Wk=t._tfengine.ENV,fS=()=>t._tfengine,t._tfengine}OS.nextTensorId=0,OS.nextVariableId=0;const MS=LS();function PS(t,e){return MS.runKernel("Add",{a:t,b:e})}function zS(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function BS(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const VS=Bk();function WS(t,e){let n=t;if(vk(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||vk(n)&&"string"!==e;)s.push(n.length),n=n[0];return Array.isArray(t)&&Bk().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&US(t,s,[]),s}function US(t,e,n){if(n=n||[],!Array.isArray(t)&&!vk(t))return void J_(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);J_(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),J_(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)US(t[r],s,n.concat(r))}function jS(t,e,n,s){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function HS(t,e,n,s="numeric"){if(t instanceof yS)return jS(s,t.dtype,e,n),t;let r=Ik(t);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),jS(s,r,e,n),null==t||!vk(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const i=WS(t,r);vk(t)||Array.isArray(t)||(t=[t]);const a="string"!==r?tS(t,r):nk(t,[],!0);return MS.makeTensor(a,i,r)}function GS(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>HS(t,`${e}[${r}]`,n,s))}function qS(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...t)=>{MS.startScope(n);try{const e=s(...t);return Pk(e)&&console.error("Cannot return a Promise inside of tidy."),MS.endScope(e),e}catch(e){throw MS.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}VS.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),VS.registerFlag("IS_BROWSER",()=>BS()),VS.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),VS.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),VS.registerFlag("PROD",()=>!1),VS.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>VS.getBool("DEBUG")),VS.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),VS.registerFlag("IS_TEST",()=>!1),VS.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),VS.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const KS=qS({complex_:function(t,e){const n=HS(t,"real","complex"),s=HS(e,"imag","complex");return tk(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),MS.runKernel("Complex",{real:n,imag:s})}});function XS(t,e,n,s){if(null==s&&(s=Ik(t)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!vk(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Ok(e);const t=sk(e),s=sk(n);J_(t===s,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${s}`);for(let r=0;r<n.length;++r){const t=n[r],s=r!==n.length-1||t!==sk(e.slice(r));J_(n[r]===e[r]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return vk(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==s?tS(t,s):nk(t,[],!0),MS.makeTensor(t,e,s)}function QS(t,e,n){return XS(t,e,WS(t,n),n)}const YS={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function ZS(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let i=0;i<r.length;++i){const a=r[i],o=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const t=new Promise(async t=>{const e=await o.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,s=new Uint8Array(n);let r=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);s.set(n,r),r+=4,s.set(t,r),r+=t.length}t(s)});s.push(t)}else s.push(o.data());null!=e&&(l.group=e),n.push(l)}return{data:tC(await Promise.all(s)),specs:n}}function JS(t,e){const n={};let s,r=0;for(const i of e){const e=i.name,a=i.dtype,o=i.shape,l=sk(o);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const o=YS[n.dtype],c=t.slice(r,r+l*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++)u[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=aC()),u=s(h)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++)u[t]=Math.round(h[t]*n.scale+n.min)}r+=l*o}else if("string"===a){const e=sk(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(r,r+4))[0];r+=4;const n=new Uint8Array(t.slice(r,r+e));u.push(n),r+=e}}else{const s=YS[a],i=t.slice(r,r+l*s);if("float32"===a)u=new Float32Array(i);else if("int32"===a)u=new Int32Array(i);else if("bool"===a)u=new Uint8Array(i);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);{u=new Float32Array(i);const t=new Float32Array(u.length/2),s=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],s[e]=u[2*e+1];const r=QS(t,o,"float32"),a=QS(s,o,"float32");n[e]=KS(r,a),r.dispose(),a.dispose()}}r+=l*s}"complex64"!==a&&(n[e]=QS(u,o,a))}return n}function tC(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(t=>{s.set(new Uint8Array(t.buffer),r),r+=t.byteLength}),s.buffer}const eC="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function nC(t){return eC?Buffer.byteLength(t):new Blob([t]).size}function sC(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let s=0;return t.forEach(t=>{n.set(new Uint8Array(t),s),s+=t.byteLength}),n.buffer}function rC(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function iC(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:nC(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:nC(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function aC(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const r=s[a];i[a]=t[n[r>>10]+(1023&r)]+e[r>>10]}return new Float32Array(r)}}class oC{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==oC.instance&&(oC.instance=new oC),oC.instance}static registerSaveRouter(t){oC.getInstance().saveRouters.push(t)}static registerLoadRouter(t){oC.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return oC.getHandlers(t,"save")}static getLoadHandlers(t,e){return oC.getHandlers(t,"load",e)}static getHandlers(t,e,n){const s=[];return("load"===e?oC.getInstance().loadRouters:oC.getInstance().saveRouters).forEach(e=>{const r=e(t,n);null!==r&&s.push(r)}),s}}const lC=t=>oC.registerSaveRouter(t),uC=t=>oC.registerLoadRouter(t),cC=t=>oC.getSaveHandlers(t),hC=(t,e)=>oC.getLoadHandlers(t,e);function dC(){if(!Bk().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function pC(t){const e=t.result;e.createObjectStore("models_store",{keyPath:"modelPath"}),e.createObjectStore("model_info_store",{keyPath:"modelPath"})}class fC{constructor(t){if(this.indexedDB=dC(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const s=this.indexedDB.open("tensorflowjs",1);s.onupgradeneeded=()=>pC(s),s.onsuccess=()=>{const r=s.result;if(null==e){const e=r.transaction("models_store","readonly"),s=e.objectStore("models_store").get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(s.result.modelArtifacts)},s.onerror=t=>(r.close(),n(s.error)),e.oncomplete=()=>r.close()}else{const s=iC(e),i=r.transaction("model_info_store","readwrite");let a=i.objectStore("model_info_store");const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:s});let l;o.onsuccess=()=>{l=r.transaction("models_store","readwrite");const o=l.objectStore("models_store").put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:s});o.onsuccess=()=>t({modelArtifactsInfo:s}),o.onerror=t=>{a=i.objectStore("model_info_store");const e=a.delete(this.modelPath);e.onsuccess=()=>(r.close(),n(o.error)),e.onerror=t=>(r.close(),n(o.error))}},o.onerror=t=>(r.close(),n(o.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},s.onerror=t=>n(s.error)})}}fC.URL_SCHEME="indexeddb://";const mC=t=>{return Bk().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(fC.URL_SCHEME)?(e=t.slice(fC.URL_SCHEME.length),new fC(e)):null;var e};oC.registerSaveRouter(mC),oC.registerLoadRouter(mC);class gC{constructor(){this.indexedDB=dC()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open("tensorflowjs",1);n.onupgradeneeded=()=>pC(n),n.onsuccess=()=>{const s=n.result,r=s.transaction("model_info_store","readonly"),i=r.objectStore("model_info_store").getAll();i.onsuccess=()=>{const e={};for(const t of i.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},i.onerror=t=>(s.close(),e(i.error)),r.oncomplete=()=>s.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(fC.URL_SCHEME)?e.slice(fC.URL_SCHEME.length):e,new Promise((e,n)=>{const s=this.indexedDB.open("tensorflowjs",1);s.onupgradeneeded=()=>pC(s),s.onsuccess=()=>{const r=s.result,i=r.transaction("model_info_store","readwrite"),a=i.objectStore("model_info_store"),o=a.get(t);let l;o.onsuccess=()=>{if(null==o.result)return r.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const s=a.delete(t),i=()=>{l=r.transaction("models_store","readwrite");const s=l.objectStore("models_store").delete(t);s.onsuccess=()=>e(o.result.modelArtifactsInfo),s.onerror=t=>n(o.error)};s.onsuccess=i,s.onerror=t=>(i(),r.close(),n(o.error))}},o.onerror=t=>(r.close(),n(o.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},s.onerror=t=>n(s.error)})}}const yC="tensorflowjs_models",bC="info",xC="model_topology",vC="weight_specs",wC="weight_data",_C="model_metadata";function kC(t){return{info:[yC,t,bC].join("/"),topology:[yC,t,xC].join("/"),weightSpecs:[yC,t,vC].join("/"),weightData:[yC,t,wC].join("/"),modelMetadata:[yC,t,_C].join("/")}}function SC(t){const e=t.split("/");if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join("/")}class CC{constructor(t){if(!Bk().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=kC(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=iC(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,function(t){if(eC)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}(t.weightData));const e={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(e)),{modelArtifactsInfo:r}}catch(e){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=s;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const t=JSON.parse(r);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(eC){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}(i),e}}CC.URL_SCHEME="localstorage://";const IC=t=>{return Bk().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(CC.URL_SCHEME)?(e=t.slice(CC.URL_SCHEME.length),new CC(e)):null;var e};oC.registerSaveRouter(IC),oC.registerLoadRouter(IC);class NC{constructor(){J_(Bk().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),J_("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=yC+"/",n="/"+bC;for(let s=0;s<this.LS.length;++s){const r=this.LS.key(s);r.startsWith(e)&&r.endsWith(n)&&(t[SC(r)]=JSON.parse(this.LS.getItem(r)))}return t}async removeModel(t){var e;const n=kC(t=(e=t).startsWith(CC.URL_SCHEME)?e.slice(CC.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),s}}class EC{constructor(){this.managers={}}static getInstance(){return null==EC.instance&&(EC.instance=new EC),EC.instance}static registerManager(t,e){J_(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),J_(t.length>0,()=>"scheme must not be an empty string.");const n=EC.getInstance();J_(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function TC(t){if(-1===t.indexOf("://"))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${EC.getSchemes().join(",")}`);return{scheme:t.split("://")[0],path:t.split("://")[1]}}async function AC(t,e,n=!1){J_(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=oC.getLoadHandlers(t);J_(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),J_(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],i=oC.getSaveHandlers(e);J_(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),J_(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=i[0],o=TC(t).scheme,l=TC(t).path,u=o===TC(t).scheme,c=await r.load();n&&u&&await EC.getManager(o).removeModel(l);const h=await a.save(c);return n&&!u&&await EC.getManager(o).removeModel(l),h.modelArtifactsInfo}async function $C(){const t=EC.getSchemes(),e={};for(const n of t){const t=await EC.getManager(n).listModels();for(const s in t)e[n+"://"+s]=t[s]}return e}async function RC(t){const e=TC(t);return EC.getManager(e.scheme).removeModel(e.path)}async function FC(t,e){return AC(t,e,!1)}async function DC(t,e){return AC(t,e,!0)}class OC{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Bk().get("IS_BROWSER")){Bk().setPlatform("browser",new OC);try{EC.registerManager(CC.URL_SCHEME,new NC)}catch(CY){}try{EC.registerManager(fC.URL_SCHEME,new gC)}catch(CY){}}let LC;function MC(t,e="float32",n){return e=e||"float32",Ok(t),new pS(t,e,n)}Bk().get("IS_NODE")&&Bk().setPlatform("node",new class{constructor(){this.util=n(2),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Bk().global.fetch?Bk().global.fetch(t,e):(null==LC&&(LC=n(1)),LC(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const PC=qS({cast_:function(t,e){const n=HS(t,"x","cast");if(!bk(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return MS.runKernel("Cast",{x:n},{dtype:e})}}),zC=qS({clone_:function(t){const e=HS(t,"x","clone","string_or_numeric");return MS.runKernel("Identity",{x:e})}});function BC(t){return new Promise(t=>setTimeout(t)).then(t)}LS(),mS={buffer:MC,cast:PC,clone:zC,print:function(t,e=!1){console.log(t.toString(e))}};class VC{constructor(t){if(!Bk().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(VC.URL_SCHEME)&&(t=t.slice(VC.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]};null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),r=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(r.download=this.modelTopologyFileName,r.href=s,await BC(()=>r.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await BC(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:iC(t)}}}}VC.URL_SCHEME="downloads://";class WC{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise((n,s)=>{const r=new FileReader;r.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(null==a)return void s(new Error(`modelTopology field is missing from file ${t.name}`));0===e.length&&n({modelTopology:a});const o=i.weightsManifest;if(null==o)return void s(new Error(`weightManifest field is missing from file ${t.name}`));let l;try{l=this.checkManifestAndWeightFiles(o,e)}catch(CY){return void s(CY)}const u=[],c=[],h=[];o.forEach(t=>{t.paths.forEach(t=>{c.push(t),h.push(null)}),u.push(...t.weights)}),o.forEach(t=>{t.paths.forEach(t=>{const e=new FileReader;e.onload=e=>{const s=e.target.result,r=c.indexOf(t);if(h[r]=s,-1===h.indexOf(null)){const t={modelTopology:a,weightSpecs:u,weightData:sC(h),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy};null!=i.signature&&(t.signature=i.signature),null!=i.userDefinedMetadata&&(t.userDefinedMetadata=i.userDefinedMetadata),null!=i.modelInitializer&&(t.modelInitializer=i.modelInitializer),n(t)}},e.onerror=e=>s(`Failed to weights data from file of path '${t}'.`),e.readAsArrayBuffer(l[t])})})},r.onerror=e=>s(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(t)})}checkManifestAndWeightFiles(t,e){const n=[],s=e.map(t=>rC(t.name)),r={};for(const i of t)i.paths.forEach(t=>{const i=rC(t);if(-1!==n.indexOf(i))throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),-1===s.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);r[t]=e[s.indexOf(i)]});if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return r}}function UC(t){return new WC(t)}function jC(t,e,n,s){!function(t){J_(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){J_(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),J_(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),J_(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(t.map(i=>(i.then(i=>{const a=n+ ++r/t.length*(s-n);return e(a),i}),i)))}async function HC(t,e){null==e&&(e={});const n=null==e.fetchFunc?Bk().platform.fetch:e.fetchFunc,s=t.map(t=>n(t,e.requestInit,{isBinary:!0})),r=(null==e.onProgress?await Promise.all(s):await jC(s,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(r):await jC(r,e.onProgress,.5,1)}async function GC(t,e="",n,s){return qC(t=>HC(t,{requestInit:s}))(t,e,n)}function qC(t){return async(e,n="",s)=>{const r=e.map(()=>!1),i={},a=null!=s?s.map(()=>!1):[],o=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l=YS["quantization"in t?t.quantization.dtype:t.dtype]*sk(t.shape),u=()=>{r[e]=!0,null==i[e]&&(i[e]=[]),i[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=s?s.forEach((e,n)=>{e===t.name&&(u(),a[n]=!0)}):u(),o.push(t.name),n+=l})}),!a.every(t=>t)){const t=s.filter((t,e)=>!a[e]);throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((t,e,n)=>(e&&t.push(n),t),[]),u=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)})});const c=await t(u),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let s=0;for(let e=0;e<n;e++)s+=c[d+e].byteLength;const r=new ArrayBuffer(s),a=new Uint8Array(r);let o=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[d+e]);a.set(t,o),o+=t.byteLength}i[t].forEach(t=>{const e=JS(r.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const n in e)h[n]=e[n]}),d+=n}),h}}oC.registerSaveRouter(t=>Bk().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(VC.URL_SCHEME)?function(t="model"){return new VC(t)}(t.slice(VC.URL_SCHEME.length)):null);class KC{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(J_("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Bk().platform.fetch,J_(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&J_(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]};null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:iC(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(p){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=e.modelTopology,s=e.weightsManifest,r=e.generatedBy,i=e.convertedBy,a=e.format,o=e.signature,l=e.userDefinedMetadata;if(null==n&&null==s)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,c;if(null!=s){const t=await this.loadWeights(s);[u,c]=t}const h={modelTopology:n,weightSpecs:u,weightData:c,generatedBy:r,convertedBy:i,format:a};null!=o&&(h.signature=o),null!=l&&(h.userDefinedMetadata=l);const d=e.modelInitializer;return d&&(h.modelInitializer=d),h}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,s]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),r=this.weightPathPrefix||n,i=[];for(const l of t)i.push(...l.weights);const a=[],o=[];for(const l of t)for(const t of l.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):a.push(r+t+s);return this.weightUrlConverter&&a.push(...await Promise.all(o)),[i,sC(await HC(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function XC(t){return null!=t.match(KC.URL_SCHEME_REGEX)}KC.URL_SCHEME_REGEX=/^https?:\/\//;const QC=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>XC(t)):XC(t),n)return YC(t,e)}return null};function YC(t,e){return new KC(t,e)}function ZC(t,e){return YC(t,e)}oC.registerSaveRouter(QC),oC.registerLoadRouter(QC);class JC{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class tI{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function eI(t,e,n,s){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new JC(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new JC({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new JC({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function nI(t){return new tI(t)}let sI;function rI(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)s=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else if(null!=t.getContext)a=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);o=!0}if(r){const e=2;if(r&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=qk("FromPixels",MS.backendName))return MS.runKernel("FromPixels",{pixels:t},{numChannels:e});const[l,u]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,h;if(a?c=t.getContext("2d").getImageData(0,0,l,u).data:s||n?c=t.data:(i||r||o)&&(null==sI&&(sI=document.createElement("canvas").getContext("2d")),sI.canvas.width=l,sI.canvas.height=u,sI.drawImage(t,0,0,l,u),c=sI.getImageData(0,0,l,u).data),4===e)h=new Int32Array(c);else{const t=l*u;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=c[4*n+t]}return function(t,e,n){if(ek(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const s=WS(t,"int32");if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return XS(t,e,s,"int32")}(h,[u,l,e])}async function iI(t,e=3){let n=null;if(Bk().getBool("WRAP_TO_IMAGEBITMAP")&&function(t){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(t instanceof ImageBitmap)&&function(t){return null!=t&&0!==t.width&&0!==t.height}(t)&&!function(t){return null!=t&&t.data instanceof Uint8Array}(t)}(t)){let e;try{e=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch(s){e=null}n=null!=e&&e.width===t.width&&e.height===t.height?e:t}else n=t;return rI(n,e)}async function aI(t,e){let n=HS(t,"img","toPixels");if(!(t instanceof yS)){const t=n;n=PC(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[s,r]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${i}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const t=[0,0,0,255];for(let s=0;s<i;s++){const e=a[u*i+s];if("float32"===n.dtype){if(e<0||e>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${e}.`)}else if("int32"===n.dtype&&(e<0||e>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${e}.`);1===i?(t[0]=e*o,t[1]=e*o,t[2]=e*o):t[s]=e*o}const e=4*u;l[e+0]=Math.round(t[0]),l[e+1]=Math.round(t[1]),l[e+2]=Math.round(t[2]),l[e+3]=Math.round(t[3])}if(null!=e){e.width=r,e.height=s;const t=e.getContext("2d"),n=new ImageData(l,r,s);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l}const oI=qS({fromPixels_:rI});function lI(t,e,n){const s=t.shape.length;J_(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),J_(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)J_(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function uI(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function cI(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function hI(t,e,n,s){const r=[...t];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)0===i?r[e]=1:(r.splice(e,0,1),r.pop());return r}function dI(t,e,n){return n<=t?n:n-(e-1)}function pI(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function fI(t,e,n,s,r,i,a,o,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;c=mI(a,l,u,s,t),h=gI(o,l,u,r,t),d=hI(i,l,u,t)}else for(let p=0;p<u;p++)c[p]=bI(a,s,i,t,p,l),h[p]=xI(o,r,i,t,p,l),d[p]=yI(i,p,l);return{begin:c,end:h,strides:d}}function mI(t,e,n,s,r){const i=[...r],a=pI(n,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const r=dI(e,n,o);let a=s[r];t&1<<r&&(a=0),i[o]=a}return i}function gI(t,e,n,s,r){const i=[...r],a=pI(n,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const r=dI(e,n,o);let a=s[r];t&1<<r&&(a=Number.MAX_SAFE_INTEGER),i[o]=a}for(let o=0;o<i.length;o++){const t=r[o];i[o]<0&&(i[o]+=t),i[o]=K_(0,i[o],r[o])}return i}function yI(t,e,n){let s=t[e];return(n&1<<e||null==s)&&(s=1),s}function bI(t,e,n,s,r,i){let a=e[r];(t&1<<r||i&1<<r||null==a)&&(a=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=s[r];return a<0&&(a+=o),a=K_(0,a,o-1),a}function xI(t,e,n,s,r,i){let a=e[r];const o=n[r]||1;(t&1<<r||i&1<<r||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=o>0?K_(0,a,l):K_(-1,a,l-1),a}function vI(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function wI(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function _I(t,e,n){let s;const r=t.shape.length;let i;return s="number"==typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),s.forEach(t=>{J_(-1!==t,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,i=i.map((e,n)=>e>=0?e:(J_(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-s[n])),[s,i]}function kI(t,e,n,s,r,i,a,o,l){let u=e.slice(),c=n.slice(),h=s;null==s&&(h=new Array(u.length));const d=uI(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==a&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==a&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=t.length-u.length,f=uI(o),m=t.slice();f.forEach(t=>{u[t]=0,c[t]=1,m.splice(t,0,1)});const{begin:g,end:y,strides:b}=fI(m,d,p,u,c,h,r,i,a);u=g,c=y,h=b;const x=uI(l);x.forEach(t=>{c[t]=u[t]+1,h[t]=1});const v=cI(u,c,h),w=v.filter((t,e)=>-1===x.indexOf(e));return{nonStrided:h.every(t=>1===t),$begin:u,$end:c,$strides:h,size:v,newShape:m,outShape:w}}class SI{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class CI{constructor(){this.classNameMap={}}static getMap(){return null==CI.instance&&(CI.instance=new CI),CI.instance}static register(t){CI.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function II(t){J_(null!=t.className,()=>"Class being registered does not have the static className property defined."),J_("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),J_(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),CI.register(t)}function NI(){return MS}function EI(){return MS.memory()}function TI(t,e){return MS.tidy(t,e)}function AI(t){$S(t).forEach(t=>t.dispose())}function $I(t){return MS.keep(t)}function RI(t,e,n=1){return MS.registerBackend(t,e,n)}function FI(t){return MS.customGrad(t)}function DI(t,e){if((vk(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&vk(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return XS(t,[],[],e)}gS=function(t){Bk().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class OI extends SI{minimize(t,e=!1,n){const{value:s,grads:r}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:r[t.name]}));this.applyGradients(t)}else this.applyGradients(r);return AI(r),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){J_(Nk(t),()=>"The f passed in variableGrads(f) must be a function"),J_(null==e||Array.isArray(e)&&e.every(t=>t instanceof xS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in MS.registeredVariables)e.push(MS.registeredVariables[t])}const s=n?e.filter(t=>!t.trainable):null,r=e.length;J_((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:i,grads:a}=MS.gradients(t,e,null,!0);J_(a.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),J_(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const o={};return e.forEach((t,e)=>{null!=a[e]&&(o[t.name]=a[e])}),null!=s&&s.forEach(t=>o[t.name]=null),{value:i,grads:o}}(t,e)}dispose(){null!=this.iterations_&&AI(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:DI(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(OI,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const LI=qS({abs_:function(t){const e=HS(t,"x","abs");return MS.runKernel("complex64"===e.dtype?"ComplexAbs":"Abs",{x:e})}}),MI=qS({add_:function(t,e){let n=HS(t,"a","add"),s=HS(e,"b","add");return[n,s]=ES(n,s),MS.runKernel("Add",{a:n,b:s})}}),PI=qS({all_:function(t,e=null,n=!1){const s=HS(t,"x","all","bool");return MS.runKernel("All",{x:s},{axis:e,keepDims:n})}}),zI=qS({any_:function(t,e=null,n=!1){const s=HS(t,"x","any","bool");return MS.runKernel("Any",{x:s},{axis:e,keepDims:n})}}),BI=qS({argMax_:function(t,e=0){const n=HS(t,"x","argMax");return MS.runKernel("ArgMax",{x:n},{axis:e})}});function VI(t,e,n,s,r="NHWC",i){return jI(t,[...e,t[3]],n,i,s,null,null,JI(r))}function WI(t,e,n,s,r,i,a="channelsLast"){const[o,l]=qI(e);let u;if("channelsLast"===a)u=[o,l,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[o,l,t[1],t[1]]}return jI(t,u,n,s,r,i,!1,a)}function UI(t,e,n,s,r,i,a="NDHWC"){const[o,l,u]=KI(e);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,l,u,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,l,u,t[1],t[1]]}return HI(t,c,n,s,r,!1,h,i)}function jI(t,e,n,s,r,i,a=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=qI(n),[y,b]=qI(s),x=XI(d,y),v=XI(p,b),{padInfo:w,outHeight:_,outWidth:k}=function(t,e,n,s,r,i,a,o,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=function(t,e,n,s,r){null==s&&(s=GI(t,e,n));const i=t[1];return[QI((t[0]-e+2*s)/n+1,r),QI((i-e+2*s)/n+1,r)]}([e,n],i,s,t,o);c=r[0],h=r[1]}else if("same"===t){c=Math.ceil(e/s),h=Math.ceil(n/r);const t=Math.max(0,(c-1)*s+i-e),o=Math.max(0,(h-1)*r+a-n),l=Math.floor(t/2),d=t-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/s),h=Math.ceil((n-a+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=QI((e-i+d+p)/s+1,o),h=QI((n-a+f+m)/r+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(r,u,c,m,g,x,v,i,o),S=a?f*h:f;let C;return"channelsFirst"===o?C=[l,S,_,k]:"channelsLast"===o&&(C=[l,_,k,S]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:_,outWidth:k,outChannels:S,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:t,outShape:C,filterShape:e}}function HI(t,e,n,s,r,i=!1,a="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[y,b,x]=KI(n),[v,w,_]=KI(s),k=XI(p,v),S=XI(f,w),C=XI(m,_),{padInfo:I,outDepth:N,outHeight:E,outWidth:T}=function(t,e,n,s,r,i,a,o,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,s,r,i){null==r&&(r=GI(t,e,s));const a=t[1],o=t[2];return[QI((t[0]-e+2*r)/s+1,i),QI((a-e+2*r)/s+1,i),QI((o-e+2*r)/s+1,i),1]}([e,n,s,1],o,0,r,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/r),p=Math.ceil(n/i),f=Math.ceil(s/a);const t=(d-1)*r+o-e,c=(p-1)*i+l-n,m=(f-1)*a+u-s,g=Math.floor(t/2),y=t-g,b=Math.floor(c/2),x=c-b,v=Math.floor(m/2);h={top:b,bottom:x,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-o+1)/r),p=Math.ceil((n-l+1)/i),f=Math.ceil((s-u+1)/a)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,u,c,h,y,b,x,k,S,C,o),A=i?g*d:g;let $;return"channelsFirst"===a?$=[l,A,N,E,T]:"channelsLast"===a&&($=[l,N,E,T,A]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:N,outHeight:E,outWidth:T,outChannels:A,padInfo:I,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:S,effectiveFilterWidth:C,dilationDepth:v,dilationHeight:w,dilationWidth:_,inShape:t,outShape:$,filterShape:e}}function GI(t,e,n,s=1){const r=XI(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function qI(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function KI(t){return"number"==typeof t?[t,t,t]:t}function XI(t,e){return e<=1?t:t+(t-1)*(e-1)}function QI(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function YI(t){const[e,n,s]=qI(t);return 1===e&&1===n&&1===s}function ZI(t,e){return YI(t)||YI(e)}function JI(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const tN=qS({reshape_:function(t,e){const n=HS(t,"x","reshape","string_or_numeric");return MS.runKernel("Reshape",{x:n},{shape:e})}}),eN=qS({avgPool_:function(t,e,n,s,r){const i=HS(t,"x","avgPool","float32");J_(ZI(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let a=i,o=!1;3===i.rank&&(o=!0,a=tN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J_(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),null!=r&&J_(ak(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let l=MS.runKernel("AvgPool",{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return l=PC(l,i.dtype),o?tN(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),nN=qS({avgPool3d_:function(t,e,n,s,r,i="NDHWC"){const a=HS(t,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=tN(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),J_(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),J_("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&J_(ak(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let u=MS.runKernel("AvgPool3D",{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return u=PC(u,o.dtype),l?tN(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),sN=qS({batchNorm_:function(t,e,n,s,r,i){null==i&&(i=.001);const a=HS(t,"x","batchNorm"),o=HS(e,"mean","batchNorm"),l=HS(n,"variance","batchNorm");let u,c;null!=r&&(u=HS(r,"scale","batchNorm")),null!=s&&(c=HS(s,"offset","batchNorm")),J_(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J_(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J_(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?tN(t,[1,1,1,t.size]):2===t.rank?tN(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?tN(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(a),d=MS.runKernel("FusedBatchNorm",{x:h,scale:u,offset:c,mean:o,variance:l},{varianceEpsilon:i});return tN(d,a.shape)}}),rN=qS({batchNorm2d_:function(t,e,n,s,r,i){const a=HS(t,"x","batchNorm"),o=HS(e,"mean","batchNorm"),l=HS(n,"variance","batchNorm");let u,c;return null!=r&&(u=HS(r,"scale","batchNorm")),null!=s&&(c=HS(s,"offset","batchNorm")),J_(2===a.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),J_(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),J_(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&J_(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&J_(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),sN(a,o,l,c,u,i)}}),iN=qS({batchNorm3d_:function(t,e,n,s,r,i){const a=HS(t,"x","batchNorm"),o=HS(e,"mean","batchNorm"),l=HS(n,"variance","batchNorm");let u,c;return null!=r&&(u=HS(r,"scale","batchNorm")),null!=s&&(c=HS(s,"offset","batchNorm")),J_(3===a.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),J_(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),J_(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&J_(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&J_(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),sN(a,o,l,c,u,i)}}),aN=qS({batchNorm4d_:function(t,e,n,s,r,i){const a=HS(t,"x","batchNorm"),o=HS(e,"mean","batchNorm"),l=HS(n,"variance","batchNorm");let u,c;return null!=r&&(u=HS(r,"scale","batchNorm")),null!=s&&(c=HS(s,"offset","batchNorm")),J_(4===a.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),J_(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),J_(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&J_(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&J_(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),sN(a,o,l,c,u,i)}}),oN=qS({clipByValue_:function(t,e,n){const s=HS(t,"x","clipByValue");return J_(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),MS.runKernel("ClipByValue",{x:s},{clipValueMin:e,clipValueMax:n})}}),lN=qS({concat_:function(t,e=0){J_(t.length>=1,()=>"Pass at least one tensor to concat");const n=GS(t,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}),1===n.length?zC(n[0]):MS.runKernel("Concat",n,{axis:e})}}),uN=qS({concat1d_:function(t){return lN(t,0)}}),cN=qS({concat2d_:function(t,e){return lN(t,e)}}),hN=qS({concat3d_:function(t,e){return lN(t,e)}}),dN=qS({concat4d_:function(t,e){return lN(t,e)}}),pN=qS({conv2d_:function(t,e,n,s,r="NHWC",i=[1,1],a){const o=HS(t,"x","conv2d"),l=HS(e,"filter","conv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=tN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J_(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),J_(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=a&&J_(ak(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h="NHWC"===r?u.shape[3]:u.shape[1];J_(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),J_(ZI(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=MS.runKernel("Conv2D",{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a});return c?tN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),fN=qS({conv1d_:function(t,e,n,s,r="NWC",i=1,a){const o=HS(t,"x","conv1d"),l=HS(e,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=tN(o,[1,o.shape[0],o.shape[1]])),J_(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),J_(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=a&&J_(ak(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),J_(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),J_(ZI(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),J_("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=tN(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=tN(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=pN(d,h,[1,n],s,"NHWC",[1,i],a);return tN(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),mN=qS({conv2DBackpropInput_:function(t,e,n,s,r,i="NHWC",a){J_(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,l=e,u=!1;3===e.rank&&(u=!0,l=tN(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),J_(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),J_(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),J_(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===i?o[3]:o[1],h="NHWC"===i?l.shape[3]:l.shape[1];J_(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),J_(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=a&&J_(ak(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const d=MS.runKernel("Conv2DBackpropInput",{dy:l,filter:n},{strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o});return u?tN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),gN=qS({conv2dTranspose_:function(t,e,n,s,r,i){const a=HS(t,"x","conv2dTranspose"),o=HS(e,"filter","conv2dTranspose");return mN(n,a,o,s,r,"NHWC",i)}}),yN=qS({conv3d_:function(t,e,n,s,r="NDHWC",i=[1,1,1]){const a=HS(t,"x","conv3d"),o=HS(e,"filter","conv3d");let l=a,u=!1;4===a.rank&&(u=!0,l=tN(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),J_(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),J_(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),J_(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),J_(ZI(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),J_("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c=MS.runKernel("Conv3D",{x:l,filter:o},{strides:n,pad:s,dataFormat:r,dilations:i});return u?tN(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),bN=qS({depthwiseConv2d_:function(t,e,n,s,r="NHWC",i=[1,1],a){const o=HS(t,"x","depthwiseConv2d"),l=HS(e,"filter","depthwiseConv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=tN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J_(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),J_(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),J_(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=a&&J_(ak(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h=MS.runKernel("DepthwiseConv2dNative",{x:u,filter:l},{strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a});return c?tN(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),xN=qS({floorDiv_:function(t,e){let n=HS(t,"a","floorDiv"),s=HS(e,"b","floorDiv");return[n,s]=ES(n,s),MS.runKernel("FloorDiv",{a:n,b:s})}}),vN=qS({div_:function(t,e){let n=HS(t,"a","div"),s=HS(e,"b","div");return[n,s]=ES(n,s),"int32"===n.dtype&&"int32"===s.dtype?xN(n,s):MS.runKernel("RealDiv",{a:n,b:s},{})}}),wN=qS({elu_:function(t){const e=HS(t,"x","elu");return MS.runKernel("Elu",{x:e})}});function _N(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,a=t[i]||1;(e[e.length-1-r]||1)>1&&1===a&&s.unshift(i)}return s}function kN(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],i=e.length-s-1,a=e[i];(null==r||1===r&&a>1)&&n.unshift(i)}return n}function SN(t,e){const n=[],s=Math.max(t.length,e.length);for(let r=0;r<s;r++){let s=t[t.length-r-1];null==s&&(s=1);let i=e[e.length-r-1];if(null==i&&(i=1),1===s)n.unshift(i);else if(1===i)n.unshift(s);else{if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(s)}}return n}const CN=qS({equal_:function(t,e){let n=HS(t,"a","equal"),s=HS(e,"b","equal");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("Equal",{a:n,b:s})}}),IN=qS({expandDims_:function(t,e=0){const n=HS(t,"x","expandDims","string_or_numeric");return J_(e<=n.rank,()=>"Axis must be <= rank of the tensor"),MS.runKernel("ExpandDims",{input:n},{dim:e})}}),NN=qS({tile_:function(t,e){const n=HS(t,"x","tile","string_or_numeric");return J_(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),MS.runKernel("Tile",{x:n},{reps:e})}}),EN=qS({eye_:function(t,e,n,s="float32"){null==e&&(e=t);const r=MC([t,e],s),i=t<=e?t:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=tN(r.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return NN(IN(a,0),[n[0],1,1]);if(2===n.length)return NN(IN(IN(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return NN(IN(IN(IN(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function TN(t,e,n){return MS.runKernel("Fill",{},{shape:t,value:e,dtype:n})}const AN=qS({floor_:function(t){const e=HS(t,"x","floor");return MS.runKernel("Floor",{x:e})}}),$N=qS({gather_:function(t,e,n=0,s=0){const r=HS(t,"x","gather"),i=HS(e,"indices","gather","int32");return MS.runKernel("GatherV2",{x:r,indices:i},{axis:n,batchDims:s})}}),RN=qS({greater_:function(t,e){let n=HS(t,"a","greater"),s=HS(e,"b","greater");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("Greater",{a:n,b:s})}}),FN=qS({greaterEqual_:function(t,e){let n=HS(t,"a","greaterEqual"),s=HS(e,"b","greaterEqual");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("GreaterEqual",{a:n,b:s})}}),DN=qS({leakyRelu_:function(t,e=.2){const n=HS(t,"x","leakyRelu");return MS.runKernel("LeakyRelu",{x:n},{alpha:e})}}),ON=qS({log_:function(t){const e=HS(t,"x","log");return MS.runKernel("Log",{x:e})}}),LN=qS({exp_:function(t){const e=HS(t,"x","exp");return MS.runKernel("Exp",{x:e})}}),MN=qS({max_:function(t,e=null,n=!1){const s=HS(t,"x","max");return MS.runKernel("Max",{x:s},{reductionIndices:e,keepDims:n})}}),PN=qS({mul_:function(t,e){let n=HS(t,"a","mul"),s=HS(e,"b","mul");return[n,s]=ES(n,s),MS.runKernel("Multiply",{a:n,b:s})}}),zN=qS({sub_:function(t,e){let n=HS(t,"a","sub"),s=HS(e,"b","sub");return[n,s]=ES(n,s),MS.runKernel("Sub",{a:n,b:s})}}),BN=qS({sum_:function(t,e=null,n=!1){let s=HS(t,"x","sum");return"bool"===s.dtype&&(s=PC(s,"int32")),MS.runKernel("Sum",{x:s},{axis:e,keepDims:n})}}),VN=qS({logSoftmax_:function(t,e=-1){const n=HS(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return FI((t,n)=>{const s=MN(t,e,!0),r=zN(t,s),i=zN(PC(r,"float32"),ON(BN(LN(r),e,!0)));return n([i]),{value:i,gradFunc:(t,n)=>{const[s]=n,r=LN(s);return zN(t,PN(BN(t,e,!0),r))}}})(n)}}),WN=qS({logicalAnd_:function(t,e){const n=HS(t,"a","logicalAnd","bool"),s=HS(e,"b","logicalAnd","bool");return SN(n.shape,s.shape),MS.runKernel("LogicalAnd",{a:n,b:s})}}),UN=qS({maxPool_:function(t,e,n,s,r){const i=HS(t,"x","maxPool");let a=i,o=!1;3===i.rank&&(o=!0,a=tN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J_(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),J_(ZI(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&J_(ak(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l=MS.runKernel("MaxPool",{x:a},{filterSize:e,strides:n,pad:s,dimRoundingMode:r});return o?tN(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),jN=qS({maxPool3d_:function(t,e=[1,1,1],n,s,r,i="NDHWC"){const a=HS(t,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=tN(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),J_(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),J_("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=r&&J_(ak(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const u=MS.runKernel("MaxPool3D",{x:o},{filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:i});return l?tN(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),HN=qS({maximum_:function(t,e){let n=HS(t,"a","maximum"),s=HS(e,"b","maximum");return[n,s]=ES(n,s),"bool"===n.dtype&&(n=PC(n,"int32"),s=PC(s,"int32")),SN(n.shape,s.shape),MS.runKernel("Maximum",{a:n,b:s})}}),GN=qS({mean_:function(t,e=null,n=!1){const s=HS(t,"x","mean");return MS.runKernel("Mean",{x:s},{axis:e,keepDims:n})}}),qN=qS({min_:function(t,e=null,n=!1){const s=HS(t,"x","min");return MS.runKernel("Min",{x:s},{axis:e,keepDims:n})}}),KN=qS({minimum_:function(t,e){let n=HS(t,"a","minimum"),s=HS(e,"b","minimum");return[n,s]=ES(n,s),"bool"===n.dtype&&(n=PC(n,"int32"),s=PC(s,"int32")),SN(n.shape,s.shape),MS.runKernel("Minimum",{a:n,b:s})}});function XN(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function QN(t,e,n){const s=t.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)-1===n.indexOf(o)?r.push(t[i++]):r.push(e[a++]);return r}function YN(t,e){const n=[],s=t.length;for(let r=0;r<s;r++)-1===e.indexOf(r)&&n.push(t[r]);return[n,e.map(e=>t[e])]}function ZN(t,e){return QN(t,e.map(t=>1),e)}function JN(t,e,n){J_(XN(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function tE(t,e){if(XN(t,e))return null;const n=[];for(let s=0;s<e;++s)-1===t.indexOf(s)&&n.push(s);return t.forEach(t=>n.push(t)),n}function eE(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function nE(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}const sE=qS({square_:function(t){const e=HS(t,"x","square");return MS.runKernel("Square",{x:e},{})}}),rE=qS({moments_:function(t,e=null,n=!1){const s=pk(e,(t=HS(t,"x","moments")).shape),r=GN(t,s,n);let i=r.shape;n||(i=ZN(r.shape,s));const a=sE(zN(PC(t,"float32"),tN(r,i)));return{mean:r,variance:GN(a,s,n)}}}),iE=qS({neg_:function(t){const e=HS(t,"x","neg");return MS.runKernel("Neg",{x:e})}}),aE=qS({notEqual_:function(t,e){let n=HS(t,"a","notEqual"),s=HS(e,"b","notEqual");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("NotEqual",{a:n,b:s})}}),oE=qS({oneHot_:function(t,e,n=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r=HS(t,"indices","oneHot","int32");return MS.runKernel("OneHot",{indices:r},{depth:e,onValue:n,offValue:s})}});function lE(t,e="float32"){if("complex64"===e){const e=lE(t,"float32"),n=lE(t,"float32");return KS(e,n)}const n=Fk(sk(t),e);return MS.makeTensor(n,t,e)}function uE(t,e="float32"){if("complex64"===e){const e=uE(t,"float32"),n=lE(t,"float32");return KS(e,n)}const n=Rk(sk(t),e);return MS.makeTensor(n,t,e)}const cE=qS({onesLike_:function(t){const e=HS(t,"x","onesLike");return MS.runKernel("OnesLike",{x:e})}}),hE=qS({pad_:function(t,e,n=0){const s=HS(t,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return MS.runKernel("PadV2",{x:s},{paddings:e,constantValue:n})}}),dE=qS({pow_:function(t,e){let n=HS(t,"base","pow"),s=HS(e,"exp","pow");return[n,s]=ES(n,s),MS.runKernel("Pow",{a:n,b:s})}}),pE=qS({prelu_:function(t,e){const n=HS(t,"x","prelu"),s=HS(e,"alpha","prelu");return MS.runKernel("Prelu",{x:n,alpha:s})}});var fE=n("YSVl");class mE{constructor(t,e,n,s,r){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=r||Math.random();this.random=fE.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let s,r,i;do{s=2*this.random()-1,r=2*this.random()-1,i=s*s+r*r}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*r*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class gE{constructor(t=0,e=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=fE.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const yE=qS({randomNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new mE(e,n,s,!1,r),a=MC(t,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),bE=qS({randomUniform_:function(t,e=0,n=1,s="float32",r){const i=MC(t,s),a=new gE(e,n,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),xE=qS({relu_:function(t){const e=HS(t,"x","relu");return MS.runKernel("Relu",{x:e})}}),vE=qS({reverse_:function(t,e){const n=HS(t,"x","reverse");return MS.runKernel("Reverse",{x:n},{dims:e})}}),wE=qS({selu_:function(t){const e=HS(t,"x","selu");return MS.runKernel("Selu",{x:e})}}),_E=qS({separableConv2d_:function(t,e,n,s,r,i=[1,1],a="NHWC"){const o=HS(t,"x","separableConv2d"),l=HS(e,"depthwiseFilter","separableConv2d"),u=HS(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=tN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J_(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),J_(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),J_(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),J_(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),J_(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];J_(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=bN(c,l,s,r,a,i),m=pN(f,u,1,"valid",a);return h?tN(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),kE=qS({sigmoid_:function(t){const e=HS(t,"x","sigmoid");return MS.runKernel("Sigmoid",{x:e})}}),SE=qS({slice_:function(t,e,n){const s=HS(t,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return MS.runKernel("Slice",{x:s},{begin:e,size:n})}}),CE=qS({slice1d_:function(t,e,n){const s=HS(t,"x","slice1d");return J_(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),SE(s,[e],[n])}}),IE=qS({slice2d_:function(t,e,n){const s=HS(t,"x","slice2d");return J_(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),SE(s,e,n)}}),NE=qS({slice3d_:function(t,e,n){const s=HS(t,"x","slice3d");return J_(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),SE(s,e,n)}}),EE=qS({slice4d_:function(t,e,n){const s=HS(t,"x","slice4d");return J_(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),SE(s,e,n)}}),TE=qS({softmax_:function(t,e=-1){const n=HS(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return MS.runKernel("Softmax",{logits:n},{dim:e})}}),AE=qS({softplus_:function(t){const e=HS(t,"x","softplus");return MS.runKernel("Softplus",{x:e})}}),$E=qS({split_:function(t,e,n=0){const s=HS(t,"x","split");return MS.runKernel("SplitV",{x:s},{numOrSizeSplits:e,axis:n})}}),RE=qS({sqrt_:function(t){const e=HS(t,"x","sqrt");return MS.runKernel("Sqrt",{x:e})}}),FE=qS({squeeze_:function(t,e){const n=HS(t,"x","squeeze");return tN(n,fk(n.shape,e).newShape)}}),DE=qS({stack_:function(t,e=0){const n=GS(t,"tensors","stack","string_or_numeric");return J_(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&J_(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),MS.runKernel("Pack",n,{axis:e})}}),OE=qS({tanh_:function(t){const e=HS(t,"x","tanh");return MS.runKernel("Tanh",{x:e})}});function LE(t,e){ek(t);const n=WS(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return XS(t,null,n,e)}function ME(t,e,n){if(ek(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const s=WS(t,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return XS(t,e,s,n)}const PE=qS({truncatedNormal_:function(t,e=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new mE(e,n,s,!0,r),a=MC(t,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),zE=qS({unstack_:function(t,e=0){const n=HS(t,"x","unstack","string_or_numeric");return J_(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),MS.runKernel("Unpack",{value:n},{axis:e})}}),BE=qS({broadcastTo_:function(t,e){let n=HS(t,"broadcastTo","x");const s=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=tN(n,t)}const r=n.shape,i=Array.from(e);for(let a=e.length-1;a>=0;a--)if(r[a]===e[a])i[a]=1;else if(1!==n.shape[a])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);return 0===i.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?zC(n):MS.runKernel("Tile",{x:n},{reps:i})}}),VE=qS({where_:function(t,e,n){const s=HS(e,"a","where"),r=HS(n,"b","where"),i=HS(t,"condition","where","bool"),a=SN(s.shape,r.shape),o=BE(s,a),l=BE(r,a);return 1===i.rank&&J_(i.shape[0]===s.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==i.rank&&tk(i.shape,l.shape,"Error in where: "),MS.runKernel("Select",{condition:i,t:o,e:l})}}),WE=qS({zerosLike_:function(t){const e=HS(t,"x","zerosLike");return MS.runKernel("ZerosLike",{x:e})}}),UE=qS({transpose_:function(t,e){const n=HS(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),J_(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{J_(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1?n.clone():MS.runKernel("Transpose",{x:n},{perm:e})}}),jE=qS({dropout_:function(t,e,n,s){const r=HS(t,"x","dropout");if(J_("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),J_(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof yS?r.clone():r;const i=function(t,e){if(null==e)return t.shape.slice();if(ik(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)n.push(null==e[s]&&null!=t.shape[s]?t.shape[s]:e[s]);return n}return e}(r,n),a=1-e,o=vN(AN(MI(bE(i,0,1,"float32",s),a)),a);return PN(r,o)}}),HE=qS({imag_:function(t){const e=HS(t,"input","imag");return MS.runKernel("Imag",{input:e})}}),GE=qS({real_:function(t){const e=HS(t,"input","real");return MS.runKernel("Real",{input:e})}}),qE=qS({fft_:function(t){return J_("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),MS.runKernel("FFT",{input:t})}}),KE=qS({rfft_:function(t,e){J_("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(null!=e&&e<n){const s=t.shape.map(t=>0),i=t.shape.map(t=>t);i[t.shape.length-1]=e,r=SE(t,s,i),n=e}else if(null!=e&&e>n){const s=t.shape.map(t=>t);s[t.shape.length-1]=e-n,r=lN([t,lE(s)],t.shape.length-1),n=e}else r=t;const i=WE(r),a=tN(KS(r,i),[s,n]),o=qE(a),l=Math.floor(n/2)+1,u=GE(o),c=HE(o),h=$E(u,[l,n-l],u.shape.length-1),d=$E(c,[l,n-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,tN(KS(h[0],d[0]),p)}}),XE=qS({ifft_:function(t){return J_("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),MS.runKernel("IFFT",{input:t})}}),QE=qS({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=tN(t,[n,e]);s=XE(r)}else{const r=[n,2*(e-1)],i=tN(GE(t),[n,e]),a=tN(HE(t),[n,e]),o=vE(SE(i,[0,1],[n,e-2]),1),l=PN(vE(SE(a,[0,1],[n,e-2]),1),DI(-1)),u=lN([i,o],1),c=lN([a,l],1),h=tN(KS(u,c),[r[0],r[1]]);s=XE(h)}if(s=GE(s),3===t.rank&&0!==t.shape[0]){const e=s,n=t.shape[0];s=tN(s,[n,s.shape[0]/n,s.shape[1]]),e.dispose()}return s}}),YE=qS({conv2DBackpropFilter_:function(t,e,n,s,r,i="NHWC",a){let o=t;3===t.rank&&(o=tN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=tN(e,[1,e.shape[0],e.shape[1],e.shape[2]])),J_(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),J_(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),J_(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return J_(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),J_(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=a&&J_(ak(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),MS.runKernel("Conv2DBackpropFilter",{x:o,dy:l},{strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:n})}}),ZE=qS({relu6_:function(t){const e=HS(t,"x","relu6");return MS.runKernel("Relu6",{x:e})}}),JE=qS({step_:function(t,e=0){const n=HS(t,"x","step");return MS.runKernel("Step",{x:n},{alpha:e})}});function tT(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return PN(t,JE(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function eT(t,e){let n=e;const s=kN(t.shape,e.shape);return s.length>0&&(n=BN(n,s)),tN(n,t.shape)}function nT(t,e,n,s){if("linear"===e)return t;if("relu"===e)return xE(t);if("elu"===e)return wN(t);if("relu6"===e)return ZE(t);if("prelu"===e)return pE(t,n);if("leakyrelu"===e)return DN(t,s);throw new Error(`Unknown fused activation ${e}.`)}const sT=(t,e)=>!(t>0)||"linear"===e,rT=qS({fusedConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===sT(MS.state.gradientDepth,l=l||"linear")){let h=pN(t,e,n,s,r,i,a);return null!=o&&(h=MI(h,o)),nT(h,l,u,c)}const h=HS(t,"x","conv2d"),d=HS(e,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=tN(h,[1,h.shape[0],h.shape[1],h.shape[2]])),J_(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),J_(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=a&&J_(ak(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),J_(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),J_(ZI(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),J_("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=jI(p.shape,d.shape,n,i,s,a);let g,y;null!=o&&(g=HS(o,"bias","fused conv2d"),[g]=ES(g,h),SN(m.outShape,g.shape)),null!=u&&(y=HS(u,"prelu weights","fused conv2d"));const b=(t,e)=>{const[r,a,o,u]=e,c=tT(t,o,l);J_(YI(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const h=[mN(a.shape,c,r,n,s),YE(a,c,r.shape,n,s)];if(null!=u){const t=eT(u,c);h.push(t)}return h},x={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return null==o?FI((t,e,n)=>{let s=MS.runKernel("FusedConv2D",x,v);return n([e,t,s]),f&&(s=tN(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):FI((t,e,n,s)=>{let r=MS.runKernel("FusedConv2D",x,v);return s([e,t,r,n]),f&&(r=tN(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),iT=qS({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,s,r,i=[1,1],a){let o=t;3===t.rank&&(o=tN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;return 3===l.rank&&(l=tN(e,[1,e.shape[0],e.shape[1],e.shape[2]])),MS.runKernel("DepthwiseConv2dNativeBackpropFilter",{x:o,dy:l},{strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:n})}}),aT=qS({depthwiseConv2dNativeBackpropInput_:function(t,e,n,s,r,i=[1,1],a){let o=e,l=!1;3===e.rank&&(l=!0,o=tN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u=MS.runKernel("DepthwiseConv2dNativeBackpropInput",{dy:o,filter:n},{strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:t});return l?tN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),oT=qS({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===sT(MS.state.gradientDepth,l)){let h=bN(t,e,n,s,r,i,a);return null!=o&&(h=MI(h,o)),nT(h,l,u,c)}const h=HS(t,"x","depthwiseConv2d"),d=HS(e,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=tN(h,[1,h.shape[0],h.shape[1],h.shape[2]])),J_(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),J_(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),J_(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==i&&(i=[1,1]),J_(ZI(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=a&&J_(ak(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${s}.`);const m=jI(p.shape,d.shape,n,i,s,a,!0);let g,y;null!=o&&(g=HS(o,"bias","fused conv2d"),[g]=ES(g,h),SN(m.outShape,g.shape)),null!=u&&(y=HS(u,"prelu weights","fused depthwiseConv2d"));const b=(t,e)=>{J_(YI(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[r,o,u,c]=e,h=tT(t,u,l),d=aT(o.shape,h,r,n,s,i,a),p=iT(o,h,r.shape,n,s,i,a);return null!=c?[d,p,eT(g,h)]:[d,p]},x={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return null==o?FI((t,e,n)=>{let s=MS.runKernel("FusedDepthwiseConv2D",x,v);return n([e,t,s]),f&&(s=tN(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d):FI((t,e,n,s)=>{let r=MS.runKernel("FusedDepthwiseConv2D",x,v);return s([e,t,r,n]),f&&(r=tN(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d,g)}}),lT=qS({matMul_:function(t,e,n=!1,s=!1){let r=HS(t,"a","matMul"),i=HS(e,"b","matMul");return[r,i]=ES(r,i),MS.runKernel("BatchMatMul",{a:r,b:i},{transposeA:n,transposeB:s})}}),uT=qS({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o}){if(!1===sT(MS.state.gradientDepth,i)){let l=lT(t,e,n,s);return null!=r&&(l=MI(l,r)),nT(l,i,a,o)}let l=HS(t,"a","fused matMul"),u=HS(e,"b","fused matMul");[l,u]=ES(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=sk(f),y=sk(m);J_(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),J_(ik(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),J_(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=l.shape.slice(0,-2).concat([d,p]),x=tN(l,n?[g,c,d]:[g,d,c]),v=tN(u,s?[y,p,h]:[y,h,p]);let w,_;null!=r&&(w=HS(r,"bias","fused matMul"),[w]=ES(w,l),SN(b,w.shape)),null!=a&&(_=HS(a,"prelu weights","fused matMul"));const k=(t,e)=>{const[a,o,l,u]=e,c=tT(tN(t,l.shape),l,i);let h,d;return n||s?!n&&s?(h=lT(c,o,!1,!1),d=lT(c,a,!0,!1)):n&&!s?(h=lT(o,c,!1,!0),d=lT(a,c,!1,!1)):(h=lT(o,c,!0,!0),d=lT(c,a,!0,!0)):(h=lT(c,o,!1,!0),d=lT(a,c,!0,!1)),null!=r?[h,d,eT(u,c)]:[h,d]},S={a:x,b:v,bias:w,preluActivationWeights:_},C={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:o};return null==r?FI((t,e,n)=>{const s=MS.runKernel("_FusedMatMul",S,C);return n([t,e,s]),{value:tN(s,b),gradFunc:k}})(x,v):FI((t,e,n,s)=>{const r=MS.runKernel("_FusedMatMul",S,C);return s([t,e,r,n]),{value:tN(r,b),gradFunc:k}})(x,v,w)}});function cT(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let i=0;i<t;++i){const a=2*Math.PI*i/(t+s-1);r[i]=e-n*Math.cos(a)}return LE(r,"float32")}qS({hammingWindow_:function(t){return cT(t,.54,.46)}});const hT=qS({hannWindow_:function(t){return cT(t,.5,.5)}}),dT=qS({frame_:function(t,e,n,s=!1,r=0){let i=0;const a=[];for(;i+e<=t.size;)a.push(SE(t,i,e)),i+=n;if(s)for(;i<t.size;){const s=i+e-t.size,o=lN([SE(t,i,e-s),TN([s],r)]);a.push(o),i+=n}return 0===a.length?ME([],[0,e]):tN(lN(a),[a.length,e])}});function pT(t,e,n,s,r,i){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==i&&(i=0);const a=t.shape[0];return n=Math.min(n,a),J_(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),J_(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),J_(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),J_(1===e.rank,()=>"scores must be a 1D tensor"),J_(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),J_(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function fT(t,e,n){const s=function(t,e,n){return function(t,e,n){let s=0,r=t.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=n(e,t[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}(t,e,n||mT)}(t,e,n);t.splice(s<0?-(s+1):s,0,e)}function mT(t,e){return t>e?1:t<e?-1:0}function gT(t,e,n,s,r){return xT(t,e,n,s,r,0)}function yT(t,e,n,s,r,i){return xT(t,e,n,s,r,0,!1,i,!0)}function bT(t,e,n,s,r,i){return xT(t,e,n,s,r,i,!0)}function xT(t,e,n,s,r,i,a=!1,o=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(_T);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:a}=e;if(n<r)break;let o=!1;for(let l=h.length-1;l>=a;--l){const n=vT(t,i,h[l]);if(n>=s){o=!0;break}if(e.score=e.score*wT(s,c,n),e.score<=r)break}e.suppressBeginIndex=h.length,o||(e.score===n?(h.push(i),d.push(e.score)):e.score>r&&fT(u,e,_T))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function vT(t,e,n){const s=t.subarray(4*e,4*e+4),r=t.subarray(4*n,4*n+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(o-i)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(a,c),y=Math.min(o,h),b=Math.min(l,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function wT(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function _T(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}qS({stft_:function(t,e,n,s,r=hT){null==s&&(s=Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2)))));const i=dT(t,e,n),a=PN(i,r(e)),o=[];for(let l=0;l<i.shape[0];l++)o.push(KE(SE(a,[l,0],[1,e]),s));return lN(o)}}),qS({cropAndResize_:function(t,e,n,s,r="bilinear",i=0){const a=HS(t,"image","cropAndResize"),o=HS(e,"boxes","cropAndResize","float32"),l=HS(n,"boxInd","cropAndResize","int32"),u=o.shape[0];return J_(4===a.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),J_(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),J_(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),J_(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),J_(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),J_("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),MS.runKernel("CropAndResize",{image:a,boxes:o,boxInd:l},{method:r,extrapolationValue:i,cropSize:s})}}),qS({flipLeftRight_:function(t){const e=HS(t,"image","flipLeftRight","float32");return J_(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),MS.runKernel("FlipLeftRight",{image:e},{})}}),qS({rotateWithOffset_:function(t,e,n=0,s=.5){const r=HS(t,"image","rotateWithOffset","float32");return J_(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),MS.runKernel("RotateWithOffset",{image:r},{radians:e,fillValue:n,center:s})}}),qS({nonMaxSuppression_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=HS(t,"boxes","nonMaxSuppression"),a=HS(e,"scores","nonMaxSuppression"),o=pT(i,a,n,s,r);return MS.runKernel("NonMaxSuppressionV3",{boxes:i,scores:a},{maxOutputSize:n=o.maxOutputSize,iouThreshold:s=o.iouThreshold,scoreThreshold:r=o.scoreThreshold})}}),qS({nonMaxSuppressionWithScore_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=HS(t,"boxes","nonMaxSuppression"),o=HS(e,"scores","nonMaxSuppression"),l=pT(a,o,n,s,r,i),u=MS.runKernel("NonMaxSuppressionV5",{boxes:a,scores:o},{maxOutputSize:n=l.maxOutputSize,iouThreshold:s=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}}),qS({nonMaxSuppressionPadded_:function(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=HS(t,"boxes","nonMaxSuppression"),o=HS(e,"scores","nonMaxSuppression"),l=pT(a,o,n,s,r,null),u=MS.runKernel("NonMaxSuppressionV4",{boxes:a,scores:o},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:u[0],validOutputs:u[1]}}});const kT=qS({resizeBilinear_:function(t,e,n=!1,s=!1){const r=HS(t,"images","resizeBilinear");J_(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),J_(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),J_(!1===s||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;3===r.rank&&(a=!0,i=tN(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,o=MS.runKernel("ResizeBilinear",{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return a?tN(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),ST=qS({resizeNearestNeighbor_:function(t,e,n=!1,s=!1){const r=HS(t,"images","resizeNearestNeighbor");J_(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),J_(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),J_("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),J_(!1===s||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;3===r.rank&&(a=!0,i=tN(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=e,o=MS.runKernel("ResizeNearestNeighbor",{images:i},{alignCorners:n,halfPixelCenters:s,size:e});return a?tN(o,[o.shape[1],o.shape[2],o.shape[3]]):o}});qS({transform_:function(t,e,n="nearest",s="constant",r=0,i){const a=HS(t,"image","transform","float32"),o=HS(e,"transforms","transform","float32");return J_(4===a.rank,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),J_(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),J_(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),MS.runKernel("Transform",{image:a,transforms:o},{interpolation:n,fillMode:s,fillValue:r,outputShape:i})}});const CT=qS({lessEqual_:function(t,e){let n=HS(t,"a","lessEqual"),s=HS(e,"b","lessEqual");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("LessEqual",{a:n,b:s})}});function IT(t,e,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");return MS.runKernel("Range",{},{start:t,stop:e,step:n,dtype:s})}const NT=qS({bandPart_:function(t,e,n){J_(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),J_(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=HS(t,"a","bandPart");J_(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=i),n<0&&(n=a);const o=tN(IT(0,i,1,"int32"),[-1,1]),l=IT(0,a,1,"int32"),u=zN(o,l),c=WN(CT(u,DI(+e,"int32")),FN(u,DI(-n,"int32"))),h=lE([i,a],s.dtype);return tN(DE(zE(tN(s,[-1,i,a])).map(t=>VE(c,t,h))),r)}});function ET(t,e,n=null){if(0===t.rank)return LI(t);if(1!==t.rank&&null===n)return ET(tN(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return BN(LI(t),n);if(e===1/0)return MN(LI(t),n);if(e===-1/0)return qN(LI(t),n);if("euclidean"===e||2===e)return RE(BN(dE(LI(t),DI(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return MN(BN(LI(t),n[0]),n[1]-1);if(e===1/0)return MN(BN(LI(t),n[1]),n[0]);if(e===-1/0)return qN(BN(LI(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return RE(BN(sE(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const TT=qS({norm_:function(t,e="euclidean",n=null,s=!1){const r=ET(t=HS(t,"x","norm"),e,n);let i=r.shape;if(s){const e=pk(n,t.shape);i=ZN(r.shape,e)}return tN(r,i)}}),AT=qS({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,J_(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)J_(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=$E(t,t.shape[0],0).map(t=>FE(t,[0]));J_(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(MS.tidy(()=>{let t=s[r];if(r>0)for(let e=0;e<r;++e){const s=PN(BN(PN(n[e],t)),n[e]);t=zN(t,s)}return vN(t,TT(t,"euclidean"))}));return e?DE(n,0):n}});function $T(t,e=!1){return MS.tidy(()=>{J_(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=EN(n),i=zC(t);const a=ME([[1]],[1,1]);let o=zC(a);const l=n>=s?s:n;for(let t=0;t<l;++t){const e=i,l=o,u=r;[o,i,r]=MS.tidy(()=>{const e=SE(i,[t,t],[n-t,1]),l=TT(e),u=SE(i,[t,t],[1,1]),c=VE(RN(u,0),ME([[-1]]),ME([[1]])),h=zN(u,PN(c,l)),d=vN(e,h);o=1===d.shape[0]?zC(a):lN([a,SE(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=iE(vN(lT(c,h),l)),f=SE(i,[t,0],[n-t,s]),m=PN(p,o),g=UE(o);if(0===t)i=zN(f,lT(m,lT(g,f)));else{const e=zN(f,lT(m,lT(g,f)));i=lN([SE(i,[0,0],[t,s]),e],0)}const y=UE(m),b=SE(r,[0,t],[n,r.shape[1]-t]);if(0===t)r=zN(b,lT(lT(b,o),y));else{const e=zN(b,lT(lT(b,o),y));r=lN([SE(r,[0,0],[n,t]),e],1)}return[o,i,r]}),AI([e,l,u])}return!e&&n>s&&(r=SE(r,[0,0],[n,s]),i=SE(i,[0,0],[s,s])),[r,i]})}const RT=qS({qr_:function(t,e=!1){if(J_(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return $T(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),s=zE(tN(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],i=[];return s.forEach(t=>{const[n,s]=$T(t,e);r.push(n),i.push(s)}),[tN(DE(r,0),t.shape),tN(DE(i,0),t.shape)]}}});var FT;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(FT||(FT={}));const DT=qS({computeWeightedLoss_:function(t,e,n=FT.SUM_BY_NONZERO_WEIGHTS){const s=HS(t,"losses","computeWeightedLoss");let r=null;null!=e&&(r=HS(e,"weights","computeWeightedLoss"));const i=null==r?s:PN(s,r);if(n===FT.NONE)return i;if(n===FT.SUM)return BN(i);if(n===FT.MEAN){if(null==r)return GN(i);{const t=s.size/r.size,e=vN(BN(i),BN(r));return t>1?vN(e,DI(t)):e}}if(n===FT.SUM_BY_NONZERO_WEIGHTS){if(null==r)return vN(BN(i),DI(s.size));{const t=PN(r,uE(s.shape)),e=PC(BN(aE(t,DI(0))),"float32");return vN(BN(i),e)}}throw Error(`Unknown reduction: ${n}`)}});qS({absoluteDifference_:function(t,e,n,s=FT.SUM_BY_NONZERO_WEIGHTS){const r=HS(t,"labels","absoluteDifference"),i=HS(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=HS(n,"weights","absoluteDifference")),tk(r.shape,i.shape,"Error in absoluteDifference: ");const o=LI(zN(r,i));return DT(o,a,s)}}),qS({cosineDistance_:function(t,e,n,s,r=FT.SUM_BY_NONZERO_WEIGHTS){const i=HS(t,"labels","cosineDistance"),a=HS(e,"predictions","cosineDistance");let o=null;null!=s&&(o=HS(s,"weights","cosineDistance")),tk(i.shape,a.shape,"Error in cosineDistance: ");const l=DI(1),u=zN(l,BN(PN(i,a),n,!0));return DT(u,o,r)}}),qS({hingeLoss_:function(t,e,n,s=FT.SUM_BY_NONZERO_WEIGHTS){let r=HS(t,"labels","hingeLoss");const i=HS(e,"predictions","hingeLoss");let a=null;null!=n&&(a=HS(n,"weights","hingeLoss")),tk(r.shape,i.shape,"Error in hingeLoss: ");const o=DI(1);r=zN(PN(DI(2),r),o);const l=xE(zN(o,PN(r,i)));return DT(l,a,s)}}),qS({huberLoss_:function(t,e,n,s=1,r=FT.SUM_BY_NONZERO_WEIGHTS){const i=HS(t,"labels","huberLoss"),a=HS(e,"predictions","huberLoss");let o=null;null!=n&&(o=HS(n,"weights","huberLoss")),tk(i.shape,a.shape,"Error in huberLoss: ");const l=DI(s),u=LI(zN(a,i)),c=KN(u,l),h=zN(u,c),d=MI(PN(DI(.5),sE(c)),PN(l,h));return DT(d,o,r)}}),qS({logLoss_:function(t,e,n,s=1e-7,r=FT.SUM_BY_NONZERO_WEIGHTS){const i=HS(t,"labels","logLoss"),a=HS(e,"predictions","logLoss");let o=null;null!=n&&(o=HS(n,"weights","logLoss")),tk(i.shape,a.shape,"Error in logLoss: ");const l=DI(1),u=DI(s),c=iE(PN(i,ON(MI(a,u)))),h=PN(zN(l,i),ON(MI(zN(l,a),u))),d=zN(c,h);return DT(d,o,r)}});const OT=qS({squaredDifference_:function(t,e){let n=HS(t,"a","squaredDifference"),s=HS(e,"b","squaredDifference");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("SquaredDifference",{a:n,b:s},{})}});qS({meanSquaredError_:function(t,e,n,s=FT.SUM_BY_NONZERO_WEIGHTS){const r=HS(t,"labels","meanSquaredError"),i=HS(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=HS(n,"weights","meanSquaredError")),tk(r.shape,i.shape,"Error in meanSquaredError: ");const o=OT(r,i);return DT(o,a,s)}});const LT=qS({log1p_:function(t){const e=HS(t,"x","log1p");return MS.runKernel("Log1p",{x:e})}});qS({sigmoidCrossEntropy_:function(t,e,n,s=0,r=FT.SUM_BY_NONZERO_WEIGHTS){let i=HS(t,"multiClassLabels","sigmoidCrossEntropy");const a=HS(e,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=HS(n,"weights","sigmoidCrossEntropy")),tk(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const t=DI(s),e=DI(1),n=DI(.5);i=MI(PN(i,zN(e,t)),PN(n,t))}const l=function(t,e){const n=HS(t,"labels","sigmoidCrossEntropyWithLogits"),s=HS(e,"logits","sigmoidCrossEntropyWithLogits");tk(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=xE(s),i=PN(s,n),a=LT(LN(iE(LI(s))));return MI(zN(r,i),a)}(i,a);return DT(l,o,r)}});const MT=qS({logSumExp_:function(t,e=null,n=!1){const s=HS(t,"x","logSumExp"),r=pk(e,s.shape),i=MN(s,r,!0),a=zN(s,i),o=LN(a),l=BN(o,r),u=ON(l),c=MI(tN(i,u.shape),u);if(n){const t=ZN(c.shape,r);return tN(c,t)}return c}});qS({softmaxCrossEntropy_:function(t,e,n,s=0,r=FT.SUM_BY_NONZERO_WEIGHTS){let i=HS(t,"onehotLabels","softmaxCrossEntropy");const a=HS(e,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=HS(n,"weights","softmaxCrossEntropy")),tk(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const t=DI(s),e=DI(1),n=DI(i.shape[1]);i=MI(PN(i,zN(e,t)),vN(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return FI((t,e,s)=>{const r=MT(e,[n],!0),i=zN(PC(e,"float32"),r);s([t,i]);const a=iE(PN(i,t));return{value:BN(a,[n]),gradFunc:(t,e)=>{const[s,r]=e,i=ZN(t.shape,[n]);return[PN(tN(t,i),zN(PC(s,"float32"),LN(r))),PN(tN(t,i),zN(LN(r),PC(s,"float32")))]}}})(t,e)}(i,a);return DT(l,o,r)}});const PT={bandPart:NT,gramSchmidt:AT,qr:RT};class zT extends OI{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=MS.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=MS.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:TI(()=>WE(s).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:TI(()=>WE(s).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;TI(()=>{const t=MI(PN(i,this.rho),PN(sE(r),1-this.rho)),e=PN(vN(RE(MI(a,this.epsilon)),RE(MI(i,this.epsilon))),r),n=MI(PN(a,this.rho),PN(sE(e),1-this.rho));i.assign(t),a.assign(n);const o=MI(PN(e,-this.learningRate),s);s.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(AI(this.accumulatedGrads.map(t=>t.variable)),AI(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}zT.className="Adadelta",II(zT);class BT extends OI{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=MS.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:TI(()=>TN(s.shape,this.initialAccumulatorValue).variable(t))}}const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedGrads[n].variable;TI(()=>{const t=MI(i,sE(r));i.assign(t);const e=MI(PN(vN(r,RE(MI(t,MS.backend.epsilon()))),-this.learningRate),s);s.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&AI(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}BT.className="Adagrad",II(BT);class VT extends OI{constructor(t,e,n,s=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],TI(()=>{this.accBeta1=DI(e).variable(),this.accBeta2=DI(n).variable()}),null==s&&(this.epsilon=MS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);TI(()=>{const n=zN(1,this.accBeta1),s=zN(1,this.accBeta2);e.forEach((e,r)=>{const i=MS.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:TI(()=>WE(i).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${e}/v`,variable:TI(()=>WE(i).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=MI(PN(o,this.beta1),PN(a,1-this.beta1)),c=MI(PN(l,this.beta2),PN(sE(a),1-this.beta2)),h=vN(u,n),d=vN(c,s);o.assign(u),l.assign(c);const p=MI(PN(vN(h,MI(RE(d),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(PN(this.accBeta1,this.beta1)),this.accBeta2.assign(PN(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&AI(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&AI(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),TI(()=>{this.accBeta1.assign(dE(this.beta1,this.iterations_+1)),this.accBeta2.assign(dE(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}VT.className="Adam",II(VT);class WT extends OI{constructor(t,e,n,s=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],TI(()=>{this.iteration=DI(0).variable(),this.accBeta1=DI(e).variable()}),null==s&&(this.epsilon=MS.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);TI(()=>{const n=zN(1,this.accBeta1),s=vN(-this.learningRate,MI(PN(this.iteration,this.decay),1));e.forEach((e,r)=>{const i=MS.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:WE(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${e}/v`,variable:WE(i).variable(!1)});const a=Array.isArray(t)?t[r].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=MI(PN(o,this.beta1),PN(a,1-this.beta1)),c=PN(l,this.beta2),h=LI(a),d=HN(c,h);o.assign(u),l.assign(d);const p=MI(PN(vN(s,n),vN(u,MI(d,this.epsilon))),i);i.assign(p)}),this.iteration.assign(MI(this.iteration,1)),this.accBeta1.assign(PN(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&AI(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&AI(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}WT.className="Adamax",II(WT);class UT extends OI{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const r=MS.registeredVariables[e];TI(()=>{const t=MI(PN(this.c,s),r);r.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=$I(DI(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}UT.className="SGD",II(UT);class jT extends UT{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=DI(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=MS.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:TI(()=>WE(s).variable(t))}}const r=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&TI(()=>{let t;const e=MI(PN(this.m,r),i);t=MI(PN(this.c,this.useNesterov?MI(i,PN(e,this.m)):e),s),r.assign(e),s.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&AI(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}jT.className="Momentum",II(jT);class HT extends OI{constructor(t,e=.9,n=0,s=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=MS.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const s=MS.registeredVariables[e];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:TI(()=>WE(s).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:TI(()=>WE(s).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:TI(()=>WE(s).variable(!1))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;TI(()=>{const t=MI(PN(i,this.decay),PN(sE(r),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,o=MI(PN(e,this.decay),PN(r,1-this.decay)),l=vN(PN(r,this.learningRate),RE(zN(t,MI(sE(o),this.epsilon)))),u=MI(PN(a,this.momentum),l);i.assign(t),e.assign(o),a.assign(u);const c=zN(s,u);s.assign(c)}else{const t=MI(PN(i,this.decay),PN(sE(r),1-this.decay)),e=MI(PN(a,this.momentum),vN(PN(r,this.learningRate),RE(MI(t,this.epsilon))));i.assign(t),a.assign(e);const n=zN(s,e);s.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&AI(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&AI(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&AI(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}HT.className="RMSProp",II(HT);class GT{static sgd(t){return new UT(t)}static momentum(t,e,n=!1){return new jT(t,e,n)}static rmsprop(t,e=.9,n=0,s=null,r=!1){return new HT(t,e,n,s,r)}static adam(t=.001,e=.9,n=.999,s=null){return new VT(t,e,n,s)}static adadelta(t=.001,e=.95,n=null){return new zT(t,e,n)}static adamax(t=.002,e=.9,n=.999,s=null,r=0){return new WT(t,e,n,s,r)}static adagrad(t,e=.1){return new BT(t,e)}}const qT={sgd:GT.sgd,momentum:GT.momentum,adadelta:GT.adadelta,adagrad:GT.adagrad,rmsprop:GT.rmsprop,adamax:GT.adamax,adam:GT.adam},KT="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function XT(){return new Promise(t=>KT(()=>t()))}function QT(t,e){const n=t[0].length;t.forEach((t,e)=>{J_(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),J_(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((t,r)=>{for(let i=0;i<n;i++)J_(i===e||t[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${r}] (${t}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function YT(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}const ZT=30;function JT(t){return t<=ZT?t:Ek(t,Math.floor(Math.sqrt(t)))}function tA(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function eA(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let s=0;s<n;++s)r=r.concat([t[s+1]/e[s],e[s]]);r=r.concat(t.slice(n+1))}return r}function nA(t,e,n=!0){const s=[];if(n){s.push(e);for(let n=e+1;n<t;++n)n<=2*e?(s.push(n),s.push(n-(e+1))):s.push(n)}else{const n=[],r=[];for(let s=1;s<t;++s)s>=2*e+1||s%2==1?r.push(s):n.push(s);s.push(...n),s.push(0),s.push(...r)}return s}function sA(t,e,n,s=!0){const r=[];r.push(s?t[0]/n:t[0]*n);for(let i=1;i<t.length;++i)r.push(i<=e.length?s?e[i-1]*t[i]:t[i]/e[i-1]:t[i]);return r}function rA(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function iA(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}function aA(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(0===sk(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let h=0;h<r.length-1;++h)a*=r[h];const o=t.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=o[h],l.push(o[h]);const c=[...Tk(t.shape).map(t=>t/u),1].slice(0,i);return[l,a,u,c]}function oA(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(i+" update.rank != "+(r+t.length-s));for(let a=0;a<r;++a)if(n.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==t[a+s])throw new Error(i+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${t[a+r]})`)}function lA(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}oA(n,e,t)}function uA(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=n.length;let a=1;for(let l=r;l<i;++l)a*=n[l];const o=r<1?1:r;return{sliceRank:r,numUpdates:sk(e.shape)/o,sliceSize:a,strides:[...Tk(n.slice(0,r)),1],outputSize:sk(n)}}const cA=1.7580993408473768,hA=1.0507009873554805,dA=.3275911,pA=.254829592,fA=-.284496736,mA=1.421413741,gA=-1.453152027,yA=1.061405429;function bA(...t){Bk().getBool("IS_TEST")||console.warn(...t)}function xA(...t){Bk().getBool("IS_TEST")||console.log(...t)}function vA(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function wA(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function _A(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function kA(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function SA(t,e){return{real:t[2*e],imag:t[2*e+1]}}function CA(t,e,n,s){t[2*s]=e,t[2*s+1]=n}function IA(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const i=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function NA(t,e,n){const s=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(s),imag:Math.sin(s)}}function EA(t,e,n=0){let s=[];if("number"==typeof e)J_(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{J_(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(-1!==r){const s=e.reduce((t,e)=>e>0?t+e:t);e[r]=t.shape[n]-s}J_(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function TA(t,e){let n,s=!1;for(t<=ZT?(n=t,s=!0):n=Ek(t,Math.floor(Math.sqrt(t)));!s;)n>e||n===t?s=!0:n=Ek(t,n+1);return n}function AA(t,e,n){const s=[],r=t.length;for(let i=0;i<r;i++)s.push(i!==e?t[i]:n);return s}function $A(t,e,n,s){const r=e.shape.length,i=t.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=t.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)o.push(t.shape[h]),l*=t.shape[h];for(let h=s;h<n;h++)o.push(t.shape[h]),u*=t.shape[h];for(let h=s;h<r;h++)o.push(e.shape[h]);for(let h=n+1;h<i;h++)o.push(t.shape[h]),c*=t.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function RA(t){try{return t.map(t=>rS(t))}catch(CY){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${CY}`)}}function FA(t){return t.map(t=>sS(t))}function DA(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const s=MC(t,"int32"),r=MC([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=s.indexToLoc(n[i]);r.values.set(e,i*t.length)}return r.toTensor()}const OA={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,JE(PC(n,"float32"),-1))}}},LA={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=sE(PC(n,"float32")),s=RE(zN(DI(1),e));return iE(vN(t,s))}}}},MA={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RE(zN(sE(PC(n,"float32")),1));return vN(t,e)}}}},PA={kernelName:"Add",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{let e=t;const s=kN(n.shape,r);return s.length>0&&(e=BN(e,s)),tN(e,n.shape)},b:()=>{let e=t;const n=kN(s.shape,r);return n.length>0&&(e=BN(e,n)),tN(e,s.shape)}}}},zA={kernelName:"ArgMax",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>WE(n)}}},BA={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>WE(n)}}},VA={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,RE(zN(DI(1),sE(PC(n,"float32")))))}}},WA={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RE(MI(DI(1),sE(PC(n,"float32"))));return vN(t,e)}}}},UA={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{const e=MI(sE(n),sE(s));let i=PN(t,vN(s,e));const a=kN(n.shape,r);return a.length>0&&(i=BN(i,a)),tN(i,n.shape)},b:()=>{const e=MI(sE(n),sE(s));let i=iE(PN(t,vN(n,e)));const a=kN(s.shape,r);return a.length>0&&(i=BN(i,a)),tN(i,s.shape)}}}},jA={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,MI(sE(PC(n,"float32")),1))}}},HA={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,zN(DI(1),sE(PC(n,"float32"))))}}},GA=qS({avgPool3dGrad_:function(t,e,n,s,r,i){const a=HS(t,"dy","avgPool3dGrad"),o=HS(e,"input","avgPool3dGrad");let l=a,u=o,c=!1;4===o.rank&&(c=!0,l=tN(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=tN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J_(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),J_(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=i&&J_(ak(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=MS.runKernel("AvgPool3DGrad",{dy:l,input:u},{filterSize:n,strides:s,pad:r,dimRoundingMode:i});return c?tN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),qA={kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=n;return{x:()=>GA(t,s,r,i,a,o)}}},KA=qS({avgPoolGrad_:function(t,e,n,s,r){const i=HS(t,"dy","avgPoolGrad"),a=HS(e,"input","avgPoolGrad");J_(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,l=i,u=!1;3===a.rank&&(u=!0,o=tN(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=tN(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J_(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),J_(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c=MS.runKernel("AvgPoolGrad",{dy:l,input:o},{filterSize:n,strides:s,pad:r});return u?tN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),XA={kernelName:"AvgPool",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=n;return{x:()=>KA(t,s,r,i,a)}}},QA={kernelName:"BatchMatMul",inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:i,transposeB:a}=n;return i||a?!i&&a?{a:()=>lT(t,r,!1,!1),b:()=>lT(t,s,!0,!1)}:i&&!a?{a:()=>lT(r,t,!1,!0),b:()=>lT(s,t,!1,!1)}:{a:()=>lT(r,t,!0,!0),b:()=>lT(t,s,!0,!0)}:{a:()=>lT(t,r,!1,!0),b:()=>lT(s,t,!0,!1)}}},YA=qS({spaceToBatchND_:function(t,e,n){const s=HS(t,"x","spaceToBatchND");return J_(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),J_(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),J_(s.shape.reduce((t,s,r)=>r>0&&r<=e.length?t&&(s+n[r-1][0]+n[r-1][1])%e[r-1]==0:t,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),MS.runKernel("SpaceToBatchND",{x:s},{blockShape:e,paddings:n})}}),ZA={kernelName:"BatchToSpaceND",gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>YA(t,s,r)}}},JA={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const s=n.inputShape,r=n.shape,i=Array.from(r);for(let o=s.length-1;o>=0;o--)if(s[o]===r[o])i[o]=1;else if(1!==s[o])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${r}].`);const a=[];for(let o=0;o<i.length;o++)i[o]>1&&a.push(o);return{x:()=>BN(t,a,!0)}}},t$={kernelName:"Ceil",gradFunc:t=>({x:()=>WE(t)})},e$={kernelName:"ClipByValue",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>VE(WN(FN(s,r),CT(s,i)),t,WE(t))}}},n$={kernelName:"ComplexAbs",inputsToSave:["x"],gradFunc:OA.gradFunc},s$={kernelName:"Concat",saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(t=>t.shape),{axis:r}=n,i=pk(r,e[0].shape)[0],a=s.map(t=>t[i]);return $E(t,a,i).map(t=>()=>t)}},r$={kernelName:"Conv2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:l}=n;return J_(YI(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>mN(s.shape,t,r,a,o,l),filter:()=>YE(s,t,r.shape,a,o,l)}}},i$={kernelName:"Conv2DBackpropInput",inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>pN(t,r,i,a,o,1,l),filter:()=>YE(t,s,r.shape,i,a,o,l)}}},a$=qS({conv3DBackpropFilter_:function(t,e,n,s,r){let i=t;4===t.rank&&(i=tN(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;return 4===a.rank&&(a=tN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),J_(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),J_(5===a.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),J_(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),J_(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),J_(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`),MS.runKernel("Conv3DBackpropFilterV2",{x:i,dy:a},{strides:s,pad:r,filterShape:n})}}),o$=qS({conv3DBackpropInput_:function(t,e,n,s,r){J_(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,a=e,o=!1;4===e.rank&&(o=!0,a=tN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=a.shape[4];J_(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),J_(5===a.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),J_(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),J_(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),J_(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=MS.runKernel("Conv3DBackpropInputV2",{dy:a,filter:n},{pad:r,strides:s,inputShape:i});return o?tN(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),l$={kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i}=n;J_(YI(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>o$(a.shape,t,o,r,i),filter:()=>a$(a,t,o.shape,r,i)}}},u$=qS({sin_:function(t){const e=HS(t,"x","sin");return MS.runKernel("Sin",{x:e})}}),c$={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(iE(u$(PC(n,"float32"))),t)}}},h$=qS({sinh_:function(t){const e=HS(t,"x","sinh");return MS.runKernel("Sinh",{x:e})}}),d$={kernelName:"Cosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(h$(PC(n,"float32")),t)}}},p$=qS({cumsum_:function(t,e=0,n=!1,s=!1){const r=HS(t,"x","cumsum");return MS.runKernel("Cumsum",{x:r},{axis:e,exclusive:n,reverse:s})}}),f$={kernelName:"Cumsum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=n;return{x:()=>{const e=tE([r],s.rank);let n=p$(t,r,i,!a);return null!=e&&(n=UE(n,e)),n}}}},m$={kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=n,o=null==s?[1,1]:s;J_(YI(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=e;return J_(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),J_(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),J_(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),J_(ZI(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),null!=a&&J_(ak(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),{x:()=>aT(l.shape,t,u,r,i,s,a),filter:()=>iT(l,t,u.shape,r,i,s,a)}}},g$={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,i={x:s,filter:r,dy:t},a={x:s,filter:r,dy:t};return{x:()=>MS.runKernel("Dilation2DBackpropInput",i,n),filter:()=>MS.runKernel("Dilation2DBackpropFilter",a,n)}}},y$={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>MS.runKernel("EluGrad",s)}}},b$={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=PN(LN(iE(sE(n))),2/Math.sqrt(Math.PI));return{x:()=>PN(t,s)}}},x$={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,n)}}},v$={kernelName:"ExpandDims",inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>tN(t,n.shape)}}},w$={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,LN(n))}}},_$={kernelName:"Floor",gradFunc:t=>({x:()=>WE(t)})},k$={kernelName:"FloorDiv",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{const e=vN(t,PC(s,"float32")),i=kN(n.shape,r);return i.length>0?tN(BN(e,i),n.shape):e},b:()=>{let e=PN(t,PC(n,"float32"));const i=kN(s.shape,r);i.length>0&&(e=tN(BN(e,i),s.shape));const a=sE(s);return iE(vN(e,PC(a,"float32")))}}}},S$=qS({rsqrt_:function(t){const e=HS(t,"x","rsqrt");return MS.runKernel("Rsqrt",{x:e})}}),C$={kernelName:"FusedBatchNorm",inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,i,a,o]=e,l=null==o?DI(1):o,u=kN(i.shape,r.shape),c=[];if(1===i.rank){for(let t=0;t<r.shape.length-1;++t)c.push(r.shape[t]);c.push(1)}const h=zN(r,i),d=PN(t,l),p=S$(MI(a,DI(s))),f=PN(PN(PN(p,p),p),DI(-.5));return{x:()=>tN(PN(PN(t,1===i.rank?NN(tN(p,[1,1,1,i.shape[0]]),c):p),l),r.shape),mean:()=>{let t=PN(PN(p,DI(-1)),d);return 1===i.rank&&(t=BN(t,u)),tN(t,i.shape)},variance:()=>{let t=PN(PN(f,h),d);return 1===i.rank&&(t=BN(t,u)),tN(t,i.shape)},scale:()=>{const e=PN(h,p);let n=PN(t,e);return 1===i.rank&&(n=BN(n,u)),tN(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=BN(e,u)),tN(e,i.shape)}}}},I$=qS({unsortedSegmentSum_:function(t,e,n){const s=HS(t,"x","unsortedSegmentSum"),r=HS(e,"segmentIds","unsortedSegmentSum","int32");return J_(ak(n),()=>"numSegments must be of dtype int"),MS.runKernel("UnsortedSegmentSum",{x:s,segmentIds:r},{numSegments:n})}}),N$={kernelName:"GatherV2",inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:i}=n,a=pk(i,s.shape)[0];return{x:()=>{const e=s.shape,n=r.size,o=e.slice(0,a),l=o.length,u=e.slice(i,e.length).slice(1),c=u.length,h=E$(0,l),d=E$(l+1,l+1+c),p=T$([o,[n],u]),f=tN(t,p),m=tN(r,[n]),g=T$([[l],h,d]),y=UE(f,g);let b=I$(y,m,s.shape[a]);const x=eE(g);return b=UE(b,x),b},indices:()=>r}}};function E$(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function T$(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}const A$={kernelName:"GreaterEqual",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>WE(n),b:()=>WE(s)}}},$$={kernelName:"Identity",gradFunc:t=>({x:()=>PC(t,"float32")})},R$={kernelName:"IsFinite",gradFunc:t=>({x:()=>WE(t)})},F$={kernelName:"IsInf",gradFunc:t=>({x:()=>WE(t)})},D$={kernelName:"IsNan",gradFunc:t=>({x:()=>WE(t)})},O$={kernelName:"LeakyRelu",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,i=RN(s,0);return{x:()=>VE(i,t,PN(t,r))}}},L$={kernelName:"Log1p",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,MI(n,1))}}},M$={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,PC(n,"float32"))}}},P$={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const e=LN(s);return zN(t,PN(BN(t,r,!0),e))}}}},z$=qS({localResponseNormalizationBackprop_:function(t,e,n,s=5,r=1,i=1,a=.5){return MS.runKernel("LRNGrad",{x:t,y:e,dy:n},{depthRadius:s,bias:r,alpha:i,beta:a})}}),B$={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:l}=n;return{x:()=>z$(s,r,t,i,a,o,l)}}};function V$(t,e,n,s){return e.rank<n.rank&&(e=tN(e,ZN(e.shape,s))),t.rank<n.rank&&(t=tN(t,ZN(t.shape,s))),{x:()=>PN(t,PC(CN(n,e),t.dtype))}}const W$={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,i=e[0],a=V$(t,e[1],i,pk(r,i.shape));return{x:()=>a.x()}}},U$=qS({less_:function(t,e){let n=HS(t,"a","less"),s=HS(e,"b","less");return[n,s]=ES(n,s),SN(n.shape,s.shape),MS.runKernel("Less",{a:n,b:s})}}),j$={kernelName:"Maximum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>PN(t,PC(FN(n,s),"float32")),b:()=>PN(t,PC(U$(n,s),"float32"))}}},H$=qS({maxPool3dGrad_:function(t,e,n,s,r,i,a){const o=HS(t,"dy","maxPool3dGrad"),l=HS(e,"input","maxPool3dGrad"),u=HS(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=tN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=tN(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=tN(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),J_(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),J_(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),J_(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=a&&J_(ak(i),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`);const f=MS.runKernel("MaxPool3DGrad",{dy:c,input:h,output:d},{filterSize:s,strides:r,pad:i,dimRoundingMode:a});return p?tN(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),G$={kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>H$(t,s,r,i,a,o,l)}}},q$=qS({maxPoolGrad_:function(t,e,n,s,r,i,a){const o=HS(t,"dy","maxPoolGrad"),l=HS(e,"input","maxPoolGrad"),u=HS(n,"output","maxPoolGrad");return J_(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),J_(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),J_(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=a&&J_(ak(i),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),MS.runKernel("MaxPoolGrad",{dy:o,input:l,output:u},{filterSize:s,strides:r,pad:i,dimRoundingMode:a})}}),K$={kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=n;return{x:()=>q$(t,s,r,i,a,o)}}},X$={kernelName:"Mean",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,i=pk(r,s.shape),a=sk(YN(s.shape,i)[1]);return{x:()=>{const e=s.shape.slice();i.forEach(t=>{e[t]=1});const n=tN(t,e);return vN(PN(n,uE(s.shape,"float32")),a)}}}},Q$={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[i,a]=e,o=V$(t,a,i,pk(r,i.shape));return{x:()=>o.x()}}},Y$={kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>PN(t,PC(CT(n,s),"float32")),b:()=>PN(t,PC(RN(n,s),"float32"))}}},Z$={kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>SE(t,i,s.shape)}}},J$={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{const e=kN(n.shape,r);return e.length>0?tN(BN(t,e),n.shape):t},b:()=>{const e=PN(t,iE(AN(vN(n,s)))),i=kN(s.shape,r);return i.length>0?tN(BN(e,i),s.shape):e}}}},tR={kernelName:"Multiply",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{const e=PN(t,PC(s,"float32")),i=kN(n.shape,r);return i.length>0?tN(BN(e,i),n.shape):e},b:()=>{const e=PN(t,PC(n,"float32")),i=kN(s.shape,r);return i.length>0?tN(BN(e,i),s.shape):e}}}},eR={kernelName:"Neg",gradFunc:t=>({x:()=>iE(t)})},nR={kernelName:"OneHot",inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>lE(n.shape,"float32")}}},sR={kernelName:"OnesLike",gradFunc:t=>({x:()=>WE(t)})},rR={kernelName:"Pack",saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return zE(t,s).map(t=>()=>t)}},iR={kernelName:"PadV2",inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,i=r.map(t=>t[0]);return{x:()=>SE(t,i,s.shape)}}},aR={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,i=n,a=s,o=SN(i.shape,a.shape);return{a:()=>{const e=PC(a,"float32");let n=PN(t,PN(e,dE(i,zN(e,DI(1)))));const s=kN(i.shape,o);return s.length>0&&(n=BN(n,s)),tN(n,i.shape)},b:()=>{const e=RN(i,0),n=VE(e,ON(i),WE(i));let s=PN(t,PN(r,n));const l=kN(a.shape,o);return l.length>0&&(s=BN(s,l)),tN(s,a.shape)}}}},oR={kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=RN(n,0);return{x:()=>VE(r,t,PN(t,s)),alpha:()=>{let e=VE(r,WE(t),PN(t,n));const i=kN(s.shape,t.shape);return i.length>0&&(e=BN(e,i)),tN(e,s.shape)}}}},lR={kernelName:"RealDiv",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{const e=vN(t,PC(s,"float32")),i=kN(n.shape,r);return i.length>0?tN(BN(e,i),n.shape):e},b:()=>{let e=PN(t,PC(n,"float32"));const i=kN(s.shape,r);i.length>0&&(e=tN(BN(e,i),s.shape));const a=sE(s);return iE(vN(e,PC(a,"float32")))}}}},uR={kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,iE(sE(n)))}}},cR={kernelName:"Relu6",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=PN(CT(n,6),JE(n));return{x:()=>PN(t,PC(s,"float32"))}}},hR={kernelName:"Relu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,PC(JE(n),"float32"))}}},dR={kernelName:"Reshape",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tN(t,n.shape)}}},pR={kernelName:"ResizeBilinear",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>MS.runKernel("ResizeBilinearGrad",r,n)}}},fR={kernelName:"ResizeNearestNeighbor",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>MS.runKernel("ResizeNearestNeighborGrad",r,n)}}},mR={kernelName:"Reverse",gradFunc:(t,e,n)=>{const{dims:s}=n,r=pk(s,t.shape);return{x:()=>vE(t,r)}}},gR={kernelName:"Round",gradFunc:t=>({x:()=>WE(t)})},yR={kernelName:"Rsqrt",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>iE(vN(t,PN(dE(n,1.5),2)))}}},bR=qS({logicalNot_:function(t){const e=HS(t,"x","logicalNot","bool");return MS.runKernel("LogicalNot",{x:e})}}),xR={kernelName:"Select",inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>PC(WE(n),"float32"),t:()=>PN(t,PC(n,t.dtype)),e:()=>PN(t,PC(bR(n),t.dtype))}}},vR={kernelName:"Selu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RN(n,DI(0)),s=DI(cA),r=DI(hA),i=PN(t,r),a=PN(PN(t,s),LN(PC(n,"float32")));return VE(e,i,a)}}}},wR={kernelName:"Sigmoid",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,PN(n,zN(DI(1),n)))}}},_R={kernelName:"Sign",gradFunc:t=>({x:()=>WE(t)})},kR=qS({cos_:function(t){const e=HS(t,"x","cos");return MS.runKernel("Cos",{x:e})}}),SR={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(kR(PC(n,"float32")),t)}}},CR=qS({cosh_:function(t){const e=HS(t,"x","cosh");return MS.runKernel("Cosh",{x:e})}}),IR={kernelName:"Sinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(CR(PC(n,"float32")),t)}}},NR={kernelName:"Slice",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:i}=n,a=s.shape,[o,l]=_I(s,r,i),u=[];for(let c=0;c<t.rank;c++)u.push([o[c],a[c]-o[c]-l[c]]);return{x:()=>hE(t,u)}}},ER={kernelName:"Softmax",outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,i=PN(t,s);return{logits:()=>zN(i,PN(BN(i,[r],!0),s))}}},TR={kernelName:"Softplus",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,kE(n))}}},AR=qS({batchToSpaceND_:function(t,e,n){const s=HS(t,"x","batchToSpaceND"),r=e.reduce((t,e)=>t*e);return J_(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),J_(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),J_(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`),MS.runKernel("BatchToSpaceND",{x:s},{blockShape:e,crops:n})}}),$R={kernelName:"SpaceToBatchND",gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>AR(t,s,r)}}},RR={kernelName:"SplitV",gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>lN(t,s)}}},FR=[OA,LA,MA,PA,{kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,s)=>{n[s]=()=>t.clone()}),n}},zA,BA,VA,WA,UA,jA,HA,qA,XA,QA,ZA,JA,{kernelName:"Cast",gradFunc:t=>({x:()=>t.clone()})},t$,e$,n$,s$,i$,r$,l$,c$,d$,f$,m$,g$,lR,y$,b$,x$,v$,w$,k$,_$,C$,N$,A$,$$,R$,F$,D$,O$,L$,M$,P$,B$,W$,W$,j$,G$,K$,X$,Q$,Y$,Z$,J$,tR,eR,nR,sR,rR,iR,iR,aR,oR,uR,cR,hR,dR,pR,fR,mR,gR,yR,xR,vR,wR,_R,SR,IR,NR,ER,TR,$R,$R,RR,RR,{kernelName:"Sqrt",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,PN(RE(PC(n,"float32")),2))}}},{kernelName:"SquaredDifference",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=DI(2);return{a:()=>PN(t,PN(r,zN(n,s))),b:()=>PN(t,PN(r,zN(s,n)))}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(t,PN(PC(n,"float32"),2))}}},{kernelName:"Step",gradFunc:t=>({x:()=>WE(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=SN(n.shape,s.shape);return{a:()=>{let e=t;const s=kN(n.shape,r);return s.length>0&&(e=BN(e,s)),tN(e,n.shape)},b:()=>{let e=t;const n=kN(s.shape,r);return n.length>0&&(e=BN(e,n)),tN(iE(e),s.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:i}=n;pk(i,s.shape).forEach(t=>{r[t]=1});const a=tN(t,r),o=PN(a,uE(s.shape,"float32"));return{x:()=>o}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>vN(t,sE(kR(n)))}}},{kernelName:"Tanh",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>PN(zN(DI(1),sE(n)),t)}}},{kernelName:"Tile",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let e=WE(s);if(1===s.rank)for(let n=0;n<r[0];++n)e=MI(e,SE(t,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)e=MI(e,SE(t,[n*s.shape[0],i*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)e=MI(e,SE(t,[n*s.shape[0],i*s.shape[1],a*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)for(let o=0;o<r[3];++o)e=MI(e,SE(t,[n*s.shape[0],i*s.shape[1],a*s.shape[2],o*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return e}}}},{kernelName:"Transpose",gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,i=eE(r);return{x:()=>UE(t,i)}}},{kernelName:"Unpack",gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>DE(t,r)}}},{kernelName:"UnsortedSegmentSum",inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=HN(e,WE(e)),s=$N(t,n);let r=FN(e,DI(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=IN(r,o+1);r=WN(r,uE(s.shape,"bool"));const a=WE(s);return VE(r,s,a)}(t,n)}}},{kernelName:"ZerosLike",gradFunc:t=>({x:()=>WE(t)})}];for(const IY of FR)Yk(IY);bS().prototype.abs=function(){return this.throwIfDisposed(),LI(this)};const DR=qS({acos_:function(t){const e=HS(t,"x","acos");return MS.runKernel("Acos",{x:e})}});bS().prototype.acos=function(){return this.throwIfDisposed(),DR(this)};const OR=qS({acosh_:function(t){const e=HS(t,"x","acosh");return MS.runKernel("Acosh",{x:e})}});bS().prototype.acosh=function(){return this.throwIfDisposed(),OR(this)},bS().prototype.add=function(t){return this.throwIfDisposed(),MI(this,t)},bS().prototype.all=function(t,e){return this.throwIfDisposed(),PI(this,t,e)},bS().prototype.any=function(t,e){return this.throwIfDisposed(),zI(this,t,e)},bS().prototype.argMax=function(t){return this.throwIfDisposed(),BI(this,t)};const LR=qS({argMin_:function(t,e=0){const n=HS(t,"x","argMin");return MS.runKernel("ArgMin",{x:n},{axis:e})}});bS().prototype.argMin=function(t){return this.throwIfDisposed(),LR(this,t)},bS().prototype.asScalar=function(){return this.throwIfDisposed(),J_(1===this.size,()=>"The array must have only 1 element."),tN(this,[])},bS().prototype.asType=function(t){return this.throwIfDisposed(),PC(this,t)},bS().prototype.as1D=function(){return this.throwIfDisposed(),tN(this,[this.size])},bS().prototype.as2D=function(t,e){return this.throwIfDisposed(),tN(this,[t,e])},bS().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),tN(this,[t,e,n])},bS().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),tN(this,[t,e,n,s])},bS().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),tN(this,[t,e,n,s,r])};const MR=qS({asin_:function(t){const e=HS(t,"x","asin");return MS.runKernel("Asin",{x:e})}});bS().prototype.asin=function(){return this.throwIfDisposed(),MR(this)};const PR=qS({asinh_:function(t){const e=HS(t,"x","asinh");return MS.runKernel("Asinh",{x:e})}});bS().prototype.asinh=function(){return this.throwIfDisposed(),PR(this)};const zR=qS({atan_:function(t){const e=HS(t,"x","atan");return MS.runKernel("Atan",{x:e})}});bS().prototype.atan=function(){return this.throwIfDisposed(),zR(this)};const BR=qS({atan2_:function(t,e){let n=HS(t,"a","atan2"),s=HS(e,"b","atan2");return[n,s]=ES(n,s),MS.runKernel("Atan2",{a:n,b:s})}});bS().prototype.atan2=function(t){return this.throwIfDisposed(),BR(this,t)};const VR=qS({atanh_:function(t){const e=HS(t,"x","atanh");return MS.runKernel("Atanh",{x:e})}});bS().prototype.atanh=function(){return this.throwIfDisposed(),VR(this)},bS().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),eN(this,t,e,n,s)},bS().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),AR(this,t,e)},bS().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),sN(this,t,e,n,s,r)},bS().prototype.broadcastTo=function(t){return this.throwIfDisposed(),BE(this,t)},bS().prototype.cast=function(t){return this.throwIfDisposed(),PC(this,t)};const WR=qS({ceil_:function(t){const e=HS(t,"x","ceil");return MS.runKernel("Ceil",{x:e})}});bS().prototype.ceil=function(){return this.throwIfDisposed(),WR(this)},bS().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),oN(this,t,e)},bS().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof yS&&(t=[t]),lN([this,...t],e)},bS().prototype.conv1d=function(t,e,n,s,r,i){return this.throwIfDisposed(),fN(this,t,e,n,s,r,i)},bS().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),gN(this,t,e,n,s,r)},bS().prototype.conv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),pN(this,t,e,n,s,r,i)},bS().prototype.cos=function(){return this.throwIfDisposed(),kR(this)},bS().prototype.cosh=function(){return this.throwIfDisposed(),CR(this)},bS().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),p$(this,t,e,n)};const UR=qS({depthToSpace_:function(t,e,n="NHWC"){const s=HS(t,"x","depthToSpace"),r="NHWC"===n?s.shape[1]:s.shape[2],i="NHWC"===n?s.shape[2]:s.shape[3],a="NHWC"===n?s.shape[3]:s.shape[1];return J_(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${e}  for depthToSpace with input shape\n    ${s.shape}`),J_(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${s.shape}`),J_(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`),MS.runKernel("DepthToSpace",{x:s},{blockSize:e,dataFormat:n})}});bS().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),UR(this,t,e)},bS().prototype.depthwiseConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),bN(this,t,e,n,s,r,i)};const jR=qS({dilation2d_:function(t,e,n,s,r=[1,1],i="NHWC"){const a=HS(t,"x","dilation2d"),o=HS(e,"filter","dilation2d");J_(3===a.rank||4===a.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),J_(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),J_("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=a,u=!1;3===a.rank&&(l=tN(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c=MS.runKernel("Dilation2D",{x:l,filter:o},{strides:n,pad:s,dilations:r});return u?tN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});bS().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),jR(this,t,e,n,s,r)};const HR=qS({divNoNan_:function(t,e){let n=HS(t,"a","div"),s=HS(e,"b","div");[n,s]=ES(n,s);const r=vN(n,s),i=WE(r),a=CN(s,i);return VE(a,i,r)}});bS().prototype.divNoNan=function(t){return this.throwIfDisposed(),HR(this,t)},bS().prototype.div=function(t){return this.throwIfDisposed(),vN(this,t)};const GR=qS({dot_:function(t,e){const n=HS(t,"t1","dot"),s=HS(e,"t2","dot");J_(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],i=1===s.rank?s.size:s.shape[0];if(J_(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),1===n.rank&&1===s.rank){const t=tN(n,[1,-1]),e=tN(s,[-1,1]),r=lT(t,e);return tN(r,[])}if(1===n.rank&&2===s.rank){const t=tN(n,[1,-1]),e=tN(s,[s.shape[0],s.shape[1]]),r=lT(t,e);return tN(r,[r.size])}if(2===n.rank&&1===s.rank){const t=tN(s,[-1,1]),e=lT(n,t);return tN(e,[e.size])}{const t=tN(s,[s.shape[0],s.shape[1]]);return lT(n,t)}}});bS().prototype.dot=function(t){return this.throwIfDisposed(),GR(this,t)},bS().prototype.elu=function(){return this.throwIfDisposed(),wN(this)},bS().prototype.equal=function(t){return this.throwIfDisposed(),CN(this,t)};const qR=qS({erf_:function(t){let e=HS(t,"x","erf");return J_("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=PC(e,"float32")),MS.runKernel("Erf",{x:e})}});bS().prototype.erf=function(){return this.throwIfDisposed(),qR(this)},bS().prototype.exp=function(){return this.throwIfDisposed(),LN(this)},bS().prototype.expandDims=function(t){return this.throwIfDisposed(),IN(this,t)};const KR=qS({expm1_:function(t){const e=HS(t,"x","expm1");return MS.runKernel("Expm1",{x:e})}});bS().prototype.expm1=function(){return this.throwIfDisposed(),KR(this)},bS().prototype.fft=function(){return this.throwIfDisposed(),qE(this)},bS().prototype.flatten=function(){return this.throwIfDisposed(),tN(this,[this.size])},bS().prototype.floor=function(){return this.throwIfDisposed(),AN(this)},bS().prototype.floorDiv=function(t){return this.throwIfDisposed(),xN(this,t)},bS().prototype.gather=function(t,e){return this.throwIfDisposed(),$N(this,t,e)},bS().prototype.greaterEqual=function(t){return this.throwIfDisposed(),FN(this,t)},bS().prototype.greater=function(t){return this.throwIfDisposed(),RN(this,t)},bS().prototype.ifft=function(){return this.throwIfDisposed(),XE(this)},bS().prototype.irfft=function(){return this.throwIfDisposed(),QE(this)};const XR=qS({isFinite_:function(t){const e=HS(t,"x","isFinite");return MS.runKernel("IsFinite",{x:e})}});bS().prototype.isFinite=function(){return this.throwIfDisposed(),XR(this)};const QR=qS({isInf_:function(t){const e=HS(t,"x","isInf");return MS.runKernel("IsInf",{x:e})}});bS().prototype.isInf=function(){return this.throwIfDisposed(),QR(this)};const YR=qS({isNaN_:function(t){const e=HS(t,"x","isNaN");return MS.runKernel("IsNan",{x:e})}});bS().prototype.isNaN=function(){return this.throwIfDisposed(),YR(this)},bS().prototype.leakyRelu=function(t){return this.throwIfDisposed(),DN(this,t)},bS().prototype.lessEqual=function(t){return this.throwIfDisposed(),CT(this,t)},bS().prototype.less=function(t){return this.throwIfDisposed(),U$(this,t)};const ZR=qS({localResponseNormalization_:function(t,e=5,n=1,s=1,r=.5){const i=HS(t,"x","localResponseNormalization");J_(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),J_(ak(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;3===i.rank&&(o=!0,a=tN(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l=MS.runKernel("LRN",{x:a},{depthRadius:e,bias:n,alpha:s,beta:r});return o?tN(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});bS().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),ZR(this,t,e,n,s)};const JR=qS({logSigmoid_:function(t){const e=HS(t,"x","logSigmoid");return FI(t=>({value:iE(AE(iE(t))),gradFunc:e=>PN(e,kE(iE(t)))}))(e)}});bS().prototype.logSigmoid=function(){return this.throwIfDisposed(),JR(this)},bS().prototype.logSoftmax=function(t){return this.throwIfDisposed(),VN(this,t)},bS().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),MT(this,t,e)},bS().prototype.log=function(){return this.throwIfDisposed(),ON(this)},bS().prototype.log1p=function(){return this.throwIfDisposed(),LT(this)},bS().prototype.logicalAnd=function(t){return this.throwIfDisposed(),WN(this,t)},bS().prototype.logicalNot=function(){return this.throwIfDisposed(),bR(this)};const tF=qS({logicalOr_:function(t,e){const n=HS(t,"a","logicalOr","bool"),s=HS(e,"b","logicalOr","bool");return SN(n.shape,s.shape),MS.runKernel("LogicalOr",{a:n,b:s})}});bS().prototype.logicalOr=function(t){return this.throwIfDisposed(),tF(this,t)};const eF=qS({logicalXor_:function(t,e){const n=HS(t,"a","logicalXor","bool"),s=HS(e,"b","logicalXor","bool");return SN(n.shape,s.shape),WN(tF(t,e),bR(WN(t,e)))}});bS().prototype.logicalXor=function(t){return this.throwIfDisposed(),eF(this,t)},bS().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),lT(this,t,e,n)},bS().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),UN(this,t,e,n,s)},bS().prototype.max=function(t,e){return this.throwIfDisposed(),MN(this,t,e)},bS().prototype.maximum=function(t){return this.throwIfDisposed(),HN(this,t)},bS().prototype.mean=function(t,e){return this.throwIfDisposed(),GN(this,t,e)},bS().prototype.min=function(t,e){return this.throwIfDisposed(),qN(this,t,e)},bS().prototype.minimum=function(t){return this.throwIfDisposed(),KN(this,t)};const nF=qS({mirrorPad_:function(t,e,n){J_("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=HS(t,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J_(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r="reflect"===n?1:0;for(let i=0;i<s.rank;i++)J_(2===e[i].length,()=>"Invalid number of paddings. Must be length of 2 each."),J_(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);return MS.runKernel("MirrorPad",{x:s},{paddings:e,mode:n})}});bS().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),nF(this,t,e)};const sF=qS({mod_:function(t,e){let n=HS(t,"a","mod"),s=HS(e,"b","mod");return[n,s]=ES(n,s),MS.runKernel("Mod",{a:n,b:s})}});bS().prototype.mod=function(t){return this.throwIfDisposed(),sF(this,t)},bS().prototype.mul=function(t){return this.throwIfDisposed(),PN(this,t)},bS().prototype.neg=function(){return this.throwIfDisposed(),iE(this)},bS().prototype.norm=function(t,e,n){return this.throwIfDisposed(),TT(this,t,e,n)},bS().prototype.notEqual=function(t){return this.throwIfDisposed(),aE(this,t)},bS().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),oE(this,t,e,n)},bS().prototype.onesLike=function(){return this.throwIfDisposed(),cE(this)},bS().prototype.pad=function(t,e){return this.throwIfDisposed(),hE(this,t,e)};const rF=qS({pool_:function(t,e,n,s,r,i){null==r&&(r=[1,1]),null==i&&(i=1),0===s&&(s="valid");const a=HS(t,"x","maxPool");let o=a,l=!1;3===a.rank&&(l=!0,o=tN(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J_(ZI(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const u=WI(o.shape,e,i,r,s),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===s?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),s=n.map(t=>Math.floor(t/2)),r=n.map((t,e)=>t-s[e]);return n.map((t,e)=>[s[e],r[e]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(t,e,n){const s=n.map(t=>t[0]),r=n.map(t=>t[1]),i=t.concat(s,r),a=e.map((t,e)=>(t-i[e]%t)%t),o=r.map((t,e)=>t+a[e]);return[e.map((t,e)=>[s[e],o[e]]),e.map((t,e)=>[0,a[e]])]}([u.inHeight,u.inWidth],c,h),m=d?s:"valid",g=d?o:YA(o,c,p),y=("avg"===n?()=>eN(g,e,i,m):()=>UN(g,e,i,m))(),b=d?y:AR(y,c,f);return l?tN(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});bS().prototype.pool=function(t,e,n,s,r){return this.throwIfDisposed(),rF(this,t,e,n,s,r)},bS().prototype.pow=function(t){return this.throwIfDisposed(),dE(this,t)},bS().prototype.prelu=function(t){return this.throwIfDisposed(),pE(this,t)};const iF=qS({prod_:function(t,e=null,n=!1){let s=HS(t,"x","prod");return"bool"===s.dtype&&(s=PC(s,"int32")),MS.runKernel("Prod",{x:s},{axis:e,keepDims:n})}});bS().prototype.prod=function(t,e){return this.throwIfDisposed(),iF(this,t,e)};const aF=qS({reciprocal_:function(t){const e=HS(t,"x","reciprocal");return MS.runKernel("Reciprocal",{x:e})}});bS().prototype.reciprocal=function(){return this.throwIfDisposed(),aF(this)},bS().prototype.relu=function(){return this.throwIfDisposed(),xE(this)},bS().prototype.relu6=function(){return this.throwIfDisposed(),ZE(this)},bS().prototype.reshapeAs=function(t){return this.throwIfDisposed(),tN(this,t.shape)},bS().prototype.reshape=function(t){return this.throwIfDisposed(),tN(this,t)},bS().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),kT(this,t,e,n)},bS().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),ST(this,t,e,n)},bS().prototype.reverse=function(t){return this.throwIfDisposed(),vE(this,t)},bS().prototype.rfft=function(){return this.throwIfDisposed(),KE(this)};const oF=qS({round_:function(t){const e=HS(t,"x","round");return MS.runKernel("Round",{x:e})}});bS().prototype.round=function(){return this.throwIfDisposed(),oF(this)},bS().prototype.rsqrt=function(){return this.throwIfDisposed(),S$(this)},bS().prototype.selu=function(){return this.throwIfDisposed(),wE(this)},bS().prototype.separableConv2d=function(t,e,n,s,r,i){return this.throwIfDisposed(),_E(this,t,e,n,s,r,i)},bS().prototype.sigmoid=function(){return this.throwIfDisposed(),kE(this)};const lF=qS({sign_:function(t){const e=HS(t,"x","sign");return MS.runKernel("Sign",{x:e})}});bS().prototype.sign=function(){return this.throwIfDisposed(),lF(this)},bS().prototype.sin=function(){return this.throwIfDisposed(),u$(this)},bS().prototype.sinh=function(){return this.throwIfDisposed(),h$(this)},bS().prototype.slice=function(t,e){return this.throwIfDisposed(),SE(this,t,e)},bS().prototype.softmax=function(t){return this.throwIfDisposed(),TE(this,t)},bS().prototype.softplus=function(){return this.throwIfDisposed(),AE(this)},bS().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),YA(this,t,e)},bS().prototype.split=function(t,e){return this.throwIfDisposed(),$E(this,t,e)},bS().prototype.sqrt=function(){return this.throwIfDisposed(),RE(this)},bS().prototype.square=function(){return this.throwIfDisposed(),sE(this)},bS().prototype.squaredDifference=function(t){return this.throwIfDisposed(),OT(this,t)},bS().prototype.squeeze=function(t){return this.throwIfDisposed(),FE(this,t)},bS().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof yS?[this,t]:[this,...t];return DE(n,e)},bS().prototype.step=function(t){return this.throwIfDisposed(),JE(this,t)};const uF=qS({stridedSlice_:function(t,e,n,s,r=0,i=0,a=0,o=0,l=0){const u=HS(t,"x","stridedSlice");return MS.runKernel("StridedSlice",{x:u},{begin:e,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l})}});bS().prototype.stridedSlice=function(t,e,n,s,r,i,a,o){return this.throwIfDisposed(),uF(this,t,e,n,s,r,i,a,o)},bS().prototype.sub=function(t){return this.throwIfDisposed(),zN(this,t)},bS().prototype.sum=function(t,e){return this.throwIfDisposed(),BN(this,t,e)};const cF=qS({tan_:function(t){const e=HS(t,"x","tan");return MS.runKernel("Tan",{x:e})}});bS().prototype.tan=function(){return this.throwIfDisposed(),cF(this)},bS().prototype.tanh=function(){return this.throwIfDisposed(),OE(this)},bS().prototype.tile=function(t){return this.throwIfDisposed(),NN(this,t)},bS().prototype.toBool=function(){return this.throwIfDisposed(),PC(this,"bool")},bS().prototype.toFloat=function(){return this.throwIfDisposed(),PC(this,"float32")},bS().prototype.toInt=function(){return this.throwIfDisposed(),PC(this,"int32")};const hF=qS({topk_:function(t,e=1,n=!0){const s=HS(t,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:n},[o,l]=MS.runKernel("TopK",i,a);return{values:o,indices:l}}});bS().prototype.topk=function(t,e){return this.throwIfDisposed(),hF(this,t,e)},bS().prototype.transpose=function(t){return this.throwIfDisposed(),UE(this,t)};const dF=qS({unique_:function(t,e=0){const n=HS(t,"x","unique","string_or_numeric");J_(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[i,a]=MS.runKernel("Unique",s,r);return{values:i,indices:a}}});let pF;function fF(){return null==pF&&(pF=MS.backend.epsilon()),pF}bS().prototype.unique=function(t){return this.throwIfDisposed(),dF(this,t)},bS().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),I$(this,t,e)},bS().prototype.unstack=function(t){return this.throwIfDisposed(),zE(this,t)},bS().prototype.where=function(t,e){return this.throwIfDisposed(),VE(t,this,e)},bS().prototype.zerosLike=function(){return this.throwIfDisposed(),WE(this)};class mF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,mF.prototype)}}class gF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,gF.prototype)}}class yF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,yF.prototype)}}class bF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,bF.prototype)}}class xF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xF.prototype)}}function vF(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function wF(t,e){if(!t)throw new xF(e)}function _F(t,e){let n=0;for(const s of t)s===e&&n++;return n}function kF(t){return 1===t.length?t[0]:t}function SF(t){return Array.isArray(t)?t:[t]}function CF(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function IF(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let NF={};function EF(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function TF(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>TF(t));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?TF(e):t[n]=e.value)}}}function AF(t,e={},n={},s="object",r=!1){if("string"==typeof t){const r=t;let i;if(r in n)i=n[r];else if(r in NF)i=NF[r];else if(i=e[r],null==i)throw new yF(`Unknown ${s}: ${t}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new yF(`${s}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const a=i.className;let o,l;if(a in n?[o,l]=n[a]:a in NF?[o,l]=NF.className:a in e&&([o,l]=e[a]),null==o)throw new yF(`Unknown ${s}: ${a}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(NF))t[n]=NF[n];for(const r of Object.keys(n))t[r]=n[r];i.config.customObjects=t;const e=Object.assign({},NF);for(const r of Object.keys(n))NF[r]=n[r];TF(i.config);const s=l(o,i.config,n,r);return NF=Object.assign({},e),s}{const t=Object.assign({},NF);for(const s of Object.keys(n))NF[s]=n[s];const e=new o(i.config);return NF=Object.assign({},t),e}}}function $F(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function RF(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function FF(t){if(null==t)throw new yF(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function DF(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new yF(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function OF(t,e,n=0,s=1/0){return wF(n>=0),wF(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(t=>typeof t===e)}function LF(t,e){Array.isArray(t)?(s.assert(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((t,n)=>LF(t,`element ${n+1} of ${e}`))):s.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${MF(t)}.`)}function MF(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>MF(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function PF(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function zF(t,e){return TI(()=>RE(BN(PN(t,t),e,!0)))}class BF extends u.Serializable{getConfig(){return{}}}class VF extends BF{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return TI(()=>{const e=zF(t,this.axis),n=oN(e,0,this.maxValue);return PN(t,vN(n,MI(fF(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}VF.className="MaxNorm",u.registerClass(VF);class WF extends BF{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return TI(()=>vN(t,MI(fF(),zF(t,this.axis))))}getConfig(){return{axis:this.axis}}}WF.className="UnitNorm",u.registerClass(WF);class UF extends BF{apply(t){return xE(t)}}UF.className="NonNeg",u.registerClass(UF);class jF extends BF{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return TI(()=>{const e=zF(t,this.axis),n=MI(PN(this.rate,oN(e,this.minValue,this.maxValue)),PN(1-this.rate,e));return PN(t,vN(n,MI(fF(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}jF.className="MinMaxNorm",u.registerClass(jF);const HF={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function GF(t){return EF(t)}function qF(t,e={}){return AF(t,u.SerializationMap.getMap().classNameMap,e,"constraint")}function KF(t){return null==t?null:"string"==typeof t?qF({className:t in HF?HF[t]:t,config:{}}):t instanceof BF?t:qF(t)}const XF=["channelsFirst","channelsLast"],QF=["nearest","bilinear"],YF=["valid","same","causal"],ZF=["max","avg"],JF=["sum","mul","concat","ave"],tD=new Map;function eD(t){DF(XF,"DataFormat",t)}function nD(t){DF(YF,"PaddingMode",t)}function sD(t){DF(ZF,"PoolMode",t)}const rD=[];function iD(t,e){rD.push(t);try{const t=e();return rD.pop(),t}catch(n){throw rD.pop(),n}}function aD(t){if(!uD(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===rD.length?"":rD.join("/")+"/")+t}function oD(t){if(!uD(t))throw new Error("Not a valid tensor name: '"+t+"'");tD.has(t)||tD.set(t,0);const e=tD.get(t);if(tD.set(t,tD.get(t)+1),e>0){const n=`${t}_${e}`;return tD.set(n,1),n}return t}const lD=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function uD(t){return!!t.match(lD)}function cD(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function hD(t){return LE(t=Array.isArray(t)?new Float32Array(t):t)}function dD(t){return qN(hD(t)).dataSync()[0]}function pD(t){return MN(hD(t)).dataSync()[0]}function fD(t,e){if(e<t)throw new yF(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}function mD(t,e){return t.asType(e)}function gD(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function yD(t,e,n){return TI(()=>{switch(t.rank){case 1:return CE(t,e,n);case 2:return IE(t,[e,0],[n,t.shape[1]]);case 3:return NE(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return EE(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return SE(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return SE(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new yF(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function bD(t,e,n){return TI(()=>{switch(t.rank){case 1:return CE(t,e,n);case 2:return IE(t,[0,e],[t.shape[0],n]);case 3:return NE(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return EE(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new yF(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function xD(t,e,n,s){return TI(()=>{switch(t.rank){case 1:return CE(t,e,n);case 2:switch(s){case 1:return yD(t,e,n);case 2:return bD(t,e,n);default:throw new yF(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return yD(t,e,n);case 2:return NE(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return bD(t,e,n);default:throw new yF(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return yD(t,e,n);case 2:return EE(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return EE(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return bD(t,e,n);default:throw new yF(`The axis is not within the rank of the tensor ${s}`)}default:throw new yF(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function vD(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),lN(t,e)}function wD(t,e){switch(t.rank){case 1:return uN([t,e]);case 2:return cN([t,e],0);case 3:return hN([t,e],0);case 4:return dN([t,e],0);default:throw new yF(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function _D(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new yF(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return NN(t,e)}function kD(t,e=0,n=1,s,r){return yE(t,e,n,s,r)}function SD(t,e,n,s){if(t.rank<2||e.rank<2)throw new bF(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new bF(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return c.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?ND(t.rank,s,"channelsLast"):null,activation:n});{const r=t.shape.slice(),i=r.pop();t=t.reshape([-1,i]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],h=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(h).reshape([l,-1]);const d=[...r,...u];return c.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?ND(t.rank,s,"channelsLast"):null,activation:n}).reshape(d)}}function CD(t,e,n){return TI(()=>(e=Array.isArray(e)?LE(e,"int32"):e.toInt(),$N(t,e,n)))}function ID(t){return PN(t,t)}function ND(t,e,n){const s=e.shape;if(1!==e.rank&&e.rank!==t)throw new yF(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===n)return e.reshape(1===s.length?[1,1,s[0]]:[1].concat(s))}else if(t<3)return e;throw new yF(`Unsupported input rank by biasAdd: ${e.rank}`)}function ED(t,e,n){return TI(()=>(null==n&&(n="channelsLast"),eD(n),t.add(ND(t.rank,e,n))))}function TD(t,e,n,s){return TI(()=>jE(t,e,n,s))}function AD(t,e,n=!1){return n?t():e()}const $D=["fanIn","fanOut","fanAvg"],RD=["normal","uniform","truncatedNormal"];class FD extends u.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class DD extends FD{apply(t,e){return lE(t,e)}}DD.className="Zeros",u.registerClass(DD);class OD extends FD{apply(t,e){return uE(t,e)}}OD.className="Ones",u.registerClass(OD);class LD extends FD{constructor(t){if(super(),"object"!=typeof t)throw new yF(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new yF(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return TI(()=>PN(DI(this.value),uE(t,e)))}getConfig(){return{value:this.value}}}LD.className="Constant",u.registerClass(LD);class MD extends FD{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return bE(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}MD.className="RandomUniform",u.registerClass(MD);class PD extends FD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new bF(`randomNormal does not support dType ${e}.`);return kD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}PD.className="RandomNormal",u.registerClass(PD);class zD extends FD{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new bF(`truncatedNormal does not support dType ${e}.`);return PE(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}zD.className="TruncatedNormal",u.registerClass(zD);class BD extends FD{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return TI(()=>{if(2!==t.length||t[0]!==t[1])throw new yF("Identity matrix initializer can only be used for 2D square matrices.");return PN(this.gain,EN(t[0]))})}getConfig(){return{gain:this.gain}}}BD.className="Identity",u.registerClass(BD);class VD extends FD{constructor(t){if(super(),t.scale<0)throw new yF(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,DF($D,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,DF(RD,"Distribution",this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,s;if(eD(e),2===t.length)n=t[0],s=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=cD(t,2);n=t[1]*e,s=t[0]*e}else if("channelsLast"===e){const e=cD(t,0,t.length-2);n=t[t.length-2]*e,s=t[t.length-1]*e}}else{const e=cD(t);n=Math.sqrt(e),s=Math.sqrt(e)}return[n,s]}(t),s=n[0],r=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new bF(`${this.getClassName()} does not support dType ${e}.`);return PE(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return bE(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}VD.className="VarianceScaling",u.registerClass(VD);class WD extends VD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return VD.className}}WD.className="GlorotUniform",u.registerClass(WD);class UD extends VD{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return VD.className}}UD.className="GlorotNormal",u.registerClass(UD);class jD extends VD{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return VD.className}}jD.className="HeNormal",u.registerClass(jD);class HD extends VD{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return VD.className}}HD.className="HeUniform",u.registerClass(HD);class GD extends VD{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return VD.className}}GD.className="LeCunNormal",u.registerClass(GD);class qD extends VD{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return VD.className}}qD.className="LeCunNormal",u.registerClass(qD);class KD extends FD{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new bF("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return TI(()=>{if(t.length<2)throw new bF("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=kD(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=PT.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),PN(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}KD.className="Orthogonal",u.registerClass(KD);const XD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function QD(t,e={}){return AF(t,u.SerializationMap.getMap().classNameMap,e,"initializer")}function YD(t){return EF(t)}function ZD(t){if("string"==typeof t){const e=t in XD?XD[t]:t;if("GlorotNormal"===e)return new UD;if("GlorotUniform"===e)return new WD;if("HeNormal"===e)return new jD;if("HeUniform"===e)return new HD;if("LeCunNormal"===e)return new GD;if("LeCunUniform"===e)return new qD;{const t={};return t.className=e,t.config={},QD(t)}}return t instanceof FD?t:QD(t)}let JD=0;function tO(){return JD++}const eO={};function nO(t=""){return t in eO||(eO[t]=0),eO[t]+=1,t+eO[t].toString()}function sO(t){return Array.isArray(t)&&Array.isArray(t[0])}function rO(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function iO(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new yF(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function aO(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new yF(`Expected exactly 1 Shape; got ${t.length}`)}return t}function oO(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class lO{constructor(t,e="float32",n="Variable",s=!0,r=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=tO(),this.originalName=aD(n=null==n?"Variable":n),this.name=oD(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(t,e=!0,n,s){return MS.makeVariable(t,e,n,s)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function uO(t){return t.map(t=>t.read())}function cO(t){t.forEach(t=>{t[0].write(t[1])})}class hO{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class dO{constructor(t,e,n,s,r,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=a,this.id=tO(),null!=i&&(this.originalName=aD(i),this.name=oD(this.originalName)),this.rank=e.length}}let pO=0;class fO{constructor(t,e){this.callArgs=e,this.id=pO++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let mO=0;class gO extends u.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=mO++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=CF(t)+"_"+nO(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new gF(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new yF(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return kF(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return kF(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new mF(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new mF(`Layer ${this.name} is not connected, no input to return.`);return kF(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new mF(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new mF(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return kF(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=SF(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=SF(this.inputSpec);if(t.length!==e.length)throw new yF(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const s=t[n],r=e[n];if(null==r)continue;const i=s.rank;if(null!=r.ndim&&i!==r.ndim)throw new yF(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${i}`);if(null!=r.maxNDim&&i>r.maxNDim)throw new yF(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${i}`);if(null!=r.minNDim&&i<r.minNDim)throw new yF(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${i}.`);if(null!=r.dtype&&s.dtype!==r.dtype)throw new yF(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);if(r.axes){const t=s.shape;for(const e in r.axes){const s=Number(e),i=r.axes[e],a=s>=0?t[s]:t[t.length+s];if(null!=i&&-1===[i,null].indexOf(a))throw new yF(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const e=r.shape[t],i=s.shape[t];if(null!=e&&null!=i&&e!==i)throw new yF(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=SF(t);let s=!0;for(const i of n)if(!(i instanceof dO)){s=!1;break}let r=!0;for(const i of n)if(i instanceof dO){r=!1;break}if(s===r)throw new yF("Arguments to apply() must be all SymbolicTensors or all Tensors");return iD(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of SF(t))e.push(n.shape);this.build(kF(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let s=this.call(t,e);const r=SF(s),i=[];for(let t of r)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(s=kF(i),null!=this.activityRegularizer)throw new bF("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(t){t=SF(t);const e=[];for(const n of t)e.push(n.shape);return kF(e)}(t),s=this.computeOutputShape(n);let r;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,s)=>new dO(i,n,this,SF(t),e,this.name,s)):new dO(i,s,this,SF(t),e,this.name),this.addInboundNode(t,r,null,null,n,s,e),this._refCount++,null!=this.activityRegularizer)throw new bF("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,s)=>{null!=n&&null!=t[s]&&t[s]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new mF(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new mF(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new gF(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return oO(this.weights)}build(t){this.built=!0}getWeights(t=!1){return uO(t?this.trainableWeights:this.weights)}setWeights(t){TI(()=>{const e=this.weights;if(e.length!==t.length)throw new yF(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],r=uO(e);for(let i=0;i<r.length;++i){const a=r[i],o=e[i],l=t[i];if(!s.arraysEqual(a.shape,l.shape))throw new yF(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);n.push([o,l])}cO(n)})}addWeight(t,e,n,s,r,i,a){if(-1!==this._addedWeightNames.indexOf(t))throw new yF(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=ZD("zeros"));const o=s.apply(e,n),l=new lO(o,n,t,i,a);return o.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=SF(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,s,r,i,a=null){const o=SF(t);e=SF(e),n=SF(n),s=SF(s),r=rO(r),i=rO(i);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new fO({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function yO(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const s=yO(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of s)-1===e.indexOf(t)&&e.push(t)}return e}}}class bO extends gO{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:nO("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new yF("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new yF("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new yF("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const s=new dO(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new fO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new yF(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function xO(t){if(null==t)return;const e=[],n=[],s=[];for(const r in t){const i=t[r];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(r),s.push(t)}}if(e.length>0){const r=await Promise.all(e);for(let e=0;e<r.length;++e)t[n[e]]=r[e][0];AI(s)}}function vO(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var wO;bO.className="InputLayer",u.registerClass(bO),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(wO||(wO={}));class _O{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class kO{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class SO extends _O{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const s in e){const t=e[s];if("number"==typeof t)this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+t*n;else{let e;s in this.totals?e=this.totals[s]:this.totals[s]=0;const r=TI(()=>MI(this.totals[s],PN(t,n)));this.totals[s]=r,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?e[n]=this.totals[n]/this.seen:TI(()=>{const t=PN(vN(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),$I(e[n])}))}}class CO extends _O{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const r in this.history){const s=this.history[r];for(let i=0;i<s.length;++i)"number"!=typeof s[i]&&(t.push(s[i].data()),e.push(r),n.push(i))}const s=await Promise.all(t);for(let r=0;r<s.length;++r)this.history[e[r]][n[r]].dispose(),this.history[e[r]][n[r]]=s[r][0]}}class IO extends _O{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");s.isNumber(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,r=s.now();return(...i)=>{const a=s.now();return a-r<e||(r=a,n=t(...i)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const s=[];null!=this.yield&&(await xO(n),s.push(this.yield(t,e,n))),s.push(XT()),await Promise.all(s)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await xO(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await xO(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(XT()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await xO(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await xO(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(XT()):s.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await xO(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await xO(t),await this.trainEnd(t))}}function NO(t,e){return null==t&&(t={}),t instanceof _O?[t]:Array.isArray(t)&&t[0]instanceof _O?t:SF(t).map(t=>new IO(t,e))}class EO{constructor(){}static registerCallbackConstructor(t,e){s.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),EO.checkForDuplicate(e),null==EO.constructors[t]&&(EO.constructors[t]=[]),EO.constructors[t].push(e)}static checkForDuplicate(t){for(const e in EO.constructors)EO.constructors[+e].forEach(e=>{if(e===t)throw new yF("Duplicate callback constructor.")})}static clear(){EO.constructors={}}static createCallbacks(t){const e=[];for(const n in EO.constructors){const s=+n;t>=s&&e.push(...EO.constructors[s])}return e.map(t=>new t)}}function TO(t,e,n,s,r,i,a,o,l){const u=new CO,c=[new SO,...EO.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new kO(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:u}}function AO(t,e={},n=!1){return AF(t,u.SerializationMap.getMap().classNameMap,e,"layer",n)}function $O(t,e){return TI(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=BN(ID(t),e,!0),s=TN(n.shape,fF()),r=RE(HN(n,s));return vN(t,r)})}function RO(t,e){return TI(()=>GN(ID(zN(e,t)),-1))}function FO(t,e){return TI(()=>GN(LI(zN(e,t)),-1))}function DO(t,e){return TI(()=>{const n=zN(t,e),s=oN(LI(t),fF(),Number.MAX_VALUE),r=LI(vN(n,s));return PN(100,GN(r,-1))})}function OO(t,e,n=!1){return TI(()=>{if(n)e=TE(e);else{const t=BN(e,e.shape.length-1,!0);e=vN(e,t)}return e=oN(e,fF(),1-fF()),iE(BN(PN(t.toFloat(),ON(e)),e.shape.length-1))})}function LO(t,e,n=!1){return TI(()=>{const s=AN(function(t){const e=[cD(t.shape)];return t.reshape(e)}(t)).toInt(),r=(e=oN(e,fF(),1-fF())).shape;return OO(oE(s,r[r.length-1]).reshape(r),e,n)})}function MO(t,e){return TI(()=>{let n;return n=oN(e,fF(),1-fF()),n=ON(vN(n,zN(1,n))),GN(function(t,e){if(!s.arraysEqual(t.shape,e.shape))throw new yF(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return TI(()=>{const n=e.relu(),s=e.abs().neg();return n.sub(e.mul(t)).add(s.exp().log1p())})}(t,n),-1)})}function PO(t,e){return TI(()=>{const n=$O(t,-1),s=$O(e,-1),r=PN(n,s);return iE(BN(r,-1))})}EO.constructors={};const zO={meanSquaredError:RO,meanAbsoluteError:FO,meanAbsolutePercentageError:DO,meanSquaredLogarithmicError:function(t,e){return TI(()=>{const n=oN(e,fF(),Number.MAX_VALUE),s=ON(MI(1,n)),r=oN(t,fF(),Number.MAX_VALUE),i=ON(MI(1,r));return GN(ID(zN(s,i)),-1)})},squaredHinge:function(t,e){return TI(()=>{const n=HN(0,zN(1,PN(t,e)));return GN(ID(n),-1)})},hinge:function(t,e){return TI(()=>{const n=HN(0,zN(1,PN(t,e)));return GN(n,-1)})},categoricalHinge:function(t,e){return TI(()=>{const n=BN(PN(t,e),-1),s=MN(PN(zN(1,t),e),-1);return HN(0,MI(1,zN(s,n)))})},logcosh:function(t,e){return TI(()=>{const n=Math.log(2),s=zN(e,t),r=zN(MI(s,AE(PN(-2,s))),n);return GN(r,-1)})},categoricalCrossentropy:OO,sparseCategoricalCrossentropy:LO,binaryCrossentropy:MO,kullbackLeiblerDivergence:function(t,e){return TI(()=>{const n=oN(t,fF(),1),s=oN(e,fF(),1);return BN(PN(t,ON(vN(n,s))),-1)})},poisson:function(t,e){return TI(()=>{const n=ON(MI(fF(),e));return GN(zN(e,PN(t,n)),-1)})},cosineProximity:PO};function BO(t){if("string"==typeof t){if(t in zO)return zO[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new yF(e)}return t}function VO(t,e){return TI(()=>{const n=PN(.5,cE(e)),s=mD(RN(e,n),t.dtype);return GN(CN(t,s),-1)})}function WO(t,e){return TI(()=>mD(CN(BI(t,-1),BI(e,-1)),"float32"))}function UO(t,e){return MO(t,e)}function jO(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),CN(t,e).asType("float32")}const HO=OO,GO=LO,qO={binaryAccuracy:VO,categoricalAccuracy:WO,precision:function(t,e){return TI(()=>{const n=function(t,e){return TI(()=>WN(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),s=function(t,e){return TI(()=>WN(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),r=n.add(s);return VE(RN(r,0),n.div(r),0).cast("float32")})},categoricalCrossentropy:HO,sparseCategoricalCrossentropy:GO,mse:RO,MSE:RO,mae:FO,MAE:FO,mape:DO,MAPE:DO,cosine:PO};function KO(t){if("string"==typeof t&&t in qO)return qO[t];if("string"!=typeof t&&null!=t)return t;throw new yF(`Unknown metric ${t}`)}function XO(t){if(wF(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(zO))if(zO[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(qO))if(qO[n]===t){e=n;break}return void 0!==e?e:t.name}}function QO(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!YO(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function YO(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!YO(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!YO(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function ZO(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function JO(t,e,n){let s;try{s=JSON.stringify(t.outputShape)}catch(CY){s="multiple"}ZO([`${t.name} (${t.getClassName()})`,s,t.countParams().toString()],e,n)}function tL(t,e,n,s){let r;try{r=JSON.stringify(t.outputShape)}catch(CY){r="multiple"}const i=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t)i.push(`${u.inboundLayers[t].name}[${u.nodeIndices[t]}][${u.tensorIndices[t]}]`);const a=t.name,o=t.getClassName(),l=0===i.length?"":i[0];ZO([`${a} (${o})`,r,t.countParams().toString(),l],e,s);for(let u=1;u<i.length;++u)ZO(["","","",i[u]],e,s)}function eL(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function nL(t,e){if(null===t)return null;if("string"==typeof t)return IF(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];eL(e,r,s)?n.push(s):n.push(nL(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];if("name"===n&&"string"==typeof s)e[n]=s;else{const t=IF(n);e[t]=nL(s,t)}}return e}}function sL(t,e){if(null==t)return null;if("string"==typeof t)return CF(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const s=t[r];eL(e,r,s)?n.push(s):n.push(sL(s,e))}return n}{const e={};for(const n of Object.keys(t)){const s=t[n];e[CF(n)]="name"!==n&&"className"!==n||"string"!=typeof s?sL(s,n):s}return e}}class rL{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof rL)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new yF(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return PC(e,t.dtype)}catch(CY){throw new yF(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof dO){if(null==this.id2Value[t.id])throw new yF(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new yF(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof dO){if(null==this.id2Value[t.id])throw new yF(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new yF(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&AI(this.id2Mask)}}const iL={},aL={};function oL(t,e,n,r){const i=null!=n&&n.training,a=Array.isArray(t),o=a?t:[t],l=o.map(t=>t.name),u=[],c=e.names();for(const s of l)-1!==c.indexOf(s)?u.push(e.getValue(s)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().join(",");let d,p;if(null==iL[h]){const t=function(t,e){s.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===t.length){const s=uL(t[0],e);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of t){const{sorted:t,recipientMap:a}=uL(i,e);for(const e of t)s.has(e.name)||(n.push(e),s.add(e.name));for(const e in a)null==r[e]&&(r[e]=new Set),a[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:lL(r)}}(o,e);d=t.sorted,p=t.recipientCounts,iL[h]=d,aL[h]=p}d=iL[h],p={},i||Object.assign(p,aL[h]);const f=new rL(e);for(let s=0;s<d.length;++s){if(null!=r){const t=EI().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const t=d[s],a=t.sourceLayer;if(a instanceof bO)continue;const o=[],c=[],h=[];let m=!1;for(const n of t.inputs){const t=f.getValue(n),s=f.getMask(n);o.push(t),c.push(s),null!=s&&(m=!0),i||(p[n.name]--,0!==p[n.name]||e.hasKey(n)||-1!==l.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||h.push(t))}m&&((n=n||{}).mask=c[0]);const g=SF(a.apply(o,n));let y=null;a.supportsMasking&&(y=a.computeMask(o,c));const b=cL(t),x=Array.isArray(b)?b:[b];for(let e=0;e<x.length;++e){f.hasKey(x[e])||f.add(x[e],g[e],Array.isArray(y)?y[0]:y);const t=l.indexOf(x[e].name);-1!==t&&(u[t]=g[e])}i||AI(h)}return f.disposeMasks(),a?u:u[0]}function lL(t){const e={};for(const n in t)e[n]=t[n].size;return e}function uL(t,e){const n=new Set,s=[],r={};for(const o of e.names())n.add(o);const i=[],a=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=a[a.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),s.push(t),n.add(t.name),e&&a.pop();else{a.push(i.length-1);for(const e of t.inputs)null==r[e.name]&&(r[e.name]=new Set),r[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:s,recipientMap:r}}function cL(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const s of t.sourceLayer.inboundNodes[e].outputTensors)if(s.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class hL extends gO{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=nO(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],RF(this.inputs).length!==this.inputs.length)throw new yF(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(t=>t.name)}`);RF(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;wF(0===e,"input layer has >1 nodes"),wF(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof bO))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},s={},r={},i={},a=[],o=(t,e,n,s,r,l)=>{null!=s&&null!=r&&null!=l||(s=t.sourceLayer,r=t.nodeIndex,l=t.tensorIndex);const u=s.inboundNodes[r];if(-1!==n.indexOf(u))throw new gF(`The tensor ${t.name} at layer "${s.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(hL.nodeKey(s,r)),s.id in i||(i[s.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++)o(u.inputTensors[i],e,n,u.inboundLayers[i],u.nodeIndices[i],u.tensorIndices[i]);for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);a.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=a.slice().reverse();for(const y of c){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==s[y.outboundLayer.id]?0:s[y.outboundLayer.id]),s[y.outboundLayer.id]=t,r[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let s=0;s<y.inboundLayers.length;s++){const r=y.inboundLayers[s].inboundNodes[y.nodeIndices[s]];e[r.id]=Math.max(t+1,null==e[r.id]?0:e[r.id]),n[r.id]=r}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in s){const t=s[y];t in d||(d[t]=[]),d[t].push(r[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort($F);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=i[t.id],s=i[e.id];return n<s?-1:n>s?1:0});for(const e of t)e instanceof hL&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort($F);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new gF(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new gF(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new fO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new yF("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let s=0;for(const i of this.layers)for(const t of i.weights){if(null!=n[t.originalName])throw new yF(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,s++}const r=[];for(const i in t){let s=i;if(null==n[i]){const t=i.split("/");s=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[s])r.push([n[s],t[i]]);else if(e)throw new yF(`Provided weight data has no target variable: ${i}`);delete n[s]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new yF(`${t.length} of ${s} weights are not set: ${t}`)}cO(r)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.3.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=sL(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return TI(()=>{t=SF(t);const n=new rL;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return oL(this.outputs,n,e)})}computeMask(t,e){return TI(()=>{let n;return t=SF(t),n=null==e?vF(null,t.length):SF(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=rO(t);if(e.length!==this.inputLayers.length)throw new yF(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let a=0;a<e.length;a++)n[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort($F);if(s.length>1)for(const a of s){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const s=[];for(let a=0;a<e.inboundLayers.length;a++)s.push(n[`${e.inboundLayers[a].name}_${e.nodeIndices[a]}_${e.tensorIndices[a]}`]);const r=rO(t.computeOutputShape(kF(s))),i=t.inboundNodes.indexOf(e);for(let e=0;e<r.length;e++)n[`${t.name}_${i}_${e}`]=r[e]}}const r=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const t=i[a];wF(t in n),r.push(n[t])}return kF(r)}runInternalGraph(t,e){null==e&&(e=vF(null,t.length));const n={};for(let o=0;o<this.inputs.length;++o)n[this.inputs[o].id]=[t[o],e[o]];const s=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort($F);for(const o of s){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer,s=e.inputTensors,r=e.outputTensors,i=new Array;for(const e of s)e.id in n&&i.push(n[e.id]);if(i.length===s.length){let s,a,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===i.length){const[e,n]=i[0];null==u.mask&&(u.mask=n),o=SF(t.call(e,u)),l=SF(t.computeMask(e,n)),s=[e],a=[n]}else s=i.map(t=>t[0]),a=i.map(t=>t[1]),null==u.mask&&(u.mask=a),o=SF(t.call(s,u)),l=SF(t.computeMask(s,a));if(t.activityRegularizer)throw new bF("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t)n[r[t].id]=[o[t],l[t]]}}}const r=[],i=[],a=[];for(const o of this.outputs){wF(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[t,e]=n[o.id];a.push(t.shape),r.push(t),i.push(e)}return[r,i,a]}buildNodeConversionMap(t){const e={};let n;for(const s of this.layers){n=s instanceof hL?1:0;for(let t=0;t<s.inboundNodes.length;t++){const r=hL.nodeKey(s,t);this.containerNodes.has(r)&&(e[r]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new yF(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new yF("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new yF(`No such layer: ${t}`)}calculateLosses(){return TI(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const s=hL.nodeKey(e,n);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const t=i.getClassName(),s=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){const t=i.inboundNodes[n],s=hL.nodeKey(i,n);let a={};if(this.containerNodes.has(s)){if(t.callArgs)try{JSON.stringify(t.callArgs),a=t.callArgs}catch(CY){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(t.inboundLayers.length>0){const n=[];for(let s=0;s<t.inboundLayers.length;s++){const r=t.inboundLayers[s],i=t.tensorIndices[s];let o=e[hL.nodeKey(r,t.nodeIndices[s])];null==o&&(o=0),n.push([r.name,o,i,a])}r.push(n)}}}const a={};a.name=i.name,a.className=t,a.config=s,a.inboundNodes=r,n.push(a)}t.layers=n;const s=[];for(let i=0;i<this.inputLayers.length;i++){const t=this.inputLayers[i],n=hL.nodeKey(t,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),s.push([t.name,r,this.inputLayersTensorIndices[i]])}t.inputLayers=s;const r=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],n=hL.nodeKey(t,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=e[n];null==s&&(s=0),r.push([t.name,s,this.outputLayersTensorIndices[i]])}return t.outputLayers=r,t}static fromConfig(t,e,n={},s=!1){const r={},i={};function a(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function o(t,e){const n=[];let s;for(const i of e){const o=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(o in r))return void a(t,e);const c=r[o];if(c.inboundNodes.length<=l)return void a(t,e);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&t.apply(kF(n),s)}function l(t){const n=t.name,i=AO(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(s),r[n]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new yF(`Corrupted configuration, expected array for nodeData: ${t}`);a(i,t)})}const u=e.name,c=e.layers;for(const m of c)l(m);for(;!FF(i);)for(const t of c){const e=r[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)o(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];wF(t in r),h.push(r[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];wF(t in r),d.push(r[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new yF("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){TI(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function dL(t,e){return function(t,e,n){const s=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===s)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${s}) outputs, so classWeight must be either an array with ${s} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}async function pL(t,e,n,s){if(null!=e||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=TI(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await e.data());AI(e);const r=[];return s.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);r.push(n[t])}),LE(r,"float32")}return null}function fL(t,e){return PN(t,e)}function mL(t,e){let n,r;n=e.xs,r=e.ys,s.assert(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=gL("input",t.inputNames,n),a=gL("output",t.outputNames,r),o=i[0].shape[0];s.assert(i.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),s.assert(a.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<i.length;l++)s.assert(i[l].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let l=0;l<a.length;l++)s.assert(a[l].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:i,ys:a}}function gL(t,e,n){if(n instanceof yS)return[n];if(Array.isArray(n))return s.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(null==n[r])throw new yF(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function yL(t){return"function"==typeof t.iterator}function bL(t){s.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function xL(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>yD(t,e,n-e)):yD(t,e,n-e)}function vL(t,e){return TI(()=>null==t?null:Array.isArray(t)?t.map(t=>vL(t,e)):CD(t,"int32"===e.dtype?e:e.toInt()))}function wL(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function _L(t){const e=[];t instanceof yS&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(1===s.rank)e.push(gD(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function kL(t,e){if(null==t)return;const n=[];if(e instanceof yS)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const r in e)n.push(e[r].id);const s=[];if(t instanceof yS)-1===n.indexOf(t.id)&&s.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&s.push(t)});else if(null!=t)for(const r in t){const e=t[r];-1===n.indexOf(e.id)&&s.push(e)}s.forEach(t=>{t.isDisposed||t.dispose()})}function SL(t){return Array.isArray(t)}function CL(t){return!function(t){return t instanceof yS}(t)&&!SL(t)}function IL(t,e,n,s=!0,r=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(SL(t)&&t.length>0)e=!0;else if(CL(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new yF(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(null==t)return e.map(t=>null);let i;if(CL(t)){t=t,i=[];for(const n of e){if(null==t[n])throw new yF(`No data provided for "${n}". Need data for each key in: ${e}`);i.push(t[n])}}else if(SL(t)){if((t=t).length!==e.length)throw new yF(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(t=t,e.length>1)throw new yF(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=_L(i),null!=n)for(let a=0;a<e.length;++a){if(null==n[a])continue;const t=i[a];if(t.shape.length!==n[a].length)throw new yF(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s). but got array with shape ${t.shape}`);for(let i=0;i<n[a].length;++i){if(0===i&&!s)continue;const o=t.shape[i],l=n[a][i];if(null!=l&&l>=0&&o!==l)throw new yF(`Error when checking ${r}: expected ${e[a]} to have shape [${n[a]}], but got array with shape [${t.shape}].`)}}return i}function NL(t,e,n,s=!0,r=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new yF(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new yF(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(null!=n)for(let a=0;a<e.length;++a){if(null==n[a])continue;const t=i[a];if(t.shape.length!==n[a].length)throw new yF(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(t.shape)}`);for(let i=0;i<n[a].length;++i){if(0===i&&!s)continue;const o=t.shape[i],l=n[a][i];if(null!=l&&l!==o)throw new yF(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class EL extends hL{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new yF("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,s=console.log){const r=function(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let t=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Output shape","Param #"];let a;if(r?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!r){i.push("Receives inputs"),a=[];for(const e in t.nodesByDepth)a.push(...t.nodesByDepth[e])}s("_".repeat(e)),ZO(i,n,s),s("=".repeat(e));const o=t.layers;for(let c=0;c<o.length;++c)r?JO(o[c],n,s):tL(o[c],n,a,s),s((c===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=oO(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),u=oO(t.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>qT.adagrad(.01),Adadelta:()=>qT.adadelta(1,.95,fF()),Adam:()=>qT.adam(.001,.9,.999,fF()),Adamax:()=>qT.adamax(.002,.9,.999,fF(),0),RMSProp:()=>qT.rmsprop(.001,.9,0,fF()),SGD:()=>qT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new yF(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof OI))throw new yF("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new yF(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>BO(t))}else{const n=BO(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new yF(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(BO(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const t=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],iD("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const s=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const s of e){let e=n.hasOwnProperty(s)?n[s]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),r=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};iD("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,s,i;for(const a of e){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const e=this.internalOutputShapes[t];let r;1===e[e.length-1]||this.lossFunctions[t]===MO?-1!==["accuracy","acc"].indexOf(a)?s=VO:-1!==["crossentropy","ce"].indexOf(a)&&(s=UO):this.lossFunctions[t]===LO?-1!==["accuracy","acc"].indexOf(a)?s=jO:-1!==["crossentropy","ce"].indexOf(a)&&(s=GO):-1!==["accuracy","acc"].indexOf(a)?s=WO:-1!==["crossentropy","ce"].indexOf(a)&&(s=HO),-1!==["accuracy","acc"].indexOf(a)?r="acc":-1!==["crossentropy","ce"].indexOf(a)&&(r="ce"),i=s,n=""+r}else{const t=KO(a);i=t,n=""+XO(a)}let e;iD(n,()=>{e=i}),r(t,n,e)}})(s[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const s=null==n.batchSize?32:n.batchSize;bL(s);const r=this.standardizeUserDataXY(t,e,!0,s);try{const i=r[0].concat(r[1]);return this.makeTestFunction(),kF(this.testLoop(this.testFunction,i,s,n.verbose,n.steps))}finally{kL(r[0],t),kL(r[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,i=t.testFunction;let a=[];if(n.verbose>0)throw new bF("Verbose mode is not implemented yet.");s.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o="function"==typeof e.next?e:await e.iterator();let l=0,u=0;for(;!r||u<n.batches;){const e=await o.next();if(a=TI(()=>{if(e.value){const{xs:n,ys:s}=mL(t,e.value),r=n.concat(s),o=TI(()=>i(r));if(AI(r),0===u)for(let t=0;t<o.length;++t)a.push(DI(0));const c=r[0].shape[0];for(let t=0;t<o.length;++t){const e=o[t],n=a[t];a[t]=TI(()=>MI(a[t],PN(c,e))),u>0&&AI(n)}AI(o),l+=c,++u}return a}),e.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let s=0;s<a.length;++s){const t=a[s];a[s]=vN(a[s],l),AI(t)}return kF(a)}(this,t,e)}checkNumSamples(t,e,n,s="steps"){let r;if(null!=n){if(r=null,null!=e)throw new yF(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new yF(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new yF("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),s=this.retrieveSymbolicTensors(n?e:[e]),r=new rL;if(t instanceof yS&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new yF(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)r.add(this.inputs[e],t[e])}else for(const a of this.inputs){const e=t[a.name];if(null==e)throw new yF(`No value is provided for the model's input ${a.name}`);r.add(a,e)}const i=oL(s,r);return n?i:i[0]}retrieveSymbolicTensors(t){const e=vF(null,t.length);let n=t.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],i=r.map(t=>t.name);for(let s=0;s<t.length;++s){const a=i.indexOf(t[s]);if(-1!==a&&(e[s]=r[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,s)=>{null==e&&n.push(t[s])}),new yF(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return TI(()=>{const s=this.checkNumSamples(t);if(n)throw new bF("Verbose predictLoop() is not implemented yet.");const r=wL(s,e),i=this.outputs.map(t=>[]);for(let e=0;e<r.length;++e)TI(()=>{const n=xL(t,r[e][0],r[e][1]),s=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)s.push({key:this.inputs[t],value:n[t]});else s.push({key:this.inputs[0],value:n});const i=new rL(s);return oL(this.outputs,i)}).forEach((t,e)=>i[e].push(t));return kF(i.map(t=>lN(t,0)))})}predict(t,e={}){const n=_L(t);NL(n,this.inputNames,this.feedInputShapes,!1);try{const s=null==e.batchSize?32:e.batchSize;return bL(s),this.predictLoop(n,s)}finally{kL(n,t)}}predictOnBatch(t){NL(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(null==this.optimizer_)throw new gF("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let s=0;s<this.feedOutputShapes.length;++s){const t=this.feedOutputShapes[s];i.push(this.feedLossFns[s]===LO?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const r=RF(t.map(t=>t.shape[0]));r.sort();const i=RF(e.map(t=>t.shape[0]));if(i.sort(),r.length>1)throw new yF(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(t=>t.shape))}`);if(i.length>1)throw new yF(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(t=>t.shape))}`);if(r.length>0&&i.length>0&&!s.arraysEqual(r,i))throw new yF(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(t=IL(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=IL(e,this.feedOutputNames,i,!1,"target")),function(t,e,n){const s=[RO,MO,OO];for(let r=0;r<t.length;++r){const i=t[r],a=e[r],o=n[r];if(null!=a){if(a===OO&&1===i.shape[i.shape.length-1])throw new yF(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(a)){const t=i.shape.slice(1),e=o.slice(1);for(let n=0;n<t.length;++n){const s=t[n],r=e[n];if(null!=r&&s!==r)throw new yF(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&t[0].shape[0]%r!=0)throw new yF(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,s,r=!0,i){const[a,o]=this.standardizeUserDataXY(t,e,r,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=s){const t=dL(s,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await pL(o[e],null,t[e]))}return[a,o,l]}testLoop(t,e,n,s=0,r){return TI(()=>{const i=this.checkNumSamples(e,n,r,"steps"),a=[];if(s>0)throw new bF("Verbose mode is not implemented yet.");if(null!=r)throw new bF("steps mode in testLoop() is not implemented yet");{const s=wL(i,n),r=LE(fD(0,i));for(let n=0;n<s.length;++n){const i=s[n][0],o=s[n][1],l=yD(r,i,o-i),u=vL(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)a.push(DI(0));for(let t=0;t<c.length;++t)a[t]=MI(a[t],PN(o-i,c[t]))}for(let t=0;t<a.length;++t)a[t]=vN(a[t],i)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const s=t[n];let r=s;_F(t,s)>1&&(r+=`_${_F(t.slice(0,n),s)}`),e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],a=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const a=new rL(t),o=oL(this.outputs,a,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(s[n],o[n]);null!=r[n]&&(t=fL(t,r[n]));const i=GN(t);e.push(i),l=0===n?t:MI(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=GN((0,this.metricsTensors[n][0])(s[e],o[e]))}$I(t),i.push(t)}return l=GN(l),this.calculateLosses().forEach(t=>{l=MI(l,t)}),l},!0,a)].concat(i)}}makeTestFunction(){this.testFunction=t=>TI(()=>{const e=[];let n;const s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:s[t]});const a=new rL(i),o=oL(this.outputs,a);for(let t=0;t<this.lossFunctions.length;++t){const s=GN((0,this.lossFunctions[t])(r[t],o[t]));n=0===t?s:MI(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],s=GN((0,this.metricsTensors[t][0])(r[n],o[n]));e.push(s)}return e})}async fit(t,e,n={}){return async function(t,e,n,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,o,l,u,c,h;t.isTraining=!0;try{const d=null==r.batchSize?32:r.batchSize;bL(d);const p=!1,f=await t.standardizeUserData(e,n,r.sampleWeight,r.classWeight,p,d);i=f[0],a=f[1],h=f[2];let m,g=!1;if(null!=r.validationData&&r.validationData.length>0){if(g=!0,2!==r.validationData.length)throw 3===r.validationData.length?new bF("validationData including sample weights is not supported yet."):new yF(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);o=r.validationData[0],l=r.validationData[1];const e=!0,n=await t.standardizeUserData(o,l,null,null,e,d);u=n[0],c=n[1],m=u.concat(c)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){g=!0;const t=Math.floor(i[0].shape[0]*(1-r.validationSplit)),e=i[0].shape[0];u=xL(i,t,e),i=xL(i,0,t),c=xL(a,t,e),a=xL(a,0,t),m=u.concat(c)}else null!=r.validationSteps&&(g=!0);const y=i.concat(a).concat(h);t.checkTrainableWeightsConsistency();const b=t.makeTrainFunction(),x=t.getDedupedMetricsNames();let v,w;g?(t.makeTestFunction(),v=t.testFunction,w=x.slice().concat(x.map(t=>"val_"+t))):(v=null,m=[],w=x.slice());const _=NO(r.callbacks,r.yieldEvery);return await async function(t,e,n,r,i,a,o,l,u,c,h,d,p,f,m){null==i&&(i=32),null==a&&(a=1),null==h&&(h=!0),null==p&&(p=0);let g=!1;null!=u&&null!=c&&(g=!0);const y=t.checkNumSamples(n,i,null,"steps_per_epoch");let b;null!=y&&(b=fD(0,y)),null==o&&(o=1);const{callbackList:x,history:v}=TO(l,o,a,p,y,null,i,g,d);x.setModel(t),t.history=v,await x.onTrainBegin(),t.stopTraining_=!1;for(let w=p;w<a;++w){await x.onEpochBegin(w);const a={};{if("batch"===h)throw new bF("batch shuffling is not implemneted yet");h&&s.shuffle(b);const o=LE(b),l=wL(y,i);for(let s=0;s<l.length;++s){const h={};if(await x.onBatchBegin(s,h),TI(()=>{const d=l[s][0],p=l[s][1],f=yD(o,d,p-d);h.batch=s,h.size=p-d;const m=vL(n,f),y=e(m);for(let t=0;t<r.length;++t){const e=y[t];h[r[t]]=e,$I(e)}if(s===l.length-1&&g){const e=t.testLoop(u,c,i);for(let t=0;t<r.length;++t){const n=r[t],s=e[t];$I(s),a["val_"+n]=s}}}),await x.onBatchEnd(s,h),vO(h),t.stopTraining_)break}o.dispose()}if(await x.onEpochEnd(w,a),t.stopTraining_)break}return await x.onTrainEnd(),await t.history.syncData(),t.history}(t,b,y,x,d,r.epochs,r.verbose,_,v,m,r.shuffle,w,r.initialEpoch)}finally{t.isTraining=!1,kL(i,e),kL(a,n),kL(u,o),kL(c,l),null!=h&&AI(h)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const r=null!=n.batchesPerEpoch;if(s.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),s.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),s.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),s.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),s.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=n.validationData;let a,o;if(i)if(yL(n.validationData))s.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const t=function(t){if(3===t.length)throw new bF("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);a=t.xs,o=t.ys}const l=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let c;c=i?u.slice().concat(u.map(t=>"val_"+t)):u.slice();const h=NO(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=TO(h,d,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,i,c);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const s={};await p.onEpochBegin(m);let c=0,h=0;for(r||(g=await e.iterator());!r||c<n.batchesPerEpoch;){const e=await g.next();if(r&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:s,ys:r}=mL(t,e.value),i={};i.batch=h,i.size=s[0].shape[0],await p.onBatchBegin(h,i);const a=[];if(null!=n.classWeight){const e=dL(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)a.push(await pL(r[t],null,e[t]))}const o=s.concat(r).concat(a),d=l(o);AI(o);for(let t=0;t<u.length;++t){const e=d[t];i[u[t]]=e,$I(e)}await p.onBatchEnd(h,i),vO(i),h++,c++}if(r?c>=n.batchesPerEpoch:e.done){if(i){let e;e=yL(n.validationData)?SF(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):SF(t.evaluate(a,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)s[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,s),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),s=n[0],r=n[1],i=this.makeTrainFunction()(s.concat(r)),a=[];for(const o of i){const t=await o.data();a.push(t[0])}return AI(i),kF(a)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let i=0;i<s.length;++i)n&&!s[i].trainable||e.push({name:s[i].originalName,tensor:r[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=EI().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-EI().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=CF(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>CF(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const s of e){if("string"!=typeof n[s])throw new Error("Serialization of non-string loss is not supported.");t[s]=CF(n[s])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[CF(XO(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>CF(XO(t)));{const t={};for(const e in this.metrics)t[e]=CF(XO(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=AO(nL(t.optimizer_config));let n,s;if("string"==typeof t.loss)n=IF(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>IF(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=IF(t.loss[e])}if(Array.isArray(t.metrics))s=t.metrics.map(t=>IF(t));else if(null!=t.metrics){s={};for(const e in t.metrics)s[e]=IF(t.metrics[e])}this.compile({loss:n,metrics:s,optimizer:e})}async save(t,e){if("string"==typeof t){const e=a.getSaveHandlers(t);if(0===e.length)throw new yF(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new yF(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new yF("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await a.encodeWeights(this.getNamedWeights(e)),s={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.3.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:r}=await a.encodeWeights(await this.optimizer.getWeights(),t);n.specs.push(...r),n.data=a.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(QO(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,t.save(s)}setUserDefinedMetadata(t){QO(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}EL.className="Model",u.registerClass(EL);class TL extends EL{}TL.className="Functional",u.registerClass(TL);class AL extends EL{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:nO("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new yF(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof AL||t instanceof EL;let n;if(e){if(n=t,1!==n.outputs.length)throw new yF("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new yF("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new yF("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new yF("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new bO({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new yF(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new yF("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=yO(this.outputs[0])}this.inboundNodes=[],new fO({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:vF(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(aO(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new EL({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new gF("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new gF("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new gF("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new gF("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},r=!1){let i,a={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new yF("Legacy serialization format not supported yet.");i=e}else s.assert(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,a=e;const o=new t(a);if(!(o instanceof AL))throw new bF(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const s of i){const t=AO(s,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(t){if(null==this.model)throw new yF("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new yF("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}AL.className="Sequential",u.registerClass(AL);class $L extends u.Serializable{getConfig(){return{}}}class RL extends $L{apply(t,e=1){return function(t,e=1){if(1!==e)throw new bF(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return wN(t)}(t,e)}}RL.className="elu",u.registerClass(RL);class FL extends $L{apply(t){return wE(t)}}FL.className="selu",u.registerClass(FL);class DL extends $L{apply(t){return xE(t)}}DL.className="relu",u.registerClass(DL);class OL extends $L{apply(t){return TI(()=>KN(6,xE(t)))}}OL.className="relu6",u.registerClass(OL);class LL extends $L{apply(t){return t}}LL.className="linear",u.registerClass(LL);class ML extends $L{apply(t){return kE(t)}}ML.className="sigmoid",u.registerClass(ML);class PL extends $L{apply(t){return function(t){return TI(()=>{const e=MI(.5,PN(.2,t));return oN(e,0,1)})}(t)}}PL.className="hardSigmoid",u.registerClass(PL);class zL extends $L{apply(t){return AE(t)}}zL.className="softplus",u.registerClass(zL);class BL extends $L{apply(t){return function(t){return TI(()=>vN(t,LI(t).add(1)))}(t)}}BL.className="softsign",u.registerClass(BL);class VL extends $L{apply(t){return OE(t)}}VL.className="tanh",u.registerClass(VL);class WL extends $L{apply(t,e=-1){return TE(t,e)}}WL.className="softmax",u.registerClass(WL);class UL extends $L{apply(t,e=-1){return VN(t,e)}}UL.className="logSoftmax",u.registerClass(UL);class jL extends $L{apply(t,e=1){return TI(()=>kE(t.mul(e)).mul(t))}}function HL(t){return t.getClassName()}function GL(t,e={}){return AF(t,u.SerializationMap.getMap().classNameMap,e,"activation")}function qL(t){if(null==t)return GL({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},GL(e)}return t instanceof $L?t:GL(t)}jL.className="swish",u.registerClass(jL);class KL extends u.Serializable{}class XL extends KL{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return TI(()=>{let e=lE([1]);return this.hasL1&&(e=MI(e,BN(PN(this.l1,LI(t))))),this.hasL2&&(e=MI(e,BN(PN(this.l2,ID(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}XL.className="L1L2",u.registerClass(XL);const QL={l1l2:"L1L2"};function YL(t){return EF(t)}function ZL(t,e={}){return AF(t,u.SerializationMap.getMap().classNameMap,e,"regularizer")}function JL(t){return null==t?null:"string"==typeof t?ZL({className:t in QL?QL[t]:t,config:{}}):t instanceof KL?t:ZL(t)}class tM extends gO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=iO(t);let n=xE(t);return null!=this.maxValue&&(n=oN(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}tM.className="ReLU",u.registerClass(tM);class eM extends gO{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=iO(t);return DN(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}eM.className="LeakyReLU",u.registerClass(eM);class nM extends gO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=ZD(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=JL(t.alphaRegularizer),this.alphaConstraint=KF(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new yF(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=aO(t)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<t.length;++s)n[s]=t[s];this.inputSpec=[new hO({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=iO(t),pE(t,this.alpha.read())}getConfig(){const t={alphaInitializer:YD(this.alphaInitializer),alphaRegularizer:YL(this.alphaRegularizer),alphaConstraint:GF(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}nM.className="PReLU",u.registerClass(nM);class sM extends gO{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new bF(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=iO(t);return wN(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}sM.className="ELU",u.registerClass(sM);class rM extends gO{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=iO(t);return n.mul(mD(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}rM.className="ThresholdedReLU",u.registerClass(rM);class iM extends gO{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new WL).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=iO(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function aM(t,e,n){if("number"==typeof t)return vF(t,e);if(t.length!==e)throw new yF(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){const i=t[r];if((s=i)!==parseInt(s.toString(),10))throw new yF(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t;var s}function oM(t,e,n,s,r=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(r-1))+1,Math.floor((i+s-1)/s)}function lM(t,e,n,s){if(null==t)return null;if("valid"===s)t=t*e+pD([n-e,0]);else{if("same"!==s)throw new yF(`Unsupport padding mode: ${s}.`);t*=e}return t}function uM(t,e){return TI(()=>(eD(e),"channelsFirst"===e?UE(t,[0,2,3,1]):t))}function cM(t,e){return TI(()=>(eD(e),"channelsFirst"===e?UE(t,[0,2,3,4,1]):t))}function hM(t,e,n,s=[1,1],r="valid",i,a,o=null){return TI(()=>{if(null==i&&(i="channelsLast"),eD(i),3!==t.rank&&4!==t.rank)throw new yF(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new yF(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=uM(t,i);if("causal"===r)throw new bF("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=c.conv2d({x:l,filter:e,strides:s,pad:"same"===r?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=UE(l,[0,3,1,2])),l})}iM.className="Softmax",u.registerClass(iM);class dM extends gO{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",dM.verifyArgs(e),this.rank=t,LF(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new bF(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=aM(e.kernelSize,t,"kernelSize"),this.strides=aM(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,nD(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,eD(this.dataFormat),this.activation=qL(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=ZD(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=KF(e.biasConstraint),this.biasRegularizer=JL(e.biasRegularizer),this.activityRegularizer=JL(e.activityRegularizer),this.dilationRate=aM(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new yF(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new yF(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new yF(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(wF("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!OF(t.kernelSize,"number",1,3))throw new yF(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:HL(this.activation),useBias:this.useBias,biasInitializer:YD(this.biasInitializer),biasRegularizer:YL(this.biasRegularizer),activityRegularizer:YL(this.activityRegularizer),biasConstraint:GF(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class pM extends dM{constructor(t,e){super(t,e),this.kernel=null,pM.verifyArgs(e),this.filters=e.filters,LF(this.filters,"filters"),this.kernelInitializer=ZD(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=KF(e.kernelConstraint),this.kernelRegularizer=JL(e.kernelRegularizer)}build(t){t=aO(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new yF(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return TI(()=>{let e;t=iO(t);const n=null==this.bias?null:this.bias.read(),s=PF(this.activation.getClassName());if(null!=s&&2===this.rank)e=hM(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)e=function(t,e,n,s=1,r="valid",i,a=1){return TI(()=>{if(null==i&&(i="channelsLast"),eD(i),3!==t.shape.length)throw new yF(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new yF(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new yF(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===i&&(t=UE(t,[0,2,1])),"causal"===r)throw new bF("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=fN(t,e,s,"same"===r?"same":"valid","NWC",a);return null!=n&&(o=ED(o,n)),o})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=hM(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new bF("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,s=[1,1,1],r="valid",i,a){return TI(()=>{if(null==i&&(i="channelsLast"),eD(i),4!==t.rank&&5!==t.rank)throw new yF(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new yF(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=cM(t,i);if("causal"===r)throw new bF("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=yN(o,e,s,"same"===r?"same":"valid","NDHWC",a),null!=n&&(o=ED(o,n)),"channelsFirst"===i&&(o=UE(o,[0,4,1,2,3])),o})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=aO(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<n.length;++r){const t=oM(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);e.push(t)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:YD(this.kernelInitializer),kernelRegularizer:YL(this.kernelRegularizer),kernelConstraint:GF(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new yF(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class fM extends pM{constructor(t){super(2,t),fM.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!OF(t.kernelSize,"number",1,2))throw new yF(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}fM.className="Conv2D",u.registerClass(fM);class mM extends pM{constructor(t){super(3,t),mM.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new yF(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}mM.className="Conv3D",u.registerClass(mM);class gM extends fM{constructor(t){if(super(t),this.inputSpec=[new hO({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new yF(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=aO(t)).length)throw new yF("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new yF("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new hO({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return TI(()=>{let e=iO(t);if(4!==e.shape.length)throw new yF(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape;let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const i=n[r],a=this.kernelSize[1],o=this.strides[1],l=[n[0],lM(n[s],this.strides[0],this.kernelSize[0],this.padding),lM(i,o,a,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=UE(e,[0,2,3,1]));let u=gN(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=UE(u,[0,3,1,2])),null!=this.bias&&(u=ED(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(t){const e=(t=aO(t)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const i=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[s]=lM(e[s],o,i,this.padding),e[r]=lM(e[r],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}gM.className="Conv2DTranspose",u.registerClass(gM);class yM extends pM{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new yF("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new yF("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new yF(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=ZD(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=JL(e.depthwiseRegularizer),this.depthwiseConstraint=KF(e.depthwiseConstraint),this.pointwiseInitializer=ZD(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=JL(e.pointwiseRegularizer),this.pointwiseConstraint=KF(e.pointwiseConstraint)}build(t){if((t=aO(t)).length<this.rank+2)throw new yF(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new yF(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.inputSpec=[new hO({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return TI(()=>{let e;if(t=iO(t),1===this.rank)throw new bF("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=UE(t,[0,2,3,1])),e=_E(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=ED(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=UE(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=YD(this.depthwiseInitializer),t.pointwiseInitializer=YD(this.pointwiseInitializer),t.depthwiseRegularizer=YL(this.depthwiseRegularizer),t.pointwiseRegularizer=YL(this.pointwiseRegularizer),t.depthwiseConstraint=GF(this.depthwiseConstraint),t.pointwiseConstraint=GF(this.pointwiseConstraint),t}}yM.className="SeparableConv";class bM extends yM{constructor(t){super(2,t)}}bM.className="SeparableConv2D",u.registerClass(bM);class xM extends pM{constructor(t){super(1,t),xM.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!OF(t.kernelSize,"number",1,1))throw new yF(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}xM.className="Conv1D",u.registerClass(xM);class vM extends gO{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return TI(()=>{if(t=iO(t),"channelsLast"===this.dataFormat){const e=xD(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return xD(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=xD(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return xD(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}vM.className="Cropping2D",u.registerClass(vM);class wM extends gO{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,DF(QF,"InterpolationFormat",this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return TI(()=>{let e=iO(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=UE(e,[0,2,3,1]);const t=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s]);return UE(r,[0,3,1,2])}{const t=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?e.resizeNearestNeighbor([t,s]):e.resizeBilinear([t,s])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}wM.className="UpSampling2D",u.registerClass(wM);class _M extends dM{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=ZD(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=KF(t.depthwiseConstraint),this.depthwiseRegularizer=JL(t.depthwiseRegularizer)}build(t){if((t=aO(t)).length<4)throw new yF(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new yF(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return TI(()=>{let e=function(t,e,n=[1,1],s="valid",r,i){return TI(()=>{null==r&&(r="channelsLast"),eD(r);let a=uM(t,r);if(4!==t.rank)throw new yF(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new yF(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=bN(a,e,n,"same"===s?"same":"valid","NHWC",i),"channelsFirst"===r&&(a=UE(a,[0,3,1,2])),a})}(t=iO(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=ED(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=aO(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=oM("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),r=oM(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,s,r]:[t[0],s,r,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=YD(this.depthwiseInitializer),t.depthwiseRegularizer=YL(this.depthwiseRegularizer),t.depthwiseConstraint=GF(this.depthwiseRegularizer),t}}function kM(t,e,n,s){if(Array.isArray(t)){if(null!=e||null!=n)throw new yF("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:n=r(n)}}function SM(t,e,n,s=!1,r,i,a=!1,o=!1){return TI(()=>{const l=e.shape.length;if(l<3)throw new yF(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(fD(2,l));if(e=UE(e,u),null!=i)throw new bF("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=r.asType("bool").asType("float32")).rank===l-1&&(r=IN(r,-1)),r=UE(r,u)),s&&(e=vE(e,0),null!=r&&(r=vE(r,0)));const c=[];let h,d=n;const p=e.shape[0],f=zE(e);let m,g;null!=r&&(m=zE(r));for(let e=0;e<p;++e){const n=f[e],s=TI(()=>t(n,d));if(null==r)h=s[0],d=s[1];else{const t=TI(()=>{const t=m[e],n=cE(t).sub(t);return{output:s[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,r)=>s[1][r].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}o&&c.push(h)}return o&&(g=DE(c,1)),[h,g,d]})}_M.className="DepthwiseConv2D",u.registerClass(_M);class CM extends gO{constructor(t){let e;if(super(t),null==t.cell)throw new yF("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new FM({cells:t.cell}):t.cell,null==e.stateSize)throw new yF("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new hO({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?fD(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){sO(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let s;if(s=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const s of e)n.push([t[0],s]);return[s].concat(n)}return s}computeMask(t,e){return TI(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new bF("Constants support is not implemented in RNN yet.");sO(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new hO({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let i;if(this.cell.build(r),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!s.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),i))throw new yF(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(t=>new hO({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){TI(()=>{if(!this.stateful)throw new mF("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new yF("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>lE([n,t])):[lE([n,this.cell.stateSize])];else if(null==t)AI(this.states_),null!=this.keptStates&&(AI(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>lE([n,t])):this.states_[0]=lE([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new yF(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):AI(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,a=[n,i];if(!s.arraysEqual(r.shape,a))throw new yF(`State ${e} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map(t=>$I(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=kM(t,n,s,this.numConstants);t=r.inputs,n=r.initialState,s=r.constants;let i=[],a=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new hO({shape:t.shape}));a=a.concat(this.stateSpec)}if(null!=s&&(e.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof dO){const n=[t].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,e);return this.inputSpec=r,o}return super.apply(t,e)}call(t,e){return TI(()=>{const n=null==e?null:e.mask,s=null==e?null:e.training;let r=null==e?null:e.initialState;t=iO(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==i)throw new yF(`RNN Layer has ${i} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},o=SM((t,e)=>{const n=this.cell.call([t].concat(e),a);return[n[0],n.slice(1)]},t,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,s);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(t){return TI(()=>{let e=lE(t.shape);return e=BN(e,[1,2]),e=gD(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?_D(e,[1,t]):e):this.cell.stateSize>1?[_D(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===CM.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const s=AO(e.cell,n);return new t(Object.assign(e,{cell:s}))}}CM.className="RNN",u.registerClass(CM);class IM extends gO{}class NM extends IM{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,LF(this.units,"units"),this.activation=qL(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=ZD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ZD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ZD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=JL(t.kernelRegularizer),this.recurrentRegularizer=JL(t.recurrentRegularizer),this.biasRegularizer=JL(t.biasRegularizer),this.kernelConstraint=KF(t.kernelConstraint),this.recurrentConstraint=KF(t.recurrentConstraint),this.biasConstraint=KF(t.biasConstraint),this.dropout=dD([1,pD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=dD([1,pD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=aO(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return TI(()=>{if(2!==(t=t).length)throw new yF(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const s=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DM({ones:()=>cE(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DM({ones:()=>cE(n),rate:this.recurrentDropout,training:s}));const i=this.dropoutMask,a=this.recurrentDropoutMask;r=SD(null!=i?PN(t,i):t,this.kernel.read()),null!=this.bias&&(r=ED(r,this.bias.read())),null!=a&&(n=PN(n,a));let o=MI(r,SD(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:HL(this.activation),useBias:this.useBias,kernelInitializer:YD(this.kernelInitializer),recurrentInitializer:YD(this.recurrentInitializer),biasInitializer:YD(this.biasInitializer),kernelRegularizer:YL(this.kernelRegularizer),recurrentRegularizer:YL(this.recurrentRegularizer),biasRegularizer:YL(this.biasRegularizer),activityRegularizer:YL(this.activityRegularizer),kernelConstraint:GF(this.kernelConstraint),recurrentConstraint:GF(this.recurrentConstraint),biasConstraint:GF(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}NM.className="SimpleRNNCell",u.registerClass(NM);class EM extends CM{constructor(t){t.cell=new NM(t),super(t)}call(t,e){return TI(()=>(null!=this.cell.dropoutMask&&(AI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(AI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return new t(e)}}EM.className="SimpleRNN",u.registerClass(EM);class TM extends IM{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new yF("GRUCell does not support reset_after parameter set to true.");this.units=t.units,LF(this.units,"units"),this.activation=qL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=qL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=ZD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ZD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ZD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=JL(t.kernelRegularizer),this.recurrentRegularizer=JL(t.recurrentRegularizer),this.biasRegularizer=JL(t.biasRegularizer),this.kernelConstraint=KF(t.kernelConstraint),this.recurrentConstraint=KF(t.recurrentConstraint),this.biasConstraint=KF(t.biasConstraint),this.dropout=dD([1,pD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=dD([1,pD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=aO(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return TI(()=>{if(2!==(t=t).length)throw new yF(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DM({ones:()=>cE(t),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DM({ones:()=>cE(s),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let i,a,o;0<this.dropout&&this.dropout<1&&(t=PN(t,this.dropoutMask[0]));let l=SD(t,this.kernel.read());this.useBias&&(l=ED(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=PN(s,r[0]));const u=this.recurrentKernel.read(),[c,h]=$E(u,[2*this.units,this.units],u.rank-1),d=SD(s,c),[p,f,m]=$E(l,3,l.rank-1),[g,y]=$E(d,2,d.rank-1);i=this.recurrentActivation.apply(MI(p,g)),a=this.recurrentActivation.apply(MI(f,y));const b=SD(PN(a,s),h);o=this.activation.apply(MI(m,b));const x=MI(PN(i,s),PN(MI(1,iE(i)),o));return[x,x]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:HL(this.activation),recurrentActivation:HL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:YD(this.kernelInitializer),recurrentInitializer:YD(this.recurrentInitializer),biasInitializer:YD(this.biasInitializer),kernelRegularizer:YL(this.kernelRegularizer),recurrentRegularizer:YL(this.recurrentRegularizer),biasRegularizer:YL(this.biasRegularizer),activityRegularizer:YL(this.activityRegularizer),kernelConstraint:GF(this.kernelConstraint),recurrentConstraint:GF(this.recurrentConstraint),biasConstraint:GF(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}TM.className="GRUCell",u.registerClass(TM);class AM extends CM{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new TM(t),super(t)}call(t,e){return TI(()=>(null!=this.cell.dropoutMask&&(AI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(AI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}AM.className="GRU",u.registerClass(AM);class $M extends IM{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,LF(this.units,"units"),this.activation=qL(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=qL(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=ZD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ZD(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ZD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=JL(t.kernelRegularizer),this.recurrentRegularizer=JL(t.recurrentRegularizer),this.biasRegularizer=JL(t.biasRegularizer),this.kernelConstraint=KF(t.kernelConstraint),this.recurrentConstraint=KF(t.recurrentConstraint),this.biasConstraint=KF(t.biasConstraint),this.dropout=dD([1,pD([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=dD([1,pD([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=aO(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,s=this.units;n=new((e=class extends FD{apply(e,n){const r=t.apply([s]),i=(new OD).apply([s]),a=t.apply([2*s]);return wD(wD(r,i),a)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return TI(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new yF(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DM({ones:()=>cE(t),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DM({ones:()=>cE(s),rate:this.recurrentDropout,training:n,count:4}));const i=this.recurrentDropoutMask;let a,o,l,u;0<this.dropout&&this.dropout<1&&(t=PN(t,this.dropoutMask[0]));let c=SD(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=PN(s,i[0])),c=MI(c,SD(s,this.recurrentKernel.read())),this.useBias&&(c=ED(c,this.bias.read()));const[h,d,p,f]=$E(c,4,c.rank-1);a=this.recurrentActivation.apply(h),o=this.recurrentActivation.apply(d),l=MI(PN(o,r),PN(a,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=PN(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:HL(this.activation),recurrentActivation:HL(this.recurrentActivation),useBias:this.useBias,kernelInitializer:YD(this.kernelInitializer),recurrentInitializer:YD(this.recurrentInitializer),biasInitializer:YD(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:YL(this.kernelRegularizer),recurrentRegularizer:YL(this.recurrentRegularizer),biasRegularizer:YL(this.biasRegularizer),activityRegularizer:YL(this.activityRegularizer),kernelConstraint:GF(this.kernelConstraint),recurrentConstraint:GF(this.recurrentConstraint),biasConstraint:GF(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}$M.className="LSTMCell",u.registerClass($M);class RM extends CM{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new $M(t),super(t)}call(t,e){return TI(()=>(null!=this.cell.dropoutMask&&(AI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(AI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}RM.className="LSTM",u.registerClass(RM);class FM extends IM{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return TI(()=>{let n=(t=t).slice(1);const s=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?s.push(n.splice(0,t.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let i;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=s[a],i=0===a?[t[0]].concat(n):[i[0]].concat(n),i=o.call(i,e),r.push(i.slice(1))}n=[];for(const t of r.slice().reverse())n.push(...t);return[i[0]].concat(n)})}build(t){let e;sO(t)&&(t=t[0]),t=t,this.cells.forEach((n,s)=>{iD(`RNNCell_${s}`,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}));return Object.assign({},t,{cells:e})}static fromConfig(t,e,n={}){const s=[];for(const r of e.cells)s.push(AO(r,n));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return uO(t)}setWeights(t){const e=[];for(const n of this.cells){const s=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],s[t]])}cO(e)}}function DM(t){const{ones:e,rate:n,training:s=!1,count:r=1}=t,i=()=>TD(e(),n),a=()=>AD(i,e,s);return!r||r<=1?$I(a().clone()):Array(r).fill(void 0).map(a).map(t=>$I(t.clone()))}var OM,LM;FM.className="StackedRNNCells",u.registerClass(FM);class MM extends CM{constructor(t){if(t.unroll)throw new bF("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new bF("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new hO({ndim:5})]}call(t,e){return TI(()=>{if(null!=this.cell.dropoutMask&&(AI(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(AI(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new yF("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return TI(()=>{const{stateSize:e}=this.cell,n=this.computeSingleOutputShape(t.shape),s=lE([n[0],...n.slice(2)]);return Array.isArray(e)?Array(e.length).fill(s):[s]})}resetStates(t,e=!1){TI(()=>{if(!this.stateful)throw new mF("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(null==n[0])throw new yF("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>lE(i)):[lE(i)];else if(null==t)AI(this.states_),null!=this.keptStates&&(AI(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>lE(i)):this.states_[0]=lE(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new yF(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):AI(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=i;if(!s.arraysEqual(n.shape,r))throw new yF(`State ${e} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map(t=>$I(t.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:s,padding:r,strides:i,dilationRate:a}=this.cell,o="channelsFirst"===e,l=t[o?4:3],u=oM(t[o?3:2],s[0],r,i[0],a[0]),c=oM(l,s[1],r,i[1],a[1]);return[...t.slice(0,2),...o?[n,u,c]:[u,c,n]]}}MM.className="ConvRNN2D";class PM extends $M{constructor(t){const{filters:e,kernelSize:n,strides:s,padding:r,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,LF(this.filters,"filters"),this.kernelSize=aM(n,2,"kernelSize"),this.kernelSize.forEach(t=>LF(t,"kernelSize")),this.strides=aM(s||1,2,"strides"),this.strides.forEach(t=>LF(t,"strides")),this.padding=r||"valid",nD(this.padding),this.dataFormat=i||"channelsLast",eD(this.dataFormat),this.dilationRate=aM(a||1,2,"dilationRate"),this.dilationRate.forEach(t=>LF(t,"dilationRate"))}build(t){var e;t=aO(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new yF(`The channel dimension of the input should be defined. Found ${t[n]}`);const s=this.kernelSize.concat([t[n],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;t=new((e=class extends FD{apply(t,e){return vD([n.apply([s]),uE([s]),n.apply([2*s])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return TI(()=>{if(3!==t.length)throw new yF(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,s=t[0],r=t[1],i=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=DM({ones:()=>cE(s),rate:this.dropout,training:n,count:4}));const a=this.dropoutMask,o=(t,e,n)=>e&&e[n]?PN(e[n],t):t;let l=o(s,a,0),u=o(s,a,1),c=o(s,a,2),h=o(s,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=DM({ones:()=>cE(r),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=o(r,d,0),f=o(r,d,1),m=o(r,d,2),g=o(r,d,3);const[y,b,x,v]=$E(this.kernel.read(),4,3),[w,_,k,S]=this.useBias?$E(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,_,this.padding),c=this.inputConv(c,x,k,this.padding),h=this.inputConv(h,v,S,this.padding);const[C,I,N,E]=$E(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,I),m=this.recurrentConv(m,N),g=this.recurrentConv(g,E);const T=this.recurrentActivation.apply(MI(l,p)),A=this.recurrentActivation.apply(MI(u,f)),$=MI(PN(A,i),PN(T,this.activation.apply(MI(c,m)))),R=PN(this.recurrentActivation.apply(MI(h,g)),this.activation.apply($));return[R,R,$]})}getConfig(){const t=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},t,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(t,e,n,s){const r=pN(t,e,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?ED(r,n,this.dataFormat):r}recurrentConv(t,e){return pN(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}PM.className="ConvLSTM2DCell",u.registerClass(PM);class zM extends MM{constructor(t){const e=new PM(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}zM.className="ConvLSTM2D",u.registerClass(zM);class BM extends gO{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?e[s]:this.noiseShape[s]);return n}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,s=this.getNoiseShape(n);return AD(()=>TD(n,this.rate,s,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}BM.className="Dropout",u.registerClass(BM);class VM extends BM{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}VM.className="SpatialDropout1D",u.registerClass(VM);class WM extends gO{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,LF(this.units,"units"),this.activation=qL(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=ZD(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ZD(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=KF(t.kernelConstraint),this.biasConstraint=KF(t.biasConstraint),this.kernelRegularizer=JL(t.kernelRegularizer),this.biasRegularizer=JL(t.biasRegularizer),this.activityRegularizer=JL(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=aO(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=aO(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t),s=PF(this.activation.getClassName());let r;return null!=s?r=SD(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=SD(n,this.kernel.read()),null!=this.bias&&(r=ED(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:HL(this.activation),useBias:this.useBias,kernelInitializer:YD(this.kernelInitializer),biasInitializer:YD(this.biasInitializer),kernelRegularizer:YL(this.kernelRegularizer),biasRegularizer:YL(this.biasRegularizer),activityRegularizer:YL(this.activityRegularizer),kernelConstraint:GF(this.kernelConstraint),biasConstraint:GF(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}WM.className="Dense",u.registerClass(WM);class UM extends gO{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=aO(t);for(const e of t.slice(1))if(null==e)throw new yF(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],cD(t,1)]}call(t,e){return TI(()=>{this.invokeCallHook(t,e);let n=iO(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new yF(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],cD(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}UM.className="Flatten",u.registerClass(UM);class jM extends gO{constructor(t){super(t),this.supportsMasking=!0,this.activation=qL(t.activation)}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t);return this.activation.apply(n)})}getConfig(){const t={activation:HL(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}jM.className="Activation",u.registerClass(jM);class HM extends gO{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return TI(()=>{return t=iO(t),e=t,n=this.n,TI(()=>{if(2!==e.shape.length)throw new yF(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return _D(gD(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}HM.className="RepeatVector",u.registerClass(HM);class GM extends gO{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",s=e.slice();let r=1,i=null;for(let o=0;o<s.length;++o){const t=s[o];if(this.isUnknown(t)){if(null!==i)throw new yF("Can only specifiy one unknown dimension.");i=o}else r*=t}const a=cD(t);if(null!==i){if(0===r||a%r!=0)throw new yF(n);s[i]=a/r}else if(a!==r)throw new yF(n);return s}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}GM.className="Reshape",u.registerClass(GM);class qM extends gO{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=fD(1,t.dims.length+1);if(!s.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new hO({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=aO(t)).slice();return this.dims.forEach((n,s)=>{e[s+1]=t[n]}),e}call(t,e){return UE(iO(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}qM.className="Permute",u.registerClass(qM);class KM extends gO{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=iO(t);return zI(aE(n,this.maskValue),-1)}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t),s=zI(aE(n,this.maskValue),-1,!0);return n.mul(s.asType(n.dtype))})}}KM.className="Masking",u.registerClass(KM);class XM extends gO{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(SF(t.inputLength))}this.inputDim=t.inputDim,LF(this.inputDim,"inputDim"),this.outputDim=t.outputDim,LF(this.outputDim,"outputDim"),this.embeddingsInitializer=ZD(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=JL(t.embeddingsRegularizer),this.activityRegularizer=JL(t.activityRegularizer),this.embeddingsConstraint=KF(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return TI(()=>this.maskZero?(t=iO(t),aE(t,WE(t))):null)}computeOutputShape(t){if(t=aO(t),null==this.inputLength)return[...t,this.outputDim];const e=SF(this.inputLength);if(e.length!==t.length-1)throw new yF(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let s=0;s<e.length;++s){const r=e[s],i=t[s+1];if(null!=r&&null!=i&&r!==i)throw new yF(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==r&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return TI(()=>{this.invokeCallHook(t,e);let n=iO(t);return"int32"!==n.dtype&&(n=mD(n,"int32")),CD(this.embeddings.read(),n.as1D()).reshape(aO(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:YD(this.embeddingsInitializer),embeddingsRegularizer:YL(this.embeddingsRegularizer),activityRegularizer:YL(this.activityRegularizer),embeddingsConstraint:GF(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}XM.className="Embedding",u.registerClass(XM);class QM extends gO{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new bF}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const r=t[t.length-e.length+s],i=e[s];if(null==r||null==i||r<0||i<0)n.push(null);else if(1===r)n.push(i);else if(1===i)n.push(r);else{if(r!==i)throw new yF("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(r)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[aO(t)]),(t=t).length<2)throw new yF(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)null!=r&&null!==r[0]&&e.push(r[0]);if(e=RF(e),e.length>1)throw new yF(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const e=null==t[r]?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const s=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==RF(s).length}call(t,e){return TI(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const s=pD(n);for(let n of t){const t=n.rank;for(let e=0;e<s-t;++e)n=gD(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,s=t[0],r=t.slice(1).concat([s]);let a=i.reshape([s].concat(cD(t.slice(1))));a=UE(a,[1,0]),a=a.reshape(r),e.push(a),n=!0}else if(t>1){const s=fD(1,t).concat([0]);e.push(UE(i,s)),n=!0}else e.push(i)}let s=this.mergeFunction(e);const r=s.rank;if(n)if(null==r){const t=s.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));s=UE(s.reshape([-1,e]),[1,0]).reshape(n)}else if(r>1){const t=[r-1].concat(fD(0,r-1));s=UE(s,t)}return s}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const n=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const s of t)null!=s&&null!==s[0]&&n.push(s[0]);return n=RF(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return TI(()=>{if(null==e)return null;if(!Array.isArray(e))throw new yF("`mask` should be an Array");if(!Array.isArray(t))throw new yF("`inputs` should be an Array");if(e.length!==t.length)throw new yF(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:IN(t,0)))[0];for(let t=1;t<e.length-1;++t)n=WN(n,e[t]);return n})}}class YM extends QM{constructor(t){super(t)}mergeFunction(t){return TI(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=MI(e,t[n]);return e})}}YM.className="Add",u.registerClass(YM);class ZM extends QM{constructor(t){super(t)}mergeFunction(t){return TI(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=PN(e,t[n]);return e})}}ZM.className="Multiply",u.registerClass(ZM);class JM extends QM{constructor(t){super(t)}mergeFunction(t){return TI(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=MI(e,t[n]);return PN(1/t.length,e)})}}JM.className="Average",u.registerClass(JM);class tP extends QM{constructor(t){super(t)}mergeFunction(t){return TI(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=HN(e,t[n]);return e})}}tP.className="Maximum",u.registerClass(tP);class eP extends QM{constructor(t){super(t)}mergeFunction(t){return TI(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=KN(e,t[n]);return e})}}eP.className="Minimum",u.registerClass(eP);class nP extends QM{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new yF("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const s of t)if(null!=s){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const e=t[r].slice();e.splice(this.axis,1);let i=!1;for(const t of n)if(s.arraysEqual(t,e)){i=!0;break}i||n.push(e)}if(n.length>1)throw new yF("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return TI(()=>vD(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new yF("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of e.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new yF("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new yF("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new yF(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return TI(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const s=[];for(let i=0;i<t.length;++i)s.push(null==e[i]?cE(t[i]).asType("bool"):e[i].rank<t[i].rank?IN(e[i],-1):e[i]);const r=lN(s,this.axis);return PI(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function sP(t,e){for(;t<0;)t+=e;return t}nP.className="Concatenate",u.registerClass(nP);class rP extends QM{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){s.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new bF("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new yF(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(2!==t.length)throw new yF(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>sP(e,t[n].shape.length)):[sP(this.axes,n.shape.length),sP(this.axes,r.shape.length)],this.normalize&&(n=$O(n,e[0]),r=$O(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new bF("batchDot is not implemented for tensors of 4D or higher rank yet");if(s.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),s.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new bF("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,i=e.shape.length;null==n&&(n=[r-1,i-2]);const a=n;return TI(()=>{let n,s;if(r>i){n=r-i;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(i>r){n=i-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(s=2===t.shape.length&&2===e.shape.length?a[0]===a[1]?t.mul(e).sum(a[0]):t.transpose([1,0]).mul(e).sum(a[1]):t.matMul(e,a[0]!==t.shape.length-1,a[1]===e.shape.length-1),n>0){let t;t=r>i?r+i-3:r-1;const e=[];for(let s=t;s<t+n;++s)e.push(s);s=s.squeeze(e)}return 1===s.shape.length&&(s=s.expandDims(1)),s})}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[sP(this.axes,t.length),sP(this.axes,e.length)],n}computeOutputShape(t){s.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new bF("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const i=e.concat(n);return 1===i.length&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}rP.className="Dot",u.registerClass(rP);class iP extends gO{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t);return AD(()=>kD(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}iP.className="GaussianNoise",u.registerClass(iP);class aP extends gO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return TI(()=>{this.invokeCallHook(t,e);const n=iO(t);return this.rate>0&&this.rate<1?AD(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(kD(n.shape,1,t))},()=>n,e.training||!1):n})}}aP.className="GaussianDropout",u.registerClass(aP);class oP extends gO{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||iO(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return TI(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return AD(()=>{const e=iO(t),s=-1.7580993408473766;let r=FN(bE(n),this.rate);r=mD(r,"float32");const i=((1-this.rate)*(1+this.rate*s**2))**-.5,a=-i*s*this.rate;return e.mul(r).add(r.add(-1).mul(s)).mul(i).add(a)},()=>iO(t),e.training||!1)}return t})}}function lP(t,e,n,s,r,i=.001){let a;if(2===t.rank)a=rN(t,e,n,s,r,i);else if(3===t.rank)a=iN(t,e,n,s,r,i);else{if(4!==t.rank)throw new bF(`batchNormalization is not implemented for array of rank ${t.rank} yet`);a=aN(t,e,n,s,r,i)}return a}oP.className="AlphaDropout",u.registerClass(oP);class uP extends gO{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=ZD(t.betaInitializer||"zeros"),this.gammaInitializer=ZD(t.gammaInitializer||"ones"),this.movingMeanInitializer=ZD(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ZD(t.movingVarianceInitializer||"ones"),this.betaConstraint=KF(t.betaConstraint),this.gammaConstraint=KF(t.gammaConstraint),this.betaRegularizer=JL(t.betaRegularizer),this.gammaRegularizer=JL(t.gammaRegularizer)}build(t){t=aO(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new yF(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new hO({ndim:t.length,axes:{[e]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return TI(()=>{const n=null!=e.training&&e.training,r=iO(t),i=r.shape,a=i.length,o=fD(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const u=vF(1,a);u[l]=i[l];const c=o.slice();c.sort();const h=!s.arraysEqual(c,fD(0,a).slice(0,a-1));if(!n)return(()=>{if(h){const t=this.movingMean.read().reshape(u),e=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,s=this.scale?this.gamma.read().reshape(u):null;return lP(r,t,e,n,s,this.epsilon)}return lP(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(t,e,n,r,i=.001){return s.arraysEqual(r.slice().sort(),fD(0,t.rank-1))?function(t,e,n,s,r=.001){return TI(()=>{const i=rE(t,s),a=i.mean,o=i.variance;return[lP(t,a,o,n,e,r),a,o]})}(t,e,n,r,i):function(t,e,n,s,r=.001){return TI(()=>{const i=rE(t,s),a=i.mean,o=i.variance,l=[];for(const e of fD(0,t.rank))-1!==s.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=a.reshape(l),c=o.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[lP(t,u,c,d,h,r),a,o]})}(t,e,n,r,i)}(r,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(t,e,n)=>{TI(()=>{const s=1-n,r=t.read(),i=r.sub(e).mul(s);t.write(r.sub(i))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:YD(this.betaInitializer),gammaInitializer:YD(this.gammaInitializer),movingMeanInitializer:YD(this.movingMeanInitializer),movingVarianceInitializer:YD(this.movingVarianceInitializer),betaRegularizer:YL(this.betaRegularizer),gammaRegularizer:YL(this.gammaRegularizer),betaConstraint:GF(this.betaConstraint),gammaConstraint:GF(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}uP.className="BatchNormalization",u.registerClass(uP);class cP extends gO{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=ZD(t.betaInitializer||"zeros"),this.gammaInitializer=ZD(t.gammaInitializer||"ones"),this.betaRegularizer=JL(t.betaRegularizer),this.gammaRegularizer=JL(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=aO(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(const s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==RF(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=iO(t),s=n.shape,r=s.length;return TI(()=>{let{mean:t,variance:e}=rE(n,this.axis,!0);const i=vF(1,r);for(const n of this.axis)i[n]=s[n];const a=t=>null!=t&&t.shape.length!==r&&this.axis!==[r-1]?t.reshape(i):t;let o=a(this.gamma.read()),l=a(this.beta.read());const u=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(u.push(s[n]),c.push(1)):(u.push(1),c.push(s[n]));return t=t.tile(u),e=e.tile(u),o=o.tile(c),l=l.tile(c),lP(n,t,e,l,o,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:YD(this.betaInitializer),gammaInitializer:YD(this.gammaInitializer),betaRegularizer:YL(this.betaRegularizer),gammaRegularizer:YL(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}cP.className="LayerNormalization",u.registerClass(cP);class hP extends gO{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new yF(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new yF(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new yF(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new hO({ndim:4})]}computeOutputShape(t){let e,n;return t=aO(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return TI(()=>{return e=iO(t),n=this.padding,s=this.dataFormat,TI(()=>{if(4!==e.rank)throw new yF(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new yF("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new yF(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],hE(e,t)});var e,n,s})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function dP(t,e,n,s,r,i){return TI(()=>{let a;eD(r),sD(i),nD(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=uM(t,r);const o="same"===s?"same":"valid";return a="max"===i?UN(t,e,n,o):eN(t,e,n,o),"channelsFirst"===r&&(a=UE(a,[0,3,1,2])),a})}function pP(t,e,n,s,r,i){return TI(()=>{let a;eD(r),sD(i),nD(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),t=cM(t,r);const o="same"===s?"same":"valid";return a="max"===i?jN(t,e,n,o):nN(t,e,n,o),"channelsFirst"===r&&(a=UE(a,[0,4,1,2,3])),a})}hP.className="ZeroPadding2D",u.registerClass(hP);class fP extends gO{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new yF(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(LF(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new yF(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}LF(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,nD(this.padding),this.inputSpec=[new hO({ndim:3})]}computeOutputShape(t){const e=oM((t=aO(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return TI(()=>{this.invokeCallHook(t,e),t=gD(iO(t),2);const n=this.poolingFunction(iO(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return FE(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class mP extends fP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return eD(r),nD(s),dP(t,e,n,s,r,"max")}}mP.className="MaxPooling1D",u.registerClass(mP);class gP extends fP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return eD(r),nD(s),dP(t,e,n,s,r,"avg")}}gP.className="AveragePooling1D",u.registerClass(gP);class yP extends gO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new yF(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];LF(this.poolSize,"poolSize"),LF(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),nD(this.padding),this.inputSpec=[new hO({ndim:4})]}computeOutputShape(t){t=aO(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=oM(e,this.poolSize[0],this.padding,this.strides[0]),n=oM(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return TI(()=>(this.invokeCallHook(t,e),this.poolingFunction(iO(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class bP extends yP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return eD(r),nD(s),dP(t,e,n,s,r,"max")}}bP.className="MaxPooling2D",u.registerClass(bP);class xP extends yP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return eD(r),nD(s),dP(t,e,n,s,r,"avg")}}xP.className="AveragePooling2D",u.registerClass(xP);class vP extends gO{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new yF(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];LF(this.poolSize,"poolSize"),LF(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),nD(this.padding),this.inputSpec=[new hO({ndim:5})]}computeOutputShape(t){t=aO(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=oM(e,this.poolSize[0],this.padding,this.strides[0]),n=oM(n,this.poolSize[1],this.padding,this.strides[1]),s=oM(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,s]:[t[0],e,n,s,t[4]]}call(t,e){return TI(()=>(this.invokeCallHook(t,e),this.poolingFunction(iO(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class wP extends vP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return eD(r),nD(s),pP(t,e,n,s,r,"max")}}wP.className="MaxPooling3D",u.registerClass(wP);class _P extends vP{constructor(t){super(t)}poolingFunction(t,e,n,s,r){return eD(r),nD(s),pP(t,e,n,s,r,"avg")}}_P.className="AveragePooling3D",u.registerClass(_P);class kP extends gO{constructor(t){super(t),this.inputSpec=[new hO({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new bF}}class SP extends kP{constructor(t){super(t||{})}call(t,e){return TI(()=>{const e=iO(t);return GN(e,1)})}}SP.className="GlobalAveragePooling1D",u.registerClass(SP);class CP extends kP{constructor(t){super(t||{})}call(t,e){return TI(()=>{const e=iO(t);return MN(e,1)})}}CP.className="GlobalMaxPooling1D",u.registerClass(CP);class IP extends gO{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,eD(this.dataFormat),this.inputSpec=[new hO({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new bF}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class NP extends IP{call(t,e){return TI(()=>{const e=iO(t);return GN(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}NP.className="GlobalAveragePooling2D",u.registerClass(NP);class EP extends IP{call(t,e){return TI(()=>{const e=iO(t);return MN(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}EP.className="GlobalMaxPooling2D",u.registerClass(EP);class TP extends gO{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const s=AO(e.layer,n);delete e.layer;const r={layer:s};return Object.assign(r,e),new t(r)}}class AP extends TP{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=aO(t)).length<3)throw new yF(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=aO(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return TI(()=>SM((t,n)=>[iO(this.layer.call(t,e)),[]],t=iO(t),[],!1,null,null,!1,!0)[1])}}AP.className="TimeDistributed",u.registerClass(AP);class $P extends TP{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=AO(n),e.goBackwards=!0!==e.goBackwards;const s={};if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=AO(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,DF(JF,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new bF("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,s,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(s=r.slice(1),e=r[0]):e=r[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[e].concat(s).concat(s.slice()):kF(n)}apply(t,e){let n=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=kM(t,n,s,this.numConstants);if(t=r.inputs,n=r.initialState,s=r.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==s)return super.apply(t,e);const i=[],a=[];if(null!=n){const t=n.length;if(t%2>0)throw new yF("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const s=n.map(t=>new hO({shape:t.shape}));this.forwardLayer.stateSpec=s.slice(0,t/2),this.backwardLayer.stateSpec=s.slice(t/2),a.push(...s)}if(null!=s)throw new bF("Support for constants in Bidirectional layers is not implemented yet.");const o=i[0]instanceof dO;for(const l of i)if(l instanceof dO!==o)throw new yF("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[t].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,e);return this.inputSpec=r,o}return super.apply(t,e)}call(t,e){return TI(()=>{const n=e.initialState;let s,r,i,a;if(null==n)s=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),a=n.slice(n.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:a}))}return this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=vE(r,1)),"concat"===this.mergeMode?a=vD([s,r]):"sum"===this.mergeMode?a=MI(s,r):"ave"===this.mergeMode?a=PN(.5,MI(s,r)):"mul"===this.mergeMode?a=PN(s,r):null==this.mergeMode&&(a=[s,r]),this.returnState?null==this.mergeMode?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){iD(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),iD(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=AO(e.layer);if(delete e.layer,null!=e.numConstants)throw new bF("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=e;return s.layer=n,new t(s)}}$P.className="Bidirectional",u.registerClass($P),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(OM||(OM={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(LM||(LM={}));const RP=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],FP=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DP=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],OP=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],LP=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],MP=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],PP=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],zP=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],BP=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],VP=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],WP=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UP=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jP=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],HP=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],GP=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],qP=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],KP=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];function XP(t,e,n=new Map,s=new Set){if(null==t)return null;if(s.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(JP(t)){const r=Array.isArray(t)?[]:{};s.add(t);for(const i in t){const a=XP(t[i],e,n,s);r[i]=a}return s.delete(t),r}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,r.value),r.value}function QP(t,e=ZP){return YP(t,e)}function YP(t,e,n=new Set){const s=t[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(JP(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const i in s){const s=YP(t.map(t=>t[i]),e,n);r[i]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function ZP(t){return null===t?null:JP(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function JP(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof yS))}function tz(t){return XP(t,ez)}function ez(t){return t instanceof yS?{value:t.clone(),recurse:!1}:JP(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}qS({addN_:function(t){J_(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),J_(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((t,e)=>HS(t,`tensors${e}`,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!ik(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),MS.runKernel("AddN",e)}}),qS({maxPoolWithArgmax_:function(t,e,n,s,r=!1){const i=HS(t,"x","maxPoolWithArgmax"),a=MS.runKernel("MaxPoolWithArgmax",{x:i},{filterSize:e,strides:n,pad:s,includeBatchInIndex:r});return{result:a[0],indexes:a[1]}}}),qS({multinomial_:function(t,e,n,s=!1){const r=HS(t,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const o=1===a?tN(r,[1,-1]):r,l=MS.runKernel("Multinomial",{logits:o},{numSamples:e,seed:n,normalized:s});return 1===a?tN(l,[l.size]):l}}),qS({sparseToDense_:function(t,e,n,s=0){const r=HS(t,"sparseIndices","sparseToDense","int32"),i=HS(e,"sparseValues","sparseToDense"),a=HS(s,"defaultValue","sparseToDense",i.dtype);return function(t,e,n,s){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,i=t.rank>1?t.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);if(0!==e.rank&&(1!==e.rank||e.size!==r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,i,n,a),MS.runKernel("SparseToDense",{sparseIndices:r,sparseValues:i,defaultValue:a},{outputShape:n})}}),qS({bincount_:function(t,e,n){const s=HS(t,"x","bincount"),r=HS(e,"weights","bincount");return J_("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),J_(n>=0,()=>`size must be non-negative, but got ${n}.`),J_(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),MS.runKernel("Bincount",{x:s,weights:r},{size:n})}}),qS({denseBincount_:function(t,e,n,s=!1){const r=HS(t,"x","denseBincount"),i=HS(e,"weights","denseBincount");return J_("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),J_(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),J_(n>=0,()=>`size must be non-negative, but got ${n}.`),J_(i.size===r.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`),MS.runKernel("DenseBincount",{x:r,weights:i},{size:n,binaryOutput:s})}}),qS({scatterND_:function(t,e,n){const s=HS(t,"indices","scatterND","int32"),r=HS(e,"updates","scatterND");return lA(r,s,n),MS.runKernel("ScatterNd",{indices:s,updates:r},{shape:n})}}),qS({gatherND_:function(t,e){const n=HS(e,"indices","gatherND","int32"),s=HS(t,"x","gatherND");return MS.runKernel("GatherNd",{params:s,indices:n})}});class nz{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class sz extends nz{constructor(){super(sz.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let s=0;s<n;s++)e[s]=this.get(this.wrap(this.begin+s));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}sz.INITIAL_CAPACITY=32;class rz{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new pz(this,t)}filter(t){return new hz(this,t)}map(t){return new dz(this,t)}mapAsync(t){return new fz(this,t)}serialMapAsync(t){return new fz(this,t).serial()}flatmap(t){return new gz(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new cz(this,t,e)}columnMajorBatch(t,e=!0,n=ZP){return this.rowMajorBatch(t,e).map(t=>QP(t,n))}concatenate(t,e){return new yz(new iz([this,t]),e)}take(t){return t<0||null==t?this:new uz(this,t)}skip(t){return t<0||null==t?this:new lz(this,t)}prefetch(t){return new xz(this,t)}shuffle(t,e){return new vz(this,t,e)}serial(){return new oz(this)}}class iz extends rz{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:tz(t),done:!1}}}class az extends rz{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class oz extends rz{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class lz extends rz{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;AI(t.value)}return this.upstream.next()}}class uz extends rz{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class cz extends rz{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class hz extends rz{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;AI(t.value)}}}class dz extends rz{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=r.getTensorsInContainer(t.value),n=this.transform(t.value),s=r.getTensorsInContainer(n);for(const i of e)r.isTensorInList(i,s)||i.dispose();return{value:n,done:!1}}}class pz extends rz{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class fz extends rz{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=r.getTensorsInContainer(t.value),n=await this.transform(t.value),s=r.getTensorsInContainer(n);for(const i of e)r.isTensorInList(i,s)||i.dispose();return{value:n,done:!1}}}class mz extends rz{constructor(){super(),this.outputQueue=new sz,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class gz extends mz{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=r.getTensorsInContainer(t.value),n=this.transform(t.value),s=r.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const i of e)r.isTensorInList(i,s)||i.dispose();return!0}}class yz extends rz{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var bz;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(bz||(bz={}));class xz extends rz{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new nz(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class vz extends xz{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=fE.alea(n||s.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class wz{constructor(){this.size=null}batch(t,e=!0){const n=this;let r;return s.assert(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),_z(async()=>(await n.iterator()).columnMajorBatch(t,e,kz),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,_z(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,_z(async()=>(await e.iterator()).filter(e=>TI(()=>t(e))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return _z(async()=>(await e.iterator()).map(e=>TI(()=>t(e))),this.size)}mapAsync(t){const e=this;return _z(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return _z(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,_z(async()=>{return n=(s=async()=>({value:await e.iterator(),done:!1}),new az(s)).take(t),new yz(n,undefined);var n,s},n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,_z(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=fE.alea(e||s.now().toString());return _z(async()=>{let e=i.int32();return n&&(e+=i.int32()),(await r.iterator()).shuffle(t,e.toString())},this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,_z(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function _z(t,e=null){return new class extends wz{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function kz(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof yS||s.isTypedArray(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof yS?DE(t):QS(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function Sz(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&s.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the CPU backend.`)})}wz.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const Cz=p.whereImpl;class Iz extends j_{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new U_(this,NI())}nextDataId(){return Iz.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,Bk().get("IS_NODE")&&d.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:n,refCount:1}),s}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&s.isString(n[0])){const i=n.map(t=>s.encodeString(t));r=this.write(i,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,s,r){this.data.set(t,{values:e,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){const t=this.readSync(n.real.dataId),e=this.readSync(n.imag.dataId);return d.mergeRealAndImagArrays(t,e)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>s.decodeString(t))}catch(SY){throw new Error("Failed to decode encoded string bytes into utf-8")}return MC(t.shape,t.dtype,n)}makeOutput(t,e,n){const s=this.write(t,e,n);return NI().makeTensorFromDataId(s,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=s.now();return t(),{kernelMs:s.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Sz([t],"where");const e=this.readSync(t.dataId);return Cz(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function Nz(t,e,n){return({inputs:r,attrs:i,backend:a})=>{const{x:o}=r;if(Sz(o,t),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const l=a,u=l.data.get(o.dataId).values,c=s.sizeFromShape(o.shape),h=n||o.dtype,d=s.getArrayFromDType(h,c);for(let t=0;t<c;++t)d[t]=e(u[t],i);return l.makeTensorInfo(o.shape,h,d)}}function Ez(t,e,n){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;if(Sz(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,l=o.data.get(a.dataId).values,u=n||a.dtype,c=e(l,u,r);return o.makeTensorInfo(a.shape,u,c)}}Iz.nextDataId=0,RI("cpu",()=>new Iz,1);const Tz=Nz("Elu",t=>t>=0?t:Math.exp(t)-1),Az={kernelName:"Elu",backendName:"cpu",kernelFunc:Tz};function $z(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Rz={kernelName:"Identity",backendName:"cpu",kernelFunc:$z};function Fz(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:a}=r;Sz([i],"leakyRelu");const o=s.sizeFromShape(i.shape),l=n.data.get(i.dataId).values,u=s.getTypedArrayFromDType("float32",o);for(let s=0;s<l.length;s++)u[s]=l[s]<0?a*l[s]:l[s];return n.makeTensorInfo(i.shape,"float32",u)}const Dz={kernelName:"LeakyRelu",backendName:"cpu",kernelFunc:Fz};function Oz(t){return(e,n,r,i,a)=>{const o=d.assertAndGetBroadcastShape(e,n),l=o.length,u=s.computeStrides(o),c=s.sizeFromShape(o),h=s.getTypedArrayFromDType(a,c),p=e.length,f=n.length,m=s.computeStrides(e),g=s.computeStrides(n),y=d.getBroadcastDims(e,o),b=d.getBroadcastDims(n,o);if(y.length+b.length===0)for(let s=0;s<h.length;++s)h[s]=t(r[s%r.length],i[s%i.length]);else for(let d=0;d<h.length;++d){const e=s.indexToLoc(d,l,u),n=e.slice(-p);y.forEach(t=>n[t]=0);const a=s.locToIndex(n,p,m),o=e.slice(-f);b.forEach(t=>o[t]=0);const c=s.locToIndex(o,f,g);h[d]=t(r[a],i[c])}return[h,o]}}const Lz=Oz((t,e)=>t<0?e*t:t);function Mz(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;Sz([s,r],"prelu");const i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,[o,l]=Lz(s.shape,r.shape,i,a,s.dtype);return n.makeTensorInfo(l,s.dtype,o)}const Pz={kernelName:"Prelu",backendName:"cpu",kernelFunc:Mz},zz=Nz("Relu",t=>Math.max(0,t)),Bz={kernelName:"Relu",backendName:"cpu",kernelFunc:zz},Vz=Nz("Relu6",t=>Math.min(Math.max(0,t),6)),Wz={kernelName:"Relu6",backendName:"cpu",kernelFunc:Vz};function Uz(t,e,n,s,r){if("linear"===n)return $z({inputs:{x:e},backend:t});if("relu"===n)return zz({inputs:{x:e},backend:t});if("elu"===n)return Tz({inputs:{x:e},backend:t});if("relu6"===n)return Vz({inputs:{x:e},backend:t});if("prelu"===n)return Mz({inputs:{x:e,alpha:s},backend:t});if("leakyrelu"===n)return Fz({inputs:{x:e},backend:t,attrs:{alpha:r}});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function jz(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",a)},o}const Hz={kernelName:"Complex",backendName:"cpu",kernelFunc:jz};function Gz(t,e,n="float32"){if("complex64"===n)return jz({inputs:{real:Gz(t,e,"float32"),imag:Gz(t,e,"float32")},backend:t});const r=s.makeZerosTypedArray(s.sizeFromShape(e),n);return t.makeTensorInfo(e,n,r)}function qz(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const Kz={kernelName:"Real",backendName:"cpu",kernelFunc:qz};function Xz(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dtype:a}=r;if("complex64"===a){if("complex64"===i.dtype)return $z({inputs:{x:i},backend:n});const t=Gz(n,i.shape,i.dtype),e=Xz({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),s=jz({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),s}if("complex64"===i.dtype){const t=qz({inputs:{input:i},backend:n}),e=Xz({inputs:{x:t},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(t),e}if(!s.hasEncodingLoss(i.dtype,a)){const t=$z({inputs:{x:i},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:a}}if("int32"===a){const t=n.data.get(i.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(i.shape,"int32",e)}if("bool"===a){const t=n.data.get(i.dataId).values,e=s.toTypedArray([0],i.dtype),[r,a]=Oz((t,e)=>t!==e?1:0)(i.shape,[],t,e,"bool");return n.makeTensorInfo(a,"bool",r)}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}const Qz={kernelName:"Cast",backendName:"cpu",kernelFunc:Xz};function Yz(t,e,n,s){return null==n?({inputs:n,backend:r})=>{const{a:i,b:a}=n,o=r;Sz([i,a],t);const l=o.data.get(i.dataId).values,u=o.data.get(a.dataId).values,c=s||i.dtype,[h,d]=e(i.shape,a.shape,l,u,c);return o.makeTensorInfo(d,c,h)}:({inputs:t,backend:r})=>{const{a:i,b:a}=t,o=r;if("complex64"===i.dtype||"complex64"===a.dtype){const t=Xz({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),e=o.data.get(t.dataId),s=e.complexTensorInfos.imag,r=o.data.get(e.complexTensorInfos.real.dataId).values,l=o.data.get(s.dataId).values,u=Xz({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(u.dataId),h=c.complexTensorInfos.imag,d=o.data.get(c.complexTensorInfos.real.dataId).values,p=o.data.get(h.dataId).values,[f,m,g]=n(i.shape,a.shape,r,l,d,p),y=o.makeTensorInfo(g,"float32",f),b=o.makeTensorInfo(g,"float32",m),x=jz({inputs:{real:y,imag:b},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(u),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(b),x}{const t=o.data.get(i.dataId).values,n=o.data.get(a.dataId).values,r=s||i.dtype,[l,u]=e(i.shape,a.shape,t,n,r);return o.makeTensorInfo(u,r,l)}}}function Zz(t){return(e,n,r,i,a,o)=>{const l=d.assertAndGetBroadcastShape(e,n),u=s.sizeFromShape(l),c=l.length,h=s.computeStrides(l),p=s.getTypedArrayFromDType("float32",u),f=s.getTypedArrayFromDType("float32",u),m=d.getBroadcastDims(e,l),g=d.getBroadcastDims(n,l),y=d.mergeRealAndImagArrays(r,i),b=d.mergeRealAndImagArrays(a,o),x=e.length,v=s.computeStrides(e),w=n.length,_=s.computeStrides(n);if(m.length+g.length===0)for(let s=0;s<p.length;s++){const e=s%y.length,n=s%b.length,r=t(y[2*e],y[2*e+1],b[2*n],b[2*n+1]);p[s]=r.real,f[s]=r.imag}else for(let d=0;d<p.length;d++){const e=s.indexToLoc(d,c,h),n=e.slice(-x);m.forEach(t=>n[t]=0);const r=s.locToIndex(n,x,v),i=e.slice(-w);g.forEach(t=>i[t]=0);const a=s.locToIndex(i,w,_),o=t(y[2*r],y[2*r+1],b[2*a],b[2*a+1]);p[d]=o.real,f[d]=o.imag}return[p,f,l]}}const Jz=Oz((t,e)=>t+e),tB=Zz((t,e,n,s)=>({real:t+n,imag:e+s})),eB=Yz("Add",Jz,tB),nB={kernelName:"Add",backendName:"cpu",kernelFunc:eB};function sB(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:a}=r,o=s.sizeFromShape(i.shape),l=s.inferFromImplicitShape(a,o),u=s.sizeFromShape(l);s.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(i.dataId);const c=n.data.get(i.dataId);if(null!=c.complexTensorInfos){const t=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=l,t.shape=l}return{dataId:i.dataId,shape:l,dtype:i.dtype}}const rB={kernelName:"Reshape",backendName:"cpu",kernelFunc:sB};function iB(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:a}=e,{transposeA:o,transposeB:l}=r;Sz([i,a],"matMul");const u=i.shape.length,c=a.shape.length,h=o?i.shape[u-2]:i.shape[u-1],d=l?a.shape[c-1]:a.shape[c-2],p=o?i.shape[u-1]:i.shape[u-2],f=l?a.shape[c-2]:a.shape[c-1],m=i.shape.slice(0,-2),g=a.shape.slice(0,-2),y=s.sizeFromShape(m),b=s.sizeFromShape(g);s.assert(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const x=(y>b?i.shape.slice(0,-2):a.shape.slice(0,-2)).concat([p,f]);s.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${o} and transposeB=${l} must match.`);const v=l?[b,f,d]:[b,d,f],w=sB({inputs:{x:i},backend:n,attrs:{shape:o?[y,h,p]:[y,p,h]}}),_=sB({inputs:{x:a},backend:n,attrs:{shape:v}}),k=o?w.shape[1]:w.shape[2],S=o?w.shape[2]:w.shape[1],C=l?_.shape[1]:_.shape[2],I=Math.max(y,b),N=n.data.get(w.dataId).values,E=n.data.get(_.dataId).values,T=s.computeStrides(w.shape),A=s.computeStrides(_.shape),[$,R,F]=o?[T[0],1,T[1]]:[T[0],T[1],1],[D,O,L]=l?[1,A[1],A[0]]:[A[1],1,A[0]],M=S*C,P=MC([I,S,C],w.dtype),z=P.values,B=n.blockSize;for(let s=0;s<I;s++)for(let t=0;t<S;t+=B)for(let e=0;e<C;e+=B)for(let n=0;n<k;n+=B){const r=Math.min(t+B,S),i=Math.min(e+B,C),a=Math.min(n+B,k);for(let o=t;o<r;o++)for(let t=e;t<i;t++){let e=0;for(let r=n;r<a;r++){const n=Math.min(s,y-1)*$,i=Math.min(s,b-1)*L;e+=N[n+o*R+r*F]*E[r*D+t*O+i]}z[s*M+(o*C+t)]+=e}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(_),n.makeTensorInfo(x,P.dtype,P.values)}const aB={kernelName:"BatchMatMul",backendName:"cpu",kernelFunc:iB},oB={kernelName:"_FusedMatMul",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=iB({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=eB({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),c&&(f=Uz(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function lB(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const uB={kernelName:"Abs",backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;Sz(e,"abs");let r=new Float32Array(s.sizeFromShape(e.shape));return r=lB(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,"float32")}},cB={kernelName:"Acos",backendName:"cpu",kernelFunc:Nz("Acos",t=>Math.acos(t))},hB={kernelName:"Acosh",backendName:"cpu",kernelFunc:Nz("Acosh",t=>Math.acosh(t))},dB={kernelName:"AddN",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,s=e;Sz(e,"addN");const r=s.map(t=>n.data.get(t.dataId).values),i=MC(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const t=r[o];for(let e=0;e<a.length;e++)a[e]+=t[e]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function pB(t,e,n,r,i){const a=e.length,o=s.sizeFromShape(e),l=s.computeStrides(e),u=s.computeStrides(i),c=s.getTypedArrayFromDType(n,s.sizeFromShape(i));for(let h=0;h<o;++h){const e=s.indexToLoc(h,a,l),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[r[t]];c[s.locToIndex(n,a,u)]=t[h]}return c}function fB(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:i}=n;Sz(r,"transpose");const a=new Array(r.shape.length);for(let l=0;l<a.length;l++)a[l]=r.shape[i[l]];const o=pB(s.data.get(r.dataId).values,r.shape,r.dtype,i,a);return{dataId:s.write(o,a,r.dtype),shape:a,dtype:r.dtype}}const mB={kernelName:"Transpose",backendName:"cpu",kernelFunc:fB},gB={kernelName:"All",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;Sz(i,"all");const l=s.parseAxisParam(a,i.shape);let u=l;const c=d.getAxesPermutation(u,i.shape.length);let h=i;null!=c&&(h=fB({inputs:{x:i},backend:n,attrs:{perm:c}}),u=d.getInnerMostAxes(u.length,i.shape.length)),d.assertAxesAreInnerMostDims("all",u,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,u),m=s.sizeFromShape(f),g=s.makeZerosTypedArray(s.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let s=0;s<g.length;++s){const t=s*m;let e=y[t];for(let n=0;n<m;++n){const s=y[t+n];e=e&&s}g[s]=e}null!=c&&n.disposeIntermediateTensorInfo(h);const b=n.makeTensorInfo(p,h.dtype,g);if(o){const t=sB({inputs:{x:b},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(b),t}return b}},yB={kernelName:"Any",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;Sz(i,"any");const l=s.parseAxisParam(a,i.shape);let u=l;const c=d.getAxesPermutation(u,i.shape.length);let h=i;null!=c&&(h=fB({inputs:{x:i},backend:n,attrs:{perm:c}}),u=d.getInnerMostAxes(u.length,i.shape.length)),d.assertAxesAreInnerMostDims("any",u,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,u),m=s.sizeFromShape(f),g=s.makeZerosTypedArray(s.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let s=0;s<g.length;++s){const t=s*m;let e=y[t];for(let n=0;n<m;++n){const s=y[t+n];e=e||s}g[s]=e}null!=c&&n.disposeIntermediateTensorInfo(h);const b=n.makeTensorInfo(p,h.dtype,g);if(o){const t=sB({inputs:{x:b},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(b),t}return b}},bB={kernelName:"ArgMax",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;Sz(i,"argMax");let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=fB({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],d.assertAxesAreInnerMostDims("argMax",o,u.shape.length);const[h,p]=d.computeOutAndReduceShapes(u.shape,o),f=s.sizeFromShape(h),m=s.makeZerosTypedArray(f,"int32"),g=s.sizeFromShape(p),y=n.data.get(u.dataId).values;for(let s=0;s<m.length;++s){const t=s*g;let e=y[t],n=0;for(let s=0;s<g;++s){const r=y[t+s];r>e&&(e=r,n=s)}m[s]=n}return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(h,"int32",m)}},xB={kernelName:"ArgMin",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;Sz(i,"argMin");let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=fB({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],d.assertAxesAreInnerMostDims("argMin",o,u.shape.length);const[h,p]=d.computeOutAndReduceShapes(u.shape,o),f=s.sizeFromShape(h),m=s.makeZerosTypedArray(f,"int32"),g=s.sizeFromShape(p),y=n.data.get(u.dataId).values;for(let s=0;s<m.length;++s){const t=s*g;let e=y[t],n=0;for(let s=0;s<g;++s){const r=y[t+s];r<e&&(e=r,n=s)}m[s]=n}return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(h,"int32",m)}},vB={kernelName:"Asin",backendName:"cpu",kernelFunc:Nz("Asin",t=>Math.asin(t))},wB={kernelName:"Asinh",backendName:"cpu",kernelFunc:Nz("Asinh",t=>Math.asinh(t))},_B={kernelName:"Atan",backendName:"cpu",kernelFunc:Nz("Atan",t=>Math.atan(t))},kB={kernelName:"Atan2",backendName:"cpu",kernelFunc:Yz("Atan2",Oz((t,e)=>Math.atan2(t,e)))},SB={kernelName:"Atanh",backendName:"cpu",kernelFunc:Nz("Atanh",t=>Math.atanh(t))};function CB(t,e,n,s,r,i){const a=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=MC(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){const e=v*y,n=v*s[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const v=y*a-d,w=Math.max(0,v),_=Math.min(r.inHeight,c+v),k=e+y*b;for(let e=0;e<r.outWidth;++e){const a=e*o-p,c=Math.max(0,a),d=Math.min(r.inWidth,h+a);let y=f,b=0,v=0;for(let e=w;e<_;e+=l){const r=n+e*s[1];for(let e=c;e<d;e+=u){const n=t[r+e*s[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,v++)}if(isNaN(y))break}g[k+e*x+m]="avg"===i?b/v:y}}}return m}function IB(t,e,n,s,r=!1,i=!1){const a=MC(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=MC(e,n,t);for(let g=0;g<s.batchSize;++g)for(let t=0;t<s.inChannels;++t)for(let e=0;e<s.outHeight;++e){const n=e*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(s.inHeight,h+n);for(let o=0;o<s.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const x=Math.min(s.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let e=y;e<b;e+=u){const a=e-n;for(let n=p;n<x;n+=c){const o=n-h,l=m.get(g,e,n,t);l>v&&(v=l,w=r?i?((g*s.inHeight+e)*s.inWidth+n)*s.inChannels+t:(e*s.inWidth+n)*s.inChannels+t:a*d+o)}}a.set(w,g,e,o,t)}}return a}function NB(t,e,n,s,r,i){const a=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=MC(r.outShape,n),v=x.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let C=0;C<r.batchSize;++C){const e=C*w,n=C*s[0];for(let x=0;x<r.inChannels;++x)for(let w=0;w<r.outDepth;++w){const C=w*a-m;let I=C;for(;I<0;)I+=u;const N=Math.min(r.inDepth,d+C),E=e+w*_;for(let e=0;e<r.outHeight;++e){const a=e*o-g;let d=a;for(;d<0;)d+=c;const m=Math.min(r.inHeight,p+a),w=E+e*k;for(let e=0;e<r.outWidth;++e){const a=e*l-y;let o=a;for(;o<0;)o+=h;const p=Math.min(r.inWidth,f+a),g=w+e*S;let _=b,k=0,C=0;for(let e=I;e<N;e+=u){const r=n+e*s[1];for(let e=d;e<m;e+=c){const n=r+e*s[2];for(let e=o;e<p;e+=h){const r=t[n+e*s[3]+x];if("max"===i&&r>_?_=r:"avg"===i&&(k+=r,C++),isNaN(_))break}if(isNaN(_))break}if(isNaN(_))break}v[g+x]="avg"===i?k/C:_}}}}return x}const EB={kernelName:"AvgPool",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Sz(i,"avgPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);let h;if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))h=$z({inputs:{x:i},backend:n});else{const t=n.data.get(i.dataId).values,e=s.computeStrides(i.shape),r=CB(t,0,i.dtype,e,c,"avg");h=n.makeTensorInfo(c.outShape,i.dtype,r.values)}return h}},TB={kernelName:"AvgPool3D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u,dataFormat:c}=r;Sz(i,"avgPool3d");const h=d.computePool3DInfo(i.shape,a,o,1,l,u,c),p=NB(n.data.get(i.dataId).values,0,i.dtype,s.computeStrides(i.shape),h,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}},AB={kernelName:"AvgPool3DGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;Sz([r,i],"avgPool3DGrad");const c=d.computePool3DInfo(i.shape,a,o,1,l,u),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=c.dilationDepth,x=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,_=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=w-1-c.padInfo.front,C=k-1-c.padInfo.left,I=_-1-c.padInfo.top,N=MC(i.shape,"float32"),E=1/(m*g*y),T=n.bufferSync(r);for(let d=0;d<c.batchSize;++d)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-S,i=n-I,a=s-C;let o=0;for(let e=0;e<w;e+=b){const n=(r+e)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let e=0;e<_;e+=x){const s=(i+e)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let e=0;e<k;e+=v){const r=(a+e)/f;r<0||r>=c.outWidth||Math.floor(r)!==r||(o+=T.get(d,n,s,r,t))}}}N.set(o*E,d,e,n,s,t)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}},$B={kernelName:"AvgPoolGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i;Sz([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=d.computePool2DInfo(a.shape,o,l,1,u),h=c.strideHeight,p=c.strideWidth,f=c.filterHeight,m=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterHeight,x=c.effectiveFilterWidth,v=x-1-c.padInfo.left,w=b-1-c.padInfo.top,_=MC(a.shape,"float32"),k=1/(f*m),S=n.data.get(r.dataId).values,C=MC(r.shape,"float32",S);for(let d=0;d<c.batchSize;++d)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inHeight;++e)for(let n=0;n<c.inWidth;++n){const s=e-w,r=n-v;let i=0;for(let e=0;e<b;e+=g){const n=(s+e)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let e=0;e<x;e+=y){const s=(r+e)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(i+=C.get(d,n,s,t))}}_.set(i*k,d,e,n,t)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},RB={kernelName:"FusedBatchNorm",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,scale:a,offset:o,mean:l,variance:u}=e;s.assert(l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),s.assert(null==o||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),s.assert(null==a||l.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Sz([i,l,u,a,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const h=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,p=n.data.get(u.dataId).values,f=a?n.data.get(a.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),y=m.length,b=f.length,x=p.length,v=d.length;let w=0,_=0,k=0,S=0;for(let s=0;s<h.length;++s)g[s]=m[w++]+(h[s]-d[_++])*f[k++]/Math.sqrt(p[S++]+c),w>=y&&(w=0),_>=v&&(_=0),k>=b&&(k=0),S>=x&&(S=0);return n.makeTensorInfo(i.shape,i.dtype,g)}};function FB(t,e,n,r,i){const a=l.isSliceContinous(r,e,n),o=s.sizeFromShape(n),u=s.computeStrides(r);if(a){const n=l.computeFlatOffset(e,u);return"string"===i?t.slice(n,n+o):t.subarray(n,n+o)}const c=MC(r,i,"string"===i?d.fromUint8ToStringArray(t):t),h=MC(n,i);for(let s=0;s<h.size;++s){const t=h.indexToLoc(s),n=t.map((t,n)=>t+e[n]);h.set(c.get(...n),...t)}return"string"===i?d.fromStringArrayToUint8(h.values):h.values}function DB(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,size:a}=s;Sz(r,"slice");const[o,u]=l.parseSliceParams(r,i,a);l.assertParamsValid(r,o,u);const c=FB(n.data.get(r.dataId).values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,c)}const OB={kernelName:"Slice",backendName:"cpu",kernelFunc:DB},LB={kernelName:"BatchToSpaceND",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:i,crops:a}=s;Sz([r],"batchToSpaceND");const o=i.reduce((t,e)=>t*e),l=d.getReshaped(r.shape,i,o),u=d.getPermuted(l.length,i.length),c=d.getReshapedPermuted(r.shape,i,o),h=d.getSliceBeginCoords(a,i.length),p=d.getSliceSize(c,a,i.length),f=sB({inputs:{x:r},backend:n,attrs:{shape:l}}),m=fB({inputs:{x:f},backend:n,attrs:{perm:u}}),g=sB({inputs:{x:m},backend:n,attrs:{shape:c}}),y=DB({inputs:{x:g},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}};function MB(t,e,n,r,i){const a=s.sizeFromShape(r),o=s.makeZerosTypedArray(i,n);for(let s=0;s<t.length;s++){const n=t[s];if(n<0)throw new Error("Input x must be non-negative!");n>=i||(o[n]+=a>0?e[s]:1)}return o}function PB(t,e,n,s=!1){const r=t.shape[0],i=t.shape[1],a=MC([r,n],e.dtype);for(let o=0;o<r;o++)for(let r=0;r<i;r++){const i=t.get(o,r);if(i<0)throw new Error("Input x must be non-negative!");i>=n||a.set(s?1:e.size>0?a.get(o,i)+e.get(o,r):a.get(o,i)+1,o,i)}return a}const zB={kernelName:"Bincount",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a}=s,o=MB(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,o)}};function BB(t){return(e,n,r)=>{const i=s.getTypedArrayFromDType(n,e.length);for(let s=0;s<e.length;++s)i[s]=t(e[s],r);return i}}const VB=BB(t=>Math.ceil(t)),WB={kernelName:"Ceil",backendName:"cpu",kernelFunc:Ez("Ceil",VB)},UB={kernelName:"ClipByValue",backendName:"cpu",kernelFunc:Nz("ClipByValue",(t,e)=>t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t)},jB={kernelName:"ComplexAbs",backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(s.sizeFromShape(e.shape)),i=n.data.get(e.dataId),a=i.complexTensorInfos.imag,o=n.data.get(i.complexTensorInfos.real.dataId).values,l=n.data.get(a.dataId).values;for(let s=0;s<o.length;s++)r[s]=Math.hypot(o[s],l[s]);return n.makeOutput(r,e.shape,"float32")}};function HB(t,e,n,r){const i=s.getArrayFromDType(n,s.sizeFromShape(e));if(r&&"string"!==n){let e=0;t.forEach(t=>{const n=s.sizeFromShape(t.shape);i.set(t.vals,e),e+=n})}else{let s=0;t.forEach(t=>{const r="string"===n?d.fromUint8ToStringArray(t.vals):t.vals;let a=0;for(let n=0;n<t.shape[0];++n){const o=n*e[1]+s;for(let e=0;e<t.shape[1];++e)i[o+e]=r[a++]}s+=t.shape[1]})}return i}function GB(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const qB={kernelName:"Imag",backendName:"cpu",kernelFunc:GB};function KB(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,a=s.parseAxisParam(i,e[0].shape)[0];let o=d.computeOutShape(e.map(t=>t.shape),a);if(0===s.sizeFromShape(o))return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(t=>s.sizeFromShape(t.shape)>0);if(1===l.length)return $z({inputs:{x:l[0]},backend:n});const u=l.map(t=>t.shape);if(d.assertParamsConsistent(u,a),"complex64"===l[0].dtype){const t=l.map(t=>qz({inputs:{input:t},backend:n})),e=l.map(t=>GB({inputs:{input:t},backend:n})),s=KB({inputs:t,backend:n,attrs:{axis:a}}),r=KB({inputs:e,backend:n,attrs:{axis:a}}),i=jz({inputs:{real:s,imag:r},backend:n});return t.forEach(t=>n.disposeIntermediateTensorInfo(t)),e.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}const c=l.map(t=>{const e=s.sizeFromShape(t.shape.slice(a));return sB({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})}),h=c.map(t=>({vals:n.data.get(t.dataId).values,shape:t.shape}));o=d.computeOutShape(c.map(t=>t.shape),1);const p=HB(h,o,e[0].dtype,1===c[0].shape[0]),f=d.computeOutShape(l.map(t=>t.shape),a),m=n.makeTensorInfo(f,e[0].dtype,p);return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),m}const XB={kernelName:"Concat",backendName:"cpu",kernelFunc:KB};function QB(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:h}=r;Sz([i,a],"conv2d");const p=d.convertConv2DDataFormat(u),f=d.computeConv2DInfo(i.shape,a.shape,o,c,l,h,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.dilationHeight,b=f.dilationWidth,x=f.padInfo.left,v=f.padInfo.top,w="channelsLast"===f.dataFormat,_=new pS(f.outShape,i.dtype),k=s.computeStrides(i.shape),S=s.computeStrides(a.shape),C=k[0],I=w?k[1]:k[2],N=w?k[2]:1,E=w?1:k[1],T=_.strides[0],A=w?_.strides[1]:_.strides[2],$=w?_.strides[2]:1,R=w?1:_.strides[1],F=n.data.get(i.dataId).values,D=n.data.get(a.dataId).values,O=_.values;for(let s=0;s<f.batchSize;++s){const t=s*C,e=s*T;for(let n=0;n<f.outHeight;++n){const s=e+n*A,r=n*f.strideHeight-v;for(let e=0;e<m;++e){const n=r+e*y;if(n<0||n>=f.inHeight)continue;const i=e*S[0],a=t+n*I;for(let t=0;t<f.outWidth;++t){const e=s+t*$,n=t*f.strideWidth-x;for(let t=0;t<g;++t){const s=n+t*b;if(s<0||s>=f.inWidth)continue;const r=a+s*N;let o=i+t*S[1];for(let t=0;t<f.inChannels;++t){const n=F[r+t*E];for(let t=0;t<f.outChannels;++t)O[e+t*R]+=n*D[o+t];o+=f.outChannels}}}}}}return n.makeTensorInfo(_.shape,_.dtype,O)}const YB={kernelName:"Conv2D",backendName:"cpu",kernelFunc:QB},ZB={kernelName:"Conv2DBackpropFilter",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;Sz([r,i],"conv2dBackpropFilter");const h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,c,a,1,o,u,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:y}=p,b="channelsLast"===p.dataFormat,x=new pS(p.filterShape,"float32"),v=p.padInfo.left,w=p.padInfo.top,_=n.data.get(r.dataId).values,k=n.data.get(i.dataId).values,S=new pS(r.shape,r.dtype,_),C=new pS(i.shape,i.dtype,k);for(let d=0;d<g;++d){const t=Math.max(0,Math.ceil((w-d)/f)),e=Math.min(p.outHeight,(p.inHeight+w-d)/f);for(let n=0;n<y;++n){const s=Math.max(0,Math.ceil((v-n)/m)),r=Math.min(p.outWidth,(p.inWidth+v-n)/m);for(let i=0;i<p.inChannels;++i)for(let a=0;a<p.outChannels;++a){let o=0;for(let l=0;l<p.batchSize;++l)for(let u=t;u<e;++u){const t=d+u*f-w;for(let e=s;e<r;++e){const s=n+e*m-v;o+=b?S.get(l,t,s,i)*C.get(l,u,e,a):S.get(l,i,t,s)*C.get(l,a,u,e)}}x.set(o,d,n,i,a)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},JB={kernelName:"Conv2DBackpropInput",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:a}=e,{inputShape:o,strides:l,pad:u,dataFormat:c,dimRoundingMode:h}=r;Sz([i,a],"conv2dBackpropInput");const p=s.computeStrides(a.shape),f=s.computeStrides(i.shape);let m=d.convertConv2DDataFormat(c);const g=d.computeConv2DInfo(o,a.shape,l,1,u,h,!1,m),y=new pS(g.inShape,"float32"),b=y.values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,[w,_,k]=p,{batchSize:S,filterHeight:C,filterWidth:I,inChannels:N,inHeight:E,inWidth:T,outChannels:A,outHeight:$,outWidth:R,strideHeight:F,strideWidth:D}=g;m=g.dataFormat;const O=C-1-g.padInfo.top,L=I-1-g.padInfo.left,M="channelsLast"===m,P=y.strides[0],z=M?y.strides[1]:y.strides[2],B=M?y.strides[2]:1,V=M?1:y.strides[1],W=f[0],U=M?f[1]:f[2],j=M?f[2]:1,H=M?1:f[1];for(let s=0;s<S;++s)for(let t=0;t<N;++t)for(let e=0;e<E;++e){const n=e-O,r=Math.max(0,Math.ceil(n/F)),i=Math.min($,(C+n)/F);for(let a=0;a<T;++a){const o=a-L,l=Math.max(0,Math.ceil(o/D)),u=Math.min(R,(I+o)/D);let c=0;for(let e=r;e<i;++e){const r=e*F-n;for(let n=l;n<u;++n){const i=W*s+U*e+j*n,a=w*(C-1-r)+_*(I-1-(n*D-o))+k*t;for(let t=0;t<A;++t)c+=x[i+H*t]*v[a+t]}}b[P*s+z*e+B*a+V*t]=c}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},tV={kernelName:"Conv3D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dilations:u}=r;Sz([i,a],"conv3d");const c=d.computeConv3DInfo(i.shape,a.shape,o,u,l),{filterDepth:h,filterHeight:p,filterWidth:f,dilationDepth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.front,v=b.left,w=b.top,_=new pS(c.outShape,i.dtype),k=n.data.get(i.dataId).values,S=n.data.get(a.dataId).values,C=_.values,I=s.computeStrides(i.shape),N=s.computeStrides(a.shape);for(let s=0;s<c.batchSize;++s){const t=s*I[0],e=s*_.strides[0];for(let n=0;n<c.outDepth;++n){const s=e+n*_.strides[1],r=n*c.strideDepth-x;for(let e=0;e<h;++e){const n=r+e*m;if(n<0||n>=c.inDepth)continue;const i=e*N[0],a=t+n*I[1];for(let t=0;t<c.outHeight;++t){const e=s+t*_.strides[2],n=t*c.strideHeight-w;for(let t=0;t<p;++t){const s=n+t*g;if(s<0||s>=c.inHeight)continue;const r=i+t*N[1],o=a+s*I[2];for(let t=0;t<c.outWidth;++t){const n=e+t*c.outChannels,s=t*c.strideWidth-v;for(let t=0;t<f;++t){const e=s+t*y;if(e<0||e>=c.inWidth)continue;const i=o+e*c.inChannels;let a=r+t*N[2];for(let t=0;t<c.inChannels;++t){const e=k[i+t];for(let t=0;t<c.outChannels;++t)C[n+t]+=e*S[a+t];a+=c.outChannels}}}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},eV={kernelName:"Conv3DBackpropFilterV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:a}=e,{strides:o,pad:l,filterShape:u}=r;Sz([i,a],"conv3dBackpropFilterV2");const c=s.computeStrides(i.shape),h=s.computeStrides(a.shape),p=d.computeConv3DInfo(i.shape,u,o,1,l),f=p.strideDepth,m=p.strideHeight,g=p.strideWidth,y=p.filterDepth,b=p.filterHeight,x=p.filterWidth,v=new pS(p.filterShape,"float32"),w=v.values,[_,k,S,C]=v.strides,I=n.data.get(a.dataId).values,[N,E,T,A]=h,$=n.data.get(i.dataId).values,[R,F,D,O]=c,L=p.padInfo.front,M=p.padInfo.left,P=p.padInfo.top;for(let s=0;s<y;++s){const t=Math.max(0,Math.ceil((L-s)/f)),e=Math.min(p.outDepth,(p.inDepth+L-s)/f),n=s*_;for(let r=0;r<b;++r){const i=Math.max(0,Math.ceil((P-r)/m)),a=Math.min(p.outHeight,(p.inHeight+P-r)/m),o=r*k+n;for(let n=0;n<x;++n){const l=Math.max(0,Math.ceil((M-n)/g)),u=Math.min(p.outWidth,(p.inWidth+M-n)/g),c=n*S+o;for(let o=0;o<p.inChannels;++o){const h=o*C+c;for(let c=0;c<p.outChannels;++c){let d=0;for(let h=0;h<p.batchSize;++h){const p=h*R,y=h*N;for(let h=t;h<e;++h){const t=(s+h*f-L)*F+p,e=h*E+y;for(let s=i;s<a;++s){const i=(r+s*m-P)*D+t,a=s*T+e;for(let t=l;t<u;++t)d+=$[(n+t*g-M)*O+i+o]*I[t*A+a+c]}}}w[h+c]=d}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},nV={kernelName:"Conv3DBackpropInputV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:a}=e,{pad:o,strides:l,inputShape:u}=r;Sz([i],"conv3dBackpropInputV2");const c=s.computeStrides(i.shape),h=s.computeStrides(a.shape),p=d.computeConv3DInfo(u,a.shape,l,1,o),f=new pS(p.inShape,"float32"),m=f.values,[g,y,b,x]=f.strides,v=n.data.get(i.dataId).values,[w,_,k,S]=c,C=n.data.get(a.dataId).values,[I,N,E,T]=h,{batchSize:A,filterDepth:$,filterHeight:R,filterWidth:F,inChannels:D,inDepth:O,inHeight:L,inWidth:M,outChannels:P,outDepth:z,outHeight:B,outWidth:V,strideDepth:W,strideHeight:U,strideWidth:j}=p,H=$-1-p.padInfo.front,G=R-1-p.padInfo.top,q=F-1-p.padInfo.left;for(let s=0;s<A;++s)for(let t=0;t<D;++t)for(let e=0;e<O;++e){const n=e-H,r=Math.max(0,Math.ceil(n/W)),i=Math.min(z,($+n)/W);for(let a=0;a<L;++a){const o=a-G,l=Math.max(0,Math.ceil(o/U)),u=Math.min(B,(R+o)/U);for(let c=0;c<M;++c){const h=c-q,d=Math.max(0,Math.ceil(h/j)),p=Math.min(V,(F+h)/j);let f=0;for(let e=r;e<i;++e){const r=e*W-n;for(let n=l;n<u;++n){const i=n*U-o;for(let a=d;a<p;++a){const o=w*s+_*e+k*n+S*a,l=I*($-1-r)+N*(R-1-i)+E*(F-1-(a*j-h))+T*t;for(let t=0;t<P;++t)f+=v[o+t]*C[l+t]}}}m[g*s+y*e+b*a+x*c+t]=f}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},sV={kernelName:"Cos",backendName:"cpu",kernelFunc:Nz("Cos",t=>Math.cos(t))},rV={kernelName:"Cosh",backendName:"cpu",kernelFunc:Nz("Cosh",t=>Math.cosh(t))},iV={kernelName:"CropAndResize",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:a,boxInd:o}=e,{cropSize:l,method:u,extrapolationValue:c}=r,[h,d,p,f]=i.shape,m=a.shape[0],[g,y]=l,b=MC([m,g,y,f],"float32"),x=n.data.get(a.dataId).values,v=n.data.get(o.dataId).values,w=n.data.get(i.dataId).values,_=s.computeStrides(i.shape),k=s.computeStrides(b.shape);for(let s=0;s<m;s++){const t=4*s,e=x[t],n=x[t+1],r=x[t+2],i=x[t+3],a=v[s];if(a>=h)continue;const o=g>1?(r-e)*(d-1)/(g-1):0,l=y>1?(i-n)*(p-1)/(y-1):0;for(let h=0;h<g;h++){const t=g>1?e*(d-1)+h*o:.5*(e+r)*(d-1);if(t<0||t>d-1)for(let e=0;e<y;e++)for(let t=0;t<f;t++)b.values[t+e*k[2]+h*k[1]+s*k[0]]=c;else if("bilinear"===u){const e=Math.floor(t),r=Math.ceil(t),o=t-e;for(let t=0;t<y;t++){const u=y>1?n*(p-1)+t*l:.5*(n+i)*(p-1);if(u<0||u>p-1){for(let e=0;e<f;e++)b.values[e+t*k[2]+h*k[1]+s*k[0]]=c;continue}const d=Math.floor(u),m=Math.ceil(u),g=u-d;for(let n=0;n<f;n++){let i=n+d*_[2]+e*_[1]+a*_[0];const l=w[i];i=n+m*_[2]+e*_[1]+a*_[0];const u=w[i];i=n+d*_[2]+r*_[1]+a*_[0];const c=w[i];i=n+m*_[2]+r*_[1]+a*_[0];const p=w[i],f=l+(u-l)*g;i=n+t*k[2]+h*k[1]+s*k[0],b.values[i]=f+(c+(p-c)*g-f)*o}}}else for(let e=0;e<y;++e){const r=y>1?n*(p-1)+e*l:.5*(n+i)*(p-1);if(r<0||r>p-1){for(let t=0;t<f;t++)b.values[t+e*k[2]+h*k[1]+s*k[0]]=c;continue}const o=Math.round(r),u=Math.round(t);for(let t=0;t<f;t++)b.values[t+e*k[2]+h*k[1]+s*k[0]]=w[t+o*_[2]+u*_[1]+a*_[0]]}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},aV={kernelName:"Cumsum",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,exclusive:o,reverse:l}=r;Sz(i,"cumsum");const u=d.getAxesPermutation([a],i.shape.length);let c=i;null!=u&&(c=fB({inputs:{x:i},backend:n,attrs:{perm:u}}));const h=d.getInnerMostAxes(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const p=IS(c.dtype,"int32"),f=s.makeZerosTypedArray(s.sizeFromShape(c.shape),p),m=n.data.get(c.dataId).values,g=c.shape[c.shape.length-1],y=l?(t,e)=>t+g-e-1:(t,e)=>t+e;for(let s=0;s<m.length;s+=g)for(let t=0;t<g;t++){const e=y(s,t);if(0===t)f[e]=o?0:m[e];else{const n=y(s,t-1);f[e]=o?m[n]+f[n]:m[e]+f[n]}}const b=n.makeTensorInfo(c.shape,p,f);if(null!=u){const t=fB({inputs:{x:b},backend:n,attrs:{perm:d.getUndoAxesPermutation(u)}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(c),t}return b}},oV={kernelName:"DenseBincount",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const t=MB(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,t)}if(2===r.shape.length){const t=PB(n.bufferSync(r),n.bufferSync(i),a,o);return n.makeTensorInfo(t.shape,i.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},lV={kernelName:"DepthToSpace",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:a,dataFormat:o}=r;s.assert("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`),s.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const l=i.shape[0],u=i.shape[1],c=i.shape[2],h=i.shape[3],d=u*a,p=c*a,f=h/(a*a),m=n.data.get(i.dataId).values,g=new Float32Array(l*d*p*f);let y=0;for(let s=0;s<l;++s)for(let t=0;t<d;++t){const e=Math.floor(t/a),n=t%a;for(let t=0;t<p;++t){const r=Math.floor(t/a),i=(n*a+t%a)*f;for(let t=0;t<f;++t)g[y++]=m[t+i+h*(r+c*(e+u*s))]}}return n.makeTensorInfo([l,d,p,f],i.dtype,g)}};function uV(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dilations:u,dimRoundingMode:c}=r;Sz([i,a],"depthwiseConv2DNative");const h=s.computeStrides(i.shape),p=s.computeStrides(a.shape);let f=u;null==f&&(f=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const m=d.computeConv2DInfo(i.shape,a.shape,o,f,l,c,!0),{filterHeight:g,filterWidth:y,dilationHeight:b,dilationWidth:x,padInfo:v}=m,w=v.left,_=v.top,k=m.outChannels/m.inChannels,S=new pS(m.outShape,i.dtype),C=n.data.get(i.dataId).values,I=n.data.get(a.dataId).values,N=S.values;for(let s=0;s<m.batchSize;++s){const t=s*h[0],e=s*S.strides[0];for(let n=0;n<m.outHeight;++n){const s=e+n*S.strides[1],r=n*m.strideHeight-w;for(let e=0;e<g;++e){const n=r+e*b;if(n<0||n>=m.inHeight)continue;const i=e*p[0],a=t+n*h[1];for(let t=0;t<m.outWidth;++t){const e=s+t*S.strides[2],n=t*m.strideWidth-_;for(let t=0;t<y;++t){const s=n+t*x;if(s<0||s>=m.inWidth)continue;const r=a+s*m.inChannels;let o=e,l=i+t*p[1];for(let t=0;t<m.inChannels;++t){const e=C[r+t];for(let t=0;t<k;++t)N[o+t]+=e*I[l+t];o+=k,l+=k}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const cV={kernelName:"DepthwiseConv2dNative",backendName:"cpu",kernelFunc:uV},hV={kernelName:"DepthwiseConv2dNativeBackpropFilter",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s;Sz([r,i],"depthwiseConv2dNativeBackpropFilter");const h=d.computeConv2DInfo(r.shape,c,a,o,l,u,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=new pS(h.filterShape,"float32"),b=h.padInfo.left,x=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,_=new pS(r.shape,r.dtype,w),k=n.data.get(i.dataId).values,S=new pS(i.shape,i.dtype,k);for(let d=0;d<m;++d){const t=Math.max(0,Math.ceil((x-d)/p)),e=Math.min(h.outHeight,(h.inHeight+x-d)/p);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((b-n)/f)),r=Math.min(h.outWidth,(h.inWidth+b-n)/f);for(let i=0;i<h.outChannels;++i){const a=Math.trunc(i/v),o=i%v;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=t;o<e;++o){const t=d+o*p-x;for(let e=s;e<r;++e)l+=_.get(u,t,n+e*f-b,a)*S.get(u,o,e,i)}y.set(l,d,n,a,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},dV={kernelName:"DepthwiseConv2dNativeBackpropInput",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:a}=e,{strides:o,dilations:l,pad:u,dimRoundingMode:c,inputShape:h}=r;Sz([i,a],"depthwiseConv2DNativeBackpropInput");const p=s.computeStrides(i.shape),f=s.computeStrides(a.shape),m=d.computeConv2DInfo(h,a.shape,o,l,u,c,!0),g=new pS(m.inShape,"float32"),y=g.values,[b,x,v]=g.strides,w=n.data.get(i.dataId).values,[_,k,S]=p,C=n.data.get(a.dataId).values,[I,N,E]=f,{batchSize:T,filterHeight:A,filterWidth:$,inChannels:R,inHeight:F,inWidth:D,outChannels:O,outHeight:L,outWidth:M,strideHeight:P,strideWidth:z}=m,B=A-1-m.padInfo.top,V=$-1-m.padInfo.left,W=O/R;for(let s=0;s<T;++s)for(let t=0;t<R;++t)for(let e=0;e<F;++e){const n=e-B,r=Math.max(0,Math.ceil(n/P)),i=Math.min(L,(A+n)/P);for(let a=0;a<D;++a){const o=a-V,l=Math.max(0,Math.ceil(o/z)),u=Math.min(M,($+o)/z);let c=0;for(let e=r;e<i;++e){const r=e*P-n;for(let n=l;n<u;++n){const i=_*s+k*e+S*n,a=I*(A-1-r)+N*($-1-(n*z-o))+E*t;for(let e=0;e<W;++e)c+=w[i+(t*W+e)]*C[a+e]}}y[b*s+x*e+v*a+t]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},pV={kernelName:"Diag",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=s.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,o=MC([i,i],r.dtype),l=o.values;for(let s=0;s<a.length;s++)l[s*i+s]=a[s];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,o.dtype,o.values)}},fV={kernelName:"Dilation2D",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=u.data.get(r.dataId).values,h=r.shape.length,p=u.data.get(i.dataId).values,f=i.shape.length,{batchSize:m,inHeight:g,inWidth:y,inChannels:b,outHeight:x,outWidth:v,padInfo:w,strideHeight:_,strideWidth:k,filterHeight:S,filterWidth:C,dilationHeight:I,dilationWidth:N,outShape:E}=d.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l),T=s.sizeFromShape(E),A=E.length,$=s.getArrayFromDType(r.dtype,T);for(let d=0;d<m;++d)for(let t=0;t<x;++t){const e=t*_-w.top;for(let n=0;n<v;++n){const a=n*k-w.left;for(let o=0;o<b;++o){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<S;++t){const n=e+t*I;if(n>=0&&n<g)for(let e=0;e<C;++e){const u=a+e*N;if(u>=0&&u<y){const a=s.locToIndex([d,n,u,o],h,s.computeStrides(r.shape)),m=s.locToIndex([t,e,o],f,s.computeStrides(i.shape)),g=c[a]+p[m];g>l&&(l=g)}}}$[s.locToIndex([d,t,n,o],A,s.computeStrides(E))]=l}}}return{dataId:u.write(s.toTypedArray($,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}},mV={kernelName:"Dilation2DBackpropFilter",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i,dy:a}=t,{strides:o,pad:l,dilations:u}=n,c=e,h=s.toNestedArray(r.shape,c.data.get(r.dataId).values),p=s.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:_,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=d.computeDilation2DInfo(r.shape,i.shape,o,l,"NHWC",u);s.assert(a.rank===N.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${N.length}, but got ${a.rank}`);const E=s.toNestedArray(N,c.data.get(a.dataId).values),T=s.makeZerosNestedTypedArray(i.shape,i.dtype);for(let s=0;s<f;++s)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<x;++n){const r=n*_-v.left;for(let i=0;i<y;++i){let a=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<k;++t){const n=e+t*C;if(n>=0&&n<m)for(let e=0;e<S;++e){const u=r+e*I;if(u>=0&&u<g){const r=h[s][n][u][i]+p[t][e][i];r>a&&(a=r,o=t,l=e)}}}T[o][l][i]+=E[s][t][n][i]}}}return{dataId:c.write(s.toTypedArray(T,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},gV={kernelName:"Dilation2DBackpropInput",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i,dy:a}=t,{strides:o,pad:l,dilations:u}=n,c=e,h=s.toNestedArray(r.shape,c.data.get(r.dataId).values),p=s.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:x,padInfo:v,strideHeight:w,strideWidth:_,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:N}=d.computeDilation2DInfo(r.shape,i.shape,o,l,"NHWC",u);s.assert(a.rank===N.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${N.length}, but got ${a.rank}`);const E=s.toNestedArray(N,c.data.get(a.dataId).values),T=s.makeZerosNestedTypedArray(r.shape,r.dtype);for(let s=0;s<f;++s)for(let t=0;t<b;++t){const e=t*w-v.top;for(let n=0;n<x;++n){const r=n*_-v.left;for(let i=0;i<y;++i){let a=Number.MIN_SAFE_INTEGER,o=e<0?0:e,l=r<0?0:r;for(let t=0;t<k;++t){const n=e+t*C;if(n>=0&&n<m)for(let e=0;e<S;++e){const u=r+e*I;if(u>=0&&u<g){const r=h[s][n][u][i]+p[t][e][i];r>a&&(a=r,o=n,l=u)}}}T[s][o][l][i]+=E[s][t][n][i]}}}return{dataId:c.write(s.toTypedArray(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yV={kernelName:"EluGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:i}=e;Sz([r,i],"eluGrad");const a=new Float32Array(s.sizeFromShape(i.shape)),o=n.data.get(i.dataId).values,l=n.data.get(r.dataId).values;for(let s=0;s<o.length;++s){const t=o[s];a[s]=t>=1?l[s]:l[s]*(t+1)}return n.makeTensorInfo(i.shape,"float32",a)}},bV=Yz("Equal",Oz((t,e)=>t===e?1:0),null,"bool"),xV={kernelName:"Equal",backendName:"cpu",kernelFunc:bV},vV=d.ERF_P,wV=d.ERF_A1,_V=d.ERF_A2,kV=d.ERF_A3,SV=d.ERF_A4,CV=d.ERF_A5,IV={kernelName:"Erf",backendName:"cpu",kernelFunc:Nz("Erf",t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+vV*n);return e*(1-((((CV*s+SV)*s+kV)*s+_V)*s+wV)*s*Math.exp(-n*n))})},NV=BB(t=>Math.exp(t)),EV=Ez("Exp",NV),TV={kernelName:"Exp",backendName:"cpu",kernelFunc:EV};function AV(t){const{inputs:e,backend:n,attrs:r}=t,{input:i}=e,{dim:a}=r,o=i.shape.length,l=i.shape.slice();let u=a;return a<0&&(s.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),l.splice(u,0,1),sB({inputs:{x:i},backend:n,attrs:{shape:l}})}const $V={kernelName:"ExpandDims",backendName:"cpu",kernelFunc:AV},RV=BB(t=>Math.expm1(t)),FV={kernelName:"Expm1",backendName:"cpu",kernelFunc:Ez("Expm1",RV)},DV=Oz((t,e)=>t*e),OV=Zz((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),LV=Yz("Multiply",DV,OV),MV={kernelName:"Multiply",backendName:"cpu",kernelFunc:LV},PV=Yz("RealDiv",Oz((t,e)=>t/e)),zV={kernelName:"RealDiv",backendName:"cpu",kernelFunc:PV},BV=Oz((t,e)=>t-e),VV=Zz((t,e,n,s)=>({real:t-n,imag:e-s})),WV=Yz("Sub",BV,VV),UV={kernelName:"Sub",backendName:"cpu",kernelFunc:WV};function jV(t,e,n){const r=t.shape,i=r[0],a=r[1],o=n.data.get(t.dataId),l=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[i,a],h=s.sizeFromShape(c),p=s.getTypedArrayFromDType("float32",h),f=s.getTypedArrayFromDType("float32",h);for(let s=0;s<i;s++){const t=DB({inputs:{x:l},backend:n,attrs:{begin:[s,0],size:[1,a]}}),r=DB({inputs:{x:u},backend:n,attrs:{begin:[s,0],size:[1,a]}}),i=jz({inputs:{real:t,imag:r},backend:n}),{real:o,imag:c}=HV(i,e,n),h=d.mergeRealAndImagArrays(o,c);for(let e=0;e<a;e++){const t=d.getComplexWithIndex(h,e);p[s*a+e]=t.real,f[s*a+e]=t.imag}n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i)}const m=n.makeTensorInfo(c,"float32",p),g=n.makeTensorInfo(c,"float32",f),y=jz({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}function HV(t,e,n){const r=s.sizeFromShape(t.shape),i=n.data.get(t.dataId),a=n.data.get(i.complexTensorInfos.real.dataId).values,o=n.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((l=r)&l-1)){const i=GV(a,o,r,e,n),l=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(l,"float32",i.real),e=n.makeTensorInfo(l,"float32",i.imag),a=n.makeTensorInfo([],"float32",s.createScalarValue(r,"float32")),o=$z({inputs:{x:a},backend:n}),u=zV.kernelFunc({inputs:{a:t,b:a},backend:n}),c=zV.kernelFunc({inputs:{a:e,b:o},backend:n}),h=n.data.get(u.dataId).values,d=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),{real:h,imag:d}}return i}{const t=function(t,e,n){const s=new Float32Array(2*e);for(let r=0;r<e;r++){let i=0,a=0;for(let s=0;s<e;s++){const o=d.exponent(r*s,e,n),l=d.getComplexWithIndex(t,s);i+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(i/=e,a/=e),d.assignToTypedArray(s,i,a,r)}return s}(d.mergeRealAndImagArrays(a,o),r,e);return d.splitRealAndImagArrays(t)}var l}function GV(t,e,n,s,r){if(1===n)return{real:t,imag:e};const i=d.mergeRealAndImagArrays(t,e),a=n/2,o=d.complexWithEvenIndex(i),l=o.real,u=o.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),p=r.makeTensorInfo(c,"float32",u),f=jz({inputs:{real:h,imag:p},backend:r}),m=d.complexWithOddIndex(i),g=m.real,y=m.imag,b=[g.length],x=r.makeTensorInfo(b,"float32",g),v=r.makeTensorInfo(b,"float32",y),w=jz({inputs:{real:x,imag:v},backend:r}),_=GV(l,u,a,s,r),k=_.real,S=_.imag,C=[k.length],I=r.makeTensorInfo(C,"float32",k),N=r.makeTensorInfo(C,"float32",S),E=jz({inputs:{real:I,imag:N},backend:r}),T=GV(g,y,a,s,r),A=T.real,$=T.imag,R=[A.length],F=r.makeTensorInfo(R,"float32",A),D=r.makeTensorInfo(R,"float32",$),O=jz({inputs:{real:F,imag:D},backend:r}),L=d.exponents(n,s),M=[L.real.length],P=r.makeTensorInfo(M,"float32",L.real),z=r.makeTensorInfo(M,"float32",L.imag),B=jz({inputs:{real:P,imag:z},backend:r}),V=LV({inputs:{a:B,b:O},backend:r}),W=eB({inputs:{a:E,b:V},backend:r}),U=WV({inputs:{a:E,b:V},backend:r}),j=qz({inputs:{input:W},backend:r}),H=qz({inputs:{input:U},backend:r}),G=GB({inputs:{input:W},backend:r}),q=GB({inputs:{input:U},backend:r}),K=KB({inputs:[j,H],backend:r,attrs:{axis:0}}),X=KB({inputs:[G,q],backend:r,attrs:{axis:0}}),Q=r.data.get(K.dataId).values,Y=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(X),{real:Q,imag:Y}}const qV={kernelName:"FFT",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,i=s.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=sB({inputs:{x:r},backend:n,attrs:{shape:[i/a,a]}}),l=jV(o,!1,n),u=sB({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};function KV(t){const{backend:e,attrs:n}=t,{shape:r,value:i,dtype:a}=n,o=a||s.inferDtype(i),l=s.getArrayFromDType(o,s.sizeFromShape(r));return function(t,e,n){t.fill(e)}(l,i),e.makeTensorInfo(r,o,l)}const XV={kernelName:"Fill",backendName:"cpu",kernelFunc:KV},QV={kernelName:"FlipLeftRight",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,i=s.getTypedArrayFromDType(n.dtype,s.sizeFromShape(n.shape)),[a,o,l,u]=n.shape,c=r.data.get(n.dataId).values;for(let s=0;s<a;s++){const t=s*l*o*u;for(let e=0;e<o;e++){const n=e*(l*u);for(let s=0;s<l;s++){const r=s*u;for(let o=0;o<u;o++){const h=Math.round(l-[a,e,s,o][2]),d=t+n+r+o;let p=c[d];h>=0&&h<l&&(p=c[t+n+h*u+o]),i[d]=p}}}}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},YV=BB(t=>Math.floor(t)),ZV={kernelName:"Floor",backendName:"cpu",kernelFunc:Ez("Floor",YV)},JV={kernelName:"FloorDiv",backendName:"cpu",kernelFunc:Yz("FloorDiv",Oz((t,e)=>Math.floor(t/e)),null,"int32")},tW={kernelName:"FusedConv2D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=QB({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=eB({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=Uz(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}},eW={kernelName:"FusedDepthwiseConv2D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=uV({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=eB({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=Uz(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}},nW={kernelName:"GatherNd",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,a=s.sizeFromShape(r.shape),o=i.shape,l=o[o.length-1],[u,c,h,p]=d.prepareAndValidate(r,i);if(0===c)return n.makeTensorInfo(u,r.dtype,[]);const f=MC([c,h],r.dtype),m=n.data.get(i.dataId).values,g=n.data.get(r.dataId).values;for(let s=0;s<c;s++){const t=[];let e=0;for(let n=0;n<l;n++){const r=m[s*l+n];e+=r*p[n],t.push(r)}if(e<0||e>=a/h)throw new Error(`Invalid indices: ${t} does not index into ${r.shape}`);for(let n=0;n<h;n++)f.values[s*h+n]=g[e*h+n]}return n.makeTensorInfo(u,f.dtype,f.values)}};function sW(t,e,n){const s=MC(n,t.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),i=e.locToIndex([n[0],n[2]]);n[2]=e.values[i];const a=t.locToIndex(n);s.values[r]=t.values[a]}return s}const rW={kernelName:"GatherV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:a}=e,{axis:o,batchDims:l}=r;Sz([i,a],"gatherV2");let u=l;null==l&&(u=0);const c=s.sizeFromShape(a.shape),h=s.parseAxisParam(o,i.shape)[0],p=d.segment_util.collectGatherOpShapeInfo(i,a,h,u),f=sB({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=sB({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,c/p.batchSize]}}),g=[p.batchSize,p.outerSize,c/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=sW(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},iW=Oz((t,e)=>t>e?1:0),aW={kernelName:"Greater",backendName:"cpu",kernelFunc:Yz("Greater",iW,null,"bool")},oW={kernelName:"GreaterEqual",backendName:"cpu",kernelFunc:Yz("GreaterEqual",Oz((t,e)=>t>=e?1:0),null,"bool")},lW={kernelName:"IFFT",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,i=s.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=sB({inputs:{x:r},backend:n,attrs:{shape:[i/a,a]}}),l=jV(o,!0,n),u=sB({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}},uW={kernelName:"IsFinite",backendName:"cpu",kernelFunc:Nz("IsFinite",t=>Number.isFinite(t)?1:0,"bool")},cW={kernelName:"IsInf",backendName:"cpu",kernelFunc:Nz("IsInf",t=>Math.abs(t)===1/0?1:0,"bool")},hW={kernelName:"IsNan",backendName:"cpu",kernelFunc:Nz("IsNan",t=>Number.isNaN(t)?1:0,"bool")},dW=Oz((t,e)=>t<e?1:0),pW={kernelName:"Less",backendName:"cpu",kernelFunc:Yz("Less",dW,null,"bool")},fW={kernelName:"LessEqual",backendName:"cpu",kernelFunc:Yz("LessEqual",Oz((t,e)=>t<=e?1:0),null,"bool")};function mW(t,e,n){const r=(e-t)/(n-1),i=s.makeZerosTypedArray(n,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}const gW={kernelName:"LinSpace",backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,a=mW(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}},yW=BB(t=>Math.log(t)),bW={kernelName:"Log",backendName:"cpu",kernelFunc:Ez("Log",yW)},xW={kernelName:"Log1p",backendName:"cpu",kernelFunc:Nz("Log1p",t=>Math.log1p(t))},vW={kernelName:"LogicalAnd",backendName:"cpu",kernelFunc:Yz("LogicalAnd",Oz((t,e)=>t&&e),null,"bool")},wW={kernelName:"LogicalNot",backendName:"cpu",kernelFunc:Nz("LogicalNot",t=>t?0:1,"bool")},_W={kernelName:"LogicalOr",backendName:"cpu",kernelFunc:Yz("LogicalOr",Oz((t,e)=>t||e),null,"bool")},kW={kernelName:"LRN",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:a,bias:o,alpha:l,beta:u}=r;Sz(i,"LRN");const c=i.shape[3],h=c-1,d=n.data.get(i.dataId).values,p=s.sizeFromShape(i.shape),f=new Float32Array(p);function m(t){const e=t%c;let n=t-e+Math.max(0,e-a);const s=t-e+Math.min(e+a,h);let r=0;for(;n<=s;n++){const t=d[n];r+=t*t}return r}for(let s=0;s<p;s++){const t=m(s),e=d[s]*Math.pow(o+l*t,-u);f[s]=e}return n.makeTensorInfo(i.shape,i.dtype,f)}},SW={kernelName:"LRNGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,y:a,dy:o}=e,{depthRadius:l,bias:u,alpha:c,beta:h}=r;Sz(o,"LRNGrad");const d=s.sizeFromShape(o.shape),p=o.shape[3],f=n.data.get(o.dataId).values,m=n.data.get(i.dataId).values,g=n.data.get(a.dataId).values,y=new Float32Array(d),b=d;for(let s=0;s<b;s++){const t=s%p,e=s-t+Math.max(0,t-l),n=s-t+Math.min(p,t+l+1);let r=0;for(let s=e;s<n;s++)r+=Math.pow(m[s],2);r=c*r+u;for(let i=e;i<n;i++){let t=-2*c*h*m[i]*g[s]/r;s===i&&(t+=Math.pow(r,-h)),t*=f[s],y[i]+=t}}return n.makeTensorInfo(o.shape,i.dtype,y)}};function CW(t,e,n,r){const i=s.getTypedArrayFromDType(r,s.sizeFromShape(n));for(let s=0;s<i.length;++s){const n=s*e;let r=t[n];for(let s=0;s<e;++s){const e=t[n+s];e>r&&(r=e)}i[s]=r}return i}function IW(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:a,keepDims:o}=r,l=n;let u=i.shape;const c=u.length,h=s.parseAxisParam(a,u);let p=h;const f=d.getAxesPermutation(p,c);let m=l.data.get(i.dataId).values;if(null!=f){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=u[f[e]];m=pB(m,u,i.dtype,f,t),p=d.getInnerMostAxes(p.length,c),u=t}Sz(i,"max"),d.assertAxesAreInnerMostDims("max",p,c);const[g,y]=d.computeOutAndReduceShapes(u,p),b=CW(m,s.sizeFromShape(y),g,i.dtype),x=l.write(b,g,i.dtype);let v=g;return o&&(v=d.expandShapeToKeepDim(g,h)),{dataId:x,shape:v,dtype:i.dtype}}const NW={kernelName:"Max",backendName:"cpu",kernelFunc:IW},EW=Oz((t,e)=>Math.max(t,e)),TW={kernelName:"Maximum",backendName:"cpu",kernelFunc:Yz("Maximum",EW)},AW={kernelName:"MaxPool",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Sz(i,"maxPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);let h;if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))h=$z({inputs:{x:i},backend:n});else{const t=n.data.get(i.dataId).values,e=s.computeStrides(i.shape),r=CB(t,0,i.dtype,e,c,"max");h=n.makeTensorInfo(c.outShape,i.dtype,r.values)}return h}},$W={kernelName:"MaxPool3D",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u,dataFormat:c}=r;Sz(i,"maxPool3d");const h=d.computePool3DInfo(i.shape,a,o,1,l,u,c),p=NB(n.data.get(i.dataId).values,0,i.dtype,s.computeStrides(i.shape),h,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}},RW={kernelName:"MaxPool3DGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;Sz([r,i],"maxPool3DGrad");const c=d.computePool3DInfo(i.shape,a,o,1,l,u),h=function(t,e){const n=MC(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*s-d;let x=b;for(;x<0;)x+=a;const v=Math.min(e.inDepth,u+b);for(let s=0;s<e.outHeight;++s){const u=s*r-p;let d=u;for(;d<0;)d+=o;const w=Math.min(e.inHeight,c+u);for(let r=0;r<e.outWidth;++r){const p=r*i-f;let _=p;for(;_<0;)_+=l;const k=Math.min(e.inWidth,h+p);let S=Number.NEGATIVE_INFINITY,C=-1;for(let e=x;e<v;e+=a){const n=e-b;for(let s=d;s<w;s+=o){const r=s-u;for(let i=_;i<k;i+=l){const a=i-p,o=t.get(m,e,s,i,g);o>=S&&(S=o,C=n*c*h+r*c+a)}}}n.set(C,m,y,s,r,g)}}}return n}(n.bufferSync(i),c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,_=x-1-c.padInfo.front,k=w-1-c.padInfo.left,S=v-1-c.padInfo.top,C=MC(i.shape,"float32"),I=n.bufferSync(r);for(let d=0;d<c.batchSize;++d)for(let t=0;t<c.inChannels;++t)for(let e=0;e<c.inDepth;++e)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=e-_,i=n-S,a=s-k;let o=0;for(let e=0;e<x;e+=g){const n=(r+e)/p;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<v;s+=y){const r=(i+s)/f;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let i=0;i<w;i+=b){const l=(a+i)/m;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=x*v*w-1-h.get(d,n,r,l,t)===e*v*w+s*w+i?1:0;0!==u&&(o+=I.get(d,n,r,l,t)*u)}}}C.set(o,d,e,n,s,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},FW={kernelName:"MaxPoolGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:a}=e,o=i;Sz([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,p=d.computePool2DInfo(o.shape,l,u,1,c,h),f=n.data.get(o.dataId).values,m=MC(p.outShape,o.dtype,IB(f,o.shape,o.dtype,p).values),g=p.strideHeight,y=p.strideWidth,b=p.dilationHeight,x=p.dilationWidth,v=p.effectiveFilterHeight,w=p.effectiveFilterWidth,_=w-1-p.padInfo.left,k=v-1-p.padInfo.top,S=MC(o.shape,"float32"),C=n.data.get(r.dataId).values,I=MC(r.shape,"float32",C);for(let d=0;d<p.batchSize;++d)for(let t=0;t<p.inChannels;++t)for(let e=0;e<p.inHeight;++e)for(let n=0;n<p.inWidth;++n){const s=e-k,r=n-_;let i=0;for(let e=0;e<v;e+=b){const n=(s+e)/g;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let s=0;s<w;s+=x){const a=(r+s)/y;if(a<0||a>=p.outWidth||Math.floor(a)!==a)continue;const o=v*w-1-m.get(d,n,a,t)===e*w+s?1:0;0!==o&&(i+=I.get(d,n,a,t)*o)}}S.set(i,d,e,n,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},DW={kernelName:"MaxPoolWithArgmax",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:a,pad:o,includeBatchInIndex:l}=e,u=n;Sz(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,h=d.computePool2DInfo(r.shape,i,a,[1,1],o),[p,f]=function(t,e,n,r,i){const a=CB(t,0,n,s.computeStrides(e),i,"max"),o=IB(t,e,n,i,!0,r);return[a.values,o.values]}(c,r.shape,r.dtype,l,h),m=u.write(p,h.outShape,r.dtype),g=u.write(f,h.outShape,r.dtype);return[{dataId:m,shape:h.outShape,dtype:r.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};function OW(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;let l;Sz(i,"sum"),l="bool"===i.dtype?Xz({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):$z({inputs:{x:i},backend:n});const u=l.shape.length,c=s.parseAxisParam(a,l.shape),h=d.getAxesPermutation(c,u);let p=c,f=l;null!=h&&(f=fB({inputs:{x:l},backend:n,attrs:{perm:h}}),p=d.getInnerMostAxes(p.length,u)),d.assertAxesAreInnerMostDims("sum",p,f.shape.length);const[m,g]=d.computeOutAndReduceShapes(f.shape,p);let y=Gz(n,m,d.upcastType(f.dtype,"int32"));const b=s.sizeFromShape(g),x=n.data.get(y.dataId).values,v=n.data.get(f.dataId).values;for(let s=0;s<x.length;++s){const t=s*b;let e=0;for(let n=0;n<b;++n)e+=v[t+n];x[s]=e}if(o){const t=y;y=sB({inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(y.shape,c)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(l),null!=h&&n.disposeIntermediateTensorInfo(f),y}const LW={kernelName:"Sum",backendName:"cpu",kernelFunc:OW},MW={kernelName:"Mean",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=s.parseAxisParam(a,i.shape),u=d.computeOutAndReduceShapes(i.shape,l),c=s.sizeFromShape(u[1]),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(p);const f=Xz({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});h.push(f);const m=PV({inputs:{a:f,b:p},backend:n});h.push(m);const g=OW({inputs:{x:m},backend:n,attrs:{axis:a,keepDims:o}});return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),g}},PW={kernelName:"Min",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;Sz(i,"min");const l=s.parseAxisParam(a,i.shape);let u=l;const c=d.getAxesPermutation(u,i.shape.length);let h=i;null!=c&&(h=fB({inputs:{x:i},backend:n,attrs:{perm:c}}),u=d.getInnerMostAxes(u.length,i.shape.length)),d.assertAxesAreInnerMostDims("min",u,h.shape.length);const[p,f]=d.computeOutAndReduceShapes(h.shape,u),m=s.sizeFromShape(f),g=s.makeZerosTypedArray(s.sizeFromShape(p),h.dtype),y=n.data.get(h.dataId).values;for(let s=0;s<g.length;++s){const t=s*m;let e=y[t];for(let n=0;n<m;++n){const s=y[t+n];s<e&&(e=s)}g[s]=e}null!=c&&n.disposeIntermediateTensorInfo(h);const b=n.makeTensorInfo(p,h.dtype,g);if(o){const t=sB({inputs:{x:b},backend:n,attrs:{shape:d.expandShapeToKeepDim(p,l)}});return n.disposeIntermediateTensorInfo(b),t}return b}},zW=Oz((t,e)=>Math.min(t,e)),BW={kernelName:"Minimum",backendName:"cpu",kernelFunc:Yz("Minimum",zW)},VW={kernelName:"MirrorPad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:a,mode:o}=r;Sz(i,"mirrorPad");const l=a.map((t,e)=>t[0]+i.shape[e]+t[1]),u=a.map(t=>t[0]),c=a.map((t,e)=>t[0]+i.shape[e]),h="reflect"===o?0:1,d=n.data.get(i.dataId).values,p=i.shape.length,f=s.computeStrides(i.shape),m=s.sizeFromShape(l),g=l.length,y=s.computeStrides(l),b=s.getTypedArrayFromDType(i.dtype,m);for(let x=0;x<m;x++){let t=s.indexToLoc(x,g,y);for(let n=0;n<g;n++)t[n]<u[n]?t[n]=2*u[n]-t[n]-h:t[n]>=c[n]&&(t[n]=2*(c[n]-1)-t[n]+h);t=t.map((t,e)=>t-u[e]);const e=s.locToIndex(t,p,f);b[x]=d[e]}return{dataId:n.write(b,l,i.dtype),shape:l,dtype:i.dtype}}},WW={kernelName:"Mod",backendName:"cpu",kernelFunc:Yz("Mod",Oz((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}))};function UW(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:a}=r,o=i.shape.length;let l=a;if(-1===l&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const u=s.parseAxisParam([l],i.shape),c=IW({inputs:{x:i},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),h=d.expandShapeToKeepDim(c.shape,u),p=sB({inputs:{x:c},backend:n,attrs:{shape:h}}),f=WV({inputs:{a:i,b:p},backend:n}),m=EV({inputs:{x:f},backend:n}),g=OW({inputs:{x:m},backend:n,attrs:{axis:u,keepDims:!1}}),y=sB({inputs:{x:g},backend:n,attrs:{shape:h}}),b=PV({inputs:{a:m,b:y},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}const jW={kernelName:"Softmax",backendName:"cpu",kernelFunc:UW},HW={kernelName:"Multinomial",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:a,seed:o,normalized:l}=r;Sz(i,"multinomial");const u=l?i:UW({inputs:{logits:i},backend:n,attrs:{dim:-1}}),c=u.shape[0],h=u.shape[1],d=n.data.get(u.dataId).values,p=[c,a],f=s.makeZerosTypedArray(s.sizeFromShape(p),"int32");for(let s=0;s<c;++s){const t=s*h,e=new Float32Array(h-1);e[0]=d[t];for(let s=1;s<e.length;++s)e[s]=e[s-1]+d[t+s];const n=fE.alea(o.toString()),r=s*a;for(let s=0;s<a;++s){const t=n();f[r+s]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){f[r+s]=n;break}}}return l||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",f)}};function GW(t,e,n){const r=s.createScalarValue(-1,n);return DV([],e,r,t,n)}const qW={kernelName:"Neg",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;Sz(s,"neg");const r=n.data.get(s.dataId).values,[i,a]=GW(r,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,i)}},KW=p.nonMaxSuppressionV3Impl,XW={kernelName:"NonMaxSuppressionV3",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;Sz(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=KW(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},QW=p.nonMaxSuppressionV4Impl,YW={kernelName:"NonMaxSuppressionV4",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s;Sz(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=QW(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},ZW=p.nonMaxSuppressionV5Impl,JW={kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s;Sz(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=ZW(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},tU=Oz((t,e)=>t!==e?1:0),eU={kernelName:"NotEqual",backendName:"cpu",kernelFunc:Yz("NotEqual",tU,null,"bool")},nU={kernelName:"OneHot",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{depth:a,onValue:o,offValue:l}=r;Sz(i,"oneHot");const u=s.sizeFromShape(i.shape),c=new Float32Array(u*a);c.fill(l);const h=n.data.get(i.dataId).values;for(let s=0;s<u;++s)h[s]>=0&&h[s]<a&&(c[s*a+h[s]]=o);return n.makeTensorInfo([...i.shape,a],"int32",c)}};function sU(t){const{inputs:e,backend:n}=t,{x:s}=e;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const t=qz({inputs:{input:s},backend:n}),e=sU({inputs:{x:t},backend:n}),r=GB({inputs:{input:s},backend:n}),i=sU({inputs:{x:r},backend:n}),a=jz({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return KV({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const rU={kernelName:"ZerosLike",backendName:"cpu",kernelFunc:sU},iU={kernelName:"OnesLike",backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=qz({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=GB({inputs:{input:r},backend:s}),a=sU({inputs:{x:i},backend:s}),o=jz({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return KV({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function aU(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(1===e.length)return AV({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const a=e[0].shape,o=e[0].dtype;e.forEach(t=>{s.assertShapesMatch(a,t.shape,"All tensors passed to stack must have matching shapes"),s.assert(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=KB({inputs:e.map(t=>{const e=AV({inputs:{input:t},backend:n,attrs:{dim:i}});return l.push(e),e}),backend:n,attrs:{axis:i}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}const oU={kernelName:"Pack",backendName:"cpu",kernelFunc:aU},lU={kernelName:"PadV2",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:a,constantValue:o}=r;Sz(i,"pad");const l=a.map((t,e)=>t[0]+i.shape[e]+t[1]),u=a.map(t=>t[0]),c=n.data.get(i.dataId).values,h=s.sizeFromShape(i.shape),d=i.shape.length,p=s.computeStrides(i.shape),f=s.sizeFromShape(l),m=l.length,g=s.computeStrides(l),y=s.getTypedArrayFromDType(i.dtype,f);0!==o&&y.fill(o);for(let b=0;b<h;b++){const t=s.indexToLoc(b,d,p).map((t,e)=>t+u[e]);y[s.locToIndex(t,m,g)]=c[b]}return{dataId:n.write(y,l,i.dtype),shape:l,dtype:i.dtype}}},uU={kernelName:"Pow",backendName:"cpu",kernelFunc:Yz("Pow",Oz((t,e)=>Math.pow(t,e)))};function cU(t,e,n,r){const[i,a]=d.computeOutAndReduceShapes(t,r),o=IS(e,"int32"),l=s.makeZerosTypedArray(s.sizeFromShape(i),o),u=s.sizeFromShape(a);for(let s=0;s<l.length;++s){const t=s*u;let e=1;for(let s=0;s<u;++s)e*=n[t+s];l[s]=e}return{outVals:l,outShape:i,outDtype:o}}const hU={kernelName:"Prod",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;Sz(i,"prod");const l=i.shape.length,u=s.parseAxisParam(a,i.shape),c=d.getAxesPermutation(u,l);let h=u,p=i;const f=[];null!=c&&(p=fB({inputs:{x:i},backend:n,attrs:{perm:c}}),f.push(p),h=d.getInnerMostAxes(h.length,l));const m=n.data.get(p.dataId).values,{outVals:g,outShape:y,outDtype:b}=cU(p.shape,p.dtype,m,h);let x=y;return o&&(x=d.expandShapeToKeepDim(y,u)),f.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(x,b,g)}};function dU(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return s.makeZerosTypedArray(0,r);const i=Math.abs(Math.ceil((e-t)/n)),a=s.makeZerosTypedArray(i,r);e<t&&1===n&&(n=-1),a[0]=t;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const pU={kernelName:"Range",backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:i,step:a}=n,o=dU(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}},fU={kernelName:"Reciprocal",backendName:"cpu",kernelFunc:Nz("Reciprocal",t=>1/t)},mU={kernelName:"ResizeBilinear",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:a,halfPixelCenters:o,size:l}=r;Sz(i,"resizeBilinear");const u=s.computeStrides(i.shape),[c,h]=l,[d,p,f,m]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(s.sizeFromShape([d,c,h,m])),b=[a&&c>1?p-1:p,a&&h>1?f-1:f],x=[a&&c>1?c-1:c,a&&h>1?h-1:h];let v=0;const w=b[0]/x[0],_=b[1]/x[1];for(let s=0;s<d;s++)for(let t=0;t<c;t++){let e;e=o?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,i=Math.min(p-1,Math.ceil(e)),a=s*u[0]+n*u[1],l=s*u[0]+i*u[1];for(let t=0;t<h;t++){let e;e=o?_*(t+.5)-.5:_*t;const n=Math.max(0,Math.floor(e)),s=e-n,i=Math.min(f-1,Math.ceil(e)),c=a+n*u[2],h=l+n*u[2],d=a+i*u[2],p=l+i*u[2];for(let t=0;t<m;t++){const e=g[c+t],n=g[h+t],i=e+(g[d+t]-e)*s;y[v++]=i+(n+(g[p+t]-n)*s-i)*r}}}return n.makeTensorInfo([d,c,h,m],"float32",y)}},gU={kernelName:"ResizeBilinearGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:a}=e,{alignCorners:o}=r;Sz([a,i],"resizeBilinearGrad");const l=s.computeStrides(i.shape),[u,c,h,d]=i.shape,[,p,f]=a.shape,m=new Float32Array(u*c*h*d),g=[o&&p>1?c-1:c,o&&f>1?h-1:h],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],b=g[0]/y[0],x=g[1]/y[1],v=n.data.get(a.dataId).values;let w=0;for(let s=0;s<u;s++){const t=s*l[0];for(let e=0;e<p;e++){const n=e*b,s=Math.floor(n),r=Math.min(Math.ceil(n),c-1),i=t+s*l[1],a=t+r*l[1],o=n-s,u=1-o;for(let t=0;t<f;t++){const e=t*x,n=Math.floor(e),s=Math.min(Math.ceil(e),h-1),r=e-n,c=1-r,p=i+n*l[2],f=i+s*l[2],g=a+n*l[2],y=a+s*l[2],b=u*c,_=u*r,k=o*c,S=o*r;for(let t=0;t<d;t++){const e=v[w++];m[p+t]+=e*b,m[f+t]+=e*_,m[g+t]+=e*k,m[y+t]+=e*S}}}}return n.makeTensorInfo([u,h,c,d],"float32",m)}},yU={kernelName:"ResizeNearestNeighbor",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:a,halfPixelCenters:o,size:l}=r;Sz(i,"resizeNearestNeighbor");const u=s.computeStrides(i.shape),[c,h]=l,[d,p,f,m]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(d*c*h*m),b=[a&&c>1?p-1:p,a&&h>1?f-1:f],x=[a&&c>1?c-1:c,a&&h>1?h-1:h],v=b[0]/x[0],w=b[1]/x[1];let _=0;for(let s=0;s<d;s++){const t=s*u[0];for(let e=0;e<c;e++){const n=o?v*(e+.5):v*e;let s=Math.min(p-1,a?Math.round(n):Math.floor(n));o&&(s=Math.max(0,s));const r=t+s*u[1];for(let t=0;t<h;t++){const e=o?w*(t+.5):w*t;let n=Math.min(f-1,a?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const s=r+n*u[2];for(let t=0;t<m;t++)y[_++]=g[s+t]}}}return n.makeTensorInfo([d,c,h,m],i.dtype,y)}},bU={kernelName:"ResizeNearestNeighborGrad",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:a}=e,{alignCorners:o}=r;Sz([a,i],"resizeNearestNeighborGrad");const l=s.computeStrides(i.shape),u=s.computeStrides(a.shape),[c,h,d,p]=i.shape,[,f,m]=a.shape,g=new Float32Array(c*h*d*p),y=n.data.get(a.dataId).values,b=[o&&f>1?h-1:h,o&&m>1?d-1:d],x=[o&&f>1?f-1:f,o&&m>1?m-1:m],v=b[0]/x[0],w=b[1]/x[1],_=1/v,k=1/w,S=2*Math.ceil(_)+2,C=2*Math.ceil(k)+2;for(let s=0;s<c;s++){const t=s*l[0];for(let e=0;e<h;e++){const n=t+e*l[1],s=Math.floor(e*_),r=Math.floor(s-S/2);for(let i=0;i<d;i++){const s=n+i*l[2],a=Math.floor(i*k),c=Math.floor(a-C/2);for(let n=0;n<p;n++){let a=0;for(let s=0;s<S;s++){const l=s+r;if(l<0||l>=f)continue;const p=t+l*u[1],g=l*v;if(e===Math.min(h-1,o?Math.round(g):Math.floor(g)))for(let t=0;t<C;t++){const e=t+c;if(e<0||e>=m)continue;const s=p+e*u[2],r=e*w;i===Math.min(d-1,o?Math.round(r):Math.floor(r))&&(a+=y[s+n])}}g[s+n]=a}}}}return n.makeTensorInfo(i.shape,i.dtype,g)}},xU={kernelName:"Reverse",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:a}=r;Sz(i,"reverse");const o=i.shape.length,l=s.parseAxisParam(a,i.shape);if(0===o)return $z({inputs:{x:i},backend:n});const u=new pS(i.shape,i.dtype),c=n.bufferSync(i);for(let s=0;s<u.size;s++){const t=u.indexToLoc(s),e=t.slice();l.forEach(t=>e[t]=i.shape[t]-1-e[t]),u.set(c.get(...e),...t)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},vU={kernelName:"RotateWithOffset",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:i,fillValue:a,center:o}=e,l=n,u=s.getTypedArrayFromDType(r.dtype,s.sizeFromShape(r.shape)),[c,h,p,f]=r.shape,[m,g]=d.getImageCenter(o,h,p),y=Math.sin(i),b=Math.cos(i),x=l.data.get(r.dataId).values;for(let s=0;s<c;s++){const t=s*p*h*f;for(let e=0;e<h;e++){const n=e*(p*f);for(let s=0;s<p;s++){const r=s*f;for(let i=0;i<f;i++){const o=[c,e,s,i],l=o[2],d=o[1];let v=(l-m)*b-(d-g)*y,w=(l-m)*y+(d-g)*b;v=Math.round(v+m),w=Math.round(w+g);let _=a;"number"!=typeof a&&(_=3===i?255:a[i]),v>=0&&v<p&&w>=0&&w<h&&(_=x[t+w*(p*f)+v*f+i]),u[t+n+r+i]=_}}}}return{dataId:l.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},wU={kernelName:"Round",backendName:"cpu",kernelFunc:Nz("Round",t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1})},_U=BB(t=>1/Math.sqrt(t)),kU={kernelName:"Rsqrt",backendName:"cpu",kernelFunc:Ez("Rsqrt",_U)};function SU(t,e,n,s,r,i,a,o,l,u){const c=[s/r,r],h=t.values,d=e.values;if(0===s)return MC(n,e.dtype);const p=MC(c,e.dtype);p.values.fill(l);for(let f=0;f<i;f++){const t=[];let i=0;for(let e=0;e<a;e++){const n=h[f*a+e];t.push(n),i+=n*o[e]}if(i<0||i>=s/r)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<r;n++)u?p.values[i*r+n]+=d[f*r+n]:p.values[i*r+n]=0===e.rank?d[0]:d[f*r+n]}return p}const CU={kernelName:"ScatterNd",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=d.calculateShapes(i,r,a),p=SU(n.bufferSync(r),n.bufferSync(i),a,h,u,l,o,c,0,!0);return n.makeTensorInfo(a,p.dtype,p.values)}},IU={kernelName:"Select",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:i,e:a}=e;Sz([r,i,a],"select");const o=r.shape.length,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,h=IS(i.dtype,a.dtype),d=s.makeZerosTypedArray(s.sizeFromShape(i.shape),h);let p=0;const f=0===o||o>1||1===i.shape.length?1:s.sizeFromShape(i.shape.slice(1));for(let s=0;s<l.length;s++)for(let t=0;t<f;t++)d[p++]=1===l[s]?u[s]:c[s];return n.makeTensorInfo(i.shape,h,d)}},NU=d.SELU_SCALEALPHA,EU=d.SELU_SCALE,TU={kernelName:"Selu",backendName:"cpu",kernelFunc:Nz("Selu",t=>t>=0?EU*t:NU*(Math.exp(t)-1))},AU={kernelName:"Sigmoid",backendName:"cpu",kernelFunc:Nz("Sigmoid",t=>1/(1+Math.exp(-t)))},$U={kernelName:"Sign",backendName:"cpu",kernelFunc:Nz("Sign",t=>t<0?-1:t>0?1:0)},RU={kernelName:"Sin",backendName:"cpu",kernelFunc:Nz("Sin",t=>Math.sin(t))},FU={kernelName:"Sinh",backendName:"cpu",kernelFunc:Nz("Sinh",t=>Math.sinh(t))},DU=Math.log(1.1920928955078125e-7)+2,OU={kernelName:"Softplus",backendName:"cpu",kernelFunc:Nz("Softplus",t=>{const e=t>-DU,n=t<DU,s=Math.exp(t);let r;return r=n?s:e?t:Math.log(1+s),r})},LU={kernelName:"SpaceToBatchND",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:a,paddings:o}=r;Sz([i],"spaceToBatchND");const l=s.sizeFromShape(a),u=[[0,0]];u.push(...o);for(let s=1+a.length;s<i.shape.length;++s)u.push([0,0]);const c=lU.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:u,constantValue:0}}),h=d.getReshaped(c.shape,a,l,!1),p=d.getPermuted(h.length,a.length,!1),f=d.getReshapedPermuted(c.shape,a,l,!1),m=sB({inputs:{x:c},backend:n,attrs:{shape:h}}),g=fB({inputs:{x:m},backend:n,attrs:{perm:p}}),y=sB({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}},MU={kernelName:"SparseToDense",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=d.calculateShapes(i,r,o),f=SU(n.bufferSync(r),n.bufferSync(i),o,p,c,u,l,h,n.data.get(a.dataId).values[0],!1);return n.makeTensorInfo(o,f.dtype,f.values)}},PU={kernelName:"SplitV",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:a,axis:o}=r,l=s.parseAxisParam(o,i.shape)[0],u=d.prepareSplitSize(i,a,l),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return u.map(t=>{const e=[...h];e[l]=t;const s=DB({inputs:{x:i},backend:n,attrs:{begin:c,size:e}});return c[l]+=t,s})}},zU={kernelName:"Sqrt",backendName:"cpu",kernelFunc:Nz("Sqrt",t=>Math.sqrt(t))},BU={kernelName:"Square",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;Sz(n,"square");const r=s.data.get(n.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const t=r[a];i[a]=t*t}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},VU=Oz((t,e)=>{const n=t-e;return n*n}),WU={kernelName:"SquaredDifference",backendName:"cpu",kernelFunc:Yz("SquaredDifference",VU)},UU={kernelName:"Step",backendName:"cpu",kernelFunc:Nz("Step",(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})};function jU(t,e,n,s){const r=MC(t,e.dtype);for(let i=0;i<r.size;i++){const t=r.indexToLoc(i),a=new Array(t.length);for(let e=0;e<a.length;e++)a[e]=t[e]*n[e]+s[e];r.set(e.get(...a),...t)}return r}const HU={kernelName:"StridedSlice",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s;Sz(r,"stridedSlice");const{nonStrided:f,$begin:m,$strides:g,size:y,newShape:b,outShape:x}=l.sliceInfo(r.shape,i,a,o,u,c,h,d,p),v=sB({inputs:{x:r},backend:n,attrs:{shape:b}});let w;if(f){const t=DB({inputs:{x:v},backend:n,attrs:{begin:m,size:y}});w=sB({inputs:{x:t},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(t)}else if(x.some(t=>0===t))w=n.makeTensorInfo(x,r.dtype,[]);else{const t=jU(x,n.bufferSync(v),g,m);w=n.makeTensorInfo(t.shape,t.dtype,t.values)}const _=sB({inputs:{x:w},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),_}},GU={kernelName:"Tan",backendName:"cpu",kernelFunc:Nz("Tan",t=>Math.tan(t))},qU=Nz("Tanh",t=>Math.tanh(t));function KU(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=MC(n,t.dtype);for(let r=0;r<s.values.length;++r){const e=s.indexToLoc(r),n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=e[s]%t.shape[s];const i=t.locToIndex(n);s.values[r]=t.values[i]}return s}function XU(t,e,n,r,i){const a=e[e.length-1],[o,l]=[t.length/a,a],u=s.getTypedArrayFromDType(n,o*r),c=s.getTypedArrayFromDType("int32",o*r);for(let s=0;s<o;s++){const e=s*l,n=t.subarray(e,e+l),i=[];for(let t=0;t<n.length;t++)i.push({value:n[t],index:t});i.sort((t,e)=>e.value-t.value);const a=s*r,o=u.subarray(a,a+r),h=c.subarray(a,a+r);for(let t=0;t<r;t++)o[t]=i[t].value,h[t]=i[t].index}const h=e.slice();return h[h.length-1]=r,[MC(h,n,u),MC(h,"int32",c)]}function QU(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return s.clamp(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;return n<0?e<=1?n=0:n+=e*(Math.trunc(-n/(e-1))+1):n>e-1&&(e<=1?n=0:n-=e*Math.trunc(n/(e-1))),s.clamp(0,n,e-1)}(t,e);case"nearest":return function(t,e){return s.clamp(0,t,e-1)}(t,e);case"constant":default:return function(t,e){return t}(t)}}function YU(t,e,n,s,r,i,a,o,l,u,c){return 0<=o&&o<e&&0<=l&&l<n?t[a*s+o*r+l*i+u]:c}function ZU(t,e,n,s,r,i,a,o,l,u,c){return YU(t,e,n,s,r,i,a,Math.round(o),Math.round(l),u,c)}function JU(t,e,n,s,r,i,a,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*YU(t,e,n,s,r,i,a,h,d,u,c)+(l-d)*YU(t,e,n,s,r,i,a,h,f,u,c))+(o-h)*((f-l)*YU(t,e,n,s,r,i,a,p,d,u,c)+(l-d)*YU(t,e,n,s,r,i,a,p,f,u,c))}function tj(t,e,n,r){const i=s.parseAxisParam(e,n)[0],a=[1,n[0],1];for(let s=0;s<i;s++)a[0]*=n[s];a[1]=n[i];for(let s=i+1;s<n.length;s++)a[2]*=n[s];const o={},l=new Int32Array(n[i]),u=new pS(a,r,t),c=[],h=1===a[0]&&1===a[2];for(let s=0;s<n[i];s++){let e;if(h)e=t[s].toString();else{const t=[];for(let e=0;e<a[0];e++)for(let n=0;n<a[2];n++)t.push(u.get(e,s,n));e=t.join(",")}if(void 0!==o[e])l[s]=o[e];else{const t=Object.keys(o).length;o[e]=t,l[s]=t,c.push(s)}}const d=a.slice();d[1]=Object.keys(o).length;const p=new pS(d,r);c.forEach((t,e)=>{for(let n=0;n<a[0];n++)for(let s=0;s<a[2];s++)p.set(u.get(n,t,s),n,e,s)});const f=n.slice();return f[i]=d[1],{outputValues:p.values,outputShape:f,indices:l}}const ej=[oB,uB,cB,hB,nB,dB,gB,yB,bB,xB,vB,wB,_B,kB,SB,EB,TB,AB,$B,aB,RB,LB,zB,Qz,WB,UB,Hz,jB,XB,ZB,JB,YB,eV,nV,tV,sV,rV,iV,aV,oV,lV,cV,hV,dV,pV,fV,gV,mV,zV,Az,yV,xV,IV,TV,$V,FV,qV,XV,QV,ZV,JV,tW,eW,nW,rW,aW,oW,Rz,lW,qB,uW,cW,hW,Dz,pW,fW,gW,bW,xW,vW,wW,_W,kW,SW,TW,AW,$W,RW,FW,DW,NW,MW,PW,BW,VW,WW,HW,MV,qW,XW,YW,JW,eU,nU,iU,oU,lU,uU,Pz,hU,pU,Kz,fU,Bz,Wz,rB,mU,gU,yU,bU,xU,vU,wU,kU,CU,IU,TU,AU,$U,RU,FU,OB,jW,OU,LU,MU,PU,zU,BU,WU,UU,HU,UV,LW,GU,{kernelName:"Tanh",backendName:"cpu",kernelFunc:qU},{kernelName:"Tile",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:i}=s;Sz(r,"tile");const a=KU(n.bufferSync(r),i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:"TopK",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i}=s;Sz(r,"topk");const a=n.data.get(r.dataId).values,[o,l]=XU(a,r.shape,r.dtype,i);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},mB,{kernelName:"Transform",backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:i,transforms:a}=e,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=n,[h,d,p,f]=i.shape,[m,g]=null!=c?c:[d,p],y=[h,m,g,f],b=s.computeStrides(i.shape),x=b[0],v=b[1],w=b[2],_=s.getTypedArrayFromDType(i.dtype,s.sizeFromShape(y));_.fill(u);const k=r.data.get(i.dataId).values,S=r.data.get(a.dataId).values;for(let s=0;s<h;++s){const t=1===a.shape[0]?S:S.subarray(8*s,8*s+8);for(let e=0;e<m;++e)for(let n=0;n<g;++n)for(let r=0;r<f;++r){let i;const a=t[6]*n+t[7]*e+1;if(0===a)continue;const c=(t[3]*n+t[4]*e+t[5])/a,h=QU((t[0]*n+t[1]*e+t[2])/a,p,l),f=QU(c,d,l);switch(o){case"nearest":i=ZU(k,d,p,x,v,w,s,f,h,r,u);break;case"bilinear":i=JU(k,d,p,x,v,w,s,f,h,r,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}_[s*x+e*v+n*w+r]=i}return r.makeTensorInfo(y,i.dtype,_)}return{dataId:r.write(_,y,i.dtype),shape:i.shape,dtype:i.dtype}}},{kernelName:"Unique",backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;Sz(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=tj(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}},{kernelName:"Unpack",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],l=new Array(a-1);let u=0;for(let p=0;p<a;p++)p!==i&&(l[u++]=r.shape[p]);const c=new Array(a).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[i]=p;const t=DB({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[p]=sB({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},{kernelName:"UnsortedSegmentSum",backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:a}=e,{numSegments:o}=r;Sz(i,"unsortedSegmentSum");const l=[],u=[],c=i.shape.length-a.shape.length;let h=a;for(let s=0;s<c;++s){const t=AV({inputs:{input:h},backend:n,attrs:{dim:s+1}});h=t,u.push(t)}for(let p=0;p<o;++p){const t=s.createScalarValue(p,"int32"),e=n.makeTensorInfo([],"int32",t),r=bV({inputs:{a:e,b:h},backend:n}),a=Xz({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),o=LV({inputs:{a,b:i},backend:n}),c=OW({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});l.push(c),u.push(e),u.push(r),u.push(a),u.push(o),u.push(c)}const d=aU({inputs:l,backend:n,attrs:{axis:0}});return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),d}},rU];for(const IY of ej)Qk(IY);const nj={},sj={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function rj(t){if(!(t in nj)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete nj[t]},!1),1===t?e.getContext("webgl",sj)||e.getContext("experimental-webgl",sj):e.getContext("webgl2",sj)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;nj[t]=e}const e=nj[t];return e.isContextLost()?(delete nj[t],rj(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),nj[t])}var ij,aj,oj;function lj(t,e){return[e,t]}function uj(t){const e=s.sizeFromShape(t),n=Math.ceil(e/4);return s.sizeToSquarishShape(n)}function cj(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function hj(t,e){const n=t;let s,r,i,a,o,l,u,c,h,d;return 2===Bk().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,i=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(s=t.RGBA,r=t.RGBA,i=t.RGBA,a=n.RGBA,o=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function dj(t,e){const n=e();return Bk().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function pj(t){return!!(Bk().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function fj(t,e){return wj(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(ij||(ij={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(aj||(aj={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(oj||(oj={}));const mj=/ERROR: [0-9]+:([0-9]+):/g;function gj(t,e){if(dj(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function yj(t,e,n,s,r,i,a){const o=t.getAttribLocation(e,n);return-1!==o&&(dj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),dj(t,()=>t.vertexAttribPointer(o,r,t.FLOAT,!1,i,a)),dj(t,()=>t.enableVertexAttribArray(o)),!0)}function bj(t,e,n){dj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),dj(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function xj(t,e){dj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),dj(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function vj(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function wj(t,e,n){const s=dj(t,()=>e());if(null==s)throw new Error(n);return s}function _j(t,e=2){return s.sizeFromShape(t.slice(0,t.length-e))}function kj(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Sj(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[_j(t),...kj(t)]),e}function Cj(t){return t%2==0}function Ij(t,e){if(t=t.slice(-2),e=e.slice(-2),s.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],s=e.slice(-1)[0];if(n===s)return!0;if(Cj(n)&&Cj(s)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&Cj(t[0])&&Cj(e[0])}let Nj,Ej;function Tj(t,e){return null!=t.getExtension(e)}function Aj(t){try{if(null!=rj(t))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function $j(t){const e=hj(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const r=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(s),r}function Rj(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&s.assert("complex64"!==t.dtype,()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const Fj=Bk();function Dj(){let t,e,n,s,r,i,a,o,l,u;return 2===Bk().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Oj(t,e,n="index"){const r=s.computeStrides(e);return r.map((e,s)=>`int ${t[s]} = ${n} / ${e}; ${s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${e}`:`index -= ${t[s]} * ${e}`};`).join("")}function Lj(t){const e=s.computeStrides(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}Fj.registerFlag("HAS_WEBGL",()=>Fj.getNumber("WEBGL_VERSION")>0),Fj.registerFlag("WEBGL_VERSION",()=>Aj(2)?2:Aj(1)?1:0),Fj.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Fj.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Fj.get("WEBGL_VERSION")),Fj.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Fj.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Fj.registerFlag("WEBGL_PACK",()=>Fj.getBool("HAS_WEBGL")),Fj.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_PACK_CLIP",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),Fj.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_PACK_REDUCE",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_LAZILY_UNPACK",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_CONV_IM2COL",()=>Fj.getBool("WEBGL_PACK")),Fj.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==Nj){const e=rj(t);Nj=e.getParameter(e.MAX_TEXTURE_SIZE)}return Nj}(Fj.getNumber("WEBGL_VERSION"))),Fj.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==Ej){const e=rj(t);Ej=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ej)}(Fj.getNumber("WEBGL_VERSION"))),Fj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Fj.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=rj(t);return e=Tj(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Tj(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),Fj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Fj.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.isMobile()),Fj.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=rj(t);if(1===t){if(!Tj(e,"OES_texture_float"))return!1}else if(!Tj(e,"EXT_color_buffer_float"))return!1;return $j(e)}(Fj.getNumber("WEBGL_VERSION"))),Fj.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Fj.getBool("WEBGL_FORCE_F16_TEXTURES")&&Fj.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Fj.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=rj(t);if(1!==t){if(Tj(e,"EXT_color_buffer_float"))return $j(e);const t="EXT_color_buffer_half_float";if(Tj(e,t)){const n=e.getExtension(t);return function(t,e){const n=hj(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(r),i}(e,n)}return!1}return!!Tj(e,"OES_texture_float")&&!!Tj(e,"WEBGL_color_buffer_float")&&$j(e)}(Fj.getNumber("WEBGL_VERSION"))),Fj.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=Fj.getNumber("WEBGL_VERSION"))&&null!=rj(t).fenceSync;var t}),Fj.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Fj.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Fj.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),Fj.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>i.isMobile()&&Fj.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});const Mj="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class Pj{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ij.DENSE;const e=uj(t),n=Dj();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Oj(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class zj{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ij.DENSE;const e=uj(t),n=Dj();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Oj(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Bj{constructor(t){this.variableNames=["A"],this.outTexUsage=aj.DOWNLOAD;const e=Dj();this.outputShape=t,this.userCode=`\n      ${Mj}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Vj{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=aj.DOWNLOAD;const e=Dj();this.outputShape=t,this.userCode=`\n      ${Mj}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class Wj{constructor(t,e,n=!1){this.variableNames=["A"];const s=Dj(),[r,i]=e;this.outputShape=t;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Lj(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class Uj{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=Dj(),[r,i]=e;this.outputShape=t;let a="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${r}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Lj(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${s.output} = ${o};\n      }\n    `}}function jj(t,e,n,s,r,i){!function(t,e){const n=Bk().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const a=function(t){return wj(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),o=t.TEXTURE_2D;return dj(t,()=>t.bindTexture(o,a)),dj(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),dj(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),dj(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),dj(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),dj(t,()=>t.texImage2D(o,0,s,e,n,0,r,i,null)),dj(t,()=>t.bindTexture(t.TEXTURE_2D,null)),a}function Hj(t){return t.internalFormatFloat}function Gj(t){return t.internalFormatHalfFloat}function qj(t){return t.downloadTextureFormat}function Kj(t){return t.internalFormatPackedFloat}function Xj(t){return t.internalFormatPackedHalfFloat}class Qj{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Bk().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){nj[t]=e}(e,t)):this.gl=rj(e);let n="WEBGL_color_buffer_float";if(1===Bk().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=fj(this.gl,"OES_texture_float"),Tj(this.gl,t))this.textureHalfFloatExtension=fj(this.gl,t);else if(Bk().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Tj(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=fj(this.gl,"EXT_color_buffer_half_float");else if(Bk().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Tj(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Tj(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=function(t){return function(t,e){const n=wj(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return dj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),dj(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=wj(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return dj(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),dj(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return wj(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=hj(this.gl,this.textureHalfFloatExtension)}get debug(){return Bk().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;dj(t,()=>t.finish()),dj(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),dj(t,()=>t.deleteFramebuffer(this.framebuffer)),dj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),dj(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),dj(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=lj(e,n);return jj(t,r,i,Hj(s),s.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=lj(e,n);return jj(t,r,i,Gj(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=lj(e,n);return jj(t,r,i,qj(s),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){dj(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?dj(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):dj(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),dj(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,s){this.throwIfDisposed(),function(t,e,n,s,r,i){let a,o,l;dj(t,()=>t.bindTexture(t.TEXTURE_2D,e)),r instanceof Uint8Array?(a=new Uint8Array(n*s*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*s*4),o=t.FLOAT,l=i.internalFormatPackedFloat),a.set(r),dj(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,o,a)),dj(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=cj(e,n);return jj(t,r,i,Xj(s),t.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,s){const[r,i]=cj(e,n);return jj(t,r,i,Kj(s),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(xj(this.gl,this.framebuffer),this.outputTexture=null),dj(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,s){const[r,i]=lj(e,n),a=new Uint8Array(e*n*4);return dj(t,()=>t.readPixels(0,0,r,i,s.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,s,r,i){return function(t,e,n,s,r,i,a,o){const l=t,u=new Float32Array(function(t,e){const[n,s]=cj(t,e);return n*s*4}(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,r,i)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const s=function(t,e,n,s){const r=t.createBuffer();dj(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const i=16*e*n;return dj(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),dj(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),dj(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Bk().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=s.clientWaitSync(r,0,0);return t===s.ALREADY_SIGNALED||t===s.CONDITION_SATISFIED},e=r}else Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const s=new Float32Array(e*n*4);return dj(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=wj(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(dj(t,()=>t.shaderSource(n,e)),dj(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=mj.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],i=t.split("\n"),a=i.length.toString().length+2,o=i.map((t,e)=>s.rightPad((e+1).toString(),a)+t);let l=0;for(let s=0;s<o.length;s++)l=Math.max(o[s].length,l);const u=o.slice(0,r-1),c=o.slice(r-1,r),h=o.slice(r);console.log(u.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${s.rightPad(c[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t),r=function(t){const e=Dj();return function(t,e){const n=wj(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(dj(t,()=>t.shaderSource(n,e)),dj(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),i=function(t){return wj(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return dj(e,()=>e.attachShader(i,r)),dj(e,()=>e.attachShader(i,n)),function(t,e){if(dj(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,i),this.debug&&gj(e,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=function(t,e,n){return dj(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),yj(t,e,"clipSpacePos",n,3,20,0)&&yj(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&dj(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&gj(this.gl,this.program),dj(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return wj(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),dj(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,s){dj(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),dj(t,()=>t.activeTexture(t.TEXTURE0+n)),dj(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,s)),dj(t,()=>t.uniform1i(n,s))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[s,r]=cj(e,n);this.setOutputMatrixTextureDriver(t,s,r)}setOutputMatrixWriteRegion(t,e,n,s){this.setOutputMatrixWriteRegionDriver(n,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&gj(this.gl,this.program),vj(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),dj(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),dj(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=fj(this.gl,2===Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await s.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||s.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),bj(this.gl,t,this.framebuffer),this.debug&&vj(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(bj(this.gl,this.outputTexture,this.framebuffer),this.debug&&vj(this.gl)):xj(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const s=this.gl;bj(s,t,this.framebuffer),this.debug&&vj(s),this.outputTexture=t,dj(s,()=>s.viewport(0,0,e,n)),dj(s,()=>s.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,s){this.throwIfDisposed(),dj(this.gl,()=>this.gl.scissor(t,e,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:Yj}=d;function Zj(t,e,n,r){const i=[];t.forEach(t=>{const e=s.sizeFromShape(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?i.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(i.push(`uniform sampler2D ${t.name};`),i.push(`uniform int offset${t.name};`))});const a=i.join("\n"),o=t.map(t=>function(t,e,n=!1){let r="";return r+=n?tH(t):Jj(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(r+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,l=Yj(t.shapeInfo.logicalShape,e.logicalShape),u=oH(o),c=o-a;let h;const d=["x","y","z","w","u","v"];h=0===a?"":o<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";p=o<2&&a>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+c]}`).join(", ");let f="return outputValue;";const m=1===s.sizeFromShape(t.shapeInfo.logicalShape),g=1===s.sizeFromShape(e.logicalShape);if(1!==a||m||g){if(m&&!g)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const t=a-2,e=a-1;l.indexOf(t)>-1&&l.indexOf(e)>-1?f="return vec4(outputValue.x);":l.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${r}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,o=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===o&&null==t.shapeInfo.flatOffset&&s.arraysEqual(t.shapeInfo.texShape,e.texShape))return`\n      float ${i}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=oH(o),u=Yj(t.shapeInfo.logicalShape,e.logicalShape),c=o-a;let h;const d=["x","y","z","w","u","v"];h=0===a?"":o<2&&u.length>=1?"coords = 0;":u.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";return p=o<2&&a>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>`coords.${d[e+c]}`).join(", "),`\n    float ${i}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(t,e)),r}(t,e,r)).join("\n"),l=e.texShape,u=Dj(),c=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let h,d,p=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${eH}\n    ${nH}\n    ${sH}\n  `}(u);return e.isPacked?(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(s.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),r=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),r=s*Math.ceil(t[t.length-2]/2);let i=r,a="",o="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],a=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+a,o=`b${l}, `+o;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${o});\n    }\n  `}(t,e)}}(e.logicalShape,l),d=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(u)):(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return s.arraysEqual(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=Oj(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=Oj(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=Oj(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=Oj(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}var n}(e.logicalShape,l),d=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(p+=rH),[p,c,d,a,h,o,n].join("\n")}function Jj(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[s,r]=t.shapeInfo.texShape;if(1===s&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[i,a]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${a}, ${iH(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${aH(t)}\n      }\n    `;const s=t.shapeInfo.texShape,r=s[0],i=s[1];if(1===i&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=iH(e);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape;if(null!=i&&s.arraysEqual(e,i))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:a,keptDims:o}=s.squeezeShape(e);if(a.length<e.length){const e=["row","col"];return`\n      ${Jj(lH(t,a))}\n      float ${r}(int row, int col) {\n        return ${r}(${uH(e,o)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${aH(t)}\n      }\n    `;const l=i[0],u=i[1],c=iH(n);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[1]*e[2],a=e[2],{newShape:o,keptDims:l}=s.squeezeShape(e);if(o.length<e.length){const e=["row","col","depth"];return`\n        ${Jj(lH(t,o))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${uH(e,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${a}, 1)));\n        ${aH(t)}\n      }\n    `;const u=t.shapeInfo.texShape,c=u[0],h=u[1],d=t.shapeInfo.flatOffset;return h===i&&null==d?`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${c}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:h===a&&null==d?`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${a} + depth + ${iH(n)};\n        vec2 uv = uvFromFlat(${c}, ${h}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[3],a=e[2]*i,o=e[1]*a,{newShape:l,keptDims:u}=s.squeezeShape(e);if(l.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${Jj(lH(t,l))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${uH(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${i}, 1)));\n        ${aH(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===i&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${iH(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[4],a=e[3]*i,o=e[2]*a,l=e[1]*o,{newShape:u,keptDims:c}=s.squeezeShape(e);if(u.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${Jj(lH(t,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${uH(e,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${o}, ${a}, ${i})) +\n          depth3;\n        ${aH(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];return f===l&&null==h?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===i&&null==h?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${o} + depth * ${a} +\n          depth2 * ${i} + depth3 + ${iH(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:a}=s.squeezeShape(e);if(i.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Jj(lH(t,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${uH(e,a)});\n      }\n    `}const o=e[5],l=e[4]*o,u=e[3]*l,c=e[2]*u,h=e[1]*c;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${c}, ${u}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${aH(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],m=p[1];return m===h&&null==d?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:m===o&&null==d?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${c} + depth * ${u} +\n          depth2 * ${l} + depth3 * ${o} + depth4 + ${iH(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function tH(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${Dj().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=Dj();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,a=i[0],o=i[1],l=Dj();if(null!=i&&s.arraysEqual(e,i))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===e[0]){const n=[1,2],r=["b","row","col"];return`\n        ${tH(lH(t,e.slice(1)))}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${uH(r,n)});\n        }\n      `}const a=i[0],o=i[1],l=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${o}, ${l*Math.ceil(e[1]/2)}, ${l}, b, row, col);\n      return ${Dj().texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],o=a[0],l=a[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=e[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${r}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${o});\n      return ${Dj().texture2D}(${s}, uv);\n    }\n  `}(t)}}const eH="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",nH="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sH="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",rH="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function iH(t){return`offset${t}`}function aH(t){const e=t.name,n=s.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function oH(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function lH(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function uH(t,e){return e.map(e=>t[e]).join(", ")}function cH(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const r=t.logicalShape,i=e[n],a=i.shape;if(!s.arraysEqual(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const o=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!s.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}const{addImpl:hH,bincountImpl:dH,bincountReduceImpl:pH,ceilImpl:fH,concatImpl:mH,expImpl:gH,expm1Impl:yH,floorImpl:bH,gatherV2Impl:xH,greaterImpl:vH,lessImpl:wH,linSpaceImpl:_H,logImpl:kH,maxImpl:SH,maximumImpl:CH,minimumImpl:IH,multiplyImpl:NH,negImpl:EH,prodImpl:TH,rangeImpl:AH,rsqrtImpl:$H,simpleAbsImpl:RH,sliceImpl:FH,stridedSliceImpl:DH,subImpl:OH,tileImpl:LH,topKImpl:MH,transposeImpl:PH,uniqueImpl:zH}=$;function BH(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function VH(t,e){return 1===e?[t]:BH(t,e)}class WH{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=VH("rc",e),s=oH(e),r=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let s="";for(let r=t-2;r<t;r++)s+=`${n[r]} >= ${e[r]}`,r<t-1&&(s+="||");return s}(e,t,n),i=function(t,e,n,s){if(1===t)return"";const r=s.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),a=function(t,e){const n=t.length,s=function(t,e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<t;n++)i=`${e[e.length-1-n]},`+i;n.push(i)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${s[0]}),\n          cEdge ? 0. : getA(${s[1]}),\n          rEdge ? 0. : getA(${s[2]}),\n          rEdge || cEdge ? 0. : getA(${s[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class UH{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let r=0;r<4;r++){let t="thisRC = rc;";r%2==1&&(t+="thisRC.z += 1;"),r>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var s;this.userCode=`\n      ${s=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${Oj(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Lj(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class jH{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const s=GH(e,n),r=qH(t,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const i=HH(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const t=this.freeTextures[r].shift();return this.usedTextures[r].push(t),t}let a;return s===oj.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===oj.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===oj.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===oj.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===oj.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,s){if(null==this.freeTextures)return;const r=GH(n,s),i=qH(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=HH(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),o=Bk().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function HH(t,e,n,s,r){const i=function(t,e){switch(t){case oj.PACKED_2X2_FLOAT32:return Kj(e);case oj.PACKED_2X2_FLOAT16:return Xj(e);case oj.UNPACKED_FLOAT32:return Hj(e);case oj.UNPACKED_FLOAT16:return Gj(e);case oj.PACKED_4X1_UNSIGNED_BYTE:return qj(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,s);let a;if(r){const[e,n]=cj(t[0],t[1]);a=e*n}else{const[e,n]=lj(t[0],t[1]);a=e*n}return a*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,i)}function GH(t,e){if(t===aj.UPLOAD)return oj.PACKED_2X2_FLOAT32;if(t===aj.RENDER||null==t)return function(t){return Bk().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?oj.PACKED_2X2_FLOAT32:oj.UNPACKED_FLOAT32:t?oj.PACKED_2X2_FLOAT16:oj.UNPACKED_FLOAT16}(e);if(t===aj.DOWNLOAD||t===aj.PIXELS)return oj.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function qH(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class KH{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const XH="return abs(x);",QH="return x;";class YH{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class ZH{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=VH("rc",e),s=oH(e),r=function(t,e){if(1===t)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const JH=p.whereImpl,tG={};class eG extends j_{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!Bk().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=rj(Bk().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Bk().getNumber("WEBGL_VERSION"))in tG||(tG[e]={}),tG[e]),this.gpgpu=new Qj(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new jH(this.gpgpu),this.numMBBeforeWarning=null==Bk().global.screen?1024:Bk().global.screen.height*Bk().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new U_(this,NI())}nextDataId(){return eG.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((Bk().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Bk().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:e,dtype:n,values:t,usage:aj.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,s,r){if(Bk().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:s,values:e,usage:aj.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:l}=e;if(null!=a){let e;e=l?new YH(o,QH):new KH(o,QH);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const u=null!=this.activeTimers;let c,h;if(u&&(c=s.now()),"complex64"===r){const t=this.readSync(i.real.dataId),e=this.readSync(i.imag.dataId);h=d.mergeRealAndImagArrays(t,e)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=s.now()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:l}=e;if(null!=i){let e;e=l?new YH(r,QH):new KH(r,QH);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(t);if(!Bk().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Bk().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==a&&Bk().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const e=this.texData.get(u.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...uj(r))}if(this.pendingRead.set(t,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);c=d.mergeRealAndImagArrays(t[0],t[1])}else if(null==h)c=this.getValuesFromTexture(t);else{const t=s.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=u&&this.disposeIntermediateTensorInfo(u);const p=this.convertAndCacheOnCPU(t,c),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(t=>t(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&NI().removeDataId(t,this),this.pendingDeletes--),p}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>s.decodeString(t))}catch(SY){throw new Error("Failed to decode encoded string bytes into utf-8")}return MC(t.shape,t.dtype,n)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!pj(n)){if(Bk().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),i=s.sizeFromShape(e);if(Bk().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),s=this.texData.get(n.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(s.texture,...uj(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),r}const a=Bk().getBool("WEBGL_PACK")&&!0===r,o=a?Sj(e):e,l=a?new Vj(o):new Bj(o),u=this.runWebGLProgram(l,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const i=s.flatten(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),a=s.flatten(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(i);o.kernelMs=s.sum(t),o.getExtraProfileInfo=()=>t.map((t,e)=>({name:a[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:s.now(),endMs:null}}endTimer(t){return Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=s.now(),t)}async getQueryTime(t){return Bk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:s,usage:r,isPacked:i,slice:a}=this.texData.get(t),o=a&&a.origDataId||t,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=e&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(e,s,r,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return Bk().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=NI().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return Bk().getBool("IS_TEST")||this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every(t=>null==this.texData.get(t.dataId).texture&&s.sizeFromShape(t.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){d.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return JH(t.shape,e)}packedUnaryOp(t,e,n){const s=new YH(t.shape,e),r=this.compileAndRun(s,[t],n);return NI().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=RH(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Bk().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,XH,t.dtype);const e=new KH(t.shape,XH),n=this.compileAndRun(e,[t]);return NI().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&s.isString(n[0])){const i=n.map(t=>s.encodeString(t));r=this.write(i,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:s}=this.makeTensorInfo(t,e,n);return NI().makeTensorFromDataId(s,t,e,this)}unpackTensor(t){const e=new ZH(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new WH(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[_j(t.shape),...kj(t.shape)],s={dtype:t.dtype,shape:n,dataId:t.dataId},r=[_j(e),...kj(e)],i=new UH(r,n),a=this.runWebGLProgram(i,[s],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:s,dtype:r}=e,i=Sj(s);let a;return a=n?new zj(i):new Pj(i),{dtype:r,shape:s,dataId:this.runWebGLProgram(a,[{shape:i,dtype:r,dataId:t}],r,null,!0).dataId}}runWebGLProgram(t,e,n,r,i=!1){const a=this.makeTensorInfo(t.outputShape,n),o=this.texData.get(a.dataId);if(t.packedOutput&&(o.isPacked=!0),t.outPackingScheme===ij.DENSE){const e=uj(t.outputShape);o.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(o.usage=t.outTexUsage),0===s.sizeFromShape(a.shape))return o.values=s.getTypedArrayFromDType(a.dtype,0),a;const l=[],u=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&s.sizeFromShape(e.shape)<=Bk().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!Ij(n.shape,e.shape)){const t=e,s=e.shape;e.shape=n.shape,e=this.packedReshape(e,s),l.push(e),n=this.texData.get(e.dataId),t.shape=s}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:o,isUniform:!1},h=function(t,e,n){let s="";e.concat(n).forEach(t=>{s+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let r=t.constructor.name;return r+="_"+s+"_"+t.userCode,r}(t,u,c),d=this.getAndSaveBinary(h,()=>function(t,e,n,s){const r=e.userCode,i=n.map((t,n)=>{const s={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(s.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:s}}),a=i.map(t=>t.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=Zj(i,o,r,e.packedInputs),u=t.createProgram(l);let c=null;const h=t.getUniformLocation(u,"NAN",!1);1===Bk().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const d={};for(let p=0;p<e.variableNames.length;p++){const n=e.variableNames[p],s=!1;d[n]=t.getUniformLocation(u,n,s),d[`offset${n}`]=t.getUniformLocation(u,`offset${n}`,s)}return{program:e,source:l,webGLProgram:u,uniformLocations:d,inShapeInfos:a,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,t,u,c)),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),function(t,e,n,r,i){cH(e.inShapeInfos,n),cH([e.outShapeInfo],[r]);const a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a,o[0],o[1]):t.setOutputMatrixTexture(a,o[0],o[1]),t.setProgram(e.webGLProgram),1===Bk().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,r)=>{const i=e.program.variableNames[r],a=e.uniformLocations[i],o=e.uniformLocations[`offset${i}`];if(null!=a)if(n.isUniform)if(s.sizeFromShape(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=n.texData.slice&&null!=o&&t.gl.uniform1i(o,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)}),null!=i&&i(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach(t=>this.disposeIntermediateTensorInfo(t)),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const m=Bk().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const t=s.now();t-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Bk().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===i){const t=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),t}return a}compileAndRun(t,e,n,s,r=!1){return this.runWebGLProgram(t,e,n=n||e[0].dtype,s,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Bk().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=TI(()=>{if(!Bk().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Bk().getBool("DEBUG");Bk().set("DEBUG",!1);const e=this.abs(DI(1e-8)).dataSync()[0];if(Bk().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:i,texture:a,usage:o,isPacked:l}=e;if(null!=a)return;const u=null!=this.activeTimers;let c;u&&(c=s.now());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=Bk().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?s.nearestLargerEven(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=s.squeezeShape(t);t=e.newShape}let r=s.sizeFromShape(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=_j(t);let n=2,i=2;return t.length&&([n,i]=kj(t)),r=e*(n/2)*(i/2),s.sizeToSquarishShape(r).map(t=>2*t)}return s.sizeToSquarishShape(r)}(n,l),e.texShape=h),null!=i){const t=Sj(n);let a,o=h[1],d=h[0];const p=i instanceof Uint8Array;l?([o,d]=cj(h[0],h[1]),a=new Uj(t,[d,o],p)):a=new Wj(t,[d,o],p);const f=this.makeTensorInfo([d,o],r);this.texData.get(f.dataId).usage=p?aj.PIXELS:aj.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,d,i);const m=this.runWebGLProgram(a,[f],r,null,!0),g=this.texData.get(m.dataId);e.texture=g.texture,e.texShape=g.texShape,e.isPacked=g.isPacked,e.usage=g.usage,this.disposeIntermediateTensorInfo(f),this.texData.delete(m.dataId),e.values=null,u&&(this.uploadWaitMs+=s.now()-c)}else{const t=this.acquireTexture(h,o,r,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:s}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,s)),n.values}acquireTexture(t,e,n,s){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,s)}computeBytes(t,e){return t[0]*t[1]*s.bytesPerElement(e)}}eG.nextDataId=0,i.isBrowser()&&RI("webgl",()=>new eG,2);class nG{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=d.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class sG{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d.assertAndGetBroadcastShape(e,n);const i=this.outputShape.length;let a="";if(r)if(0===i||1===s.sizeFromShape(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${oH(i)} coords = getOutputCoords();\n        `,1===i)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=VH("coords",i);a+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function rG(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const iG={kernelName:"Identity",backendName:"webgl",kernelFunc:rG};function aG(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,i=n.makeTensorInfo(s.shape,"complex64"),a=n.texData.get(i.dataId),o=rG({inputs:{x:s},backend:n}),l=rG({inputs:{x:r},backend:n});return a.complexTensorInfos={real:o,imag:l},i}const oG={kernelName:"Complex",backendName:"webgl",kernelFunc:aG},lG="return (a < 0.) ? b * a : a;",uG="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",cG={kernelName:"LeakyRelu",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:a}=r,o=n.makeTensorInfo([],"float32",s.createScalarValue(a,"float32")),l=Bk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sG(uG,i.shape,o.shape):new nG(lG,i.shape,o.shape),u=n.runWebGLProgram(l,[i,o],i.dtype);return n.disposeIntermediateTensorInfo(o),u}},hG="return (a < 0.) ? b * a : a;",dG="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",pG={kernelName:"Prelu",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,i=Bk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sG(dG,s.shape,r.shape):new nG(hG,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}};function fG({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const t=o.texData.get(a.dataId),e=n(t.values,l);return o.makeTensorInfo(a.shape,l,e)}let u;return u=Bk().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new YH(a.shape,e):new KH(a.shape,t),o.runWebGLProgram(u,[a],l)}}function mG({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:l,b:u}=a,c=o;if(s&&"complex64"===l.dtype){const e=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[s,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,s]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:s.dataId,dtype:s.dtype,shape:u.shape},a=new nG(t,l.shape,u.shape);return c.runWebGLProgram(a,[r,i],IS(n.dtype,s.dtype))}),i=aG({inputs:{real:s,imag:r},backend:c});return c.disposeIntermediateTensorInfo(s),c.disposeIntermediateTensorInfo(r),i}const h=i||IS(l.dtype,u.dtype);if(c.shouldExecuteOnCPU([l,u])&&null!=r){const t=c.texData.get(l.dataId),e=c.texData.get(u.dataId),[n,s]=r(l.shape,u.shape,t.values,e.values,h),i=c.makeTensorInfo(s,h);return c.texData.get(i.dataId).values=n,i}let d;return d=Bk().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new sG(e,l.shape,u.shape,n):new nG(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function gG(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return e?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return e?dG:hG;if("leakyrelu"===t)return e?uG:lG;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class yG{constructor(t,e,n,s=!1,r=!1,i=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=Math.ceil((s?t[1]:t[2])/2),c=s?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";a&&(f=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,m="result = activation(result);");const g=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",b="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(b=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          int batchA = ${y};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class bG{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=d.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const xG="return a * b;";function vG(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,i=d.upcastType(s.dtype,r.dtype);if("complex64"===s.dtype){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),i=new bG("return areal * breal - aimag * bimag;",s.shape,r.shape),a=new bG("return areal * bimag + aimag * breal;",s.shape,r.shape),o=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(i,o,"float32"),u=n.runWebGLProgram(a,o,"float32"),c=aG({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([s,r])){const t=n.texData.get(s.dataId),e=n.texData.get(r.dataId),[a,o]=NH(s.shape,r.shape,t.values,e.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=a,l}let a;return a=Bk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sG(xG,s.shape,r.shape):new nG(xG,s.shape,r.shape),n.runWebGLProgram(a,[s,r],i)}const wG={kernelName:"Multiply",backendName:"webgl",kernelFunc:vG};function _G(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:a}=r,o=n,l=s.sizeFromShape(i.shape),u=s.inferFromImplicitShape(a,l),c=s.sizeFromShape(u);s.assert(l===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${i.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(i.dataId);return!h.isPacked||Ij(i.shape,u)||null!==h.texture&&Ij(h.shape,u)?(o.incRef(i.dataId),{dataId:i.dataId,shape:u,dtype:i.dtype}):function(t,e,n){const s=[_j(t.shape),...kj(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[_j(e),...kj(e)],a=new UH(i,s),o=n.runWebGLProgram(a,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}(i,u,o)}const kG={kernelName:"Reshape",backendName:"webgl",kernelFunc:_G};class SG{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:a}=t;this.outputShape=[r,a];const o=4*Math.floor(n/4),l=n%4;let u="sumValue += dot(values, ones);";if(null!=e){const t=1/e;u=`sumValue += dot(values * ${s.isInt(t)?t.toPrecision(2):t}, ones);`}let c="";i%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class CG{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=t;this.outputShape=[s,i];let a="0.0",o="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",o="min"):"max"===e&&(a="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function IG(t,e,n,s){const r=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],s=d.computeOptimalWindowSize(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}(t.shape);let i=t;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:l,outSize:u}=r[a];let c,h;c="mean"===n?0===a?new SG({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new SG({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):new CG({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),h=i,i=s.runWebGLProgram(c,[i],e),h.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(h)}return i}class NG{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const s=oH(this.rank),r=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class EG{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=oH(this.rank),r=BH("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=r[u];const a=`vec2(${i.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function TG(t,e,n){const s=Bk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EG(t.shape,e):new NG(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}function AG(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r;return function(t,e,n,r){const i=t.shape.length,a=s.parseAxisParam(e,t.shape);let o=a;const l=d.getAxesPermutation(o,i),u=null!=l;let c=t;u&&(c=TG(t,l,r),o=d.getInnerMostAxes(o.length,i)),d.assertAxesAreInnerMostDims("sum",o,i);const[h,p]=d.computeOutAndReduceShapes(c.shape,o);let f=h;n&&(f=d.expandShapeToKeepDim(h,a));const m=s.sizeFromShape(p),g=_G({inputs:{x:c},attrs:{shape:[s.sizeFromShape(t.shape)/m,m]},backend:r}),y=IG(g,NS(t.dtype),"sum",r),b=_G({inputs:{x:y},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(y),u&&r.disposeIntermediateTensorInfo(c),b}(i,a,o,n)}const $G={kernelName:"Sum",backendName:"webgl",kernelFunc:AG};function RG(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:i}=s,a=n,o=new Array(r.shape.length);for(let u=0;u<o.length;u++)o[u]=r.shape[i[u]];let l;if(a.shouldExecuteOnCPU([r])){const t=a.texData.get(r.dataId),e=PH(t.values,r.shape,r.dtype,i,o);l=a.makeTensorInfo(o,r.dtype),a.texData.get(l.dataId).values=e}else l=TG(r,i,a);return l}const FG={kernelName:"Transpose",backendName:"webgl",kernelFunc:RG};function DG({a:t,b:e,transposeA:n,transposeB:r,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}){const c=t.shape.length,h=e.shape.length,d=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[h-1]:e.shape[h-2],f=n?t.shape[c-1]:t.shape[c-2],m=r?e.shape[h-2]:e.shape[h-1],g=t.shape.slice(0,-2),y=e.shape.slice(0,-2),b=s.sizeFromShape(g),x=s.sizeFromShape(y);s.assert(c>=2&&h>=2&&(b===x||1===b||1===x),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${g}) and (${y}).`);const v=(b>x?t.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,m]);s.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[b,d,f]:[b,f,d],_=r?[x,m,p]:[x,p,m],k=_G({inputs:{x:t},backend:i,attrs:{shape:w}}),S=_G({inputs:{x:e},backend:i,attrs:{shape:_}}),C=[k,S],I=Math.max(b,x),N=n?k.shape[1]:k.shape[2],E=null!=a,T=null!=o,A="leakyrelu"===u,$=null!=u?gG(u,!0):null;let R;if((1===f||1===m)&&N>1e3&&!1===(E||T||A||null!=$)){let t=k,e=S;n&&(t=RG({inputs:{x:k},backend:i,attrs:{perm:[0,2,1]}}),C.push(t)),r&&(e=RG({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),C.push(e));const s=1===m;let a=t;1!==m&&(a=_G({inputs:{x:t},backend:i,attrs:{shape:[I,N,1]}}),C.push(a));const o=1===m?2:1;let l=e;s&&(l=_G({inputs:{x:e},backend:i,attrs:{shape:[I,1,N]}}),C.push(l));const u=vG({inputs:{a,b:l},backend:i});R=AG({inputs:{x:u},backend:i,attrs:{axis:o,keepDims:!0}}),C.push(u)}else{const u=IS(t.dtype,e.dtype),c=new yG(w,_,[I,f,m],n,r,E,$,T,A),h=[k,S];if(null!=a&&h.push(a),T&&h.push(o),A){const t=i.makeTensorInfo([],"float32",s.createScalarValue(l,"float32"));h.push(t),C.push(t)}R=i.runWebGLProgram(c,h,u)}const F=_G({inputs:{x:R},backend:i,attrs:{shape:v}});C.push(R);for(const s of C)i.disposeIntermediateTensorInfo(s);return F}const OG={kernelName:"_FusedMatMul",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return DG({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},LG={kernelName:"Abs",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const t=n.texData.get(s.dataId),e=RH(t.values);return n.makeTensorInfo(s.shape,s.dtype,e)}let r;return r=Bk().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new YH(s.shape,"return abs(x);"):new KH(s.shape,"return abs(x);"),n.runWebGLProgram(r,[s],s.dtype)}},MG={kernelName:"Acos",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"})},PG={kernelName:"Acosh",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"})},zG="return a + b;",BG={kernelName:"Add",backendName:"webgl",kernelFunc:mG({opSnippet:zG,packedOpSnippet:zG,supportsComplex:!0,cpuKernelImpl:hH})};class VG{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class WG{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const s=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const UG={kernelName:"AddN",backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,r=n;if(1===r.length)return rG({inputs:{x:r[0]},backend:s});if(r.length>Bk().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),n=t({inputs:r.slice(0,e),backend:s}),i=t({inputs:r.slice(e),backend:s});return t({inputs:[n,i],backend:s})}const i=r.map(t=>t.dtype).reduce((t,e)=>IS(t,e)),a=r.map(t=>t.shape),o=Bk().getBool("WEBGL_PACK")?new WG(r[0].shape,a):new VG(r[0].shape,a);return s.runWebGLProgram(o,r,i)}},jG={kernelName:"All",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l);let p=i;null!=h&&(p=RG({inputs:{x:i},backend:n,attrs:{perm:h}}),c=d.getInnerMostAxes(c.length,l)),d.assertAxesAreInnerMostDims("all",c,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,c),g=_G({inputs:{x:p},backend:n,attrs:{shape:[-1,s.sizeFromShape(m)]}}),y=IG(g,g.dtype,"all",n);let b;return b=_G(o?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,u)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),b}},HG={kernelName:"Any",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l);let p=i;null!=h&&(p=RG({inputs:{x:i},backend:n,attrs:{perm:h}}),c=d.getInnerMostAxes(c.length,l)),d.assertAxesAreInnerMostDims("any",c,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,c),g=_G({inputs:{x:p},backend:n,attrs:{shape:[-1,s.sizeFromShape(m)]}}),y=IG(g,g.dtype,"any",n);let b;return b=_G(o?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,u)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),b}};class GG{constructor(t,e,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class qG{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,s.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,l=oH(o),u=VH("coords",o);let c,h;if(1===i){h=o+1;const t=oH(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[o-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),m=VH("sourceLocR",h-1).concat("inIdx.r"),g=VH("sourceLocG",h-1).concat("inIdx.g"),y=VH("sourceLocB",h-1).concat("inIdx.b"),b=VH("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,_=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function KG(t,e,n,s=null){let r=e.shape[0],i=e.shape[1];null!=s&&(r=s.shape[0],i=s.shape[1]);const a=d.computeOptimalWindowSize(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},l=new GG(o,n,null==s),u=[e];null!=s&&u.push(s);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=KG(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function XG(t,e,n,s=null){const r=null!=s?s.shape:e.shape,i=d.computeOptimalWindowSize(r[r.length-1]),a=new qG(r,i,n,null==s),o=t.runWebGLProgram(a,null==s?[e]:[e,s],"int32");if(o.shape.length===e.shape.length){const s=XG(t,e,n,o);return t.disposeIntermediateTensorInfo(o),s}return o}function QG(t,e,n,r){const i=[n];if(d.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!Bk().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],[a,o]=d.computeOutAndReduceShapes(e.shape,i),l=s.sizeFromShape(o),u=_G({inputs:{x:e},backend:t,attrs:{shape:[-1,l]}});n.push(u);const c=KG(t,u,r);n.push(c);const h=_G({inputs:{x:c},backend:t,attrs:{shape:a}});return n.forEach(e=>t.disposeIntermediateTensorInfo(e)),h}return XG(t,e,r)}const YG={kernelName:"ArgMax",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=RG({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),d.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);const h=QG(n,u,o[0],"max");return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},ZG={kernelName:"ArgMin",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a}=r;let o=s.parseAxisParam(a,i.shape);const l=d.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=l&&(u=RG({inputs:{x:i},backend:n,attrs:{perm:l}}),c.push(u),o=d.getInnerMostAxes(o.length,u.shape.length)),d.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);const h=QG(n,u,o[0],"min");return c.forEach(t=>n.disposeIntermediateTensorInfo(t)),h}},JG={kernelName:"Asin",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"})},tq={kernelName:"Asinh",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"})},eq={kernelName:"Atan",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"})},nq={kernelName:"Atan2",backendName:"webgl",kernelFunc:mG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},sq={kernelName:"Atanh",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"})};class rq{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(i/4),b=i%4,x=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${x}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${x}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class iq{constructor(t,e,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let x="0.0";if(b||(x="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const w=4*Math.floor(i/4),_=i%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}const aq={kernelName:"AvgPool",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Rj(i,"avgPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))return rG({inputs:{x:i},backend:n});const h=new rq(c,"avg",!1);return n.runWebGLProgram(h,[i],"float32")}},oq={kernelName:"AvgPool3D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s,c=d.computePool3DInfo(r.shape,i,a,[1,1,1],o,l,u),h=new iq(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class lq{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class uq{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const cq={kernelName:"AvgPool3DGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=d.computePool3DInfo(a.shape,o,l,[1,1,1],u,c),p=new uq(h);return n.runWebGLProgram(p,[r],a.dtype)}},hq={kernelName:"AvgPoolGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i;Rj([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=d.computePool2DInfo(a.shape,o,l,1,u),h=new lq(c);return n.runWebGLProgram(h,[r],a.dtype)}},dq={kernelName:"BatchMatMul",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return DG({a:r,b:i,transposeA:a,transposeB:o,backend:n})}};class pq{constructor(t,e,n,s,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],d.assertAndGetBroadcastShape(t,e),d.assertAndGetBroadcastShape(t,n);let a="0.0";null!=s&&(d.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=r&&(d.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class fq{constructor(t,e,n,s,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],d.assertAndGetBroadcastShape(t,e),d.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";null!=s&&(d.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=r&&(d.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const mq={kernelName:"FusedBatchNorm",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:i,variance:a,offset:o,scale:l}=t;s.assert(i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),s.assert(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),s.assert(null==l||i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const c=[r,i,a];let h=null;null!=o&&(h=o.shape,c.push(o));let d=null;null!=l&&(d=l.shape,c.push(l));const p=Bk().getBool("WEBGL_PACK_NORMALIZATION")?new fq(r.shape,i.shape,a.shape,h,d,u):new pq(r.shape,i.shape,a.shape,h,d,u);return e.runWebGLProgram(p,c,c[0].dtype)}};class gq{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=oH(this.rank),n=`uniform int start[${this.rank}];`,s=function(t){if(1===t)return"sourceLoc";if(t<=6)return yq.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${yq[e]} = start[${e}] + coords.${yq[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const yq=["x","y","z","w","u","v"];class bq{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=oH(this.rank),n=VH("coords",this.rank),s=VH("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${r})`,a=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${s[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}function xq(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:a,size:o}=r,[u,c]=l.parseSliceParams(i,a,o);if(l.assertParamsValid(i,u,c),0===s.sizeFromShape(c))return n.makeTensorInfo(c,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||"string"===i.dtype){const t=n.texData.get(i.dataId),e=FH(t.values,u,c,i.shape,i.dtype);return n.makeTensorInfo(c,i.dtype,e)}const{isPacked:h}=n.texData.get(i.dataId),d=l.isSliceContinous(i.shape,u,c);if(h||!d){const t=Bk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bq(c):new gq(c),e=t.getCustomSetupFunc(u);return n.runWebGLProgram(t,[i],i.dtype,e)}return n.uploadToGPU(i.dataId),function(t,e,n,r){const i=r.texData.get(t.dataId),a=r.makeTensorInfo(n,t.dtype),o=r.texData.get(a.dataId);Object.assign(o,i),o.refCount=1,o.shape=n,o.dtype=t.dtype;let u=l.computeFlatOffset(e,s.computeStrides(t.shape));i.slice&&(u+=i.slice.flatOffset),o.slice={flatOffset:u,origDataId:i.slice&&i.slice.origDataId||t.dataId};const c=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,c+1),a}(i,u,c,n)}const vq={kernelName:"Slice",backendName:"webgl",kernelFunc:xq},wq={kernelName:"BatchToSpaceND",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:a,crops:o}=r;s.assert(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=a.reduce((t,e)=>t*e),u=d.getReshaped(i.shape,a,l),c=d.getPermuted(u.length,a.length),h=d.getReshapedPermuted(i.shape,a,l),p=d.getSliceBeginCoords(o,a.length),f=d.getSliceSize(h,o,a.length),m=[],g=_G({inputs:{x:i},backend:n,attrs:{shape:u}}),y=RG({inputs:{x:g},backend:n,attrs:{perm:c}}),b=_G({inputs:{x:y},backend:n,attrs:{shape:h}}),x=xq({inputs:{x:b},backend:n,attrs:{begin:p,size:f}});return m.push(g),m.push(y),m.push(b),m.forEach(t=>n.disposeIntermediateTensorInfo(t)),x}},_q={kernelName:"Bincount",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a}=s,o=n.readSync(r.dataId),l=n.readSync(i.dataId),u=dH(o,l,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,u)}},kq=mG({opSnippet:"return float(a != b);",dtype:"bool"}),Sq={kernelName:"NotEqual",backendName:"webgl",kernelFunc:kq};function Cq(t){const{inputs:e,backend:n}=t,{input:s}=e;return rG({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const Iq={kernelName:"Real",backendName:"webgl",kernelFunc:Cq},Nq={kernelName:"Cast",backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:i}=e,{x:a}=n,{dtype:o}=i;if("complex64"===o){if("complex64"===a.dtype)return rG({inputs:{x:a},backend:r});const e=lE(a.shape),n=t({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=aG({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const e=Cq({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(e),n}if(!s.hasEncodingLoss(a.dtype,o)){const t=rG({inputs:{x:a},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:o}}if("int32"===o)return function(t,e){const n=new KH(t.shape,"return float(int(x));"),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(a,r);if("bool"===o){const t=r.makeTensorInfo([],"bool",s.getTypedArrayFromDType("bool",1)),e=kq({inputs:{a,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${o}`)}},Eq="return ceil(x);",Tq={kernelName:"Ceil",backendName:"webgl",kernelFunc:fG({opSnippet:Eq,packedOpSnippet:Eq,cpuKernelImpl:fH})};class Aq{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class $q{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}const Rq={kernelName:"ClipByValue",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;o=Bk().getBool("WEBGL_PACK_CLIP")?new $q(r.shape):new Aq(r.shape);const l=o.getCustomSetupFunc(i,a);return n.runWebGLProgram(o,[r],r.dtype,l)}};class Fq{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Dq(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const Oq={kernelName:"ComplexAbs",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),i=new Fq(s.shape),a=[Dq(s,r.complexTensorInfos.real),Dq(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}};class Lq{constructor(t){this.outputShape=[],this.outputShape=d.computeOutShape(t,1),this.variableNames=t.map((t,e)=>`T${e}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<e.length;s++)n.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${e[s-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Mq{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=d.computeOutShape(t,e);const n=this.outputShape,s=n.length,r=oH(s),i=VH("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((t,e)=>`T${e}`);const o=new Array(t.length-1);o[0]=t[0][e];for(let d=1;d<o.length;d++)o[d]=o[d-1]+t[d][e];const l=a[e],u=a.slice(-2),c=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let d=1;d<o.length;d++){const t=o[d-1];h+=`\n        if (${l} < ${o[d]}  && ${l} >= ${o[d-1]}) {\n          return getChannel(\n            getT${d}(${Pq(a,l,t)}),\n            vec2(${Pq(u,l,t)}));\n        }`}const p=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${Pq(a,l,p)}),\n          vec2(${Pq(u,l,p)}));`,this.userCode=`\n      float getValue(${a.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${n[s-2]} &&\n            ${i[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Pq(t,e,n){const s=t.indexOf(e);return t.map((t,e)=>e===s?`${t} - ${n}`:t).join()}function zq(t){const{inputs:e,backend:n}=t,{input:s}=e;return rG({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const Bq={kernelName:"Imag",backendName:"webgl",kernelFunc:zq};function Vq(t,e,n){const s=t[0].dtype;if("complex64"===s){const s=t.map(t=>Cq({inputs:{input:t},backend:n})),r=t.map(t=>zq({inputs:{input:t},backend:n})),i=Vq(s,e,n),a=Vq(r,e,n),o=aG({inputs:{real:i,imag:a},backend:n});return s.forEach(t=>n.disposeIntermediateTensorInfo(t)),r.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}if("string"===s){const{tensors2D:r,outShape:i}=Wq(t,e,n),a=r.map(t=>({vals:n.readSync(t.dataId),shape:t.shape})),o=mH(a,i,s,1===r[0].shape[0]),l=d.computeOutShape(t.map(t=>t.shape),e),u=n.makeTensorInfo(l,s,o);return r.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}if(t.length>Bk().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(t.length/2),r=Vq(t.slice(0,s),e,n),i=Vq(t.slice(s),e,n),a=Vq([r,i],e,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}if(Bk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const r=new Mq(t.map(t=>t.shape),e);return n.runWebGLProgram(r,t,s)}const{tensors2D:r,outShape:i}=Wq(t,e,n),a=new Lq(r.map(t=>t.shape)),o=n.runWebGLProgram(a,r,s);r.forEach(t=>n.disposeIntermediateTensorInfo(t));const l=_G({inputs:{x:o},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(o),l}function Wq(t,e,n){const r=d.computeOutShape(t.map(t=>t.shape),e);return{tensors2D:t.map(t=>_G({inputs:{x:t},attrs:{shape:[-1,s.sizeFromShape(t.shape.slice(e))]},backend:n})),outShape:r}}function Uq(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,a=s.parseAxisParam(i,e[0].shape)[0],o=d.computeOutShape(e.map(t=>t.shape),a);if(0===s.sizeFromShape(o))return n.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(t=>s.sizeFromShape(t.shape)>0);if(1===l.length)return rG({inputs:{x:l[0]},backend:n});const u=l.map(t=>t.shape);return d.assertParamsConsistent(u,a),Vq(l,a,n)}const jq={kernelName:"Concat",backendName:"webgl",kernelFunc:Uq};class Hq{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",v="";n&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class Gq{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,s=t.padInfo.left,r=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qq{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:s,inChannels:r,strideWidth:i,strideHeight:a,padInfo:o,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=o,f=r*s,m=Dj(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let x="";for(let v=0;v<=1;v++)for(let n=0;n<=1;n++)x+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${v};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${a} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${e[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*v+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*v+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${x}\n\n        ${m.output} = result;\n      }\n    `}}function Kq({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape,c=r.texData.get(t.dataId),h="channelsLast"===n.dataFormat;let d;const p=[],f=u[2]%2!=0&&!!c.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&Bk().getBool("WEBGL_LAZILY_UNPACK")&&Bk().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&f){const f={dataId:t.dataId,shape:[1,h?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:t.dtype},m=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,s.assert(Ij(c.shape,f.shape),()=>`packed reshape ${c.shape} to ${f.shape} isn't free`);const g=_G({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});p.push(g);const y=DG({a:f,b:g,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:l,preluActivationWeights:a,leakyreluAlpha:o}),b=r.texData.get(y.dataId);s.assert(b.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=m,b.shape=n.outShape,d=rG({inputs:{x:y},backend:r}),d.shape=n.outShape,p.push(y)}else{const s=_G({inputs:{x:t},backend:r,attrs:{shape:[1,h?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),c=_G({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=DG({a:s,b:c,transposeA:!1,transposeB:!1,backend:r,bias:i,activation:l,preluActivationWeights:a,leakyreluAlpha:o});d=_G({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),p.push(s),p.push(c),p.push(f)}for(const s of p)r.disposeIntermediateTensorInfo(s);return d}function Xq({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:u,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=n,m="channelsLast"===f,g=u*c*h,y=p*d,b=[g,y],x=[],v=_G({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),w=_G({inputs:{x:e},backend:r,attrs:{shape:[1,g,s.sizeFromShape(e.shape)/g]}});x.push(v),x.push(w);const _=new qq(b,v.shape,n),k=r.runWebGLProgram(_,[v],"float32"),S=_G({inputs:{x:k},backend:r,attrs:{shape:[1,b[0],b[1]]}});x.push(k),x.push(S);const C=null!=i,I=null!=a,N="leakyrelu"===l,E=l?gG(l,!0):null,T=new yG(S.shape,w.shape,[1,y,n.outChannels],!0,!1,C,E,I,N),A=[S,w];if(i&&A.push(i),I&&A.push(a),N){const t=r.makeTensorInfo([],"float32",s.createScalarValue(o,"float32"));A.push(t),x.push(t)}const $=r.runWebGLProgram(T,A,"float32"),R=_G({inputs:{x:$},backend:r,attrs:{shape:m?[1,p,d,n.outChannels]:[1,n.outChannels,p,d]}});x.push($);for(const s of x)r.disposeIntermediateTensorInfo(s);return R}const Qq={kernelName:"Conv2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,i.shape,a,u,o,c,!1,h);let f;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(Bk().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])f=Xq({x:r,filter:i,convInfo:p,backend:n});else{const t=new Hq(p);f=n.runWebGLProgram(t,[r,i],"float32")}else f=Kq({x:r,filter:i,convInfo:p,backend:n});const m=_G({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}};class Yq{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Zq{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Jq{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class tK{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const eK={kernelName:"Conv2DBackpropFilter",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=d.convertConv2DDataFormat(l),p=d.computeConv2DInfo(r.shape,c,a,1,o,u,!1,h),f=new Yq(p);return n.runWebGLProgram(f,[r,i],"float32")}},nK={kernelName:"Conv2DBackpropInput",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=d.convertConv2DDataFormat(u),p=d.computeConv2DInfo(a,i.shape,o,1,l,c,!1,h),f=new Zq(p);return n.runWebGLProgram(f,[r,i],"float32")}},sK={kernelName:"Conv3D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,u=d.computeConv3DInfo(r.shape,i.shape,a,l,o),c=new Gq(u);return n.runWebGLProgram(c,[r,i],"float32")}},rK={kernelName:"Conv3DBackpropFilterV2",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s,u=d.computeConv3DInfo(r.shape,l,a,1,o),c=new Jq(u);return n.runWebGLProgram(c,[r,i],"float32")}},iK={kernelName:"Conv3DBackpropInputV2",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s,u=d.computeConv3DInfo(l,i.shape,o,1,a),c=new tK(u);return n.runWebGLProgram(c,[r,i],"float32")}},aK={kernelName:"Cos",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"})},oK={kernelName:"Cosh",backendName:"webgl",kernelFunc:fG({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"})};class lK{constructor(t,e,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,o,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===s?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,x,v]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const uK={kernelName:"CropAndResize",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=s,c=new lK(r.shape,i.shape,o,l,u);return n.runWebGLProgram(c,[r,i,a],"float32")}};class cK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const s=t.length,r=e?"0.0":`getX(${hK(s,"coords")})`,i=t[t.length-1];let a="",o="";e?(a=n?"end != "+(i-1):"end != 0",o=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${oH(s)} coords = getOutputCoords();\n        int end = ${dK(s,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${o};\n          ${dK(s,"coords")} = idx;\n          val += getX(${hK(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function hK(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function dK(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const pK={kernelName:"Cumsum",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s,l=r.shape.length,u=d.getAxesPermutation([i],l);let c=r;null!=u&&(c=RG({inputs:{x:r},backend:n,attrs:{perm:u}}));const h=d.getInnerMostAxes(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${i}`);const p=c.shape[h];let f=rG({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(p))-1;d++){const t=new cK(c.shape,!1,o),e=t.getCustomSetupFunc(d),s=f;f=n.runWebGLProgram(t,[f],f.dtype,e),n.disposeIntermediateTensorInfo(s)}if(a){const t=new cK(c.shape,a,o),e=f;f=n.runWebGLProgram(t,[f],f.dtype),n.disposeIntermediateTensorInfo(e)}if(null!=u){const t=RG({inputs:{x:f},backend:n,attrs:{perm:d.getUndoAxesPermutation(u)}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(c),t}return f}},fK={kernelName:"DenseBincount",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const t=n.readSync(r.dataId),e=n.readSync(i.dataId),s=dH(t,e,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,s)}if(2===r.shape.length){const t=n.bufferSync(r),e=n.bufferSync(i),s=pH(t,e,a,o);return n.makeTensorInfo(s.shape,i.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class mK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const gK={kernelName:"DepthToSpace",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:a,dataFormat:o}=r;s.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const l=i.shape[0],u=("NHWC"===o?i.shape[1]:i.shape[2])*a,c=("NHWC"===o?i.shape[2]:i.shape[3])*a,h=("NHWC"===o?i.shape[3]:i.shape[1])/(a*a),d=new mK("NHWC"===o?[l,u,c,h]:[l,h,u,c],a,o);return n.runWebGLProgram(d,[i],i.dtype)}};class yK{constructor(t,e=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.inHeight,a=t.inWidth,o=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=t.outChannels/t.inChannels;let g="",y="";n&&(g=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${y}\n        setOutput(result);\n      }\n    `}}class bK{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const a=t.inHeight,o=t.inWidth,l=t.padInfo.top,u=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,g=m;let y="int xR; int xC; int xCOffset;";for(let s=0;s<f;s++)for(let t=0;t<m;t++)y+=`\n          vec4 xTexelR${s}C${2*t} = vec4(0.);\n          vec4 wR${s}C${t} = vec4(0.);\n          vec4 xR${s}C${t} = vec4(0.);`;for(let w=0;w<f;w++)for(let t=0;t<g;t++){const e=2*t;if(y+=`\n          xR = xRCorner + ${w*d};\n          xC = xCCorner + ${e*p};\n        `,1===h){if(e<m&&(y+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    xTexelR${w}C${e}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${o}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${w}C${e} = vec4(previous.zw, xTexelR${w}C${e}.xy);\n                } else {\n                  xR${w}C${e} = vec4(0, 0, xTexelR${w}C${e}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${a} && xC >= 0 && xC < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                xR${w}C${e} = xTexelR${w}C${e};\n              `,e+1<m)){const t=u%2==0?s.nearestLargerEven(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if(xR >= 0 && xR < ${a} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${w}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${a} &&\n                      xCOffset >= 0 && xCOffset < ${o}) {\n                      xTexelR${w}C${e} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${w}C${e} = vec4(0.);\n                    }\n                  `),y+=`\n                  xR${w}C${e+1} = vec4(\n                    xTexelR${w}C${e}.zw, xTexelR${w}C${e+2}.xy);\n                `):y+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${a} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${w}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${w}C${e+1} = xTexelR${w}C${e+2};\n                `}}else e<m&&(y+=`\n              if(xR >= 0 && xR < ${a}) {\n            `,u%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o}) {\n                  xTexelR${w}C${e+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${w}C${e+2} = vec4(0.);\n                }\n\n                xR${w}C${e} = vec4(\n                  xTexelR${w}C${e}.zw, xTexelR${w}C${e+2}.zw);\n              `,e+1<m&&(y+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${w}C${e+1} = vec4(xTexelR${w}C${e+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${o}) {\n                  xTexelR${w}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${w}C${e+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${e+2} = vec4(0.);\n                }\n\n                xR${w}C${e} = vec4(\n                  xTexelR${w}C${e}.xy, xTexelR${w}C${e+2}.xy);\n              `,e+1<m&&(y+=`\n                  xR${w}C${e+1} = vec4(\n                    xTexelR${w}C${e}.zw, xTexelR${w}C${e+2}.zw);\n                `)),y+="}");e<m&&(y+=`\n            vec4 wTexelR${w}C${e} = getW(${w}, ${e}, d1, q);\n            wR${w}C${e} = vec4(wTexelR${w}C${e}.xz, wTexelR${w}C${e}.xz);\n          `,e+1<m&&(y+=`\n              vec4 wTexelR${w}C${e+1} = getW(${w}, ${e+1}, d1, q);\n              wR${w}C${e+1} =\n                vec4(wTexelR${w}C${e+1}.xz, wTexelR${w}C${e+1}.xz);`))}for(let s=0;s<f;s++)for(let t=0;t<m;t++)y+=`dotProd += xR${s}C${t} * wR${s}C${t};`;let b="",x="";n&&(b=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,x="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${y}\n\n        vec4 result = dotProd;\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}}const xK={kernelName:"DepthwiseConv2dNative",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a}=e,{strides:o,pad:l,dilations:u,dimRoundingMode:c}=r;let h=u;null==h&&(h=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const p=d.computeConv2DInfo(i.shape,a.shape,o,h,l,c,!0);let f;return f=Bk().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new bK(p):new yK(p),n.runWebGLProgram(f,[i,a],"float32")}};class vK{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wK{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,s=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const _K={kernelName:"DepthwiseConv2dNativeBackpropFilter",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s,h=d.computeConv2DInfo(r.shape,c,a,o,l,u,!0),p=new vK(h);return n.runWebGLProgram(p,[r,i],"float32")}},kK={kernelName:"DepthwiseConv2dNativeBackpropInput",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=s,h=d.computeConv2DInfo(c,i.shape,a,o,l,u,!0),p=new wK(h);return n.runWebGLProgram(p,[r,i],"float32")}};class SK{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const CK={kernelName:"Diag",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=[...r.shape,...r.shape],a=s.sizeFromShape(r.shape),o=_G({inputs:{x:r},backend:n,attrs:{shape:[a]}}),l=new SK(a),u=n.runWebGLProgram(l,[o],o.dtype),c=_G({inputs:{x:u},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}};class IK{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:s,strideHeight:r,strideWidth:i,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const NK={kernelName:"Dilation2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,u=d.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l);let c;const h=new IK(u);c=n.runWebGLProgram(h,[r,i],"float32");const p=_G({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}},EK={kernelName:"Elu",backendName:"webgl",kernelFunc:fG({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"})},TK={kernelName:"EluGrad",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,i=Bk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sG("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new nG("return (b >= 1.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}},AK={kernelName:"Equal",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"})},$K={kernelName:"Erf",backendName:"webgl",kernelFunc:fG({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${d.ERF_P};\n  float a1 = ${d.ERF_A1};\n  float a2 = ${d.ERF_A2};\n  float a3 = ${d.ERF_A3};\n  float a4 = ${d.ERF_A4};\n  float a5 = ${d.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`})},RK="return exp(x);",FK=fG({opSnippet:RK,packedOpSnippet:RK,cpuKernelImpl:gH}),DK={kernelName:"Exp",backendName:"webgl",kernelFunc:FK};function OK(t){const{inputs:e,attrs:n,backend:r}=t,{dim:i}=n,{input:a}=e,o=a.shape.length,l=a.shape.slice();let u=i;return i<0&&(s.assert(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),l.splice(u,0,1),_G({inputs:{x:a},backend:r,attrs:{shape:l}})}const LK={kernelName:"ExpandDims",backendName:"webgl",kernelFunc:OK},MK="return exp(x) - 1.0;",PK={kernelName:"Expm1",backendName:"webgl",kernelFunc:fG({opSnippet:MK,packedOpSnippet:MK,cpuKernelImpl:yH})};class zK{constructor(t,e,n){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function BK(t,e,n){const r=n.texData.get(t.dataId),i=s.sizeFromShape(t.shape),a=t.shape[t.shape.length-1],o=_G({inputs:{x:t},backend:n,attrs:{shape:[i/a,a]}}),l=o.shape,u=new zK("real",l,e),c=new zK("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,h,"float32"),p=n.runWebGLProgram(c,h,"float32"),f=aG({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const m=_G({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}const VK={kernelName:"FFT",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return BK(s,!1,n)}};class WK{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}function UK(t){const{backend:e,attrs:n}=t,{shape:r,value:i}=n;let{dtype:a}=n;if(a=a||s.inferDtype(i),"string"===a){const t=s.getArrayFromDType(a,s.sizeFromShape(r));return t.fill(i),e.makeTensorInfo(r,a,t)}{const t=new WK(r,i),n=t.getCustomSetupFunc(i);return e.runWebGLProgram(t,[],a,n)}}const jK={kernelName:"Fill",backendName:"webgl",kernelFunc:UK};class HK{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const GK={kernelName:"FlipLeftRight",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new HK(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}},qK="return floor(x);",KK={kernelName:"Floor",backendName:"webgl",kernelFunc:fG({opSnippet:qK,packedOpSnippet:qK,cpuKernelImpl:bH})},XK={kernelName:"FloorDiv",backendName:"webgl",kernelFunc:mG({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"})};class QK{constructor(t){this.variableNames=["A"];const e=Dj(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class YK{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Dj(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const ZK={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:i}=s,a="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];(o||a)&&(null==JK&&(JK=document.createElement("canvas").getContext("2d")),JK.canvas.width=l,JK.canvas.height=u,JK.drawImage(r,0,0,l,u),r=JK.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=aj.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=Bk().getBool("WEBGL_PACK")?new YK(h):new QK(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let JK;const tX={kernelName:"FusedConv2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a,bias:o,preluActivationWeights:l}=e,{strides:u,pad:c,dataFormat:h,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=r,y=d.convertConv2DDataFormat(h),b=d.computeConv2DInfo(i.shape,a.shape,u,p,c,f,!1,y);let x;const v=[];if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(Bk().getBool("WEBGL_CONV_IM2COL")&&1===i.shape[0])x=Xq({x:i,filter:a,convInfo:b,backend:n,bias:o,activation:m,preluActivationWeights:l,leakyreluAlpha:g});else{const t=null!=o,e=null!=l,r="leakyrelu"===m,u=m?gG(m,!1):null,c=new Hq(b,t,u,e,r),h=[i,a];if(o&&h.push(o),l&&h.push(l),r){const t=n.makeTensorInfo([],"float32",s.createScalarValue(g,"float32"));h.push(t),v.push(t)}x=n.runWebGLProgram(c,h,"float32")}else x=Kq({x:i,filter:a,convInfo:b,backend:n,bias:o,activation:m,preluActivationWeights:l,leakyreluAlpha:g});const w=_G({inputs:{x},backend:n,attrs:{shape:b.outShape}});return v.push(x),v.forEach(t=>n.disposeIntermediateTensorInfo(t)),w}},eX={kernelName:"FusedDepthwiseConv2D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:a,bias:o,preluActivationWeights:l}=e,{strides:u,pad:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=[];let y=h;null==y&&(y=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(u,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${y}'`);const b=d.computeConv2DInfo(i.shape,a.shape,u,y,c,p,!0),x=Bk().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels==1,v=f?gG(f,x):null,w=[i,a],_=null!=o,k=null!=l,S="leakyrelu"===f;if(_&&w.push(o),k&&w.push(l),S){const t=n.makeTensorInfo([],"float32",s.createScalarValue(m,"float32"));w.push(t),g.push(t)}let C;C=x?new bK(b,_,v,k,S):new yK(b,_,v,k,S);const I=n.runWebGLProgram(C,w,"float32");return g.forEach(t=>n.disposeIntermediateTensorInfo(t)),I}};class nX{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const s=oH(e.length),r=oH(n.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const sX={kernelName:"GatherNd",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,a=i.shape,o=a[a.length-1],[l,u,c,h]=d.prepareAndValidate(r,i),p=_G({inputs:{x:i},backend:n,attrs:{shape:[u,o]}}),f=_G({inputs:{x:r},backend:n,attrs:{shape:[s.sizeFromShape(r.shape)/c,c]}}),m=new nX(o,h,[u,c]),g=n.runWebGLProgram(m,[f,p],f.dtype),y=_G({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}};class rX{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=oH(this.rank),s=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)s.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const iX={kernelName:"GatherV2",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:a}=e,{axis:o,batchDims:l}=r,u=s.parseAxisParam(o,i.shape)[0],c=d.segment_util.collectGatherOpShapeInfo(i,a,u,l),h=s.sizeFromShape(a.shape),p=[],f=_G({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=_G({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}});p.push(f),p.push(m);const g=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,a])||"string"===i.dtype){const t=n.bufferSync(m),e=n.bufferSync(f),s=xH(e,t,g);return p.forEach(t=>n.disposeIntermediateTensorInfo(t)),n.makeTensorInfo(c.outputShape,s.dtype,s.values)}const y=new rX(f.shape,g),b=n.runWebGLProgram(y,[f,m],f.dtype);p.push(b);const x=_G({inputs:{x:b},backend:n,attrs:{shape:c.outputShape}});return p.forEach(t=>n.disposeIntermediateTensorInfo(t)),x}},aX={kernelName:"Greater",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:vH,dtype:"bool"})},oX={kernelName:"GreaterEqual",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"})},lX={kernelName:"IFFT",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:s}=e;return BK(s,!0,n)}},uX={kernelName:"IsFinite",backendName:"webgl",kernelFunc:fG({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},cX={kernelName:"IsInf",backendName:"webgl",kernelFunc:fG({opSnippet:"return float(isinf(x));",dtype:"bool"})},hX={kernelName:"IsNan",backendName:"webgl",kernelFunc:fG({opSnippet:"return float(isnan(x));",dtype:"bool"})},dX={kernelName:"Less",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:wH,dtype:"bool"})},pX={kernelName:"LessEqual",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"})},fX={kernelName:"LinSpace",backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:i}=n,a=_H(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}},mX={kernelName:"Log",backendName:"webgl",kernelFunc:fG({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:kH})},gX={kernelName:"Log1p",backendName:"webgl",kernelFunc:fG({opSnippet:"return log(1.0 + x);"})},yX={kernelName:"LogicalAnd",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"})},bX={kernelName:"LogicalNot",backendName:"webgl",kernelFunc:fG({opSnippet:"return float(!(x >= 1.0));"})},xX={kernelName:"LogicalOr",backendName:"webgl",kernelFunc:mG({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"})};class vX{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class wX{constructor(t,e,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const _X={kernelName:"LRN",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s,u=Bk().getBool("WEBGL_PACK_NORMALIZATION")?new wX(r.shape,i,a,o,l):new vX(r.shape,i,a,o,l);return n.runWebGLProgram(u,[r],r.dtype)}};class kX{constructor(t,e,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const SX={kernelName:"LRNGrad",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=s,h=new kX(r.shape,o,l,u,c);return n.runWebGLProgram(h,[r,i,a],r.dtype)}};function CX(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l),p=null!=h,f=n.shouldExecuteOnCPU([i]);let m=i;if(p){if(f){const t=n.texData.get(m.dataId).values,e=new Array(l);for(let n=0;n<e.length;n++)e[n]=i.shape[h[n]];const s=PH(t,i.shape,i.dtype,h,e);m=n.makeTensorInfo(e,i.dtype),n.texData.get(m.dataId).values=s}else m=TG(i,h,n);c=d.getInnerMostAxes(c.length,l)}d.assertAxesAreInnerMostDims("max",c,l);const[g,y]=d.computeOutAndReduceShapes(m.shape,c);let b,x=g;if(o&&(x=d.expandShapeToKeepDim(g,u)),f){const t=n.texData.get(m.dataId),e=SH(t.values,s.sizeFromShape(y),x,i.dtype);b=n.makeTensorInfo(x,i.dtype),n.texData.get(b.dataId).values=e}else b=function(t,e,n,r){const i=s.sizeFromShape(e),a=_G({inputs:{x:t},attrs:{shape:[s.sizeFromShape(t.shape)/i,i]},backend:r}),o=IG(a,t.dtype,"max",r),l=_G({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(o),l}(m,y,x,n);return p&&n.disposeIntermediateTensorInfo(m),b}const IX={kernelName:"Max",backendName:"webgl",kernelFunc:CX},NX={kernelName:"Maximum",backendName:"webgl",kernelFunc:mG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:CH})},EX={kernelName:"MaxPool",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Rj(i,"maxPool");const{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;s.assert(d.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=d.computePool2DInfo(i.shape,a,o,1,l,u);if(1===c.filterWidth&&1===c.filterHeight&&s.arraysEqual(c.inShape,c.outShape))return rG({inputs:{x:i},backend:n});const h=new rq(c,"max",!1);return n.runWebGLProgram(h,[i],i.dtype)}},TX={kernelName:"MaxPool3D",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=s,c=d.computePool3DInfo(r.shape,i,a,[1,1,1],o,u,l),h=new iq(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class AX{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $X{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,s=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*s-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${s} +\n                  wR * ${s} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const RX={kernelName:"MaxPool3DGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=d.computePool3DInfo(a.shape,o,l,[1,1,1],u,c),p=new iq(h,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),m=new $X(h),g=n.runWebGLProgram(m,[r,f],a.dtype);return n.disposeIntermediateTensorInfo(f),g}},FX={kernelName:"MaxPoolGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:i,output:a}=e,o=i;Rj([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,p=d.computePool2DInfo(o.shape,l,u,1,c,h),f=new rq(p,"max",!0),m=n.runWebGLProgram(f,[o],o.dtype),g=new AX(p),y=n.runWebGLProgram(g,[r,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}},DX={kernelName:"MaxPoolWithArgmax",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:a,pad:o,includeBatchInIndex:l}=e,u=n;s.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];s.assert(d.eitherStridesOrDilationsAreOne(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=d.computePool2DInfo(r.shape,i,a,c,o),[p,f]=function(t,e,n,s){let r=new rq(n,"max",!1);const i=s.runWebGLProgram(r,[t],"float32");return r=new rq(n,"max",!0,!0,e),[i,s.runWebGLProgram(r,[t],"float32")]}(r,l,h,u);return[p,f]}},OX={kernelName:"Mean",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:i,axis:a}=e,o=n,l=r.shape.length,u=s.parseAxisParam(a,r.shape);let c=u;const h=d.getAxesPermutation(c,l),p=null!=h,f=o.shouldExecuteOnCPU([r]),m=[];let g=r;if(p){if(f){const t=o.texData.get(g.dataId).values,e=new Array(l);for(let s=0;s<e.length;s++)e[s]=r.shape[h[s]];const n=PH(t,r.shape,r.dtype,h,e);g=o.makeTensorInfo(e,r.dtype),o.texData.get(g.dataId).values=n}else g=TG(r,h,o);m.push(g),c=d.getInnerMostAxes(c.length,l)}d.assertAxesAreInnerMostDims("sum",c,l);const[y,b]=d.computeOutAndReduceShapes(g.shape,c);let x=y;i&&(x=d.expandShapeToKeepDim(y,u));const v=function(t,e,n,r){const i=s.sizeFromShape(e),a=_G({inputs:{x:t},attrs:{shape:[s.sizeFromShape(t.shape)/i,i]},backend:r}),o=IG(a,"float32","mean",r),l=_G({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(o),l}(g,b,x,o);for(const s of m)o.disposeIntermediateTensorInfo(s);return v}},LX={kernelName:"Min",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=s.parseAxisParam(a,i.shape);let c=u;const h=d.getAxesPermutation(c,l);let p=i;null!=h&&(p=RG({inputs:{x:i},backend:n,attrs:{perm:h}}),c=d.getInnerMostAxes(c.length,i.shape.length)),d.assertAxesAreInnerMostDims("min",c,l);const[f,m]=d.computeOutAndReduceShapes(p.shape,c),g=_G({inputs:{x:p},backend:n,attrs:{shape:[-1,s.sizeFromShape(m)]}}),y=IG(g,g.dtype,"min",n);let b;return b=_G(o?{inputs:{x:y},backend:n,attrs:{shape:d.expandShapeToKeepDim(f,u)}}:{inputs:{x:y},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=h&&n.disposeIntermediateTensorInfo(p),b}},MX={kernelName:"Minimum",backendName:"webgl",kernelFunc:mG({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:IH})};class PX{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=oH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class zX{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=oH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=VH("rc",s),l=VH("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===s){const t=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const t=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[s-2]} += 1;\n        if(${o[s-2]} < ${this.outputShape[s-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[s-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const BX={kernelName:"MirrorPad",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:i}=n,a=Bk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zX(s.shape,r,i):new PX(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)}},VX={kernelName:"Mod",backendName:"webgl",kernelFunc:mG({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})};class WX{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}const UX=mG({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),jX={kernelName:"RealDiv",backendName:"webgl",kernelFunc:UX},HX="return a - b;",GX=mG({opSnippet:HX,packedOpSnippet:HX,supportsComplex:!0,cpuKernelImpl:OH}),qX={kernelName:"Sub",backendName:"webgl",kernelFunc:GX};function KX(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:a}=r,o=s.parseAxisParam([a],i.shape),l=CX({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=d.expandShapeToKeepDim(l.shape,o),c=_G({inputs:{x:l},backend:n,attrs:{shape:u}}),h=GX({inputs:{a:i,b:c},backend:n}),p=FK({inputs:{x:h},backend:n}),f=AG({inputs:{x:p},backend:n,attrs:{axis:o,keepDims:!1}}),m=_G({inputs:{x:f},backend:n,attrs:{shape:u}}),g=UX({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const XX={kernelName:"Softmax",backendName:"webgl",kernelFunc:KX},QX={kernelName:"Multinomial",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,l=o?r:KX({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=new WX(l.shape[0],l.shape[1],i),c=u.getCustomSetupFunc(a),h=n.runWebGLProgram(u,[l],"int32",c);return o||n.disposeIntermediateTensorInfo(l),h}},YX="return -x;",ZX={kernelName:"Neg",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const t=n.texData.get(s.dataId),[e,r]=EH(t.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,e)}let r;return r=Bk().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new YH(s.shape,YX):new KH(s.shape,YX),n.runWebGLProgram(r,[s],s.dtype)}},JX=p.nonMaxSuppressionV3Impl,tQ={kernelName:"NonMaxSuppressionV3",backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=JX(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},eQ=p.nonMaxSuppressionV4Impl,nQ={kernelName:"NonMaxSuppressionV4",backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:p,validOutputs:f}=eQ(c,h,a,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},sQ=p.nonMaxSuppressionV5Impl,rQ={kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(t){d.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),p=a,f=o,m=l,g=u,{selectedIndices:y,selectedScores:b}=sQ(c,h,p,f,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class iQ{constructor(t,e,n,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const aQ={kernelName:"OneHot",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{depth:a,onValue:o,offValue:l}=r,u=s.sizeFromShape(i.shape),c=new iQ(u,a,o,l),h=_G({inputs:{x:i},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],i.dtype);n.disposeIntermediateTensorInfo(h);const p=_G({inputs:{x:d},backend:n,attrs:{shape:[...i.shape,a]}});return n.disposeIntermediateTensorInfo(d),p}};function oQ(t){const{inputs:e,backend:n}=t,{x:s}=e;if("complex64"===s.dtype){const t=Cq({inputs:{input:s},backend:n}),e=oQ({inputs:{x:t},backend:n}),r=zq({inputs:{input:s},backend:n}),i=oQ({inputs:{x:r},backend:n}),a=aG({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return UK({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const lQ={kernelName:"ZerosLike",backendName:"webgl",kernelFunc:oQ},uQ={kernelName:"OnesLike",backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:s}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=Cq({inputs:{input:r},backend:s}),n=t({inputs:{x:e},backend:s}),i=zq({inputs:{input:r},backend:s}),a=oQ({inputs:{x:i},backend:s}),o=aG({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return UK({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}},cQ={kernelName:"Pack",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(1===e.length)return OK({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const a=e[0].shape,o=e[0].dtype;e.forEach(t=>{s.assertShapesMatch(a,t.shape,"All tensors passed to stack must have matching shapes"),s.assert(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=Uq({inputs:e.map(t=>{const e=OK({inputs:{input:t},backend:n,attrs:{dim:i}});return l.push(e),e}),backend:n,attrs:{axis:i}});return l.forEach(t=>n.disposeIntermediateTensorInfo(t)),u}};class hQ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=oH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class dQ{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const s=t.length,r=oH(s),i=e.map(t=>t[0]).join(","),a=e.map((e,n)=>e[0]+t[n]).join(","),o=VH("rc",s),l=VH("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${o[s-2]} += 1;\n       if(${o[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${o[s-1]} += 1;\n         if(${u}) {`],d=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===s?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}const pQ=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:i,constantValue:a}=s,o=Bk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dQ(r.shape,i,a):new hQ(r.shape,i,a),l=o.getCustomSetupFunc(a);return n.runWebGLProgram(o,[r],r.dtype,l)},fQ={kernelName:"PadV2",backendName:"webgl",kernelFunc:pQ},mQ={kernelName:"Pow",backendName:"webgl",kernelFunc:mG({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},gQ={kernelName:"Prod",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:a,keepDims:o}=r,l=i.shape.length,u=[],c=s.parseAxisParam(a,i.shape);let h=c;const p=d.getAxesPermutation(h,l);let f,m=i;if(null!=p&&(m=RG({inputs:{x:i},backend:n,attrs:{perm:p}}),h=d.getInnerMostAxes(h.length,l),u.push(m)),d.assertAxesAreInnerMostDims("prod",h,l),n.shouldExecuteOnCPU([m])){const t=n.texData.get(m.dataId).values,{outVals:e,outShape:s,outDtype:r}=TH(m.shape,m.dtype,t,h);f=n.makeTensorInfo(s,r,e)}else{const[t,e]=d.computeOutAndReduceShapes(m.shape,h),r=s.sizeFromShape(e),a=_G({inputs:{x:m},backend:n,attrs:{shape:[-1,r]}}),o=IG(a,NS(i.dtype),"prod",n);f=_G({inputs:{x:o},backend:n,attrs:{shape:t}}),u.push(a),u.push(o)}if(o){u.push(f);const t=d.expandShapeToKeepDim(f.shape,c);f=_G({inputs:{x:f},backend:n,attrs:{shape:t}})}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}},yQ=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:i,dtype:a}=n,o=AH(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},bQ={kernelName:"Range",backendName:"webgl",kernelFunc:yQ},xQ={kernelName:"Reciprocal",backendName:"webgl",kernelFunc:fG({opSnippet:"return 1.0 / x;"})},vQ={kernelName:"Relu",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"})},wQ={kernelName:"Relu6",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"})};class _Q{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class kQ{constructor(t,e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const SQ={kernelName:"ResizeBilinear",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=Bk().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kQ(r.shape,l,u,i,a):new _Q(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],"float32")}};class CQ{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,a]=t,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const IQ={kernelName:"ResizeBilinearGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s,o=new CQ(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class NQ{constructor(t,e,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[s&&e>1?a-1:a,s&&n>1?o-1:o],c=[s&&e>1?e-1:e,s&&n>1?n-1:n];let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const EQ={kernelName:"ResizeNearestNeighbor",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=new NQ(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],r.dtype)}};class TQ{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,r]=e,[,i,a]=t,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const AQ={kernelName:"ResizeNearestNeighborGrad",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:i}=e,{alignCorners:a}=s,o=new TQ(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class $Q{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const s=t.map((n,s)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(s)).join(","),r=oH(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class RQ{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const s=VH("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,a=oH(n);function o(n){const s=t.map((s,r)=>function(n,s){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return o(t)}(s.slice())};\n          if(${r}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",o(t)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",o(t)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",o(t)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const FQ={kernelName:"Reverse",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:a}=r,o=i.shape.length,l=s.parseAxisParam(a,i.shape);if(0===o)return rG({inputs:{x:i},backend:n});const u=Bk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RQ(i.shape,l):new $Q(i.shape,l);return n.runWebGLProgram(u,[i],i.dtype)}};class DQ{constructor(t,e){this.variableNames=["Image"],this.outputShape=[];const n=t[1],s=t[2];this.outputShape=t;let r="";r="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(t,e,n,s){return(r,i)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(i,"params")),r.gl.uniform4f(this.paramsLoc,t,e,n,s)}}}const OQ={kernelName:"RotateWithOffset",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:i,center:a}=e,o=n,l=new DQ(s.shape,i),[u,c]=d.getImageCenter(a,s.shape[1],s.shape[2]),h=l.getCustomSetupFunc(u,c,Math.sin(r),Math.cos(r));return o.runWebGLProgram(l,[s],s.dtype,h)}},LQ={kernelName:"Round",backendName:"webgl",kernelFunc:fG({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"})},MQ={kernelName:"Rsqrt",backendName:"webgl",kernelFunc:fG({opSnippet:"return inversesqrt(x);",cpuKernelImpl:$H})};class PQ{constructor(t,e,n,s,r,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const o=oH(r.length),l=oH(i.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===s?c="i":2===s&&(c="i, coords[1]"),this.userCode=`\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const zQ={kernelName:"ScatterNd",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=d.calculateShapes(i,r,a),p=[h/u,u];if(0===h)return n.makeTensorInfo(a,r.dtype);const f=_G({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),m=_G({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),y=new PQ(l,o,f.shape.length,m.shape.length,c,p),b=n.runWebGLProgram(y,[m,f,g],m.dtype),x=_G({inputs:{x:b},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),x}};class BQ{constructor(t,e,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let s=0;s<e.length;s++)a.push(`${n[s]}`),s<t&&i.push(`${n[s]}`);s=i.join(),r=a.join()}const i=oH(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const VQ={kernelName:"Select",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:i}=e,a=new BQ(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(a,[s,r,i],IS(r.dtype,i.dtype))}},WQ={kernelName:"Selu",backendName:"webgl",kernelFunc:fG({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${d.SELU_SCALEALPHA};\n  float scale = ${d.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`})},UQ={kernelName:"Sigmoid",backendName:"webgl",kernelFunc:fG({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"})},jQ={kernelName:"Sign",backendName:"webgl",kernelFunc:fG({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"})},HQ={kernelName:"Sin",backendName:"webgl",kernelFunc:fG({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"})},GQ={kernelName:"Sinh",backendName:"webgl",kernelFunc:fG({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"})},qQ={kernelName:"Softplus",backendName:"webgl",kernelFunc:fG({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"})},KQ={kernelName:"SpaceToBatchND",backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:a,paddings:o}=r;s.assert(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=a.reduce((t,e)=>t*e),u=[[0,0]];u.push(...o);for(let s=1+a.length;s<i.shape.length;++s)u.push([0,0]);const c=[],h=pQ({inputs:{x:i},backend:n,attrs:{paddings:u,constantValue:0}}),p=d.getReshaped(h.shape,a,l,!1),f=d.getPermuted(p.length,a.length,!1),m=d.getReshapedPermuted(h.shape,a,l,!1),g=_G({inputs:{x:h},backend:n,attrs:{shape:p}}),y=RG({inputs:{x:g},backend:n,attrs:{perm:f}}),b=_G({inputs:{x:y},backend:n,attrs:{shape:m}});return c.push(h),c.push(g),c.push(y),c.forEach(t=>n.disposeIntermediateTensorInfo(t)),b}},XQ={kernelName:"SparseToDense",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:u,strides:c,outputSize:h}=d.calculateShapes(i,r,o),p=new PQ(u,l,r.shape.length,i.shape.length,c,[h,1],!1),f=n.runWebGLProgram(p,[i,r,a],i.dtype),m=_G({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}},QQ={kernelName:"SplitV",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:a,axis:o}=r,l=s.parseAxisParam(o,i.shape)[0],u=d.prepareSplitSize(i,a,l),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return u.map(t=>{const e=[...h];e[l]=t;const s=xq({inputs:{x:i},backend:n,attrs:{begin:c,size:e}});return c[l]+=t,s})}},YQ={kernelName:"Sqrt",backendName:"webgl",kernelFunc:fG({opSnippet:"return sqrt(x);"})},ZQ={kernelName:"Square",backendName:"webgl",kernelFunc:fG({opSnippet:"return x * x;"})},JQ={kernelName:"SquaredDifference",backendName:"webgl",kernelFunc:mG({opSnippet:"return (a - b) * (a - b);",packedOpSnippet:"return (a - b) * (a - b);"})},tY={kernelName:"Step",backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=new KH(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `);return n.runWebGLProgram(r,[s],s.dtype)}};class eY{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=oH(n.length),i=oH(n.length);let a="";if(1===s)a="coords * strides + begin";else{let t=0;a=n.map((e,s)=>(t++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${t-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const nY={kernelName:"StridedSlice",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{nonStrided:f,$begin:m,$strides:g,size:y,newShape:b,outShape:x}=l.sliceInfo(r.shape,i,a,o,u,c,h,d,p),v=_G({inputs:{x:r},backend:n,attrs:{shape:b}});let w;if(f){const t=xq({inputs:{x:v},backend:n,attrs:{begin:m,size:y}});w=_G({inputs:{x:t},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(t)}else if(x.some(t=>0===t))w=n.makeTensorInfo(x,r.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const t=n.texData.get(v.dataId),e=MC(v.shape,v.dtype,t.values),s=DH(x,e,g,m);w=n.makeTensorInfo(x,v.dtype,s.values)}else{const t=new eY(m,g,x);w=n.runWebGLProgram(t,[v],v.dtype)}const _=_G({inputs:{x:w},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),_}},sY={kernelName:"Tan",backendName:"webgl",kernelFunc:fG({opSnippet:"return tan(x);"})},rY={kernelName:"Tanh",backendName:"webgl",kernelFunc:fG({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"})};class iY{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const s=oH(this.rank),r=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function aY(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:a}=r;if("string"===i.dtype){const t=n.readSync(i.dataId).map(t=>s.decodeString(t)),e=MC(i.shape,i.dtype,t),r=LH(e,a);return n.makeTensorInfo(r.shape,r.dtype,r.values)}const o=new iY(i.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}const oY={kernelName:"Tile",backendName:"webgl",kernelFunc:aY},lY={kernelName:"TopK",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:i,sorted:a}=s,o=n.readSync(r.dataId),[l,u]=MH(o,r.shape,r.dtype,i,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};class uY{constructor(t,e,n,s,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===n?1:2;let o;switch(s){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const cY={kernelName:"Transform",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,m]=null!=u?u:[h,d],g=new uY(h,d,a,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[r,i],"float32")}},hY={kernelName:"Unique",backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:i}=e;Rj(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=zH(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}},dY={kernelName:"Unpack",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==i&&(u[c++]=a.shape[m]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;const t=xq({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),e=_G({inputs:{x:t},backend:n,attrs:{shape:u}});f[m]=e,h.push(t)}return h.forEach(t=>n.disposeIntermediateTensorInfo(t)),f}};class pY{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,s=t.batchSize,r=t.inSize,i=t.numSegments,a=i*Math.ceil(r/n);this.outputShape=[s,a];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const fY=[_X,SX,OG,LG,MG,PG,BG,UG,jG,HG,YG,ZG,JG,tq,nq,eq,sq,oq,aq,cq,hq,dq,mq,wq,_q,Nq,Tq,Rq,Oq,oG,jq,eK,nK,Qq,rK,iK,sK,aK,oK,uK,pK,fK,gK,_K,kK,xK,CK,NK,EK,TK,AK,$K,DK,LK,PK,VK,jK,GK,KK,XK,ZK,tX,eX,sX,iX,aX,oX,iG,lX,Bq,uX,cX,hX,cG,dX,pX,fX,gX,mX,yX,bX,xX,IX,TX,EX,RX,FX,DX,NX,OX,LX,MX,BX,VX,QX,wG,ZX,tQ,nQ,rQ,Sq,aQ,uQ,cQ,fQ,mQ,pG,gQ,bQ,Iq,jX,xQ,wQ,vQ,kG,SQ,IQ,EQ,AQ,FQ,OQ,LQ,MQ,zQ,VQ,WQ,UQ,jQ,HQ,GQ,vq,XX,qQ,KQ,XQ,QQ,YQ,ZQ,JQ,tY,nY,qX,$G,sY,rY,oY,lY,cY,FG,hY,dY,{kernelName:"UnsortedSegmentSum",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:a}=e,{numSegments:o}=r,l=i.shape.length,u=[];let c=0;const h=d.getAxesPermutation([c],l);let p=i;null!=h&&(p=RG({inputs:{x:i},backend:n,attrs:{perm:h}}),u.push(p),c=d.getInnerMostAxes(1,l)[0]);const f=d.segment_util.computeOutShape(p.shape,c,o),m=s.sizeFromShape([p.shape[c]]),g=_G({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}});u.push(g);const y=NS(i.dtype),b=(t,e,s,r,i)=>{const a=t.shape[0],o=t.shape[1],l=d.segment_util.segOpComputeOptimalWindowSize(o,i),c=new pY({windowSize:l,inSize:o,batchSize:a,numSegments:i},e),h=n.compileAndRun(c,[t,s],r);if(u.push(h),h.shape[1]===i)return h;const p=yQ({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=aY({inputs:{x:p},backend:n,attrs:{reps:[o/l]}});return u.push(p),u.push(f),b(h,e,f,r,i)},x=_G({inputs:{x:b(g,"unsortedSegmentSum",a,y,o)},backend:n,attrs:{shape:f}});let v=x;if(null!=h){u.push(x);const t=d.getUndoAxesPermutation(h);v=RG({inputs:{x:v},backend:n,attrs:{perm:t}})}return u.forEach(t=>n.disposeIntermediateTensorInfo(t)),v}},lQ];for(const IY of fY)Qk(IY);function mY(t,e){1&t&&(Ua(0,"div"),Ha(1,"mat-progress-bar",6),ja())}function gY(t,e){if(1&t){const t=Ga();Ua(0,"div"),Ua(1,"mat-card"),Io(2," Drop your screenshots below: "),Ha(3,"br"),Ha(4,"br"),Ua(5,"ngx-dropzone",7),Ka("change",function(e){rn(t);const n=Ja();return n.onSelect(e),n.startEyeball()}),Ua(6,"ngx-dropzone-label"),Io(7," Files dropped here are "),Ua(8,"span",8),Io(9,"not uploaded anywhere."),ja(),Io(10," No data leaves your computer at all on this tool. "),ja(),ja(),ja(),Ha(11,"br"),Ua(12,"mat-card"),Ua(13,"span",8),Io(14,"Note:"),ja(),Io(15," For best results, ensure your screenshots are taken natively in a "),Ua(16,"span",8),Io(17,"16:10 aspect ratio."),ja(),Io(18," (ie: 1440x900 or other) "),ja(),Ua(19,"mat-card"),Io(20," Source code available at "),Ua(21,"a",9),Io(22,"GitHub"),ja(),ja(),ja()}}function yY(t,e){if(1&t&&(Ua(0,"div"),Ua(1,"mat-card"),Ua(2,"h3"),Io(3),ja(),Ha(4,"mat-progress-bar",10),ja(),Ua(5,"mat-card"),Ua(6,"h3"),Io(7),ja(),Ha(8,"mat-progress-bar",10),ja(),Ua(9,"mat-card"),Io(10," This processing is happening in your browser. "),Ua(11,"span",8),Io(12,"There is no backend."),ja(),ja(),ja()),2&t){const t=Ja();pi(3),To("Loading Images: ",t.images.size," of ",t.imageCount,""),pi(1),Va("value",t.loadPercent()),pi(3),To("Classifying: ",t.eyeballedCount," of ",t.imageCount,""),pi(1),Va("value",t.eyeballPercent())}}function bY(t,e){if(1&t&&(Ua(0,"div"),Ua(1,"mat-card",23),Ua(2,"mat-card-header"),Ua(3,"mat-card-title"),Io(4),ja(),ja(),Ha(5,"img",24),Ua(6,"span",25),Io(7),ja(),Ua(8,"span",26),Io(9),ja(),Ua(10,"span",27),Io(11),ja(),Ua(12,"span",28),Io(13),ja(),Ua(14,"span",29),Io(15),ja(),ja(),ja()),2&t){const t=e.$implicit,n=e.index,s=Ja(2);Ma("data-index",n),pi(4),Eo(" ",t," "),pi(1),so("src",s.images.get(t),xr),pi(2),No(s.isWebapp(t)),pi(2),No(s.isCustom404(t)),pi(2),No(s.isLoginPage(t)),pi(2),No(s.isOldLooking(t)),pi(2),No(s.isParked(t))}}function xY(t,e){if(1&t){const t=Ga();Ua(0,"div"),Ua(1,"div",11),Ua(2,"h2"),Io(3,"Results"),ja(),Ua(4,"mat-toolbar"),Ua(5,"mat-toolbar-row",12),Ha(6,"span",13),Ua(7,"button",14),Ka("click",function(){rn(t);const e=Ja();return e.selected.webapp=0,e.updateSelections()}),Io(8,"Must Include"),ja(),Ua(9,"button",15),Ka("click",function(){rn(t);const e=Ja();return e.selected.webapp=1,e.updateSelections()}),Io(10,"Webapp"),ja(),Ua(11,"button",16),Ka("click",function(){rn(t);const e=Ja();return e.selected.webapp=2,e.updateSelections()}),Io(12,"Never Include"),ja(),Ua(13,"label",17),Io(14),ja(),Ha(15,"span",13),ja(),Ua(16,"mat-toolbar-row",12),Ha(17,"span",13),Ua(18,"button",14),Ka("click",function(){rn(t);const e=Ja();return e.selected.oldLooking=0,e.updateSelections()}),Io(19,"Must Include"),ja(),Ua(20,"button",15),Ka("click",function(){rn(t);const e=Ja();return e.selected.oldLooking=1,e.updateSelections()}),Io(21,"Old Looking"),ja(),Ua(22,"button",16),Ka("click",function(){rn(t);const e=Ja();return e.selected.oldLooking=2,e.updateSelections()}),Io(23,"Never Include"),ja(),Ua(24,"label",17),Io(25),ja(),Ha(26,"span",13),ja(),Ua(27,"mat-toolbar-row",12),Ha(28,"span",13),Ua(29,"button",18),Ka("click",function(){rn(t);const e=Ja();return e.selected.loginPage=0,e.updateSelections()}),Io(30,"Must Include"),ja(),Ua(31,"button",15),Ka("click",function(){rn(t);const e=Ja();return e.selected.loginPage=1,e.updateSelections()}),Io(32,"Login Page"),ja(),Ua(33,"button",16),Ka("click",function(){rn(t);const e=Ja();return e.selected.loginPage=2,e.updateSelections()}),Io(34,"Never Include"),ja(),Ua(35,"label",17),Io(36),ja(),Ha(37,"span",13),ja(),Ua(38,"mat-toolbar-row",12),Ha(39,"span",13),Ua(40,"button",18),Ka("click",function(){rn(t);const e=Ja();return e.selected.custom404=0,e.updateSelections()}),Io(41,"Must Include"),ja(),Ua(42,"button",15),Ka("click",function(){rn(t);const e=Ja();return e.selected.custom404=1,e.updateSelections()}),Io(43,"Custom 404"),ja(),Ua(44,"button",16),Ka("click",function(){rn(t);const e=Ja();return e.selected.custom404=2,e.updateSelections()}),Io(45,"Never Include"),ja(),Ua(46,"label",17),Io(47),ja(),Ha(48,"span",13),ja(),Ua(49,"mat-toolbar-row",12),Ha(50,"span",13),Ua(51,"button",18),Ka("click",function(){rn(t);const e=Ja();return e.selected.parked=0,e.updateSelections()}),Io(52,"Must Include"),ja(),Ua(53,"button",15),Ka("click",function(){rn(t);const e=Ja();return e.selected.parked=1,e.updateSelections()}),Io(54,"Parked Domain"),ja(),Ua(55,"button",16),Ka("click",function(){rn(t);const e=Ja();return e.selected.parked=2,e.updateSelections()}),Io(56,"Never Include"),ja(),Ua(57,"label",17),Io(58),ja(),Ha(59,"span",13),ja(),ja(),Ua(60,"mat-card"),Ua(61,"span",8),Io(62,"Total Selected:"),ja(),Io(63),ja(),Ha(64,"br"),Ua(65,"mat-card"),Ua(66,"button",19),Ka("click",function(){return rn(t),Ja().exportResults()}),Io(67," Export "),ja(),Ua(68,"a",20),Io(69,"What do these labels mean?"),ja(),ja(),Ua(70,"div",21),za(71,bY,16,8,"div",22),ja(),ja(),ja()}if(2&t){const t=Ja();pi(7),Va("disabled",0===t.selected.webapp),pi(2),Va("disabled",1===t.selected.webapp),pi(2),Va("disabled",2===t.selected.webapp),pi(3),No(t.classifications.webapp.length),pi(4),Va("disabled",0===t.selected.oldLooking),pi(2),Va("disabled",1===t.selected.oldLooking),pi(2),Va("disabled",2===t.selected.oldLooking),pi(3),No(t.classifications.oldLooking.length),pi(4),Va("disabled",0===t.selected.loginPage),pi(2),Va("disabled",1===t.selected.loginPage),pi(2),Va("disabled",2===t.selected.loginPage),pi(3),No(t.classifications.loginPage.length),pi(4),Va("disabled",0===t.selected.custom404),pi(2),Va("disabled",1===t.selected.custom404),pi(2),Va("disabled",2===t.selected.custom404),pi(3),No(t.classifications.custom404.length),pi(4),Va("disabled",0===t.selected.parked),pi(2),Va("disabled",1===t.selected.parked),pi(2),Va("disabled",2===t.selected.parked),pi(3),No(t.classifications.parked.length),pi(5),Eo(" ",t.selectedScreens.length," "),pi(8),Va("ngForOf",t.selectedScreens.slice(0,8))}}const vY=[{path:"",component:(()=>{class t{constructor(){this.offset=DI(127.5),this.images=new Map,this.confidence=.5,this.width=224,this.height=224,this.tfFilesCompleted=!1,this.tfFiles=[],this.maxWorkers=20,this.imageCount=0,this.loadedCount=0,this.finishedLoading=!1,this.eyeballing=!1,this.eyeballCompleted=!1,this.eyeballedCount=0,this.classifications={custom404:[],loginPage:[],webapp:[],oldLooking:[],parked:[]},this.selected={custom404:2,loginPage:1,webapp:0,oldLooking:1,parked:2},this.selectedScreens=[]}ngOnInit(){this.fetchTfFiles()}onSelect(t){return eg(this,void 0,void 0,function*(){this.imageCount=t.addedFiles.length,yield Promise.all(t.addedFiles.map(t=>eg(this,void 0,void 0,function*(){const e=yield this.dataURI(t);this.images.set(t.name,e)})))})}onRemove(t){this.images.delete(t.name)}isWebapp(t){return this.classifications.webapp.includes(t)?"Webapp":""}isCustom404(t){return this.classifications.custom404.includes(t)?"Custom 404":""}isLoginPage(t){return this.classifications.loginPage.includes(t)?"Login Page":""}isOldLooking(t){return this.classifications.oldLooking.includes(t)?"Old Looking":""}isParked(t){return this.classifications.parked.includes(t)?"Parked Domain":""}fetchTfFiles(){var t;return eg(this,void 0,void 0,function*(){let e=yield fetch("assets/tf/model.json");const n=yield e.json(),s=Array.from(null===(t=n.weightsManifest[0])||void 0===t?void 0:t.paths);this.tfFiles=[],e=yield fetch("assets/tf/model.json");const r=yield e.blob();this.tfFiles.push(new File([r],"model.json")),yield Promise.all(s.map(t=>eg(this,void 0,void 0,function*(){const e=yield this.fetchTfFile(t);this.tfFiles.push(e)}))),this.tfFilesCompleted=!0})}fetchTfFile(t){return eg(this,void 0,void 0,function*(){const e=t.split("/").reverse()[0],n=yield fetch(`assets/tf/${e}`),s=yield n.blob();return new File([s],e)})}startEyeball(){return eg(this,void 0,void 0,function*(){yield this.executeQueue(),yield this.updateSelections()})}updateSelections(){return eg(this,void 0,void 0,function*(){let t=new Set([]);for(let n of this.classifications.webapp)t.add(n);for(let n of this.classifications.oldLooking)t.add(n);for(let n of this.classifications.loginPage)t.add(n);for(let n of this.classifications.custom404)t.add(n);for(let n of this.classifications.parked)t.add(n);let e=Array.from(t);if(0===this.selected.webapp){let t=e.filter(t=>this.classifications.webapp.includes(t));e=t}if(0===this.selected.oldLooking){let t=e.filter(t=>this.classifications.oldLooking.includes(t));e=t}if(0===this.selected.loginPage){let t=e.filter(t=>this.classifications.loginPage.includes(t));e=t}if(0===this.selected.custom404){let t=e.filter(t=>this.classifications.custom404.includes(t));e=t}if(0===this.selected.parked){let t=e.filter(t=>this.classifications.parked.includes(t));e=t}if(t=new Set(e),2===this.selected.webapp)for(let n of this.classifications.webapp)t.delete(n);if(2===this.selected.oldLooking)for(let n of this.classifications.oldLooking)t.delete(n);if(2===this.selected.loginPage)for(let n of this.classifications.loginPage)t.delete(n);if(2===this.selected.custom404)for(let n of this.classifications.custom404)t.delete(n);if(2===this.selected.parked)for(let n of this.classifications.parked)t.delete(n);this.selectedScreens=Array.from(t)})}executeQueue(){return eg(this,void 0,void 0,function*(){this.eyeballing=!0;const t=yield(e=a.browserFiles(this.tfFiles),null==n&&(n={}),async function(t,e){if(null==e&&(e={}),"string"==typeof t){const n=a.getLoadHandlers(t,e);if(0===n.length)n.push(a.browserHTTPRequest(t,e));else if(n.length>1)throw new yF(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return async function(t,e,n){if(null==n&&(n={}),null==t.load)throw new yF("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await t.load();let r=s.modelTopology;null!=r.model_config&&(r=r.model_config);const i=null==n.strict||n.strict,o=null!=s.weightData&&null!=s.weightSpecs&&i,l=AO(nL(r),void 0,o),u=s.trainingConfig;if(null!=u&&l.loadTrainingConfig(u),null!=s.userDefinedMetadata&&l.setUserDefinedMetadata(s.userDefinedMetadata),null!=s.weightData){if(null==s.weightSpecs)throw new yF("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=a.decodeWeights(t,e),s={},r=[];return e.forEach(t=>{"optimizer"===t.group?r.push({name:t.name,tensor:n[t.name]}):s[t.name]=n[t.name]}),{modelWeights:s,optimizerWeights:r}}(s.weightData,s.weightSpecs);l.loadWeights(t,i),null!=l.optimizer&&e.length>0&&await l.optimizer.setWeights(e),AI(t),AI(e.map(t=>t.tensor))}return l}(t,0,e)}(e,n));var e,n;const s=Array.from(this.images.keys());let r=0,i=0;return new Promise(e=>{const n=()=>{if(r<this.maxWorkers&&i<this.imageCount){const e=new Image(this.width,this.height),a=s[i];e.src=this.images.get(a),this.loadedCount++,e.onerror=()=>{this.eyeballedCount++,this.eyeballedCount>=this.imageCount&&(this.eyeballing=!1,this.eyeballCompleted=!0,this.updateSelections()),r--,n()},e.onload=()=>{TI(()=>{const s=o.fromPixels(e).resizeNearestNeighbor([224,224]).toFloat().sub(this.offset).div(this.offset).expandDims(),i=t.predict(s),l=i.dataSync();s.dispose(),i.dispose(),l[0]>this.confidence&&this.classifications.custom404.push(a),l[1]>this.confidence&&this.classifications.loginPage.push(a),l[2]>this.confidence&&this.classifications.webapp.push(a),l[3]>this.confidence&&this.classifications.oldLooking.push(a),l[4]>this.confidence&&this.classifications.parked.push(a),this.eyeballedCount++,this.eyeballedCount>=this.imageCount&&(this.eyeballing=!1,this.eyeballCompleted=!0,this.updateSelections()),r--,n()})},i++,r++,n()}else 0===r&&i===this.imageCount&&e()};n()})})}dataURI(t){var e;return eg(this,void 0,void 0,function*(){const n=yield t.arrayBuffer();let s=null===(e=t.name.split(".").reverse()[0])||void 0===e?void 0:e.toLocaleLowerCase();return["jpg","jpeg","png","gif","bmp"].some(t=>t===s)||(s="jpg"),`data:image/${encodeURIComponent(s)};base64,${W_.encode(n)}`})}eyeballPercent(){return this.eyeballedCount/this.imageCount*100}loadPercent(){return this.images.size/this.imageCount*100}restart(){window.location.reload()}exportResults(){return eg(this,void 0,void 0,function*(){const t=this.selectedScreens.join("\n"),e=new Blob([t],{type:"text/csv"}),n=window.URL.createObjectURL(e);window.open(n)})}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["app-eyeballer"]],decls:15,vars:4,consts:[["color","primary","fxLayout","row","fxLayoutAlign","start center",1,"app-toolbar"],["src","assets/eyeballer_logo.png","width","46","height","60"],["fxFlex",""],["mat-raised-button","",3,"click"],[1,"fas","fa-fw","fa-undo"],[4,"ngIf"],["mode","indeterminate"],[3,"change"],[2,"font-weight","bold"],["href","https://github.com/BishopFox/eyeballer","target","_blank","rel","noopener noreferrer"],["mode","determinate",3,"value"],[1,"results-container"],[2,"height","40px"],[1,"button-spacer"],["mat-raised-button","","color","primary",1,"label-button",3,"disabled","click"],["mat-raised-button","","color","basic",1,"label-button",3,"disabled","click"],["mat-raised-button","","color","accent",1,"label-button",3,"disabled","click"],[1,"label-count"],["mat-raised-button","","color","primary","mat-raised-button","",1,"label-button",3,"disabled","click"],["mat-raised-button","","color","primary",1,"export-button",3,"click"],["href","https://github.com/BishopFox/eyeballer#what-the-labels-mean","target","_blank","rel","noopener noreferrer"],[1,"eyeballed-class-container"],[4,"ngFor","ngForOf"],[1,"result-card"],["mat-card-image","",1,"preview-image",3,"src"],[1,"webapp-label"],[1,"custom-404-label"],[1,"login-label"],[1,"old-looking-label"],[1,"parked-label"]],template:function(t,e){1&t&&(Ua(0,"mat-toolbar",0),Ua(1,"h2"),Ha(2,"img",1),ja(),Io(3," Eyeballer "),Ha(4,"span",2),Ua(5,"span"),Io(6,"Bishop Fox R&D"),ja(),Ha(7,"span",2),Ua(8,"button",3),Ka("click",function(){return e.restart()}),Ha(9,"i",4),Io(10," Restart "),ja(),ja(),za(11,mY,2,0,"div",5),za(12,gY,23,0,"div",5),za(13,yY,13,6,"div",5),za(14,xY,72,22,"div",5)),2&t&&(pi(11),Va("ngIf",!e.tfFilesCompleted),pi(1),Va("ngIf",e.tfFilesCompleted&&!e.eyeballing&&!e.eyeballCompleted),pi(1),Va("ngIf",e.tfFilesCompleted&&e.eyeballing&&!e.eyeballCompleted),pi(1),Va("ngIf",e.tfFilesCompleted&&!e.eyeballing&&e.eyeballCompleted))},directives:[Ax,np,xp,up,my,Vc,sx,ky,mg,ug,Tx,zc,Sy,wy,_y],styles:[".app-toolbar[_ngcontent-%COMP%]{position:fixed;position:-webkit-sticky;top:0;z-index:1000}.not-completed-container[_ngcontent-%COMP%]{display:grid;justify-items:center;align-items:center;grid-template-columns:1fr 1fr 1fr}.not-completed-message[_ngcontent-%COMP%]{grid-column:2/3;grid-row:2/3}.results-container[_ngcontent-%COMP%]{grid-template-columns:1fr}.eyeballed-class-container[_ngcontent-%COMP%], .results-container[_ngcontent-%COMP%]{display:grid;justify-items:center;align-items:center}.eyeballed-class-container[_ngcontent-%COMP%]{grid-template-columns:1fr 1fr 1fr 1fr;grid-gap:1em;margin:1em}.result-card[_ngcontent-%COMP%]{max-width:100%}.result-card[_ngcontent-%COMP%]:hover{background-color:#f5f5f5}.result-card[_ngcontent-%COMP%]:hover   img[_ngcontent-%COMP%]{opacity:.5}.result-card[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]{display:none;position:absolute;top:50%;left:50%;width:70px;height:70px;z-index:10}.fill-remaining-space[_ngcontent-%COMP%]{flex:1 1 auto}.fill-space[_ngcontent-%COMP%]{flex:auto}.img-container[_ngcontent-%COMP%]{position:relative;text-align:center;color:#fff}.preview-image[_ngcontent-%COMP%]{width:100%}.webapp-label[_ngcontent-%COMP%]{background-color:#00f}.old-looking-label[_ngcontent-%COMP%], .webapp-label[_ngcontent-%COMP%]{color:#fff;margin-left:1px;margin-right:1px}.old-looking-label[_ngcontent-%COMP%]{background-color:green}.login-label[_ngcontent-%COMP%]{background-color:purple}.custom-404-label[_ngcontent-%COMP%], .login-label[_ngcontent-%COMP%]{color:#fff;margin-left:1px;margin-right:1px}.custom-404-label[_ngcontent-%COMP%]{background-color:orange}.parked-label[_ngcontent-%COMP%]{background-color:red;color:#fff;margin-left:1px;margin-right:1px}.label-count[_ngcontent-%COMP%]{margin-left:10px;width:50px!important;min-width:unset!important}.label-button[_ngcontent-%COMP%]{width:130px!important;min-width:unset!important}.button-spacer[_ngcontent-%COMP%]{flex:1 1 auto}.export-button[_ngcontent-%COMP%]{margin-right:10px}"]}),t})()}];let wY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t}),t.\u0275inj=Vt({imports:[[F_.forRoot(vY,{relativeLinkResolution:"legacy"})],F_]}),t})(),_Y=(()=>{class t{constructor(){this.title="weballer"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=be({type:t,selectors:[["app-root"]],decls:2,vars:0,template:function(t,e){1&t&&(Ua(0,"router-outlet"),Ha(1,"router-outlet"),ja())},directives:[k_],styles:[""]}),t})(),kY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=_e({type:t,bootstrap:[_Y]}),t.\u0275inj=Vt({providers:[],imports:[[Ih,wY,yg,tg,Mx,$p]]}),t})();(function(){if(Yu)throw new Error("Cannot enable prod mode after platform setup.");Qu=!1})(),Sh().bootstrapModule(kY).catch(t=>console.error(t))},zn8P:function(t,e){function n(t){return Promise.resolve().then(function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}n.keys=function(){return[]},n.resolve=n,t.exports=n,n.id="zn8P"}},[[0,0]]]);